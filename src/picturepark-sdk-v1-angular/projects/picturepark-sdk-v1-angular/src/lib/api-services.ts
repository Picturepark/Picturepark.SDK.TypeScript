/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.3.0 (NJsonSchema v10.1.5.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { Injector } from '@angular/core';
import { mergeMap } from 'rxjs/operators';
import { LazyGetter } from 'lazy-get-decorator';
import { AuthService } from './auth.service';
import { PictureparkServiceBase } from './base.service';
import { LiquidRenderingService } from './liquid-rendering.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const PICTUREPARK_API_URL = new InjectionToken<string>('PICTUREPARK_API_URL');

@Injectable({
    providedIn: 'root'
})
export class BusinessProcessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param businessProcessSearchRequest The business process request.
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest): Observable<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<BusinessProcessSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessSearchResult>(<any>null);
    }

    /**
     * Wait for life cycles
     * @param processId The business process id.
     * @param lifeCycleIds (optional) Business process life cycles to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(processId: string, lifeCycleIds: BusinessProcessLifeCycle[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitLifeCycles?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (lifeCycleIds !== undefined)
            lifeCycleIds && lifeCycleIds.forEach(item => { url_ += "lifeCycleIds=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForLifeCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForLifeCycles(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForLifeCycles(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Wait for states
     * @param processId The business process id.
     * @param states (optional) Business process states to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitStates?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForStates(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForStateResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForStates(response: HttpResponseBase): Observable<BusinessProcessWaitForStateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForStateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForStateResult>(<any>null);
    }

    /**
     * Wait for completion
     * @param processId The business process id.
     * @param timeout (optional) The timeout to wait for completion.
     * @param waitForContinuationCompletion (optional) Waits for the completion of the continuation business process (if existing, recursively). Default to true.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(processId: string, timeout: string | null | undefined, waitForContinuationCompletion: boolean | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitCompletion?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitForContinuationCompletion === null)
            throw new Error("The parameter 'waitForContinuationCompletion' cannot be null.");
        else if (waitForContinuationCompletion !== undefined)
            url_ += "waitForContinuationCompletion=" + encodeURIComponent("" + waitForContinuationCompletion) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForCompletion(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessWaitForLifeCycleResult>><any>_observableThrow(response_);
        }));
    }

    protected processWaitForCompletion(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Get details
     * @param processId The business process id.
     * @return BusinessProcessDetails
     */
    getDetails(processId: string): Observable<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/details";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcessDetails>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<BusinessProcessDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcessDetails>(<any>null);
    }

    /**
     * Get business process
     * @param processId The business process id.
     * @return BusinessProcess
     */
    get(processId: string): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Create business process
     * @param request The business process create request.
     * @return BusinessProcess
     */
    create(request: BusinessProcessCreateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/businessProcesses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Change business process state
     * @param processId The business process id.
     * @param request The business process state change request.
     * @return BusinessProcess
     */
    changeState(processId: string, request: BusinessProcessStateChangeRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/state";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeState(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processChangeState(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BusinessProcessNotExternalException.fromJS(resultData403);
            return throwException("Business process is not driven externally, no state changes are allowed.", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update business process notification
     * @param processId The business process id.
     * @param request The business process notification update request.
     */
    updateNotification(processId: string, request: BusinessProcessNotificationUpdateRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/notification";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BusinessProcessNotExternalException.fromJS(resultData403);
            return throwException("Business process is not driven externally, no notification changes are allowed.", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Cancel business process
     * @param processId The business process id.
     */
    cancel(processId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/cancel";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Business process does not support cancellation.\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BusinessRuleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get the current business rule configuration
     * @return BusinessRuleConfiguration
     */
    getConfiguration(): Observable<BusinessRuleConfiguration> {
        let url_ = this.baseUrl + "/v1/businessrules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<BusinessRuleConfiguration>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessRuleConfiguration>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<BusinessRuleConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRuleConfiguration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessRuleConfiguration>(<any>null);
    }

    /**
     * Updates the business rule configuration.
     * @param request Request containing the new configuration.
     * @return Business process
     */
    updateConfiguration(request: BusinessRuleConfigurationUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/businessrules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChannelService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all channels
     * @return List of channel
     */
    getAll(): Observable<Channel[]> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Channel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Channel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Channel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel[]>(<any>null);
    }

    /**
     * Create channel
     * @param request The request containing information needed to create new channel.
     * @return Channel
     */
    create(request: ChannelCreateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Get channel
     * @param id The channel ID.
     * @return Channel
     */
    get(id: string): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Update channel
     * @param id ID of channel to update
     * @param request The request containing information needed to update the channel.
     * @return Updated channel
     */
    update(id: string, request: ChannelUpdateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Channel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Channel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Channel>(<any>null);
    }

    /**
     * Delete channel
     * @param id ID of the channel that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
    @LazyGetter()
    protected get liquidRenderingService(): LiquidRenderingService {
        return this.injector.get(LiquidRenderingService);
    }

    constructor(protected injector: Injector,
        @Inject(AuthService) configuration: AuthService,
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
    }

    public create(resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined,
        timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, contentCreateRequest: ContentCreateRequest): Observable<ContentDetail> {
        return this.createCore(resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation, contentCreateRequest).pipe(
            mergeMap(async content => {
                await this.liquidRenderingService.renderNestedDisplayValues(content);
                return content;
            })
        );
    }

    public get(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail> {
        return this.getCore(contentId, resolveBehaviors).pipe(
            mergeMap(async content => {
                await this.liquidRenderingService.renderNestedDisplayValues(content);
                return content;
            })
        );
    }

    public getMany(ids: string[] | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail[]> {
        return this.getManyCore(ids, resolveBehaviors).pipe(
            mergeMap(async contents => {
                contents.forEach(async content => await this.liquidRenderingService.renderNestedDisplayValues(content));
                return contents;
            })
        );
    }

    public search(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult> {
        return this.searchCore(contentSearchRequest).pipe(
            mergeMap(async  searchResult => {
                await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
                return searchResult;
            })
        );
    }

    public updateMetadata(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined,
        allowMissingDependencies: boolean | undefined, timeout: string | null | undefined,
        waitSearchDocCreation: boolean | undefined, updateRequest: ContentMetadataUpdateRequest): Observable<ContentDetail> {
        return this.updateMetadataCore(contentId, resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation, updateRequest).pipe(
            mergeMap(async content => {
                await this.liquidRenderingService.renderNestedDisplayValues(content);
                return content;
            })
        );
    }

    public updatePermissions(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined,
        timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined,
        updateRequest: ContentPermissionsUpdateRequest): Observable<ContentDetail> {
        return this.updatePermissionsCore(contentId, resolveBehaviors, timeout, waitSearchDocCreation, updateRequest).pipe(
            mergeMap(async content => {
                await this.liquidRenderingService.renderNestedDisplayValues(content);
                return content;
            })
        );
    }

    /**
     * Get content
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return Content detail
     */
    protected getCore(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Content not found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Delete content
     * @param contentId The ID of the content to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(contentId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get multiple contents
     * @param ids List of content IDs
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return List of Content detail
     */
    protected getManyCore(ids: string[] | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("One or more contents not found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail[]>(<any>null);
    }

    /**
     * Create content
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param contentCreateRequest Content create request.
     * @return The content details
     */
    protected createCore(resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, contentCreateRequest: ContentCreateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Search contents
     * @param contentSearchRequest Content search request.
     * @return Content search result
     */
    protected searchCore(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate contents
     * @param contentAggregationRequest Content aggregation request.
     * @return Object aggregation result
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate contents on channel
     * @param contentAggregationOnChannelRequest Content aggregation on channel request.
     * @return Object aggregation result
     */
    aggregateOnChannel(contentAggregationOnChannelRequest: ContentAggregationOnChannelRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregateOnChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationOnChannelRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregateOnChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregateOnChannel(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregateOnChannel(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Get content references
     * @param contentId The content ID whose references to retrieve.
     * @param contentReferencesRequest Content references request.
     * @return ContentReferencesResult
     */
    getReferences(contentId: string, contentReferencesRequest: ContentReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/references/search";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferences(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferences(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Get many content references
     * @param contentManyReferencesRequest Content many references request.
     * @return Content references result
     */
    getReferencesMany(contentManyReferencesRequest: ContentManyReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/contents/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentManyReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesMany(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentReferencesResult>(<any>null);
    }

    /**
     * Create download link
     * @param request Content download link request
     * @return Download link
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDownloadLink(<any>response_);
                } catch (e) {
                    return <Observable<DownloadLink>><any>_observableThrow(e);
                }
            } else
                return <Observable<DownloadLink>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DownloadLink>(<any>null);
    }

    /**
     * Download content
     * @param contentId The content ID.
     * @param outputFormatId The output format ID.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000).
     * @return Http response message
     */
    download(contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @param contentId The content ID.
     * @param size Thumbnail size. Either small, medium or large.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @return Http response message
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, width: number | null | undefined, height: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/thumbnails/{contentId}/{size}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadThumbnail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadThumbnail(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadThumbnail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Create multiple contents
     * @param contentCreateManyRequest Content create many request.
     * @return Business process
     */
    createMany(contentCreateManyRequest: ContentCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents
     * @param deleteManyRequest Delete many request.
     * @return Business process
     */
    deleteMany(deleteManyRequest: ContentDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents - by filter
     * @param deleteManyFilterRequest Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(deleteManyFilterRequest: ContentDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyFilterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore content
     * @param contentId The content ID.
     * @param allowMissingDependencies (optional) Allows restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(contentId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/restore?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore multiple contents
     * @param restoreManyRequest Content restore many request.
     * @return Business process
     */
    restoreMany(restoreManyRequest: ContentRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update content file
     * @param contentId The ID of the content to replace.
     * @param updateRequest Content file update request
     * @return Business process
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/file";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update content metadata
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows storing references to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param updateRequest Content metadata update request.
     * @return Content detail
     */
    protected updateMetadataCore(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, updateRequest: ContentMetadataUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/metadata?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadata(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadata(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update content permissions
     * @param contentId The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param updateRequest Content permissions update request.
     * @return Content detail
     */
    protected updatePermissionsCore(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, updateRequest: ContentPermissionsUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentDetail>(<any>null);
    }

    /**
     * Update multiple content metadata
     * @param updateRequest Content metadata update many request.
     * @return Business process
     */
    updateMetadataMany(updateRequest: ContentMetadataUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadataMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadataMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMetadataMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Not all provided contents could be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple contents permissions
     * @param updateManyRequest Content permissions update many request.
     * @return Business process
     */
    updatePermissionsMany(updateManyRequest: ContentPermissionsUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissionsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Transfer content ownership
     * @param contentId The content ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param updateRequest Content ownership transfer request.
     * @return Ok
     */
    transferOwnership(contentId: string, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, updateRequest: ContentOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/ownership?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer multiple contents ownerships
     * @param contentOwnershipTransferManyRequest Content ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(contentOwnershipTransferManyRequest: ContentOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentOwnershipTransferManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update content fields - by IDs
     * @param updateRequest Content fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(updateRequest: ContentFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest Content fields batch update filter request. It contains the changes that need to be applied to the contents and the filter request to identify the contents.
     * @return Business process
     */
    batchUpdateFieldsByFilter(updateRequest: ContentFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get content permission set
     * @param permissionSetId The content permission set ID.
     * @return Content permission set detail
     */
    get(permissionSetId: string): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Create content permission set
     * @param request The request containing information needed to create new permission set.
     * @return Content permission set detail
     */
    create(request: ContentPermissionSetCreateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple permission sets
     * @param ids (optional) Permission set IDs to get information about
     * @return Content permission set details
     */
    getMany(ids: string[] | undefined): Observable<ContentPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentPermissionSetDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail[]>(<any>null);
    }

    /**
     * Update content permission set
     * @param id ID of permission set to update
     * @param request The request containing information needed to update the permission set.
     * @return Content permission set detail
     */
    update(id: string, request: ContentPermissionSetUpdateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Delete content permission set
     * @param id ID of the permission set that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer ownership of content permission set
     * @param id ID of the permission set to transfer
     * @param request The request containing user who should be the new owner.
     * @return OK
     */
    transferOwnership(id: string, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for the permission set
     * @param id ID of the permission set to view permissions of.
     * @return List of permissions
     */
    getPermissions(id: string): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetRight[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetRight[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple content permission sets
     * @param request The request containing information needed to create new permission sets.
     * @return Bulk response with information about created permission sets
     */
    createMany(request: ContentPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple content permission sets
     * @param request The request containing information needed to update the permission set.
     * @return Bulk response with information about updated permission sets
     */
    updateMany(request: ContentPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple content permission sets
     * @param request The request with permission set IDs to delete.
     * @return Bulk response with information about success or failure
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple content permission sets
     * @param request The request containing information on which permission set to transfer to which user.
     * @return OK
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for multiple permission sets
     * @param ids (optional) IDs of the permission sets to view permissions of.
     * @return List of permissions
     */
    getPermissionsMany(ids: string[] | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/many/permissions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search content permission sets
     * @param request The permission set search request.
     * @return Permission set search result
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/contentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DisplayValueService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Re-render the display values
     * @return VersionInfo
     */
    rerender(): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/displayvalues/rerender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRerender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRerender(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRerender(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Get status
     * @return VersionInfo
     */
    getStatus(): Observable<DisplayValueStatus> {
        let url_ = this.baseUrl + "/v1/displayvalues/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<DisplayValueStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<DisplayValueStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<DisplayValueStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DisplayValueStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DisplayValueStatus>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param documentHistorySearchRequest The document history search request.
     * @return Document history search result.
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest): Observable<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistorySearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistorySearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<DocumentHistorySearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistorySearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistorySearchResult>(<any>null);
    }

    /**
     * Get current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @return Document history item
     */
    getCurrent(documentType: string, documentId: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrent(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrent(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Get version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document.
     * @return Document history item
     */
    getVersion(documentType: string, documentId: string, documentVersion: number): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistory>(<any>null);
    }

    /**
     * Compare with current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference.
     */
    compareWithCurrent(documentType: string, documentId: string, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithCurrent(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processCompareWithCurrent(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Compare with version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document to use for the comparison.
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference
     */
    compareWithVersion(documentType: string, documentId: string, documentVersion: number, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>_observableThrow(response_);
        }));
    }

    protected processCompareWithVersion(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentHistoryDifference>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InfoService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    getInfo(): Observable<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/info/customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(<any>response_);
                } catch (e) {
                    return <Observable<CustomerInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<CustomerInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerInfo>(<any>null);
    }

    /**
     * Get version
     * @return VersionInfo
     */
    getVersion(): Observable<VersionInfo> {
        let url_ = this.baseUrl + "/v1/info/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<VersionInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<VersionInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VersionInfo>(<any>null);
    }

    /**
     * Get status
     * @return SystemStatus
     */
    getStatus(): Observable<SystemStatus> {
        let url_ = this.baseUrl + "/v1/info/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<SystemStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<SystemStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemStatus>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class JsonSchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get json schema
     * @param schemaId The ID of the schema whose json schema to retrieve.
     * @return Json schema view item: almost a 1:1 representation of the Newtonsoft json schema.
     */
    get(schemaId: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/jsonSchemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ListItemService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
    @LazyGetter()
    protected get liquidRenderingService(): LiquidRenderingService {
        return this.injector.get(LiquidRenderingService);
    }

    constructor(protected injector: Injector,
        @Inject(AuthService) configuration: AuthService,
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
    }

    public get(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail> {
        return this.getCore(listItemId, resolveBehaviors).pipe(
            mergeMap(async  listItem => {
                await this.liquidRenderingService.renderNestedDisplayValues(listItem);
                return listItem;
            })
        );
    }

    public search(listItemSearchRequest: ListItemSearchRequest): Observable<ListItemSearchResult> {
        return this.searchCore(listItemSearchRequest).pipe(
            mergeMap(async  searchResult => {
                await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
                return searchResult;
            })
        );
    }

    /**
     * Get list item
     * @param listItemId The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @return List item detail
     */
    protected getCore(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("List item not found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Update list item
     * @param listItemId The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param updateRequest The list item update request.
     * @return List item detail
     */
    update(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, updateRequest: ListItemUpdateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Delete list item
     * @param listItemId The ID of the list item to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the list item should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(listItemId: string, forceReferenceRemoval: boolean | null | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get multiple list items
     * @param ids List of list item IDs.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list items are resolved and returned.
     * @return List of list item details
     */
    getMany(ids: string[] | null, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ListItemDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("One or more list items not found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail[]>(<any>null);
    }

    /**
     * Create list item
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param listItemCreateRequest List item create request.
     * @return List item detail
     */
    create(resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, listItemCreateRequest: ListItemCreateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemDetail>(<any>null);
    }

    /**
     * Search list items
     * @param listItemSearchRequest The list item search request.
     * @return List item search result
     */
    protected searchCore(listItemSearchRequest: ListItemSearchRequest): Observable<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/listItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListItemSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListItemSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate list items
     * @param listItemAggregationRequest The list item aggregation request.
     * @return Object aggregation result
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/listItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create multiple list items
     * @param listItemCreateManyRequest List item create many request.
     * @return Business process
     */
    createMany(listItemCreateManyRequest: ListItemCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple list items
     * @param listItemUpdateManyRequest List item update many request.
     * @return Business process
     */
    updateMany(listItemUpdateManyRequest: ListItemUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemUpdateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items
     * @param deleteManyRequest List item delete many request.
     * @return Business process
     */
    deleteMany(deleteManyRequest: ListItemDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items - by filter
     * @param deleteManyFilterRequest Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(deleteManyFilterRequest: ListItemDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyFilterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Restore list item
     * @param listItemId The list item ID.
     * @param allowMissingDependencies (optional) Allows restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(listItemId: string, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/restore?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("The specified wait timeout exceeded\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore multiple list items
     * @param restoreManyRequest List item restore many request.
     * @return Business process
     */
    restoreMany(restoreManyRequest: ListItemRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(restoreManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by IDs
     * @param updateRequest List item fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(updateRequest: ListItemFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param updateRequest List item fields batch update by filter request.
     * @return Business process
     */
    batchUpdateFieldsByFilter(updateRequest: ListItemFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Get list item references
     * @param listItemId The ID of the list item.
     * @param listItemReferencesRequest Request options to specify how many references to fetch.
     * @return List item references
     */
    getReferencesToListItem(listItemId: string, listItemReferencesRequest: ListItemReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/references/search";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItem(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItem(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferencesResult>(<any>null);
    }

    /**
     * Get multiple list items references
     * @param listItemManyReferencesRequest ListItemManyReferencesRequest
     * @return A list of references per list item.
     */
    getReferencesToListItems(listItemManyReferencesRequest: ListItemManyReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/listItems/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemManyReferencesRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesToListItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesToListItems(<any>response_);
                } catch (e) {
                    return <Observable<ListItemReferencesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemReferencesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferencesToListItems(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemReferencesResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LiveStreamService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * This endpoint cannot be used. It is kept to generate LiveStream message contracts.
     * @return OK
     * @deprecated
     */
    getMessage(): Observable<LiveStreamMessage> {
        let url_ = this.baseUrl + "/v1/liveStream/message";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessage(<any>response_);
                } catch (e) {
                    return <Observable<LiveStreamMessage>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiveStreamMessage>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessage(response: HttpResponseBase): Observable<LiveStreamMessage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiveStreamMessage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiveStreamMessage>(<any>null);
    }

    /**
     * Search
     * @param request Parameters for the search
     * @return Resulting live stream events
     */
    search(request: LiveStreamSearchRequest): Observable<LiveStreamSearchResult> {
        let url_ = this.baseUrl + "/v1/liveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<LiveStreamSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiveStreamSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<LiveStreamSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiveStreamSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiveStreamSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MetadataService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get status
     * @return MetadataStatus
     */
    getStatus(): Observable<MetadataStatus> {
        let url_ = this.baseUrl + "/v1/metadata/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<MetadataStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<MetadataStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<MetadataStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MetadataStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MetadataStatus>(<any>null);
    }

    /**
     * Update outdated
     */
    updateOutdated(): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/metadata/many/updateOutdated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateOutdated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOutdated(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOutdated(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search output documents
     * @param outputSearchRequest The output search request.
     * @return Output result set.
     */
    search(outputSearchRequest: OutputSearchRequest): Observable<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(outputSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<OutputSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<OutputSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputSearchResult>(<any>null);
    }

    /**
     * Get - single
     * @param outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetail> {
        let url_ = this.baseUrl + "/v1/outputs/{outputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{outputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkBusinessException.fromJS(resultData404);
            return throwException("\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputDetail>(<any>null);
    }

    /**
     * Resets retry attempts counter on failed (optionally also completed) outputs and they will be subsequently picked up for re-rendering.
     * @param request Request containing options to filter which outputs should be reset.
     * @return Business process tracking the resetting
     */
    resetRetryAttempts(request: OutputResetRetryAttemptsRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputs/resetRetryAttempts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processResetRetryAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetRetryAttempts(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processResetRetryAttempts(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs in request exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputFormatService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get output format
     * @param id The output format ID.
     * @return Output format
     */
    get(id: string): Observable<OutputFormatDetail> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormatDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormatDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputFormatDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputFormatDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormatDetail>(<any>null);
    }

    /**
     * Update output format
     * @param id ID of output format to update
     * @param request The request containing information needed to update the output format.
     * @return Business process
     */
    update(id: string, request: OutputFormatEditable): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete output format
     * @param id ID of the output format that should be deleted.
     * @return Business process
     */
    delete(id: string): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Create output format
     * @param request The request containing information needed to create new output format.
     * @return Business process
     */
    create(request: OutputFormat): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Get multiple output formats
     * @param ids (optional) Output format IDs to get information about. If this is omitted, all output formats in the system will be returned.
     * @return Output formats
     */
    getMany(ids: string[] | null | undefined): Observable<OutputFormatDetail[]> {
        let url_ = this.baseUrl + "/v1/outputFormats?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<OutputFormatDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutputFormatDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<OutputFormatDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutputFormatDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutputFormatDetail[]>(<any>null);
    }

    /**
     * Create multiple output formats
     * @param request The request containing information needed to create new output formats.
     * @return Business process
     */
    createMany(request: OutputFormatCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple output formats
     * @param request The request containing information needed to update the output format.
     * @return Business process
     */
    updateMany(request: OutputFormatUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple output formats
     * @param request The request with output formats IDs to delete.
     * @return Business process
     */
    deleteMany(request: OutputFormatDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Sets the download file name patterns for an output format
     * @param id ID of the output format.
     * @param patterns Dictionary containing patterns per metadata language.
    If this is set, at least the customer's default language is required.
    Set any other language to an empty string and a fallback to the default language will occur.
    Set parameter to null to clear any already set patterns.
     * @return Business process
     */
    setDownloadFileNamePatterns(id: string | null, patterns: { [key: string]: string; }): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/{id}/downloadFileNamePatterns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patterns);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDownloadFileNamePatterns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDownloadFileNamePatterns(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processSetDownloadFileNamePatterns(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Sets the download file name patterns for multiple output formats
     * @param request The request containing the patterns for each output format.
     * @return Business process
     */
    setDownloadFileNamePatternsMany(request: OutputFormatDownloadFileNamePatternUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/outputFormats/many/downloadFileNamePatterns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDownloadFileNamePatternsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDownloadFileNamePatternsMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processSetDownloadFileNamePatternsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Preview OutputFormat
     * @param request Information about the OutputFormat as well as which Content to use for the preview.
     * @return Rendered file
     */
    renderFormatPreview(request: OutputFormatRenderPreviewRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/outputFormats/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRenderFormatPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenderFormatPreview(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRenderFormatPreview(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProfileService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return User profile
     */
    get(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }

    /**
     * Update
     * @return Updated user profile
     */
    update(updateRequest: UserProfileUpdateRequest): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfile>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfile>(<any>null);
    }

    /**
     * Request deletion
     * @return OK
     */
    requestDeletion(): Observable<void> {
        let url_ = this.baseUrl + "/v1/profile/requestDeletion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRequestDeletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDeletion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestDeletion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema
     * @param schemaId The schema ID.
     * @return Schema detail
     */
    get(schemaId: string): Observable<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Requested schema could not be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail>(<any>null);
    }

    /**
     * Update schema
     * @param schemaId The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param schema The schema update request.
     * @return Schema update result, containing the updated schema
     */
    update(schemaId: string, timeout: string | null | undefined, schema: SchemaUpdateRequest): Observable<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaUpdateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaUpdateResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaUpdateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaUpdateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Schema with this ID could not be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Argument must not be null\nor\nThe validation exception of schema creation\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaUpdateResult>(<any>null);
    }

    /**
     * Delete schema
     * @param schemaId The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema delete result
     */
    delete(schemaId: string, timeout: string | null | undefined): Observable<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDeleteResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDeleteResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SchemaDeleteResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDeleteResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Schema with this ID could not be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Argument must not be null\nor\nSchema is used in other entities and cannot be deleted\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDeleteResult>(<any>null);
    }

    /**
     * Get multiple schemas
     * @param ids (optional) Comma separated list of schema IDs.
     * @return List of schema details
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Create schema
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param schema The schema create request.
     * @return Schema create result, containing the created schema
     */
    create(timeout: string | null | undefined, schema: SchemaCreateRequest): Observable<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaCreateResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaCreateResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaCreateResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Schema with this name already exists\nor\nArgument must not be null\nor\nThe validation exception of schema creation\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaCreateResult>(<any>null);
    }

    /**
     * Search schemas
     * @param schemaSearchRequest The schema search request.
     * @return Schema search result
     */
    search(schemaSearchRequest: SchemaSearchRequest): Observable<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SchemaSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SchemaSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaSearchResult>(<any>null);
    }

    /**
     * Search index fields
     * @param request The search request.
     * @return Indexed fields
     */
    getIndexFields(request: IndexFieldsSearchBySchemaIdsRequest): Observable<IndexField[]> {
        let url_ = this.baseUrl + "/v1/schemas/indexFields/searchBySchemaIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetIndexFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndexFields(<any>response_);
                } catch (e) {
                    return <Observable<IndexField[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndexField[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndexFields(response: HttpResponseBase): Observable<IndexField[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexField.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndexField[]>(<any>null);
    }

    /**
     * Exists schema
     * @param schemaId The schema ID.
     * @return Schema Exists response
     */
    exists(schemaId: string): Observable<SchemaExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<SchemaExistsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaExistsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<SchemaExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaExistsResponse>(<any>null);
    }

    /**
     * Exists field in schema
     * @param schemaId The schema ID.
     * @param fieldId The field ID.
     * @return Field Exists response
     */
    fieldExists(schemaId: string, fieldId: string): Observable<FieldExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/{fieldId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processFieldExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFieldExists(<any>response_);
                } catch (e) {
                    return <Observable<FieldExistsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldExistsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFieldExists(response: HttpResponseBase): Observable<FieldExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldExistsResponse>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schema specified in
     * @param schemaId The schema ID.
     * @return Referenced schema details
     */
    getReferenced(schemaId: string): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/referenced";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenced(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Transfer ownership
     * @param schemaId The schema ID.
     * @param request Request detailing which user to transfer to.
     * @return OK
     */
    transferOwnership(schemaId: string, request: SchemaOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/ownership";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schemas specified in
     * @param ids (optional) The schema IDs.
     * @return Referenced schema details
     */
    getManyReferenced(ids: string[] | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas/many/referenced?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetManyReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyReferenced(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaDetail[]>(<any>null);
    }

    /**
     * Create multiple schemas
     * @param schemas The schema create many request.
     * @return BusinessProcess which can be awaited.
     */
    createMany(schemas: SchemaCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemas);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("One or more schemas in the request already exist\nor\nArgument must not be null\nor\nOne or more schemas failed to validate\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple schema
     * @return BusinessProcess which can be awaited.
     */
    updateMany(request: SchemaUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Argument must not be null\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }

    /**
     * Transfer ownership of multiple schemas
     * @param request Schema ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: SchemaOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessProcess>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessProcess>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema permission set
     * @param permissionSetId The schema permission set ID.
     * @return Schema permission set detail
     */
    get(permissionSetId: string): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Create schema permission set
     * @param request The request containing information needed to create new permission set.
     * @return Schema permission set detail
     */
    create(request: SchemaPermissionSetCreateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple permission sets
     * @param ids (optional) Permission set IDs to get information about
     * @return Schema permission set details
     */
    getMany(ids: string[] | undefined): Observable<SchemaPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaPermissionSetDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail[]>(<any>null);
    }

    /**
     * Update schema permission set
     * @param id ID of permission set to update
     * @param request The request containing information needed to update the permission set.
     * @return Schema permission set detail
     */
    update(id: string, request: SchemaPermissionSetUpdateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Delete schema permission set
     * @param id ID of the permission set that should be deleted.
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Transfer ownership of schema permission set
     * @param id ID of the permission set to transfer
     * @param request The request containing user who should be the new owner.
     * @return OK
     */
    transferOwnership(id: string, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for the permission set
     * @param id ID of the permission set to view permissions of.
     * @return List of permissions
     */
    getPermissions(id: string): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetRight[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetRight[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple schema permission sets
     * @param request The request containing information needed to create new permission sets.
     * @return Bulk response with information about created permission sets
     */
    createMany(request: SchemaPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple schema permission sets
     * @param request The request containing information needed to update the permission set.
     * @return Bulk response with information about updated permission sets
     */
    updateMany(request: SchemaPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple schema permission sets
     * @param request The request with permission set IDs to delete.
     * @return Bulk response with information about success or failure
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple schema permission sets
     * @param request The request containing information on which permission set to transfer to which user.
     * @return OK
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get permissions for multiple permission sets
     * @param ids (optional) IDs of the permission sets to view permissions of.
     * @return List of permissions
     */
    getPermissionsMany(ids: string[] | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/many/permissions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetUserPermissionRights[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search schema permission sets
     * @param request The permission set search request.
     * @return Permission set search result
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/schemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionSetSearchResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaTransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Import schemas
     * @param schemaImportRequest The schema import request.
     * @return Transfer
     */
    import(schemaImportRequest: SchemaImportRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/schematransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaImportRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkBusinessException.fromJS(resultData400);
            return throwException("File transfer not found\nor\nArgument must not be null\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShareService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
    @LazyGetter()
    protected get liquidRenderingService(): LiquidRenderingService {
        return this.injector.get(LiquidRenderingService);
    }

    constructor(protected injector: Injector,
        @Inject(AuthService) configuration: AuthService,
        @Inject(HttpClient) http: HttpClient,
        @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
    }

    public get(id: string): Observable<ShareDetail> {
        return this.getCore(id).pipe(
            mergeMap(async  shareDetail => {
                await this.liquidRenderingService.renderNestedDisplayValues(shareDetail);
                return shareDetail;
            })
        );
    }

    public getShareJson(token: string, lang: string | null | undefined, hostUrl?: string): Observable<any> {
        if (hostUrl) {
            return this.getShareJsonCoreFromUrl(token, lang, hostUrl + '/json/{token}?').pipe(
                tap(async shareJson => await this.liquidRenderingService.renderNestedDisplayValues(shareJson))
            );
        } else {
            return this.getShareJsonCore(token, lang).pipe(
                tap(async shareJson => await this.liquidRenderingService.renderNestedDisplayValues(shareJson))
            );
        }
    }

    /**
     * Get share json
     * @param token Share token
     * @param lang (optional) Language code
     * @return ShareDetail
     */
    protected getShareJsonCoreFromUrl(token: string, lang: string | null | undefined, url: string): Observable<any> {
        let url_ = url;
        if (token === undefined || token === null) {
            throw new Error('The parameter \'token\' must be defined.');
        }
        url_ = url_.replace('{token}', encodeURIComponent('' + token));
        if (lang !== undefined) {
            url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
        }
        url_ = url_.replace(/[?&]$/, '');

        const options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Accept': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request('get', url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareJson(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else {
                return <Observable<any>><any>_observableThrow(response_);
            }
        }));
    }

    public search(shareSearchRequest: ShareSearchRequest): Observable<ShareSearchResult> {
        return this.searchCore(shareSearchRequest).pipe(
            mergeMap(async  searchResult => {
                await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
                return searchResult;
            })
        );
    }

    /**
     * Get
     * @param id Share Id (not token, use [GetShareJson](#operation/Share_GetShareJson) to get share by token)
     * @return Share detail
     */
    protected getCore(id: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Share could not be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Update
     * @param id The share id.
     * @param timeout (optional) Optional timeout to wait for the request to complete
     * @param updateRequest The share update request.
     * @return Share detail
     */
    update(id: string, timeout: string | null | undefined, updateRequest: ShareBaseUpdateRequest): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareDetail>(<any>null);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    protected searchCore(request: ShareSearchRequest): Observable<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ShareSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShareSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ShareSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShareSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return Share aggregation result
     */
    aggregate(request: ShareAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create
     * @param timeout (optional) Optional timeout to wait for the request to complete
     * @param request Polymorphic create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(timeout: string | null | undefined, request: ShareBaseCreateRequest): Observable<CreateShareResult> {
        let url_ = this.baseUrl + "/v1/shares?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateShareResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateShareResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Content could not be found\nor\nEntity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PermissionValidationException.fromJS(resultData403);
            return throwException("No permission to share", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateShareResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateShareResult>(<any>null);
    }

    /**
     * Delete multiple shares
     * @param timeout (optional) Optional timeout to wait for the request to complete
     * @param deleteManyRequest A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(timeout: string | null | undefined, deleteManyRequest: ShareDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/shares/many/delete?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Get share json
     * @param token Share token
     * @param lang (optional) Language code
     * @return ShareDetail
     */
    protected getShareJsonCore(token: string, lang: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/v1/shares/json/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareJson(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetShareJson(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(token: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param contentId The content id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithContentId(token: string, contentId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}/{contentId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithContentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithContentId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithContentId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param contentId The content id
     * @param outputFormatId The output format id+
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    downloadWithOutputFormatId(token: string, contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/shares/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithOutputFormatId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithOutputFormatId(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWithOutputFormatId(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get transfer details
     * @param transferId ID of transfer.
     * @return TransferDetail
     */
    get(transferId: string): Observable<TransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferDetail>(<any>null);
    }

    /**
     * Delete transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Observable<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<TransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferSearchResult>(<any>null);
    }

    /**
     * Cancel transfer
     * @param transferId ID of transfer.
     * @return OK
     */
    cancelTransfer(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTransfer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelTransfer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkException.fromJS(resultData400);
            return throwException("\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Get file
     * @param fileTransferId ID of file transfer.
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Observable<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/files/{fileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{fileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileTransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @param request The file transfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Observable<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFiles(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearchFiles(response: HttpResponseBase): Observable<FileTransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileTransferSearchResult>(<any>null);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Observable<Blacklist> {
        let url_ = this.baseUrl + "/v1/transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBlacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlacklist(<any>response_);
                } catch (e) {
                    return <Observable<Blacklist>><any>_observableThrow(e);
                }
            } else
                return <Observable<Blacklist>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlacklist(response: HttpResponseBase): Observable<Blacklist> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Blacklist.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Blacklist>(<any>null);
    }

    /**
     * Delete files
     * @param request The file transfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Import transfer
     * @param transferId ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    importTransfer(transferId: string, request: ImportTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImportTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTransfer(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processImportTransfer(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Import transfer partially
     * @param transferId ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(transferId: string, request: ImportTransferPartialRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/partialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPartialImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartialImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transfer>><any>_observableThrow(response_);
        }));
    }

    protected processPartialImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transfer>(<any>null);
    }

    /**
     * Upload file
     * @param formFile (optional) Gets or sets the form file.
     * @param chunkNumber Current chunk number. Starts at 1.
     * @param currentChunkSize Size in bytes of the current chunk.
     * @param totalSize Total size in bytes of the uploading file.
     * @param totalChunks Total chunks of the uploading file.
     * @param transferId ID of transfer.
     * @param requestId Identifier of file.
     * @return OK
     */
    uploadFile(formFile: FileParameter | null | undefined, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string, requestId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/files/{requestId}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId)); 
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create user
     * @param request Requested user information.
     * @return Newly created user
     */
    create(request: UserCreateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get user
     * @param userId User ID to search for.
     * @return Requested user details
     */
    get(userId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Update user
     * @param userId User ID to action on.
     * @param request New user information.
     * @return User details after the update of the user
     */
    update(userId: string, request: UserUpdateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Search users
     * @param searchRequest User search request.
     * @return Result of the user search
     */
    search(searchRequest: UserSearchRequest): Observable<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSearchResult>(<any>null);
    }

    /**
     * Get user by owner token
     * @param tokenId ID of the owner token.
     * @return User details of the user referenced by the owner token
     */
    getByOwnerToken(tokenId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByOwnerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOwnerToken(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetByOwnerToken(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail>(<any>null);
    }

    /**
     * Get multiple users
     * @param ids User IDs.
     * @return Details of all the users who were found
     */
    getMany(ids: string[] | null): Observable<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/users/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetail[]>(<any>null);
    }

    /**
     * Aggregate users
     * @param request User aggregation request.
     * @return Aggregation based on the request
     */
    aggregate(request: UserAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectAggregationResult>(<any>null);
    }

    /**
     * Lock / unlock user
     * @param userId User ID to action on.
     * @param request Request detailing if the user should be locked or unlocked.
     * @return OK
     */
    lock(userId: string, request: UserLockRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/lock";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Change user's review state
     * @param userId User ID to action on.
     * @param request Request detailing if the user should be set as _reviewed_ or _to be reviewed_.
     * @return OK
     */
    review(userId: string, request: UserReviewRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/review";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReview(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Invite user
     * @param userId User ID to action on.
     * @return OK
     */
    invite(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/invite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvite(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Reinvite user
     * @param userId User ID to action on.
     * @return OK
     */
    reinvite(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/reinvite";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReinvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvite(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReinvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Delete user
     * @param userId User ID to action on.
     * @param request Request with details regarding the deletion.
     * @return OK
     */
    delete(userId: string, request: UserDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/delete";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Cancels a user triggered deletion request and returns user to _Reviewed_ state.
     * @param userId User ID to action on.
     * @return OK
     */
    cancelDeletionRequest(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/cancelDeletionRequest";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelDeletionRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelDeletionRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelDeletionRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore user
     * @param userId User ID to action on.
     * @return OK
     */
    restore(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{userId}/restore";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get multiple user roles
     * @param ids User role IDs to get information about.
     * @return List of user roles
     */
    getMany(ids: string[] | null): Observable<UserRoleDetail[]> {
        let url_ = this.baseUrl + "/v1/userRoles?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserRoleDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDetail.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("List of IDs exceeded maximum size\nor\nValidation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDetail[]>(<any>null);
    }

    /**
     * Create user role
     * @param request User role creation request.
     * @return Newly created user role
     */
    create(request: UserRoleCreateRequest): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/userRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDetail>(<any>null);
    }

    /**
     * Get user role
     * @param userRoleId The user role ID
     * @return User role or null if not found
     */
    get(userRoleId: string): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/userRoles/{userRoleId}";
        if (userRoleId === undefined || userRoleId === null)
            throw new Error("The parameter 'userRoleId' must be defined.");
        url_ = url_.replace("{userRoleId}", encodeURIComponent("" + userRoleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDetail>(<any>null);
    }

    /**
     * Search user roles
     * @param searchRequest User role search request.
     * @return Result of the user role search
     */
    search(searchRequest: UserRoleSearchRequest): Observable<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/userRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleSearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleSearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserRoleSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleSearchResult>(<any>null);
    }

    /**
     * Update user roles
     * @param id ID of the user role to update.
     * @param request User role update request.
     * @return Updated user role
     */
    update(id: string, request: UserRoleEditable): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/userRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleDetail>(<any>null);
    }

    /**
     * Delete user role
     * @param id ID of user role to delete
     * @return OK
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/userRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create multiple user roles
     * @param request Multiple user role creation request.
     * @return Bulk response
     */
    createMany(request: UserRoleCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Update multiple user roles
     * @param request Multiple user role update request.
     * @return Bulk response
     */
    updateMany(request: UserRoleUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple user roles
     * @param request Multiple user role deletion request.
     * @return Bulk request
     */
    deleteMany(request: UserRoleDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/userRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BulkResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not authorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Too many requests", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkResponse>(<any>null);
    }
}

export class BaseResultOfBusinessProcess implements IBaseResultOfBusinessProcess {
    totalResults!: number;
    results!: BusinessProcess[];
    elapsedMilliseconds!: number;
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BusinessProcess.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface IBaseResultOfBusinessProcess {
    totalResults: number;
    results: BusinessProcess[];
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export class SearchBehaviorBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess implements ISearchBehaviorBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten!: boolean;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfBusinessProcess) {
        super(data);
        if (data) {
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            this.queryDebugInformation = _data["queryDebugInformation"] ? QueryDebugInformation.fromJS(_data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchBehaviorBaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviorBaseResultOfBusinessProcess extends IBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Search result from a search for business processes */
export class BusinessProcessSearchResult extends SearchBehaviorBaseResultOfBusinessProcess implements IBusinessProcessSearchResult {

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): BusinessProcessSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** Search result from a search for business processes */
export interface IBusinessProcessSearchResult extends ISearchBehaviorBaseResultOfBusinessProcess {
}

export class QueryDebugInformation implements IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;

    constructor(data?: IQueryDebugInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"];
            this.auditTrail = _data["auditTrail"];
            this.request = _data["request"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): QueryDebugInformation {
        data = typeof data === 'object' ? data : {};
        let result = new QueryDebugInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general;
        data["auditTrail"] = this.auditTrail;
        data["request"] = this.request;
        data["response"] = this.response;
        return data; 
    }
}

export interface IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;
}

/** Business process */
export class BusinessProcess implements IBusinessProcess {
    /** ID of the business process. */
    id!: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId!: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation!: boolean;
    /** Scope of the business process. */
    businessProcessScope!: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle!: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate!: Date;
    /** When the business process finished. */
    endDate!: Date;
    /** Is the business process finished. */
    finished!: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: BusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
    /** Id of the business process that will be automatically started after the completion of the current one, if any. */
    continuationBusinessProcessId?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.stateHistory) {
                this.stateHistory = [];
                for (let i = 0; i < data.stateHistory.length; i++) {
                    let item = data.stateHistory[i];
                    this.stateHistory[i] = item && !(<any>item).toJSON ? new BusinessProcessState(item) : <BusinessProcessState>item;
                }
            }
        }
        this._discriminator = "BusinessProcess";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processDefinitionId = _data["processDefinitionId"];
            this.referenceId = _data["referenceId"];
            this.referenceDocType = _data["referenceDocType"];
            this.supportsCancellation = _data["supportsCancellation"];
            this.businessProcessScope = _data["businessProcessScope"];
            this.lifeCycle = _data["lifeCycle"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.finished = _data["finished"];
            if (Array.isArray(_data["stateHistory"])) {
                this.stateHistory = [] as any;
                for (let item of _data["stateHistory"])
                    this.stateHistory!.push(BusinessProcessState.fromJS(item));
            }
            this.currentState = _data["currentState"];
            this.lastReportedProgress = _data["lastReportedProgress"] ? new Date(_data["lastReportedProgress"].toString()) : <any>undefined;
            this.continuationBusinessProcessId = _data["continuationBusinessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcess {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetails") {
            let result = new BusinessProcessDetails();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["processDefinitionId"] = this.processDefinitionId;
        data["referenceId"] = this.referenceId;
        data["referenceDocType"] = this.referenceDocType;
        data["supportsCancellation"] = this.supportsCancellation;
        data["businessProcessScope"] = this.businessProcessScope;
        data["lifeCycle"] = this.lifeCycle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["finished"] = this.finished;
        if (Array.isArray(this.stateHistory)) {
            data["stateHistory"] = [];
            for (let item of this.stateHistory)
                data["stateHistory"].push(item.toJSON());
        }
        data["currentState"] = this.currentState;
        data["lastReportedProgress"] = this.lastReportedProgress ? this.lastReportedProgress.toISOString() : <any>undefined;
        data["continuationBusinessProcessId"] = this.continuationBusinessProcessId;
        return data; 
    }
}

/** Business process */
export interface IBusinessProcess {
    /** ID of the business process. */
    id: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation: boolean;
    /** Scope of the business process. */
    businessProcessScope: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate: Date;
    /** When the business process finished. */
    endDate: Date;
    /** Is the business process finished. */
    finished: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: IBusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
    /** Id of the business process that will be automatically started after the completion of the current one, if any. */
    continuationBusinessProcessId?: string | undefined;
}

/** Scope of the business process */
export enum BusinessProcessScope {
    System = "System",
    User = "User",
}

/** Life cycle of the business process */
export enum BusinessProcessLifeCycle {
    Draft = "Draft",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    Cancelled = "Cancelled",
    CancellationInProgress = "CancellationInProgress",
    Failed = "Failed",
    SucceededWithErrors = "SucceededWithErrors",
}

/** State transition information of a business process */
export class BusinessProcessState implements IBusinessProcessState {
    /** State of the business process */
    state!: string;
    /** Date and time of when the state transition was performed. */
    timestamp!: Date;
    /** Eventual error associated to the state transition. */
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.error = _data["error"] ? ErrorResponse.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessState {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

/** State transition information of a business process */
export interface IBusinessProcessState {
    /** State of the business process */
    state: string;
    /** Date and time of when the state transition was performed. */
    timestamp: Date;
    /** Eventual error associated to the state transition. */
    error?: IErrorResponse | undefined;
}

/** Error information with serialized exception */
export class ErrorResponse implements IErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exception = _data["exception"];
            this.traceId = _data["traceId"];
            this.traceJobId = _data["traceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        return data; 
    }
}

/** Error information with serialized exception */
export interface IErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.innerException = data.innerException && !(<any>data.innerException).toJSON ? new Exception(data.innerException) : <Exception>this.innerException; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.innerException = _data["innerException"] ? Exception.fromJS(_data["innerException"]) : <any>undefined;
            this.stackTrace = _data["stackTrace"];
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["stackTrace"] = this.stackTrace;
        data["source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: IException | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel!: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode!: number;
    exceptionMessage?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.traceLevel = _data["traceLevel"];
            this.traceId = _data["traceId"];
            this.traceJobId = _data["traceJobId"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.exceptionMessage = _data["exceptionMessage"];
        }
    }

    static fromJS(data: any): PictureparkException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FormatNotApplicableForRenderingException") {
            let result = new FormatNotApplicableForRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ElasticVersionUpdateException") {
            let result = new ElasticVersionUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidVersionException") {
            let result = new InvalidVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotDeactivatedException") {
            let result = new EnvironmentNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotFoundException") {
            let result = new EnvironmentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentDeactivationException") {
            let result = new EnvironmentDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerViolationException") {
            let result = new CustomerViolationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasNotFoundException") {
            let result = new CustomerAliasNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotDeactivatedException") {
            let result = new CustomerNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerDeactivationException") {
            let result = new CustomerDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotActiveException") {
            let result = new CustomerNotActiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationIndexNotFoundException") {
            let result = new ConfigurationIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAliasException") {
            let result = new DuplicateAliasException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RedisDatabaseExceededException") {
            let result = new RedisDatabaseExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumTransferSizeException") {
            let result = new MaximumTransferSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCountLimitReachedException") {
            let result = new SchemaCountLimitReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessContinuationException") {
            let result = new BusinessProcessContinuationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotSkippedException") {
            let result = new SnapshotSkippedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotAvailableException") {
            let result = new EnvironmentNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotAvailableException") {
            let result = new CustomerNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointDocumentTypeException") {
            let result = new BusinessRuleConditionInvalidTriggerPointDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointActionException") {
            let result = new BusinessRuleConditionInvalidTriggerPointActionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTagsFoundException") {
            let result = new NoTagsFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotAvailableException") {
            let result = new OutputNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ModelNotFoundException") {
            let result = new ModelNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatNotFoundException") {
            let result = new OutputFormatNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["traceLevel"] = this.traceLevel;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        data["httpStatusCode"] = this.httpStatusCode;
        data["exceptionMessage"] = this.exceptionMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
    exceptionMessage?: string | undefined;
}

export enum TraceLevel {
    Critical = "Critical",
    Error = "Error",
    Warning = "Warning",
    Information = "Information",
    Verbose = "Verbose",
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerAlias = _data["customerAlias"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PictureparkBusinessException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FormatNotApplicableForRenderingException") {
            let result = new FormatNotApplicableForRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RetryException") {
            let result = new RetryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCountLimitReachedException") {
            let result = new SchemaCountLimitReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessContinuationException") {
            let result = new BusinessProcessContinuationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotSkippedException") {
            let result = new SnapshotSkippedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointDocumentTypeException") {
            let result = new BusinessRuleConditionInvalidTriggerPointDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointActionException") {
            let result = new BusinessRuleConditionInvalidTriggerPointActionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTagsFoundException") {
            let result = new NoTagsFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotAvailableException") {
            let result = new OutputNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ModelNotFoundException") {
            let result = new ModelNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatNotFoundException") {
            let result = new OutputFormatNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class PictureparkValidationException extends PictureparkBusinessException implements IPictureparkValidationException {

    constructor(data?: IPictureparkValidationException) {
        super(data);
        this._discriminator = "PictureparkValidationException";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PictureparkValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatResizingNotSupportedException") {
            let result = new OutputFormatResizingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIndexException") {
            let result = new SchemaFieldIndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidExecutionScopeException") {
            let result = new BusinessRuleActionInvalidExecutionScopeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointDocumentTypeException") {
            let result = new BusinessRuleConditionInvalidTriggerPointDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointActionException") {
            let result = new BusinessRuleConditionInvalidTriggerPointActionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        let result = new PictureparkValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkValidationException extends IPictureparkBusinessException {
}

export class PictureparkConflictException extends PictureparkBusinessException implements IPictureparkConflictException {
    reference?: string | undefined;

    constructor(data?: IPictureparkConflictException) {
        super(data);
        this._discriminator = "PictureparkConflictException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): PictureparkConflictException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        let result = new PictureparkConflictException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkConflictException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class PictureparkTimeoutException extends PictureparkValidationException implements IPictureparkTimeoutException {

    constructor(data?: IPictureparkTimeoutException) {
        super(data);
        this._discriminator = "PictureparkTimeoutException";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PictureparkTimeoutException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkTimeoutException extends IPictureparkValidationException {
}

export class PictureparkForbiddenException extends PictureparkBusinessException implements IPictureparkForbiddenException {

    constructor(data?: IPictureparkForbiddenException) {
        super(data);
        this._discriminator = "PictureparkForbiddenException";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PictureparkForbiddenException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        let result = new PictureparkForbiddenException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkForbiddenException extends IPictureparkBusinessException {
}

export class UserEmailAlreadyExistsException extends PictureparkValidationException implements IUserEmailAlreadyExistsException {
    email?: string | undefined;

    constructor(data?: IUserEmailAlreadyExistsException) {
        super(data);
        this._discriminator = "UserEmailAlreadyExistsException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserEmailAlreadyExistsException {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailAlreadyExistsException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserEmailAlreadyExistsException extends IPictureparkValidationException {
    email?: string | undefined;
}

export class UserRoleAssignedException extends PictureparkValidationException implements IUserRoleAssignedException {
    userRoleId?: string | undefined;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userRoleId = _data["userRoleId"];
        }
    }

    static fromJS(data: any): UserRoleAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleAssignedException extends IPictureparkValidationException {
    userRoleId?: string | undefined;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.missingUserId = _data["missingUserId"];
        }
    }

    static fromJS(data: any): UserNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string | undefined;
}

export class UserInactiveOrDeletedException extends PictureparkValidationException implements IUserInactiveOrDeletedException {

    constructor(data?: IUserInactiveOrDeletedException) {
        super(data);
        this._discriminator = "UserInactiveOrDeletedException";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UserInactiveOrDeletedException {
