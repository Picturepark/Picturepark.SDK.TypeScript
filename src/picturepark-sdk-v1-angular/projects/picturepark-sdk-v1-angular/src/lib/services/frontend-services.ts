/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.1.0 (NJsonSchema v10.2.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import {
  PictureparkValidationException,
  PictureparkForbiddenException,
  PictureparkNotFoundException,
  PictureparkConflictException,
  PictureparkException,
  ShareResolveBehavior,
  ShareDetail,
  ShareContentDetailResult,
  OutputResolveResult,
  DownloadLink,
  ShareDownloadRequest,
} from './api-services';

export const PICTUREPARK_CDN_URL = new InjectionToken<string>('PICTUREPARK_CDN_URL');

@Injectable({
  providedIn: 'root',
})
export class ShareAccesService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_CDN_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getSharePage(token: string | null, lang: string | null | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/s/{token}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (lang !== undefined && lang !== null) url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSharePage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSharePage(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetSharePage(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getJson(
    token: string | null,
    lang: string | null | undefined,
    resolveBehaviors: ShareResolveBehavior[] | null | undefined,
    contentResolveLimit: number | null | undefined
  ): Observable<ShareDetail> {
    let url_ = this.baseUrl + '/json/{token}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (lang !== undefined && lang !== null) url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
    if (resolveBehaviors !== undefined && resolveBehaviors !== null)
      resolveBehaviors &&
        resolveBehaviors.forEach((item) => {
          url_ += 'resolveBehaviors=' + encodeURIComponent('' + item) + '&';
        });
    if (contentResolveLimit !== undefined && contentResolveLimit !== null)
      url_ += 'contentResolveLimit=' + encodeURIComponent('' + contentResolveLimit) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetJson(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetJson(<any>response_);
            } catch (e) {
              return <Observable<ShareDetail>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShareDetail>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetJson(response: HttpResponseBase): Observable<ShareDetail> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShareDetail.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShareDetail>(<any>null);
  }

  getContentsInShare(
    token: string | null,
    lang: string | null | undefined,
    limit: number | undefined,
    pageToken: string | null | undefined
  ): Observable<ShareContentDetailResult> {
    let url_ = this.baseUrl + '/json/{token}/contents?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (lang !== undefined && lang !== null) url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
    if (pageToken !== undefined && pageToken !== null) url_ += 'pageToken=' + encodeURIComponent('' + pageToken) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContentsInShare(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContentsInShare(<any>response_);
            } catch (e) {
              return <Observable<ShareContentDetailResult>>(<any>_observableThrow(e));
            }
          } else return <Observable<ShareContentDetailResult>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetContentsInShare(response: HttpResponseBase): Observable<ShareContentDetailResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ShareContentDetailResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<ShareContentDetailResult>(<any>null);
  }

  getOutputsInShare(token: string | null): Observable<OutputResolveResult[]> {
    let url_ = this.baseUrl + '/json/{token}/outputs';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOutputsInShare(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOutputsInShare(<any>response_);
            } catch (e) {
              return <Observable<OutputResolveResult[]>>(<any>_observableThrow(e));
            }
          } else return <Observable<OutputResolveResult[]>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOutputsInShare(response: HttpResponseBase): Observable<OutputResolveResult[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(OutputResolveResult.fromJS(item));
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<OutputResolveResult[]>(<any>null);
  }

  downloadShare(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/d/{token}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShare(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShare(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShare(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  createShareSelectionDownloadLink(token: string | null, request: ShareDownloadRequest): Observable<DownloadLink> {
    let url_ = this.baseUrl + '/d/{token}';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateShareSelectionDownloadLink(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateShareSelectionDownloadLink(<any>response_);
            } catch (e) {
              return <Observable<DownloadLink>>(<any>_observableThrow(e));
            }
          } else return <Observable<DownloadLink>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateShareSelectionDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DownloadLink.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<DownloadLink>(<any>null);
  }

  downloadShare2(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/d/{token}/{contentId}/{outputFormatId}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShare2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShare2(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShare2(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  downloadShare3(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/d/{token}/{conversionPreset}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShare3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShare3(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShare3(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  downloadShareInline(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/v/{token}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShareInline(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShareInline(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShareInline(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  downloadShareInline2(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/v/{token}/{contentId}/{outputFormatId}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShareInline2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShareInline2(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShareInline2(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  downloadShareInline3(
    token: string | null,
    conversionPreset: string | null,
    w: number | null | undefined,
    h: number | null | undefined,
    width: number | null | undefined,
    height: number | null | undefined,
    contentId: string | null,
    outputFormatId: string | null
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/v/{token}/{conversionPreset}?';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (conversionPreset === undefined || conversionPreset === null)
      throw new Error("The parameter 'conversionPreset' must be defined.");
    url_ = url_.replace('{conversionPreset}', encodeURIComponent('' + conversionPreset));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    if (outputFormatId === undefined || outputFormatId === null)
      throw new Error("The parameter 'outputFormatId' must be defined.");
    url_ = url_.replace('{outputFormatId}', encodeURIComponent('' + outputFormatId));
    if (w !== undefined && w !== null) url_ += 'w=' + encodeURIComponent('' + w) + '&';
    if (h !== undefined && h !== null) url_ += 'h=' + encodeURIComponent('' + h) + '&';
    if (width !== undefined && width !== null) url_ += 'width=' + encodeURIComponent('' + width) + '&';
    if (height !== undefined && height !== null) url_ += 'height=' + encodeURIComponent('' + height) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadShareInline3(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadShareInline3(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDownloadShareInline3(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getContentIcon(token: string | null, contentId: string | null): Observable<FileResponse> {
    let url_ = this.baseUrl + '/icon/{token}/{contentId}';
    if (token === undefined || token === null) throw new Error("The parameter 'token' must be defined.");
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (contentId === undefined || contentId === null) throw new Error("The parameter 'contentId' must be defined.");
    url_ = url_.replace('{contentId}', encodeURIComponent('' + contentId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContentIcon(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContentIcon(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetContentIcon(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result400: any = null;
          let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = PictureparkValidationException.fromJS(resultData400);
          return throwException('Validation exception', status, _responseText, _headers, result400);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Unauthorized', status, _responseText, _headers);
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result403: any = null;
          let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = PictureparkForbiddenException.fromJS(resultData403);
          return throwException('Forbidden', status, _responseText, _headers, result403);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result404: any = null;
          let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = PictureparkNotFoundException.fromJS(resultData404);
          return throwException('Entity not found', status, _responseText, _headers, result404);
        })
      );
    } else if (status === 405) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Method not allowed', status, _responseText, _headers);
        })
      );
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result409: any = null;
          let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = PictureparkConflictException.fromJS(resultData409);
          return throwException('Version conflict', status, _responseText, _headers, result409);
        })
      );
    } else if (status === 429) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('Too many requests', status, _responseText, _headers);
        })
      );
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result500: any = null;
          let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = PictureparkException.fromJS(resultData500);
          return throwException('Internal server error', status, _responseText, _headers, result500);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
