/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.16.0 (NJsonSchema v9.10.19.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { PictureparkServiceBase } from './base.service';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

export const PICTUREPARK_API_URL = new InjectionToken<string>('PICTUREPARK_API_URL');

export abstract class AuthService {
    private _pictureparkApiUrl: string;

    constructor(pictureparkApiUrl: string) {
        this._pictureparkApiUrl = pictureparkApiUrl;
    }

    get apiServer() {
        return this._pictureparkApiUrl;
    }

    abstract get isAuthenticated(): boolean;
    abstract transformHttpRequestOptions(options: any): Promise<any>;
}

@Injectable()
export class ContentService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    
    private thumbnailCache: { [key: string]: FileResponse | null; } = {};

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize, cache?: boolean): Observable<FileResponse | null> {
        const key = contentId + ':' + size;
        if (cache !== false && this.thumbnailCache[key] !== undefined) {
            return Observable.of(this.thumbnailCache[key]);
        }

        const response = this.downloadThumbnailCore(contentId, size, null, null);
        response.subscribe(blob => {
            this.thumbnailCache[key] = blob;
        });
        return response;
    }

    /**
     * Get detail - single
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @return ContentDetail
     */
    get(contentId: string, resolve: boolean, patterns: DisplayPatternType[] | null | undefined): Observable<ContentDetail | null> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail | null>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<ContentDetail | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : new ContentNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail | null>(<any>null);
    }

    /**
     * Get detail - many
     * @ids List of contentIds
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @return List of ContentDetail
     */
    getMany(ids: string[] | null, resolve: boolean, patterns: DisplayPatternType[] | null | undefined): Observable<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/contents/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContentDetail.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail[]>(<any>null);
    }

    /**
     * Create - many
     * @contentCreateManyRequest The content create many request.
     */
    createMany(contentCreateManyRequest: ContentCreateManyRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Search
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest | null): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : new ContentSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentSearchResult>(<any>null);
    }

    /**
     * Search by channel
     * @channelId The channel id.
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    searchByChannel(channelId: string, contentSearchRequest: ContentSearchRequest | null): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/contents/{channelId}/search";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{channelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchByChannel(<any>response_);
                } catch (e) {
                    return <Observable<ContentSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchByChannel(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentSearchResult.fromJS(resultData200) : new ContentSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest | null): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate by channel
     * @channelId The channel id
     * @contentAggregationRequest The content aggregation request.
     * @return ObjectAggregationResult
     */
    aggregateByChannel(channelId: string, contentAggregationRequest: ContentAggregationRequest | null): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/contents/{channelId}/aggregate";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{channelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAggregateByChannel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregateByChannel(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregateByChannel(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create download link
     * @request The content download link request
     * @return ContentBatchDonloadItem
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest | null): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateDownloadLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDownloadLink(<any>response_);
                } catch (e) {
                    return <Observable<DownloadLink>><any>Observable.throw(e);
                }
            } else
                return <Observable<DownloadLink>><any>Observable.throw(response_);
        });
    }

    protected processCreateDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DownloadLink.fromJS(resultData200) : new DownloadLink();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DownloadLink>(<any>null);
    }

    /**
     * Download output
     * @contentId The content id
     * @outputFormatId The output format id
     * @width (optional) Optional width in pixels to resize image
     * @height (optional) Optional height in pixels to resize image
     * @range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     * @return HttpResponseMessage
     */
    download(contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDownload(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @width (optional) Optional width in pixels to resize image
     * @height (optional) Optional height in pixels to resize image
     * @return HttpResponseMessage
     */
    protected downloadThumbnailCore(contentId: string, size: ThumbnailSize, width: number | null | undefined, height: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/contents/thumbnails/{contentId}/{size}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDownloadThumbnail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadThumbnail(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processDownloadThumbnail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse>(<any>null);
    }

    /**
     * Create - single
     * @contentCreateRequest The content create request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     */
    create(contentCreateRequest: ContentCreateRequest | null, resolve: boolean, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Deactivate - single
     * @contentId the id of the content to deactivate
     * @timeout Maximum time to wait for the business process completed state.
     */
    deactivate(contentId: string, timeout: string | null): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/deactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout === undefined)
            throw new Error("The parameter 'timeout' must be defined.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processDeactivate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Deactivate - many
     * @deactivateRequest The deactivate request
     * @return BusinessProcess
     */
    deactivateMany(deactivateRequest: ContentDeactivateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDeactivateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Reactivate - single
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @allowMissingDependencies (optional) Allow reactivating contents that refer to list items or contents that don't exist in the system.
     * @return ContentDetail
     */
    reactivate(contentId: string, resolve: boolean, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined, allowMissingDependencies: boolean | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/reactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processReactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivate(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processReactivate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Reactivate - many
     * @reactivateRequest The content reactivate request.
     * @return BusinessProcess
     */
    reactivateMany(reactivateRequest: ContentReactivateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/reactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reactivateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processReactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processReactivateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Update file - single
     * @contentId The id of the content to replace
     * @updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/file";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Update metadata - single
     * @contentId The content id.
     * @updateRequest The metadata update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @allowMissingDependencies (optional) Allow storing references to missing list items
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, updateRequest: ContentMetadataUpdateRequest | null, resolve: boolean, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/metadata?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateMetadata(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadata(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadata(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Update permissions - single
     * @contentId The content id.
     * @updateRequest The content permission update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, updateRequest: ContentPermissionsUpdateRequest | null, resolve: boolean, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdatePermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Update metadata - many
     * @updateRequest The metadata update requests.
     * @return BusinessProcess
     */
    updateMetadataMany(updateRequest: ContentMetadataUpdateManyRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateMetadataMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadataMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMetadataMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentsNotFoundException.fromJS(resultData404) : new ContentsNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Update permissions - many
     * @updateRequest The permissions update request.
     * @return BusinessProcess
     */
    updatePermissionsMany(updateRequest: ContentPermissionsUpdateRequest[] | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdatePermissionsMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionsMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePermissionsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Transfer ownership - single
     * @contentId The content id.
     * @updateRequest The content ownership transfer request update request.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @return ContentDetail
     */
    transferOwnership(contentId: string, updateRequest: ContentOwnershipTransferRequest | null, timeout: string | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/contents/{contentId}/ownership/transfer?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processTransferOwnership(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(<any>response_);
                } catch (e) {
                    return <Observable<ContentDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentDetail>><any>Observable.throw(response_);
        });
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentDetail.fromJS(resultData200) : new ContentDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentDetail>(<any>null);
    }

    /**
     * Transfer ownership - many
     * @contentsOwnershipTransferRequest The content ownership transfer request.
     * @return BusinessProcess
     */
    transferOwnershipMany(contentsOwnershipTransferRequest: ContentsOwnershipTransferRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/many/ownership/transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsOwnershipTransferRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ContentFieldsUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ContentFieldsFilterUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }
}

@Injectable()
export class BusinessProcessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @businessProcessSearchRequest The business process request
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest | null): Observable<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<BusinessProcessSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessSearchResult.fromJS(resultData200) : new BusinessProcessSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcessSearchResult>(<any>null);
    }

    /**
     * Wait
     * @processId The process id
     * @states (optional) The states to wait for
     * @lifeCycleIds (optional) Business process lifeCycle to wait for
     * @timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    wait(processId: string, states: string[] | null | undefined, lifeCycleIds: BusinessProcessLifeCycle[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (lifeCycleIds !== undefined)
            lifeCycleIds && lifeCycleIds.forEach(item => { url_ += "lifeCycleIds=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processWait(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWait(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWait(response: HttpResponseBase): Observable<BusinessProcessWaitResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : new BusinessProcessWaitResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcessWaitResult>(<any>null);
    }

    /**
     * Wait for completion
     * @processId The process id
     * @timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(processId: string, timeout: string | null | undefined): Observable<BusinessProcessWaitResult> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/waitCompletion?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processWaitForCompletion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForCompletion(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessWaitResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessWaitResult>><any>Observable.throw(response_);
        });
    }

    protected processWaitForCompletion(response: HttpResponseBase): Observable<BusinessProcessWaitResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessWaitResult.fromJS(resultData200) : new BusinessProcessWaitResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcessWaitResult>(<any>null);
    }

    /**
     * Get details
     * @processId The process id
     * @return BusinessProcessDetails
     */
    getDetails(processId: string): Observable<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/details";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDetails(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcessDetails>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcessDetails>><any>Observable.throw(response_);
        });
    }

    protected processGetDetails(response: HttpResponseBase): Observable<BusinessProcessDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcessDetails.fromJS(resultData200) : new BusinessProcessDetails();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcessDetails>(<any>null);
    }
}

@Injectable()
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @documentHistorySearchRequest The document history search request
     * @return DocumentHistorySearchResult
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest | null): Observable<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistorySearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistorySearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<DocumentHistorySearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistorySearchResult.fromJS(resultData200) : new DocumentHistorySearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DocumentHistorySearchResult>(<any>null);
    }

    /**
     * Get latest
     * @id The id of the document (e.g. ContentId)
     * @return DocumentHistory
     */
    get(id: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistory>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : new DocumentHistory();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DocumentHistory>(<any>null);
    }

    /**
     * Get latest by version
     * @id The id of the document (e.g. ContentId)
     * @version The version
     * @return DocumentHistory
     */
    getVersion(id: string, version: string): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{id}/{version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetVersion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistory>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistory>><any>Observable.throw(response_);
        });
    }

    protected processGetVersion(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistory.fromJS(resultData200) : new DocumentHistory();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DocumentHistory>(<any>null);
    }

    /**
     * Get latest difference
     * @id The id of the document (e.g. ContentId)
     * @oldVersion The old version
     * @return DocumentHistoryDifference
     */
    getDifferenceLatest(id: string, oldVersion: number): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDifferenceLatest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDifferenceLatest(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>Observable.throw(response_);
        });
    }

    protected processGetDifferenceLatest(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : new DocumentHistoryDifference();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Get difference
     * @id The id of the document (e.g. ContentId)
     * @oldVersion The old version
     * @newVersion The new version
     * @return DocumentHistoryDifference
     */
    getDifference(id: string, oldVersion: number, newVersion: number): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{id}/difference/{oldVersion}/{newVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{oldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{newVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetDifference(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDifference(<any>response_);
                } catch (e) {
                    return <Observable<DocumentHistoryDifference>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentHistoryDifference>><any>Observable.throw(response_);
        });
    }

    protected processGetDifference(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentHistoryDifference.fromJS(resultData200) : new DocumentHistoryDifference();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DocumentHistoryDifference>(<any>null);
    }
}

@Injectable()
export class JsonSchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Json Schema
     * @schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Observable<any> {
        let url_ = this.baseUrl + "/v1/jsonSchemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }
}

@Injectable()
export class ListItemService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @listItemId The list item id.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @patterns (optional) Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    get(listItemId: string, resolve: boolean, patterns: DisplayPatternType[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ListItemNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemDetail>(<any>null);
    }

    /**
     * Update - single
     * @listItemId The list item id.
     * @updateRequest The list item update request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    update(listItemId: string, updateRequest: ListItemUpdateRequest | null, resolve: boolean, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemDetail>(<any>null);
    }

    /**
     * Search
     * @listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest | null): Observable<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/listItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListItemSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<ListItemSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemSearchResult.fromJS(resultData200) : new ListItemSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest | null): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/listItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - single
     * @listItemCreateRequest List item create request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @allowMissingDependencies (optional) Allow creating list items that refer to list items or contents that don't exist in the system.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    create(listItemCreateRequest: ListItemCreateRequest | null, resolve: boolean, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemDetail>(<any>null);
    }

    /**
     * Create - many
     * @listItemCreateManyRequest List item create many request.
     * @return BusinessProcess
     */
    createMany(listItemCreateManyRequest: ListItemCreateManyRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemCreateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Update - many
     * @listItemUpdateManyRequest List item update many request.
     * @return BusinessProcess
     */
    updateMany(listItemUpdateManyRequest: ListItemUpdateManyRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemUpdateManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Deactivate - single
     * @listItemId the id of the list item to deactivate
     * @timeout Maximum time to wait for the business process completed state.
     */
    deactivate(listItemId: string, timeout: string | null): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/deactivate?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (timeout === undefined)
            throw new Error("The parameter 'timeout' must be defined.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processDeactivate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemDetail>(<any>null);
    }

    /**
     * Deactivate - many
     * @deactivateRequest The list items deactivate request
     * @return BusinessProcess
     */
    deactivateMany(deactivateRequest: ListItemDeactivateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDeactivateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Reactivate - single
     * @listItemId The list item id.
     * @timeout (optional) Maximum time to wait for the business process completed state.
     * @patterns (optional) List of display pattern types. Resolves display values of referenced list items where the display pattern matches.
     * @allowMissingDependencies (optional) Allow reactivating list items that refer to list items or contents that don't exist in the system.
     * @return ListItemDetail
     */
    reactivate(listItemId: string, timeout: string | null | undefined, patterns: DisplayPatternType[] | null | undefined, allowMissingDependencies: boolean | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/listItems/{listItemId}/reactivate?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processReactivate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivate(<any>response_);
                } catch (e) {
                    return <Observable<ListItemDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListItemDetail>><any>Observable.throw(response_);
        });
    }

    protected processReactivate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListItemDetail.fromJS(resultData200) : new ListItemDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListItemDetail>(<any>null);
    }

    /**
     * Reactivate - many
     * @reactivateRequest The list items reactivate request.
     * @return BusinessProcess
     */
    reactivateMany(reactivateRequest: ListItemReactivateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/many/reactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reactivateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processReactivateMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivateMany(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processReactivateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by ids
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByIds(updateRequest: ListItemFieldsUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    batchUpdateFieldsByFilter(updateRequest: ListItemFieldsFilterUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/listItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }
}

@Injectable()
export class LiveStreamService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search LiveStream
     * @liveStreamSearchRequest The livestream search request
     * @return ObjectSearchResult
     */
    search(liveStreamSearchRequest: LiveStreamSearchRequest | null): Observable<ObjectSearchResult> {
        let url_ = this.baseUrl + "/v1/liveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(liveStreamSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ObjectSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<ObjectSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectSearchResult.fromJS(resultData200) : new ObjectSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ObjectSearchResult>(<any>null);
    }
}

@Injectable()
export class SchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @schemaId The schema id.
     * @return SchemaDetail
     */
    get(schemaId: string): Observable<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaDetail.fromJS(resultData200) : new SchemaDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SchemaDetail>(<any>null);
    }

    /**
     * Update - single
     * @schemaId The schema id.
     * @schema The schema update request.
     * @return BusinessProcess
     */
    update(schemaId: string, schema: SchemaUpdateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? SchemaNotFoundException.fromJS(resultData404) : new SchemaNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkBusinessException.fromJS(resultData400) : new PictureparkBusinessException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Delete - single
     * @schemaId The schema id.
     * @return BusinessProcess
     */
    delete(schemaId: string): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? SchemaNotFoundException.fromJS(resultData404) : new SchemaNotFoundException();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkBusinessException.fromJS(resultData400) : new PictureparkBusinessException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Get - many
     * @ids (optional) Comma separated list of schema ids
     * @return SchemaDetail
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<SchemaDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SchemaDetail.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SchemaDetail[]>(<any>null);
    }

    /**
     * Create - single
     * @schema The schema create request.
     * @return BusinessProcess
     */
    create(schema: SchemaCreateRequest | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BusinessProcess>><any>Observable.throw(e);
                }
            } else
                return <Observable<BusinessProcess>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessProcess.fromJS(resultData200) : new BusinessProcess();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? PictureparkBusinessException.fromJS(resultData400) : new PictureparkBusinessException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BusinessProcess>(<any>null);
    }

    /**
     * Search
     * @schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest | null): Observable<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<SchemaSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<SchemaSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaSearchResult.fromJS(resultData200) : new SchemaSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SchemaSearchResult>(<any>null);
    }

    /**
     * Exists
     * @schemaId The schema id.
     * @fieldId (optional) The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId: string | null | undefined): Observable<ExistsResponse> {
        let url_ = this.baseUrl + "/v1/schemas/{schemaId}/exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processExists(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<ExistsResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExistsResponse>><any>Observable.throw(response_);
        });
    }

    protected processExists(response: HttpResponseBase): Observable<ExistsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExistsResponse.fromJS(resultData200) : new ExistsResponse();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ExistsResponse>(<any>null);
    }
}

@Injectable()
export class PermissionService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search Content Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchContentPermissionSets(request: PermissionSetSearchRequest | null): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/permission/contentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchContentPermissionSets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchContentPermissionSets(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchContentPermissionSets(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : new PermissionSetSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get Content Permission - single
     * @permissionSetId The content permission set id.
     * @return ContentPermissionSetDetail
     */
    getContentPermissionSet(permissionSetId: string): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/permission/contentPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetContentPermissionSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContentPermissionSet(<any>response_);
                } catch (e) {
                    return <Observable<ContentPermissionSetDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentPermissionSetDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetContentPermissionSet(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentPermissionSetDetail.fromJS(resultData200) : new ContentPermissionSetDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Search Schema PermissionSets
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchSchemaPermissionSets(request: PermissionSetSearchRequest | null): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/permission/schemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchSchemaPermissionSets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchSchemaPermissionSets(<any>response_);
                } catch (e) {
                    return <Observable<PermissionSetSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<PermissionSetSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchSchemaPermissionSets(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionSetSearchResult.fromJS(resultData200) : new PermissionSetSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PermissionSetSearchResult>(<any>null);
    }

    /**
     * Get Schema PermissionSets - single
     * @permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetail
     */
    getSchemaPermissionSet(permissionSetId: string): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/permission/schemaPermissionSets/{permissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{permissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSchemaPermissionSet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchemaPermissionSet(<any>response_);
                } catch (e) {
                    return <Observable<SchemaPermissionSetDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<SchemaPermissionSetDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetSchemaPermissionSet(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SchemaPermissionSetDetail.fromJS(resultData200) : new SchemaPermissionSetDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Get User rights
     * @return list of user permissions
     */
    getUserRights(): Observable<UserRight[]> {
        let url_ = this.baseUrl + "/v1/permission/userPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserRights(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRights(<any>response_);
                } catch (e) {
                    return <Observable<UserRight[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserRight[]>><any>Observable.throw(response_);
        });
    }

    protected processGetUserRights(response: HttpResponseBase): Observable<UserRight[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserRight[]>(<any>null);
    }

    /**
     * Has UserRight
     * @userRight The UserRight to validate
     * @return Boolean - user has permission
     */
    hasUserRight(userRight: UserRight): Observable<boolean> {
        let url_ = this.baseUrl + "/v1/permission/userPermissions/{userRight}";
        if (userRight === undefined || userRight === null)
            throw new Error("The parameter 'userRight' must be defined.");
        url_ = url_.replace("{userRight}", encodeURIComponent("" + userRight)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processHasUserRight(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasUserRight(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processHasUserRight(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<boolean>(<any>null);
    }
}

@Injectable()
export class PublicAccessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Version
     * @return VersionInfo
     */
    getVersion(): Observable<VersionInfo> {
        let url_ = this.baseUrl + "/v1/publicAccess/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetVersion(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(<any>response_);
                } catch (e) {
                    return <Observable<VersionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<VersionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VersionInfo.fromJS(resultData200) : new VersionInfo();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<VersionInfo>(<any>null);
    }

    /**
     * Get Share
     * @token The token
     * @return ShareBaseDetail
     */
    getShare(token: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/publicAccess/shares/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetShare(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShare(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetShare(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShareDetail>(<any>null);
    }
}

@Injectable()
export class ShareService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get - single
     * @id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ShareNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShareDetail>(<any>null);
    }

    /**
     * Update - single
     * @id The share id.
     * @updateRequest The share update request.
     * @return Share
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest | null): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ShareDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareDetail>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareDetail.fromJS(resultData200) : new ShareDetail();
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? BusinessProcessWaitTimeoutException.fromJS(resultData400) : new BusinessProcessWaitTimeoutException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShareDetail>(<any>null);
    }

    /**
     * Search
     * @request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest | null): Observable<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ShareSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ShareSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<ShareSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShareSearchResult.fromJS(resultData200) : new ShareSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ShareSearchResult>(<any>null);
    }

    /**
     * Aggregate
     * @request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest | null): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAggregate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(<any>response_);
                } catch (e) {
                    return <Observable<ObjectAggregationResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ObjectAggregationResult>><any>Observable.throw(response_);
        });
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ObjectAggregationResult.fromJS(resultData200) : new ObjectAggregationResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ObjectAggregationResult>(<any>null);
    }

    /**
     * Create - single
     * @request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest | null): Observable<CreateShareResult> {
        let url_ = this.baseUrl + "/v1/shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateShareResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateShareResult>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateShareResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ContentNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 403) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = resultData403 ? PermissionException.fromJS(resultData403) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateShareResult.fromJS(resultData200) : new CreateShareResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CreateShareResult>(<any>null);
    }

    /**
     * Delete - many
     * @ids A list of shareIds to delete.
     * @return BusinessProcess
     */
    deleteMany(ids: string[] | null): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/shares/many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteMany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<BulkResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<BulkResponse>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BulkResponse.fromJS(resultData200) : new BulkResponse();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BulkResponse>(<any>null);
    }
}

@Injectable()
export class ServiceProviderService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get configuration
     */
    getConfiguration(serviceProviderId: string): Observable<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetConfiguration(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<CustomerServiceProviderConfiguration>><any>Observable.throw(e);
                }
            } else
                return <Observable<CustomerServiceProviderConfiguration>><any>Observable.throw(response_);
        });
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<CustomerServiceProviderConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerServiceProviderConfiguration.fromJS(resultData200) : new CustomerServiceProviderConfiguration();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CustomerServiceProviderConfiguration>(<any>null);
    }

    /**
     * Update configuration
     */
    updateConfiguration(serviceProviderId: string, configuration: ServiceProviderConfigurationUpdateRequest | null): Observable<CustomerServiceProviderConfiguration> {
        let url_ = this.baseUrl + "/v1/serviceProviders/{serviceProviderId}/configuration";
        if (serviceProviderId === undefined || serviceProviderId === null)
            throw new Error("The parameter 'serviceProviderId' must be defined.");
        url_ = url_.replace("{serviceProviderId}", encodeURIComponent("" + serviceProviderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configuration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateConfiguration(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<CustomerServiceProviderConfiguration>><any>Observable.throw(e);
                }
            } else
                return <Observable<CustomerServiceProviderConfiguration>><any>Observable.throw(response_);
        });
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<CustomerServiceProviderConfiguration> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerServiceProviderConfiguration.fromJS(resultData200) : new CustomerServiceProviderConfiguration();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CustomerServiceProviderConfiguration>(<any>null);
    }
}

@Injectable()
export class TransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Transferdetail
     * @transferId The tranfer id
     * @return TransferDetail
     */
    get(transferId: string): Observable<TransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TransferDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferDetail.fromJS(resultData200) : new TransferDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransferDetail>(<any>null);
    }

    /**
     * Delete Transfer
     * @transferId The tranfer id
     * @return Transfer
     */
    delete(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Search
     * @request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest | null): Observable<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<TransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<TransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransferSearchResult.fromJS(resultData200) : new TransferSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TransferSearchResult>(<any>null);
    }

    /**
     * Cancels a transfer.
     */
    cancelTransfer(transferId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCancelTransfer(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTransfer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelTransfer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Create Transfer
     * @request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest | null): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Transfer>(<any>null);
    }

    /**
     * Get File
     * @fileTransferId The filetransfer id
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Observable<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/transfers/files/{fileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{fileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileTransferDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferDetail.fromJS(resultData200) : new FileTransferDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @request The file transfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest | null): Observable<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearchFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFiles(<any>response_);
                } catch (e) {
                    return <Observable<FileTransferSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileTransferSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearchFiles(response: HttpResponseBase): Observable<FileTransferSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileTransferSearchResult.fromJS(resultData200) : new FileTransferSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileTransferSearchResult>(<any>null);
    }

    /**
     * Get Blacklist
     * @return Blacklist
     */
    getBlacklist(): Observable<Blacklist> {
        let url_ = this.baseUrl + "/v1/transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetBlacklist(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlacklist(<any>response_);
                } catch (e) {
                    return <Observable<Blacklist>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blacklist>><any>Observable.throw(response_);
        });
    }

    protected processGetBlacklist(response: HttpResponseBase): Observable<Blacklist> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Blacklist.fromJS(resultData200) : new Blacklist();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Blacklist>(<any>null);
    }

    /**
     * Delete Files
     * @request The filetransfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Import transfer
     * @transferId The tranfer id
     * @request The filetransfer to content create request
     * @return Transfer
     */
    importTransfer(transferId: string, request: FileTransfer2ContentCreateRequest | null): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processImportTransfer(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTransfer(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processImportTransfer(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Transfer>(<any>null);
    }

    /**
     * Create a partial import
     * @transferId The transfer id
     * @request The filetransfer partial to content create request
     */
    partialImport(transferId: string, request: FileTransferPartial2ContentCreateRequest | null): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/partialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processPartialImport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartialImport(<any>response_);
                } catch (e) {
                    return <Observable<Transfer>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transfer>><any>Observable.throw(response_);
        });
    }

    protected processPartialImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transfer.fromJS(resultData200) : new Transfer();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Transfer>(<any>null);
    }

    /**
     * Upload file
     * @formFile (optional) Gets or sets the form file.
     * @relativePath (optional) Relative path of the uploading file
     * @chunkNumber (optional) Current chunk number. starts with 1
     * @currentChunkSize (optional) Size in bytes of the current chunk
     * @totalSize (optional) Total size in bytes of the uploading file
     * @totalChunks (optional) Total chunks of the uploading file
     */
    uploadFile(formFile: FileParameter | null | undefined, relativePath: string | null | undefined, chunkNumber: number | undefined, currentChunkSize: number | undefined, totalSize: number | undefined, totalChunks: number | undefined, transferId: string, identifier: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/transfers/{transferId}/files/{identifier}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{identifier}", encodeURIComponent("" + identifier)); 
        if (relativePath !== undefined)
            url_ += "relativePath=" + encodeURIComponent("" + relativePath) + "&"; 
        if (chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' cannot be null.");
        else if (chunkNumber !== undefined)
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' cannot be null.");
        else if (currentChunkSize !== undefined)
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === null)
            throw new Error("The parameter 'totalSize' cannot be null.");
        else if (totalSize !== undefined)
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === null)
            throw new Error("The parameter 'totalChunks' cannot be null.");
        else if (totalChunks !== undefined)
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUploadFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get by id
     * @userId The user id
     * @return UserDetail
     */
    get(userId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserDetail>(<any>null);
    }

    /**
     * Search for users
     * @searchRequest The user search request
     * @return UserSearchResult
     */
    search(searchRequest: UserSearchRequest | null): Observable<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<UserSearchResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserSearchResult>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: HttpResponseBase): Observable<UserSearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSearchResult.fromJS(resultData200) : new UserSearchResult();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserSearchResult>(<any>null);
    }

    /**
     * Get by owner token
     * @tokenId The token id
     * @return UserDetail
     */
    getByOwnerToken(tokenId: string): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetByOwnerToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOwnerToken(<any>response_);
                } catch (e) {
                    return <Observable<UserDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDetail>><any>Observable.throw(response_);
        });
    }

    protected processGetByOwnerToken(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDetail.fromJS(resultData200) : new UserDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserDetail>(<any>null);
    }

    /**
     * Get list of channels
     */
    getChannels(): Observable<Channel[]> {
        let url_ = this.baseUrl + "/v1/users/channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetChannels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChannels(<any>response_);
                } catch (e) {
                    return <Observable<Channel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Channel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetChannels(response: HttpResponseBase): Observable<Channel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Channel.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Channel[]>(<any>null);
    }
}

@Injectable()
export class OutputService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get outputs by contentIds
     * @contentsByIdsRequest Contains the list of contentIds for which the outputs are requested
     * @return The Result containing a list of OutputDetail's
     */
    getByContentIds(contentsByIdsRequest: ContentsByIdsRequest | null): Observable<OutputDetail[]> {
        let url_ = this.baseUrl + "/v1/outputs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsByIdsRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetByContentIds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByContentIds(<any>response_);
                } catch (e) {
                    return <Observable<OutputDetail[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OutputDetail[]>><any>Observable.throw(response_);
        });
    }

    protected processGetByContentIds(response: HttpResponseBase): Observable<OutputDetail[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OutputDetail.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OutputDetail[]>(<any>null);
    }

    /**
     * Get - single
     * @outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Observable<OutputDetail> {
        let url_ = this.baseUrl + "/v1/outputs/{outputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{outputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OutputDetail>><any>Observable.throw(e);
                }
            } else
                return <Observable<OutputDetail>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<OutputDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? OutputNotFoundException.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutputDetail.fromJS(resultData200) : new OutputDetail();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OutputDetail>(<any>null);
    }
}

@Injectable()
export class ProfileService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return UserProfile
     */
    get(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfile>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfile.fromJS(resultData200) : new UserProfile();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserProfile>(<any>null);
    }

    /**
     * Update
     * @return UserProfile
     */
    update(profile: UserProfile | null): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserProfile>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfile>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfile.fromJS(resultData200) : new UserProfile();
            return Observable.of(result200);
            });
        } else if (status === 500) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? PictureparkException.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserProfile>(<any>null);
    }
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Name = <any>"Name", 
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.innerException = data.innerException && !(<any>data.innerException).toJSON ? new Exception(data.innerException) : <Exception>this.innerException; 
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.innerException = data["innerException"] ? Exception.fromJS(data["innerException"]) : <any>undefined;
            this.stackTrace = data["stackTrace"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): Exception {
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["stackTrace"] = this.stackTrace;
        data["source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: IException | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.traceLevel = data["traceLevel"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
            this.httpStatusCode = data["httpStatusCode"];
        }
    }

    static fromJS(data: any): PictureparkException {
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentsNotFoundException") {
            let result = new ContentsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCyclicDependencyException") {
            let result = new SchemaCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidCustomerException") {
            let result = new InvalidCustomerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUserOrPasswordException") {
            let result = new InvalidUserOrPasswordException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MessagePerformerTaskCanceledException") {
            let result = new MessagePerformerTaskCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["traceLevel"] = this.traceLevel;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        data["httpStatusCode"] = this.httpStatusCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkException extends IException {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
            this.customerAlias = data["customerAlias"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): PictureparkBusinessException {
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessWaitTimeoutException") {
            let result = new BusinessProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentsNotFoundException") {
            let result = new ContentsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCyclicDependencyException") {
            let result = new SchemaCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionException") {
            let result = new PermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentNotFoundException") {
            let result = new DocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DriveRequestException") {
            let result = new DriveRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkInvalidMetadataException") {
            let result = new PictureparkInvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkMappingException") {
            let result = new PictureparkMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFoundException") {
            let result = new NotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationTimeoutException") {
            let result = new OperationTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingJobItemNotSetException") {
            let result = new RenderingJobItemNotSetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenValidationException") {
            let result = new TokenValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPermanentlyRemovedException") {
            let result = new UserPermanentlyRemovedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesRightsAssignedException") {
            let result = new UserRolesRightsAssignedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class ContentNotFoundException extends PictureparkBusinessException implements IContentNotFoundException {
    contentId?: string | undefined;

    constructor(data?: IContentNotFoundException) {
        super(data);
        this._discriminator = "ContentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): ContentNotFoundException {
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);
        this._discriminator = "PictureparkApplicationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkApplicationException {
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class PictureparkArgumentNullException extends PictureparkBusinessException implements IPictureparkArgumentNullException {
    argumentName?: string | undefined;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this._discriminator = "PictureparkArgumentNullException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
        }
    }

    static fromJS(data: any): PictureparkArgumentNullException {
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkArgumentNullException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
}

export class ContentsNotFoundException extends PictureparkBusinessException implements IContentsNotFoundException {
    contentIds?: string[] | undefined;

    constructor(data?: IContentsNotFoundException) {
        super(data);
        this._discriminator = "ContentsNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentsNotFoundException {
        let result = new ContentsNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentsNotFoundException extends IPictureparkBusinessException {
    contentIds?: string[] | undefined;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[] | undefined;

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["processDefinitionIds"] && data["processDefinitionIds"].constructor === Array) {
                this.processDefinitionIds = [];
                for (let item of data["processDefinitionIds"])
                    this.processDefinitionIds.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionCreateException {
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.processDefinitionIds && this.processDefinitionIds.constructor === Array) {
            data["processDefinitionIds"] = [];
            for (let item of this.processDefinitionIds)
                data["processDefinitionIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkBusinessException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string | undefined;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.processDefinitionId = data["processDefinitionId"];
        }
    }

    static fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefinitionId"] = this.processDefinitionId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkBusinessException {
    processDefinitionId?: string | undefined;
}

export class BusinessProcessNotFoundException extends PictureparkBusinessException implements IBusinessProcessNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessNotFoundException {
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessNotFoundException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
}

export class BusinessProcessWaitTimeoutException extends PictureparkBusinessException implements IBusinessProcessWaitTimeoutException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessWaitTimeoutException) {
        super(data);
        this._discriminator = "BusinessProcessWaitTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.businessProcessId = data["businessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcessWaitTimeoutException {
        let result = new BusinessProcessWaitTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessWaitTimeoutException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string | undefined;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this._discriminator = "CustomerHostNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CustomerHostNotFoundException {
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string | undefined;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this._discriminator = "CustomerNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CustomerNotFoundException {
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string | undefined;
}

export class DocumentNotFoundException extends PictureparkBusinessException implements IDocumentNotFoundException {
    documentId?: string | undefined;

    constructor(data?: IDocumentNotFoundException) {
        super(data);
        this._discriminator = "DocumentNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
        }
    }

    static fromJS(data: any): DocumentNotFoundException {
        let result = new DocumentNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
}

export class DocumentVersionNotFoundException extends PictureparkBusinessException implements IDocumentVersionNotFoundException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this._discriminator = "DocumentVersionNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
        }
    }

    static fromJS(data: any): DocumentVersionNotFoundException {
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentVersionNotFoundException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export class DriveRequestException extends PictureparkBusinessException implements IDriveRequestException {

    constructor(data?: IDriveRequestException) {
        super(data);
        this._discriminator = "DriveRequestException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): DriveRequestException {
        let result = new DriveRequestException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IDriveRequestException extends IPictureparkBusinessException {
}

export class DuplicateRightException extends PictureparkBusinessException implements IDuplicateRightException {
    permissionSetId?: string | undefined;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this._discriminator = "DuplicateRightException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permissionSetId = data["permissionSetId"];
        }
    }

    static fromJS(data: any): DuplicateRightException {
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateRightException extends IPictureparkBusinessException {
    permissionSetId?: string | undefined;
}

export class DuplicateDocumentException extends PictureparkBusinessException implements IDuplicateDocumentException {
    documentId?: string | undefined;
    documentType?: string | undefined;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this._discriminator = "DuplicateDocumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentId = data["documentId"];
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): DuplicateDocumentException {
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateDocumentException extends IPictureparkBusinessException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export class DuplicateAggregatorException extends PictureparkBusinessException implements IDuplicateAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this._discriminator = "DuplicateAggregatorException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregatorName = data["aggregatorName"];
        }
    }

    static fromJS(data: any): DuplicateAggregatorException {
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateAggregatorException extends IPictureparkBusinessException {
    aggregatorName?: string | undefined;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string | undefined;

    constructor(data?: IFailedToLockException) {
        super(data);
        this._discriminator = "FailedToLockException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
        }
    }

    static fromJS(data: any): FailedToLockException {
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data; 
    }
}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexException) {
        super(data);
        this._discriminator = "IndexException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): IndexException {
        let result = new IndexException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class InvalidArgumentException extends PictureparkBusinessException implements IInvalidArgumentException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this._discriminator = "InvalidArgumentException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.argumentName = data["argumentName"];
            this.argumentValue = data["argumentValue"];
        }
    }

    static fromJS(data: any): InvalidArgumentException {
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        data["argumentValue"] = this.argumentValue;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidArgumentException extends IPictureparkBusinessException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export class InvalidCustomerException extends PictureparkException implements IInvalidCustomerException {
    customerId?: string | undefined;

    constructor(data?: IInvalidCustomerException) {
        super(data);
        this._discriminator = "InvalidCustomerException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): InvalidCustomerException {
        let result = new InvalidCustomerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidCustomerException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkInvalidMetadataException extends PictureparkBusinessException implements IPictureparkInvalidMetadataException {
    metadataErrors?: MetadataError[] | undefined;

    constructor(data?: IPictureparkInvalidMetadataException) {
        super(data);
        this._discriminator = "PictureparkInvalidMetadataException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["metadataErrors"] && data["metadataErrors"].constructor === Array) {
                this.metadataErrors = [];
                for (let item of data["metadataErrors"])
                    this.metadataErrors.push(MetadataError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PictureparkInvalidMetadataException {
        let result = new PictureparkInvalidMetadataException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadataErrors && this.metadataErrors.constructor === Array) {
            data["metadataErrors"] = [];
            for (let item of this.metadataErrors)
                data["metadataErrors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkInvalidMetadataException extends IPictureparkBusinessException {
    metadataErrors?: IMetadataError[] | undefined;
}

export class MetadataError implements IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IMetadataError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorType = data["errorType"];
            this.lineNumber = data["lineNumber"];
            this.linePosition = data["linePosition"];
            this.path = data["path"];
            this.message = data["message"];
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataError {
        let result = new MetadataError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorType"] = this.errorType;
        data["lineNumber"] = this.lineNumber;
        data["linePosition"] = this.linePosition;
        data["path"] = this.path;
        data["message"] = this.message;
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

export interface IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidStateException extends PictureparkBusinessException implements IInvalidStateException {
    resourceId?: string | undefined;
    state?: string | undefined;

    constructor(data?: IInvalidStateException) {
        super(data);
        this._discriminator = "InvalidStateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.resourceId = data["resourceId"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): InvalidStateException {
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["state"] = this.state;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string | undefined;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this._discriminator = "InvalidStateTransitionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.transition = data["transition"];
        }
    }

    static fromJS(data: any): InvalidStateTransitionException {
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transition"] = this.transition;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string | undefined;
}

export class InvalidUserOrPasswordException extends PictureparkException implements IInvalidUserOrPasswordException {
    customerId?: string | undefined;

    constructor(data?: IInvalidUserOrPasswordException) {
        super(data);
        this._discriminator = "InvalidUserOrPasswordException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): InvalidUserOrPasswordException {
        let result = new InvalidUserOrPasswordException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvalidUserOrPasswordException extends IPictureparkException {
    customerId?: string | undefined;
}

export class PictureparkMappingException extends PictureparkBusinessException implements IPictureparkMappingException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IPictureparkMappingException) {
        super(data);
        this._discriminator = "PictureparkMappingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.indexName = data["indexName"];
            this.debugInformation = data["debugInformation"];
        }
    }

    static fromJS(data: any): PictureparkMappingException {
        let result = new PictureparkMappingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkMappingException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class MessagePerformerTaskCanceledException extends PictureparkException implements IMessagePerformerTaskCanceledException {
    messageId?: string | undefined;
    customerId?: string | undefined;

    constructor(data?: IMessagePerformerTaskCanceledException) {
        super(data);
        this._discriminator = "MessagePerformerTaskCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.messageId = data["messageId"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): MessagePerformerTaskCanceledException {
        let result = new MessagePerformerTaskCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IMessagePerformerTaskCanceledException extends IPictureparkException {
    messageId?: string | undefined;
    customerId?: string | undefined;
}

export class NotFoundException extends PictureparkBusinessException implements INotFoundException {
    reference?: string | undefined;

    constructor(data?: INotFoundException) {
        super(data);
        this._discriminator = "NotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reference = data["reference"];
        }
    }

    static fromJS(data: any): NotFoundException {
        let result = new NotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data; 
    }
}

export interface INotFoundException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IObjectStoreException) {
        super(data);
        this._discriminator = "ObjectStoreException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): ObjectStoreException {
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this._discriminator = "ObjectStoreResponseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.rowErrorMessages = data["rowErrorMessages"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ObjectStoreResponseException {
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["message"] = this.message;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);
        this._discriminator = "PictureparkOperationCanceledException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PictureparkOperationCanceledException {
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
}

export class OperationTimeoutException extends PictureparkBusinessException implements IOperationTimeoutException {

    constructor(data?: IOperationTimeoutException) {
        super(data);
        this._discriminator = "OperationTimeoutException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OperationTimeoutException {
        let result = new OperationTimeoutException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOperationTimeoutException extends IPictureparkBusinessException {
}

export class OutputNotFoundException extends PictureparkBusinessException implements IOutputNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this._discriminator = "OutputNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): OutputNotFoundException {
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputNotFoundException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class PermissionException extends PictureparkBusinessException implements IPermissionException {
    permission?: string | undefined;
    operation?: string | undefined;

    constructor(data?: IPermissionException) {
        super(data);
        this._discriminator = "PermissionException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.permission = data["permission"];
            this.operation = data["operation"];
        }
    }

    static fromJS(data: any): PermissionException {
        let result = new PermissionException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["operation"] = this.operation;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionException extends IPictureparkBusinessException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string | undefined;
    serverError?: StorageServerError | undefined;

    constructor(data?: IQueryException) {
        super(data);
        this._discriminator = "QueryException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.debugInformation = data["debugInformation"];
            this.serverError = data["serverError"] ? StorageServerError.fromJS(data["serverError"]) : <any>undefined;
        }
    }

    static fromJS(data: any): QueryException {
        let result = new QueryException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugInformation"] = this.debugInformation;
        data["serverError"] = this.serverError ? this.serverError.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string | undefined;
    serverError?: IStorageServerError | undefined;
}

export class StorageServerError implements IStorageServerError {
    error?: StorageError | undefined;
    status: number;

    constructor(data?: IStorageServerError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new StorageError(data.error) : <StorageError>this.error; 
        }
    }

    init(data?: any) {
        if (data) {
            this.error = data["error"] ? StorageError.fromJS(data["error"]) : <any>undefined;
            this.status = data["status"];
        }
    }

    static fromJS(data: any): StorageServerError {
        let result = new StorageServerError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }
}

export interface IStorageServerError {
    error?: IStorageError | undefined;
    status: number;
}

export class StorageError implements IStorageError {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
    rootCause?: StorageRootCause[] | undefined;
    causedBy?: StorageCausedBy | undefined;

    constructor(data?: IStorageError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rootCause) {
                this.rootCause = [];
                for (let i = 0; i < data.rootCause.length; i++) {
                    let item = data.rootCause[i];
                    this.rootCause[i] = item && !(<any>item).toJSON ? new StorageRootCause(item) : <StorageRootCause>item;
                }
            }
            this.causedBy = data.causedBy && !(<any>data.causedBy).toJSON ? new StorageCausedBy(data.causedBy) : <StorageCausedBy>this.causedBy; 
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.reason = data["reason"];
            this.resourceId = data["resourceId"];
            this.resourceType = data["resourceType"];
            this.type = data["type"];
            if (data["rootCause"] && data["rootCause"].constructor === Array) {
                this.rootCause = [];
                for (let item of data["rootCause"])
                    this.rootCause.push(StorageRootCause.fromJS(item));
            }
            this.causedBy = data["causedBy"] ? StorageCausedBy.fromJS(data["causedBy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StorageError {
        let result = new StorageError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["reason"] = this.reason;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        if (this.rootCause && this.rootCause.constructor === Array) {
            data["rootCause"] = [];
            for (let item of this.rootCause)
                data["rootCause"].push(item.toJSON());
        }
        data["causedBy"] = this.causedBy ? this.causedBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStorageError {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
    rootCause?: IStorageRootCause[] | undefined;
    causedBy?: IStorageCausedBy | undefined;
}

export class StorageRootCause implements IStorageRootCause {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;

    constructor(data?: IStorageRootCause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.reason = data["reason"];
            this.resourceId = data["resourceId"];
            this.resourceType = data["resourceType"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): StorageRootCause {
        let result = new StorageRootCause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["reason"] = this.reason;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        return data; 
    }
}

export interface IStorageRootCause {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
}

export class StorageCausedBy implements IStorageCausedBy {
    reason?: string | undefined;
    type?: string | undefined;
    innerCausedBy?: StorageCausedBy | undefined;

    constructor(data?: IStorageCausedBy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.innerCausedBy = data.innerCausedBy && !(<any>data.innerCausedBy).toJSON ? new StorageCausedBy(data.innerCausedBy) : <StorageCausedBy>this.innerCausedBy; 
        }
    }

    init(data?: any) {
        if (data) {
            this.reason = data["reason"];
            this.type = data["type"];
            this.innerCausedBy = data["innerCausedBy"] ? StorageCausedBy.fromJS(data["innerCausedBy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StorageCausedBy {
        let result = new StorageCausedBy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["type"] = this.type;
        data["innerCausedBy"] = this.innerCausedBy ? this.innerCausedBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStorageCausedBy {
    reason?: string | undefined;
    type?: string | undefined;
    innerCausedBy?: IStorageCausedBy | undefined;
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);
        this._discriminator = "RenderingException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingException {
        let result = new RenderingException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class RenderingJobItemNotSetException extends PictureparkBusinessException implements IRenderingJobItemNotSetException {

    constructor(data?: IRenderingJobItemNotSetException) {
        super(data);
        this._discriminator = "RenderingJobItemNotSetException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): RenderingJobItemNotSetException {
        let result = new RenderingJobItemNotSetException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IRenderingJobItemNotSetException extends IPictureparkBusinessException {
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this._discriminator = "ServiceProviderCreateException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userId = data["userId"];
            this.externalId = data["externalId"];
            this.virtualHost = data["virtualHost"];
            this.detailErrorMessage = data["detailErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderCreateException {
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["externalId"] = this.externalId;
        data["virtualHost"] = this.virtualHost;
        data["detailErrorMessage"] = this.detailErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderCreateException extends IPictureparkException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this._discriminator = "ServiceProviderDeleteException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.detailedErrorMessage = data["detailedErrorMessage"];
        }
    }

    static fromJS(data: any): ServiceProviderDeleteException {
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["detailedErrorMessage"] = this.detailedErrorMessage;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string | undefined;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this._discriminator = "ServiceProviderNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingServiceProviderId = data["missingServiceProviderId"];
        }
    }

    static fromJS(data: any): ServiceProviderNotFoundException {
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingServiceProviderId"] = this.missingServiceProviderId;
        super.toJSON(data);
        return data; 
    }
}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string | undefined;
}

export class TokenValidationException extends PictureparkBusinessException implements ITokenValidationException {

    constructor(data?: ITokenValidationException) {
        super(data);
        this._discriminator = "TokenValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TokenValidationException {
        let result = new TokenValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITokenValidationException extends IPictureparkBusinessException {
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {
    exceptionDetail?: string | undefined;

    constructor(data?: IUnknownException) {
        super(data);
        this._discriminator = "UnknownException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.exceptionDetail = data["exceptionDetail"];
        }
    }

    static fromJS(data: any): UnknownException {
        let result = new UnknownException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionDetail"] = this.exceptionDetail;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnknownException extends IPictureparkBusinessException {
    exceptionDetail?: string | undefined;
}

export class UserNotFoundException extends PictureparkBusinessException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.missingUserId = data["missingUserId"];
        }
    }

    static fromJS(data: any): UserNotFoundException {
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserNotFoundException extends IPictureparkBusinessException {
    missingUserId?: string | undefined;
}

export class UserPermanentlyRemovedException extends PictureparkBusinessException implements IUserPermanentlyRemovedException {
    removedUserId?: string | undefined;

    constructor(data?: IUserPermanentlyRemovedException) {
        super(data);
        this._discriminator = "UserPermanentlyRemovedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.removedUserId = data["removedUserId"];
        }
    }

    static fromJS(data: any): UserPermanentlyRemovedException {
        let result = new UserPermanentlyRemovedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["removedUserId"] = this.removedUserId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserPermanentlyRemovedException extends IPictureparkBusinessException {
    removedUserId?: string | undefined;
}

export class UserRoleAssignedException extends PictureparkBusinessException implements IUserRoleAssignedException {
    userRoleId?: string | undefined;

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.userRoleId = data["userRoleId"];
        }
    }

    static fromJS(data: any): UserRoleAssignedException {
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRoleAssignedException extends IPictureparkBusinessException {
    userRoleId?: string | undefined;
}

export class UserRolesRightsAssignedException extends PictureparkBusinessException implements IUserRolesRightsAssignedException {
    contentPermissionSetId?: string | undefined;

    constructor(data?: IUserRolesRightsAssignedException) {
        super(data);
        this._discriminator = "UserRolesRightsAssignedException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentPermissionSetId = data["contentPermissionSetId"];
        }
    }

    static fromJS(data: any): UserRolesRightsAssignedException {
        let result = new UserRolesRightsAssignedException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentPermissionSetId"] = this.contentPermissionSetId;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserRolesRightsAssignedException extends IPictureparkBusinessException {
    contentPermissionSetId?: string | undefined;
}

/** A content detail. */
export class ContentDetail implements IContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit | undefined;
    /** The content data */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the content schema */
    contentSchemaId?: string | undefined;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content id. */
    id?: string | undefined;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[] | undefined;
    /** The metadata dictionary */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;

    constructor(data?: IContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.content = data["content"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
            this.contentSchemaId = data["contentSchemaId"];
            this.contentType = data["contentType"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.id = data["id"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(Output.fromJS(item));
            }
            this.ownerTokenId = data["ownerTokenId"];
            this.trashed = data["trashed"];
        }
    }

    static fromJS(data: any): ContentDetail {
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["content"] = this.content;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        data["contentSchemaId"] = this.contentSchemaId;
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["ownerTokenId"] = this.ownerTokenId;
        data["trashed"] = this.trashed;
        return data; 
    }
}

/** A content detail. */
export interface IContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: IUserAudit | undefined;
    /** The content data */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the content schema */
    contentSchemaId?: string | undefined;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The content id. */
    id?: string | undefined;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[] | undefined;
    /** The metadata dictionary */
    metadata?: IDataDictionary | undefined;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;
}

export class UserAudit implements IUserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string | undefined;
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationDate = data["creationDate"] ? new Date(data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.createdByUser = data["createdByUser"];
            this.modifiedByUser = data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAudit {
        let result = new UserAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser;
        data["modifiedByUser"] = this.modifiedByUser;
        return data; 
    }
}

export interface IUserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string | undefined;
    modifiedByUser?: string | undefined;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
    ContentItem = <any>"ContentItem", 
}

export class DisplayValueDictionary implements IDisplayValueDictionary {

    [key: string]: string | any; 

    constructor(data?: IDisplayValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DisplayValueDictionary {
        let result = new DisplayValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

export interface IDisplayValueDictionary {

    [key: string]: string | any; 
}

/** A custom implementation of Dictionary{string, object} */
export class DataDictionary implements IDataDictionary {

    [key: string]: any; 

    constructor(data?: IDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): DataDictionary {
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

/** A custom implementation of Dictionary{string, object} */
export interface IDataDictionary {

    [key: string]: any; 
}

export class Output implements IOutput {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;

    protected _discriminator: string;

    constructor(data?: IOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Output";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.outputFormatId = data["outputFormatId"];
            this.contentId = data["contentId"];
            this.detail = data["detail"] ? OutputDetailBase.fromJS(data["detail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Output {
        if (data["kind"] === "OutputDetail") {
            let result = new OutputDetail();
            result.init(data);
            return result;
        }
        let result = new Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        data["contentId"] = this.contentId;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOutput {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;
}

export abstract class OutputDetailBase implements IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputDetailBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDetailBase";
    }

    init(data?: any) {
        if (data) {
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
        }
    }

    static fromJS(data: any): OutputDetailBase {
        if (data["kind"] === "OutputDetailImage") {
            let result = new OutputDetailImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailAudio") {
            let result = new OutputDetailAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailVideo") {
            let result = new OutputDetailVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailDocument") {
            let result = new OutputDetailDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDetailDefault") {
            let result = new OutputDetailDefault();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OutputDetailBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        return data; 
    }
}

export interface IOutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
}

export class OutputDetailImage extends OutputDetailBase implements IOutputDetailImage {
    width: number;
    height: number;

    constructor(data?: IOutputDetailImage) {
        super(data);
        this._discriminator = "OutputDetailImage";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): OutputDetailImage {
        let result = new OutputDetailImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailImage extends IOutputDetailBase {
    width: number;
    height: number;
}

export class OutputDetailAudio extends OutputDetailBase implements IOutputDetailAudio {
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDetailAudio) {
        super(data);
        this._discriminator = "OutputDetailAudio";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
        }
    }

    static fromJS(data: any): OutputDetailAudio {
        let result = new OutputDetailAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailAudio extends IOutputDetailBase {
    durationInSeconds?: number | undefined;
}

export class OutputDetailVideo extends OutputDetailBase implements IOutputDetailVideo {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDetailVideo) {
        super(data);
        this._discriminator = "OutputDetailVideo";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
            this.width = data["width"];
            this.height = data["height"];
            if (data["sprites"] && data["sprites"].constructor === Array) {
                this.sprites = [];
                for (let item of data["sprites"])
                    this.sprites.push(Sprite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputDetailVideo {
        let result = new OutputDetailVideo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        data["width"] = this.width;
        data["height"] = this.height;
        if (this.sprites && this.sprites.constructor === Array) {
            data["sprites"] = [];
            for (let item of this.sprites)
                data["sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailVideo extends IOutputDetailBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: ISprite[] | undefined;
}

export class Sprite implements ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;

    constructor(data?: ISprite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.y = data["y"];
            this.x = data["x"];
            this.start = data["start"];
            this.end = data["end"];
        }
    }

    static fromJS(data: any): Sprite {
        let result = new Sprite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["y"] = this.y;
        data["x"] = this.x;
        data["start"] = this.start;
        data["end"] = this.end;
        return data; 
    }
}

export interface ISprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export class OutputDetailDocument extends OutputDetailBase implements IOutputDetailDocument {
    pageCount: number;

    constructor(data?: IOutputDetailDocument) {
        super(data);
        this._discriminator = "OutputDetailDocument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pageCount = data["pageCount"];
        }
    }

    static fromJS(data: any): OutputDetailDocument {
        let result = new OutputDetailDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDocument extends IOutputDetailBase {
    pageCount: number;
}

export class OutputDetailDefault extends OutputDetailBase implements IOutputDetailDefault {

    constructor(data?: IOutputDetailDefault) {
        super(data);
        this._discriminator = "OutputDetailDefault";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetailDefault {
        let result = new OutputDetailDefault();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetailDefault extends IOutputDetailBase {
}

export class OutputDetail extends Output implements IOutputDetail {

    constructor(data?: IOutputDetail) {
        super(data);
        this._discriminator = "OutputDetail";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDetail {
        let result = new OutputDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDetail extends IOutput {
}

export class ContentSearchRequest implements IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied in the specified order. */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the returned contents that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IContentSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["channelIds"] && data["channelIds"].constructor === Array) {
                this.channelIds = [];
                for (let item of data["channelIds"])
                    this.channelIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.lifeCycleFilter = data["lifeCycleFilter"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["rightsFilter"] && data["rightsFilter"].constructor === Array) {
                this.rightsFilter = [];
                for (let item of data["rightsFilter"])
                    this.rightsFilter.push(item);
            }
            this.searchType = data["searchType"];
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): ContentSearchRequest {
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.channelIds && this.channelIds.constructor === Array) {
            data["channelIds"] = [];
            for (let item of this.channelIds)
                data["channelIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.rightsFilter && this.rightsFilter.constructor === Array) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        data["searchType"] = this.searchType;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied in the specified order. */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the returned contents that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export enum SearchBehaviour {
    DropInvalidCharactersOnFailure = <any>"DropInvalidCharactersOnFailure", 
    WildcardOnSingleTerm = <any>"WildcardOnSingleTerm", 
}

export class SortInfo implements ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string | undefined;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): SortInfo {
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface ISortInfo {
    /** The elastic search index field to sort on. */
    field?: string | undefined;
    /** The sort direction (Asc/Desc). */
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

/** The FilterBase is the base class for all filters. */
export class FilterBase implements IFilterBase {

    protected _discriminator: string;

    getDisplayName(locale: string): string | null {
        return null;
    }

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FilterBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): FilterBase {
        if (data["kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

/** The FilterBase is the base class for all filters. */
export interface IFilterBase {
}

/** The AndFilter&gt; is a compound filter and returns documents that match all of the specified filters. */
export class AndFilter extends FilterBase implements IAndFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IAndFilter) {
        super(data);
        this._discriminator = "AndFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AndFilter {
        let result = new AndFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The AndFilter&gt; is a compound filter and returns documents that match all of the specified filters. */
export interface IAndFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export class OrFilter extends FilterBase implements IOrFilter {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IOrFilter) {
        super(data);
        this._discriminator = "OrFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["filters"] && data["filters"].constructor === Array) {
                this.filters = [];
                for (let item of data["filters"])
                    this.filters.push(FilterBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrFilter {
        let result = new OrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.filters && this.filters.constructor === Array) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export interface IOrFilter extends IFilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export class NotFilter extends FilterBase implements INotFilter {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INotFilter) {
        super(data);
        this._discriminator = "NotFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotFilter {
        let result = new NotFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export interface INotFilter extends IFilterBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;

    getDisplayName(locale: string) {
        return this.range && this.range.names ? this.range.names.translate(locale) : 'n/a';
    }

    constructor(data?: IDateRangeFilter) {
        super(data);
        this._discriminator = "DateRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? DateRange.fromJS(data["range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeFilter {
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export interface IDateRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: IDateRange | undefined;
}

/** The date range class used in aggregators and filters. */
export class DateRange implements IDateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): DateRange {
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

/** The date range class used in aggregators and filters. */
export interface IDateRange {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A custom dictionary type to distinguish language specific class properties. */
export class TranslatedStringDictionary implements ITranslatedStringDictionary {

    [key: string]: string | any; 

    translate(locale: string) {
        const language = locale.split('-')[0];
        return this[language] ? this[language] : this[Object.keys(this)[0]];
    }

    constructor(data?: ITranslatedStringDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }

    static fromJS(data: any): TranslatedStringDictionary {
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data; 
    }
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface ITranslatedStringDictionary {

    [key: string]: string | any; 
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;

    constructor(data?: IExistsFilter) {
        super(data);
        this._discriminator = "ExistsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
        }
    }

    static fromJS(data: any): ExistsFilter {
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        super.toJSON(data);
        return data; 
    }
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export interface IExistsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        this._discriminator = "GeoBoundingBoxFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.topLeft = data["topLeft"] ? GeoLocation.fromJS(data["topLeft"]) : <any>undefined;
            this.bottomRight = data["bottomRight"] ? GeoLocation.fromJS(data["bottomRight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeoBoundingBoxFilter {
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["topLeft"] = this.topLeft ? this.topLeft.toJSON() : <any>undefined;
        data["bottomRight"] = this.bottomRight ? this.bottomRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: IGeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: IGeoLocation | undefined;
}

export class GeoLocation implements IGeoLocation {
    lat: number;
    lon: number;

    constructor(data?: IGeoLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"];
            this.lon = data["lon"];
        }
    }

    static fromJS(data: any): GeoLocation {
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data; 
    }
}

export interface IGeoLocation {
    lat: number;
    lon: number;
}

/** The GeoDistanceFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        this._discriminator = "GeoDistanceFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : <any>undefined;
            this.distance = data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export interface IGeoDistanceFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: IGeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: INestedFilter) {
        super(data);
        this._discriminator = "NestedFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NestedFilter {
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;

    constructor(data?: INumericRangeFilter) {
        super(data);
        this._discriminator = "NumericRangeFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.range = data["range"] ? NumericRange.fromJS(data["range"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NumericRangeFilter {
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export interface INumericRangeFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: INumericRange | undefined;
}

export class NumericRange implements INumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.from = data["from"];
            this.to = data["to"];
        }
    }

    static fromJS(data: any): NumericRange {
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data; 
    }
}

export interface INumericRange {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;

    constructor(data?: IPrefixFilter) {
        super(data);
        this._discriminator = "PrefixFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.prefix = data["prefix"];
        }
    }

    static fromJS(data: any): PrefixFilter {
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["prefix"] = this.prefix;
        super.toJSON(data);
        return data; 
    }
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export interface IPrefixFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export class TermFilter extends FilterBase implements ITermFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;

    constructor(data?: ITermFilter) {
        super(data);
        this._discriminator = "TermFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.term = data["term"];
        }
    }

    static fromJS(data: any): TermFilter {
        let result = new TermFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["term"] = this.term;
        super.toJSON(data);
        return data; 
    }
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export interface ITermFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;

    constructor(data?: ITermsFilter) {
        super(data);
        this._discriminator = "TermsFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["terms"] && data["terms"].constructor === Array) {
                this.terms = [];
                for (let item of data["terms"])
                    this.terms.push(item);
            }
        }
    }

    static fromJS(data: any): TermsFilter {
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.terms && this.terms.constructor === Array) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export interface ITermsFilter extends IFilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;

    constructor(data?: IAggregationFilter) {
        super(data);
        this._discriminator = "AggregationFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregationName = data["aggregationName"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.temporaryAggregatorRequestId = data["temporaryAggregatorRequestId"];
        }
    }

    static fromJS(data: any): AggregationFilter {
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["temporaryAggregatorRequestId"] = this.temporaryAggregatorRequestId;
        super.toJSON(data);
        return data; 
    }
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export class ChildFilter extends FilterBase implements IChildFilter {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IChildFilter) {
        super(data);
        this._discriminator = "ChildFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.childType = data["childType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChildFilter {
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childType"] = this.childType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export interface IChildFilter extends IFilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export class ParentFilter extends FilterBase implements IParentFilter {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;

    constructor(data?: IParentFilter) {
        super(data);
        this._discriminator = "ParentFilter";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.parentType = data["parentType"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParentFilter {
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentType"] = this.parentType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export interface IParentFilter extends IFilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
    ActiveInactiveOnly = <any>"ActiveInactiveOnly", 
}

export enum BrokenDependenciesFilter {
    All = <any>"All", 
    NotBrokenOnly = <any>"NotBrokenOnly", 
    BrokenOnly = <any>"BrokenOnly", 
}

export enum ContentRight {
    View = <any>"View", 
    AccessOriginal = <any>"AccessOriginal", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export enum ContentSearchType {
    Metadata = <any>"Metadata", 
    FullText = <any>"FullText", 
    MetadataAndFullText = <any>"MetadataAndFullText", 
}

export class BaseResultOfContent implements IBaseResultOfContent {
    totalResults: number;
    results?: Content[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Content(item) : <Content>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Content.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfContent {
        let result = new BaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfContent {
    totalResults: number;
    results?: IContent[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfContent extends BaseResultOfContent implements ISearchBehaviourBaseResultOfContent {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfContent) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfContent {
        let result = new SearchBehaviourBaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfContent extends IBaseResultOfContent {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class ContentSearchResult extends SearchBehaviourBaseResultOfContent implements IContentSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IContentSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ContentSearchResult {
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentSearchResult extends ISearchBehaviourBaseResultOfContent {
    elapsedMilliseconds: number;
}

export class Content implements IContent {
    audit?: UserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the ids of the broken relations */
    brokenRelationIds?: string[] | undefined;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
    }

    init(data?: any) {
        if (data) {
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayValues"]) {
                this.displayValues = {};
                for (let key in data["displayValues"]) {
                    if (data["displayValues"].hasOwnProperty(key))
                        this.displayValues[key] = data["displayValues"][key];
                }
            }
            this.id = data["id"];
            if (data["brokenReferenceIds"] && data["brokenReferenceIds"].constructor === Array) {
                this.brokenReferenceIds = [];
                for (let item of data["brokenReferenceIds"])
                    this.brokenReferenceIds.push(item);
            }
            if (data["brokenIndirectReferenceIds"] && data["brokenIndirectReferenceIds"].constructor === Array) {
                this.brokenIndirectReferenceIds = [];
                for (let item of data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds.push(item);
            }
            if (data["brokenRelationIds"] && data["brokenRelationIds"].constructor === Array) {
                this.brokenRelationIds = [];
                for (let item of data["brokenRelationIds"])
                    this.brokenRelationIds.push(item);
            }
        }
    }

    static fromJS(data: any): Content {
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayValues) {
            data["displayValues"] = {};
            for (let key in this.displayValues) {
                if (this.displayValues.hasOwnProperty(key))
                    data["displayValues"][key] = this.displayValues[key];
            }
        }
        data["id"] = this.id;
        if (this.brokenReferenceIds && this.brokenReferenceIds.constructor === Array) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (this.brokenIndirectReferenceIds && this.brokenIndirectReferenceIds.constructor === Array) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        if (this.brokenRelationIds && this.brokenRelationIds.constructor === Array) {
            data["brokenRelationIds"] = [];
            for (let item of this.brokenRelationIds)
                data["brokenRelationIds"].push(item);
        }
        return data; 
    }
}

export interface IContent {
    audit?: IUserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the ids of the broken relations */
    brokenRelationIds?: string[] | undefined;
}

export class QueryDebugInformation implements IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;

    constructor(data?: IQueryDebugInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"];
            this.auditTrail = data["auditTrail"];
            this.request = data["request"];
            this.response = data["response"];
        }
    }

    static fromJS(data: any): QueryDebugInformation {
        let result = new QueryDebugInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general;
        data["auditTrail"] = this.auditTrail;
        data["request"] = this.request;
        data["response"] = this.response;
        return data; 
    }
}

export interface IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;
}

export class ContentAggregationRequest implements IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;

    constructor(data?: IContentAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.channelId = data["channelId"];
            this.displayLanguage = data["displayLanguage"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.collectionId = data["collectionId"];
            this.lifeCycleFilter = data["lifeCycleFilter"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            this.searchType = data["searchType"];
        }
    }

    static fromJS(data: any): ContentAggregationRequest {
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["channelId"] = this.channelId;
        data["displayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        data["searchType"] = this.searchType;
        return data; 
    }
}

export interface IContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
}

/** The AggregatorBase is the base class for all aggregators. */
export abstract class AggregatorBase implements IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;

    protected _discriminator: string;

    constructor(data?: IAggregatorBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
        this._discriminator = "AggregatorBase";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregatorBase {
        if (data["kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterAggregator") {
            let result = new FilterAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregatorBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        return data; 
    }
}

/** The AggregatorBase is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: ITranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;

    constructor(data?: IDateRangeAggregator) {
        super(data);
        this._discriminator = "DateRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(DateRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateRangeAggregator {
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export interface IDateRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: IDateRange[] | undefined;
}

/** The FilterAggregator is a single bucket aggregation of documents that match a specified filter. */
export class FilterAggregator extends AggregatorBase implements IFilterAggregator {
    /** Limits the result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFilterAggregator) {
        super(data);
        this._discriminator = "FilterAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FilterAggregator {
        let result = new FilterAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** The FilterAggregator is a single bucket aggregation of documents that match a specified filter. */
export interface IFilterAggregator extends IAggregatorBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: GeoDistance[] | undefined;

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        this._discriminator = "GeoDistanceAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.location = data["location"] ? GeoLocation.fromJS(data["location"]) : <any>undefined;
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(GeoDistance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeoDistanceAggregator {
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: IGeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: IGeoDistance[] | undefined;
}

export class GeoDistance implements IGeoDistance {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The to value. */
    distance: number;

    constructor(data?: IGeoDistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.distance = data["distance"];
        }
    }

    static fromJS(data: any): GeoDistance {
        let result = new GeoDistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data; 
    }
}

export interface IGeoDistance {
    /** Tranlsated range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The to value. */
    distance: number;
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path?: string | undefined;

    constructor(data?: INestedAggregator) {
        super(data);
        this._discriminator = "NestedAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.path = data["path"];
        }
    }

    static fromJS(data: any): NestedAggregator {
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data; 
    }
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;

    constructor(data?: INumericRangeAggregator) {
        super(data);
        this._discriminator = "NumericRangeAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            if (data["ranges"] && data["ranges"].constructor === Array) {
                this.ranges = [];
                for (let item of data["ranges"])
                    this.ranges.push(NumericRange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NumericRangeAggregator {
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (this.ranges && this.ranges.constructor === Array) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export interface INumericRangeAggregator extends IAggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: INumericRange[] | undefined;
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;

    constructor(data?: ITermsAggregator) {
        super(data);
        this._discriminator = "TermsAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.field = data["field"];
            this.size = data["size"];
            if (data["includes"] && data["includes"].constructor === Array) {
                this.includes = [];
                for (let item of data["includes"])
                    this.includes.push(item);
            }
            if (data["excludes"] && data["excludes"].constructor === Array) {
                this.excludes = [];
                for (let item of data["excludes"])
                    this.excludes.push(item);
            }
        }
    }

    static fromJS(data: any): TermsAggregator {
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["size"] = this.size;
        if (this.includes && this.includes.constructor === Array) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        if (this.excludes && this.excludes.constructor === Array) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export interface ITermsAggregator extends IAggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this._discriminator = "TermsRelationAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.documentType = data["documentType"];
        }
    }

    static fromJS(data: any): TermsRelationAggregator {
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export interface ITermsRelationAggregator extends ITermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
    ContentPermissionSet = <any>"ContentPermissionSet", 
    Owner = <any>"Owner", 
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this._discriminator = "TermsEnumAggregator";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.enumType = data["enumType"];
        }
    }

    static fromJS(data: any): TermsEnumAggregator {
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumType"] = this.enumType;
        super.toJSON(data);
        return data; 
    }
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export interface ITermsEnumAggregator extends ITermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;
}

export class ObjectAggregationResult implements IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;

    constructor(data?: IObjectAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): ObjectAggregationResult {
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        return data; 
    }
}

export interface IObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: IAggregationResult[] | undefined;
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;
}

export class AggregationResult implements IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;

    constructor(data?: IAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResultItems) {
                this.aggregationResultItems = [];
                for (let i = 0; i < data.aggregationResultItems.length; i++) {
                    let item = data.aggregationResultItems[i];
                    this.aggregationResultItems[i] = item && !(<any>item).toJSON ? new AggregationResultItem(item) : <AggregationResultItem>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sumOtherDocCount = data["sumOtherDocCount"];
            this.temporaryRequestId = data["temporaryRequestId"];
            if (data["aggregationResultItems"] && data["aggregationResultItems"].constructor === Array) {
                this.aggregationResultItems = [];
                for (let item of data["aggregationResultItems"])
                    this.aggregationResultItems.push(AggregationResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResult {
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sumOtherDocCount"] = this.sumOtherDocCount;
        data["temporaryRequestId"] = this.temporaryRequestId;
        if (this.aggregationResultItems && this.aggregationResultItems.constructor === Array) {
            data["aggregationResultItems"] = [];
            for (let item of this.aggregationResultItems)
                data["aggregationResultItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: IAggregationResultItem[] | undefined;
}

export class AggregationResultItem implements IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;

    getDisplayName(locale: string) {
      const displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null;
      return displayName ? displayName : this.name;
    }

    constructor(data?: IAggregationResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.count = data["count"];
            this.filter = data["filter"] ? AggregationFilter.fromJS(data["filter"]) : <any>undefined;
            this.active = data["active"];
            if (data["aggregationResults"] && data["aggregationResults"].constructor === Array) {
                this.aggregationResults = [];
                for (let item of data["aggregationResults"])
                    this.aggregationResults.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResultItem {
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["active"] = this.active;
        if (this.aggregationResults && this.aggregationResults.constructor === Array) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: IAggregationResult[] | undefined;
}

export class ContentDownloadLinkCreateRequest implements IContentDownloadLinkCreateRequest {
    contents?: ContentDownloadRequestItem[] | undefined;

    constructor(data?: IContentDownloadLinkCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contents) {
                this.contents = [];
                for (let i = 0; i < data.contents.length; i++) {
                    let item = data.contents[i];
                    this.contents[i] = item && !(<any>item).toJSON ? new ContentDownloadRequestItem(item) : <ContentDownloadRequestItem>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ContentDownloadRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentDownloadLinkCreateRequest {
        let result = new ContentDownloadLinkCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContentDownloadLinkCreateRequest {
    contents?: IContentDownloadRequestItem[] | undefined;
}

export class ContentDownloadRequestItem implements IContentDownloadRequestItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IContentDownloadRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
        }
    }

    static fromJS(data: any): ContentDownloadRequestItem {
        let result = new ContentDownloadRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        return data; 
    }
}

export interface IContentDownloadRequestItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class DownloadLink implements IDownloadLink {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;

    constructor(data?: IDownloadLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.downloadToken = data["downloadToken"];
            this.downloadUrl = data["downloadUrl"];
        }
    }

    static fromJS(data: any): DownloadLink {
        let result = new DownloadLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadToken"] = this.downloadToken;
        data["downloadUrl"] = this.downloadUrl;
        return data; 
    }
}

export interface IDownloadLink {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

/** A request structure for creating a content document. */
export class ContentCreateRequest implements IContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"];
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentCreateRequest {
        let result = new ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

/** A request structure for creating a content document. */
export interface IContentCreateRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
}

/** A request structure for creating multiple content documents. */
export class ContentCreateManyRequest implements IContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create requests */
    requests?: ContentCreateRequest[] | undefined;

    constructor(data?: IContentCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.requests) {
                this.requests = [];
                for (let i = 0; i < data.requests.length; i++) {
                    let item = data.requests[i];
                    this.requests[i] = item && !(<any>item).toJSON ? new ContentCreateRequest(item) : <ContentCreateRequest>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["requests"] && data["requests"].constructor === Array) {
                this.requests = [];
                for (let item of data["requests"])
                    this.requests.push(ContentCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentCreateManyRequest {
        let result = new ContentCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.requests && this.requests.constructor === Array) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for creating multiple content documents. */
export interface IContentCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create requests */
    requests?: IContentCreateRequest[] | undefined;
}

export class BusinessProcess implements IBusinessProcess {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    supportsCancellation: boolean;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCycle;
    startDate: Date;
    endDate: Date;
    finished: boolean;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    currentState?: string | undefined;
    processDefinitionName?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.stateHistory) {
                this.stateHistory = [];
                for (let i = 0; i < data.stateHistory.length; i++) {
                    let item = data.stateHistory[i];
                    this.stateHistory[i] = item && !(<any>item).toJSON ? new BusinessProcessStateItem(item) : <BusinessProcessStateItem>item;
                }
            }
        }
        this._discriminator = "BusinessProcess";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.processDefinitionId = data["processDefinitionId"];
            this.referenceId = data["referenceId"];
            this.referenceDocType = data["referenceDocType"];
            this.supportsCancellation = data["supportsCancellation"];
            this.businessProcessScope = data["businessProcessScope"];
            this.lifeCycle = data["lifeCycle"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.finished = data["finished"];
            if (data["stateHistory"] && data["stateHistory"].constructor === Array) {
                this.stateHistory = [];
                for (let item of data["stateHistory"])
                    this.stateHistory.push(BusinessProcessStateItem.fromJS(item));
            }
            this.currentState = data["currentState"];
            this.processDefinitionName = data["processDefinitionName"];
        }
    }

    static fromJS(data: any): BusinessProcess {
        if (data["kind"] === "BusinessProcessDetails") {
            let result = new BusinessProcessDetails();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessBulkResponse") {
            let result = new BusinessProcessBulkResponse();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["processDefinitionId"] = this.processDefinitionId;
        data["referenceId"] = this.referenceId;
        data["referenceDocType"] = this.referenceDocType;
        data["supportsCancellation"] = this.supportsCancellation;
        data["businessProcessScope"] = this.businessProcessScope;
        data["lifeCycle"] = this.lifeCycle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["finished"] = this.finished;
        if (this.stateHistory && this.stateHistory.constructor === Array) {
            data["stateHistory"] = [];
            for (let item of this.stateHistory)
                data["stateHistory"].push(item.toJSON());
        }
        data["currentState"] = this.currentState;
        data["processDefinitionName"] = this.processDefinitionName;
        return data; 
    }
}

export interface IBusinessProcess {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    supportsCancellation: boolean;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCycle;
    startDate: Date;
    endDate: Date;
    finished: boolean;
    stateHistory?: IBusinessProcessStateItem[] | undefined;
    currentState?: string | undefined;
    processDefinitionName?: string | undefined;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCycle {
    Draft = <any>"Draft", 
    InProgress = <any>"InProgress", 
    Succeeded = <any>"Succeeded", 
    Cancelled = <any>"Cancelled", 
    CancellationInProgress = <any>"CancellationInProgress", 
    Failed = <any>"Failed", 
}

export class BusinessProcessStateItem implements IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessStateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error; 
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.error = data["error"] ? ErrorResponse.fromJS(data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessStateItem {
        let result = new BusinessProcessStateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: IErrorResponse | undefined;
}

export class ErrorResponse implements IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exception = data["exception"];
            this.traceId = data["traceId"];
            this.traceJobId = data["traceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        return data; 
    }
}

export interface IErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
}

export class BusinessProcessBulkResponse extends BusinessProcess implements IBusinessProcessBulkResponse {
    response?: BulkResponse | undefined;

    constructor(data?: IBusinessProcessBulkResponse) {
        super(data);
        this._discriminator = "BusinessProcessBulkResponse";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.response = data["response"] ? BulkResponse.fromJS(data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessBulkResponse {
        let result = new BusinessProcessBulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessBulkResponse extends IBusinessProcess {
    response?: IBulkResponse | undefined;
}

export class BulkResponse implements IBulkResponse {
    rows?: BulkResponseRow[] | undefined;

    constructor(data?: IBulkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rows) {
                this.rows = [];
                for (let i = 0; i < data.rows.length; i++) {
                    let item = data.rows[i];
                    this.rows[i] = item && !(<any>item).toJSON ? new BulkResponseRow(item) : <BulkResponseRow>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["rows"])
                    this.rows.push(BulkResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkResponse {
        let result = new BulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBulkResponse {
    rows?: IBulkResponseRow[] | undefined;
}

export class BulkResponseRow implements IBulkResponseRow {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;
    status: number;

    constructor(data?: IBulkResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.version = data["version"];
            this.error = data["error"];
            this.reason = data["reason"];
            this.succeeded = data["succeeded"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BulkResponseRow {
        let result = new BulkResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["error"] = this.error;
        data["reason"] = this.reason;
        data["succeeded"] = this.succeeded;
        data["status"] = this.status;
        return data; 
    }
}

export interface IBulkResponseRow {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;
    status: number;
}

export class ContentDeactivateRequest implements IContentDeactivateRequest {
    contentIds?: string[] | undefined;
    resolve: boolean;
    displayPatternIds?: string[] | undefined;
    forceReferenceRemoval: boolean;

    constructor(data?: IContentDeactivateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.resolve = data["resolve"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            this.forceReferenceRemoval = data["forceReferenceRemoval"];
        }
    }

    static fromJS(data: any): ContentDeactivateRequest {
        let result = new ContentDeactivateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["resolve"] = this.resolve;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        return data; 
    }
}

export interface IContentDeactivateRequest {
    contentIds?: string[] | undefined;
    resolve: boolean;
    displayPatternIds?: string[] | undefined;
    forceReferenceRemoval: boolean;
}

export class ContentReactivateRequest implements IContentReactivateRequest {
    contentIds?: string[] | undefined;
    resolve: boolean;
    displayPatternIds?: string[] | undefined;
    allowMissingDependencies: boolean;

    constructor(data?: IContentReactivateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.resolve = data["resolve"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ContentReactivateRequest {
        let result = new ContentReactivateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["resolve"] = this.resolve;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IContentReactivateRequest {
    contentIds?: string[] | undefined;
    resolve: boolean;
    displayPatternIds?: string[] | undefined;
    allowMissingDependencies: boolean;
}

export class ContentFileUpdateRequest implements IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;

    constructor(data?: IContentFileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.fileTransferId = data["fileTransferId"];
        }
    }

    static fromJS(data: any): ContentFileUpdateRequest {
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fileTransferId"] = this.fileTransferId;
        return data; 
    }
}

export interface IContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;
}

export class ContentMetadataUpdateRequest implements IContentMetadataUpdateRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;

    constructor(data?: IContentMetadataUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentMetadataUpdateRequest {
        let result = new ContentMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContentMetadataUpdateRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: IDataDictionary | undefined;
}

export class ContentPermissionsUpdateRequest implements IContentPermissionsUpdateRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IContentPermissionsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateRequest {
        let result = new ContentPermissionsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IContentPermissionsUpdateRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Update many contents metadata */
export class ContentMetadataUpdateManyRequest implements IContentMetadataUpdateManyRequest {
    /** Allow storing references to missing list items */
    allowMissingDependencies: boolean;
    /** Update requests */
    requests?: ContentMetadataUpdateRequest[] | undefined;

    constructor(data?: IContentMetadataUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.requests) {
                this.requests = [];
                for (let i = 0; i < data.requests.length; i++) {
                    let item = data.requests[i];
                    this.requests[i] = item && !(<any>item).toJSON ? new ContentMetadataUpdateRequest(item) : <ContentMetadataUpdateRequest>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["requests"] && data["requests"].constructor === Array) {
                this.requests = [];
                for (let item of data["requests"])
                    this.requests.push(ContentMetadataUpdateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentMetadataUpdateManyRequest {
        let result = new ContentMetadataUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.requests && this.requests.constructor === Array) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data; 
    }
}

/** Update many contents metadata */
export interface IContentMetadataUpdateManyRequest {
    /** Allow storing references to missing list items */
    allowMissingDependencies: boolean;
    /** Update requests */
    requests?: IContentMetadataUpdateRequest[] | undefined;
}

export class ContentOwnershipTransferRequest implements IContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: IContentOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.transferUserId = data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentOwnershipTransferRequest {
        let result = new ContentOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["transferUserId"] = this.transferUserId;
        return data; 
    }
}

export interface IContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string | undefined;
}

export class ContentsOwnershipTransferRequest implements IContentsOwnershipTransferRequest {
    /** The content ids. */
    contentIds?: string[] | undefined;
    /** The id of user to whom the content documents have to be transfered to. */
    transferUserId?: string | undefined;

    constructor(data?: IContentsOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.transferUserId = data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentsOwnershipTransferRequest {
        let result = new ContentsOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["transferUserId"] = this.transferUserId;
        return data; 
    }
}

export interface IContentsOwnershipTransferRequest {
    /** The content ids. */
    contentIds?: string[] | undefined;
    /** The id of user to whom the content documents have to be transfered to. */
    transferUserId?: string | undefined;
}

export abstract class MetadataValuesChangeRequestBase implements IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeRequestBase";
    }

    init(data?: any) {
        if (data) {
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        if (data["kind"] === "ContentFieldsUpdateRequest") {
            let result = new ContentFieldsUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFieldsFilterUpdateRequest") {
            let result = new ContentFieldsFilterUpdateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IMetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
}

export class ContentFieldsUpdateRequest extends MetadataValuesChangeRequestBase implements IContentFieldsUpdateRequest {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;

    constructor(data?: IContentFieldsUpdateRequest) {
        super(data);
        this._discriminator = "ContentFieldsUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentFieldsUpdateRequest {
        let result = new ContentFieldsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContentFieldsUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;
}

/** The base class for metadata value change commands. */
export abstract class MetadataValuesChangeCommandBase implements IMetadataValuesChangeCommandBase {
    /** The id of the schema to which the operation scope is addressed. */
    schemaId?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeCommandBase";
    }

    init(data?: any) {
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        if (data["kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeCommandBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
    /** The id of the schema to which the operation scope is addressed. */
    schemaId?: string | undefined;
}

/** Updates schema values. */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpdateCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Updates schema values. */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: IDataDictionary | undefined;
}

/** Adds or updates schema values. */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpsertCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"] ? DataDictionary.fromJS(data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Adds or updates schema values. */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: IDataDictionary | undefined;
}

/** Removes schema values. */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** Removes schema values. */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
}

/** Removes a field and its value from the schema values. */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The path of the field to be removed (within tha data structure), e.g. "data.schemaId.fieldId" */
    fieldPath?: string | undefined;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesFieldRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
        }
    }

    static fromJS(data: any): MetadataValuesFieldRemoveCommand {
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a field and its value from the schema values. */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field to be removed (within tha data structure), e.g. "data.schemaId.fieldId" */
    fieldPath?: string | undefined;
}

/** Adds a list item id reference to a multi tagbox. */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string | undefined;
    /** The field namespace */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemAddCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Adds a list item id reference to a multi tagbox. */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string | undefined;
    /** The field namespace */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;
}

/** Removes a list item id reference from a multi tagbox. */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string | undefined;
    /** The field namespace */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemRemoveCommand";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldPath = data["fieldPath"];
            this.fieldNamespace = data["fieldNamespace"];
            this.referenceId = data["referenceId"];
        }
    }

    static fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data; 
    }
}

/** Removes a list item id reference from a multi tagbox. */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property */
    fieldPath?: string | undefined;
    /** The field namespace */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;
}

export class ContentFieldsFilterUpdateRequest extends MetadataValuesChangeRequestBase implements IContentFieldsFilterUpdateRequest {
    contentFilterRequest?: ContentFilterRequest | undefined;

    constructor(data?: IContentFieldsFilterUpdateRequest) {
        super(data);
        this._discriminator = "ContentFieldsFilterUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.contentFilterRequest = data["contentFilterRequest"] ? ContentFilterRequest.fromJS(data["contentFilterRequest"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentFieldsFilterUpdateRequest {
        let result = new ContentFieldsFilterUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentFilterRequest"] = this.contentFilterRequest ? this.contentFilterRequest.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IContentFieldsFilterUpdateRequest extends IMetadataValuesChangeRequestBase {
    contentFilterRequest?: IContentFilterRequest | undefined;
}

export class ContentFilterRequest implements IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified in the channel. */
    channelIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;

    constructor(data?: IContentFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["channelIds"] && data["channelIds"].constructor === Array) {
                this.channelIds = [];
                for (let item of data["channelIds"])
                    this.channelIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            this.searchString = data["searchString"];
            this.searchType = data["searchType"];
            this.collectionId = data["collectionId"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.lifeCycleFilter = data["lifeCycleFilter"];
            if (data["rightsFilter"] && data["rightsFilter"].constructor === Array) {
                this.rightsFilter = [];
                for (let item of data["rightsFilter"])
                    this.rightsFilter.push(item);
            }
        }
    }

    static fromJS(data: any): ContentFilterRequest {
        let result = new ContentFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.channelIds && this.channelIds.constructor === Array) {
            data["channelIds"] = [];
            for (let item of this.channelIds)
                data["channelIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        data["searchString"] = this.searchString;
        data["searchType"] = this.searchType;
        data["collectionId"] = this.collectionId;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        if (this.rightsFilter && this.rightsFilter.constructor === Array) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        return data; 
    }
}

export interface IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified in the channel. */
    channelIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
}

export class BusinessProcessSearchRequest implements IBusinessProcessSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;

    constructor(data?: IBusinessProcessSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessProcessSearchRequest {
        let result = new BusinessProcessSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBusinessProcessSearchRequest {
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
}

export class BaseResultOfBusinessProcess implements IBaseResultOfBusinessProcess {
    totalResults: number;
    results?: BusinessProcess[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(BusinessProcess.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfBusinessProcess {
    totalResults: number;
    results?: BusinessProcess[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess implements ISearchBehaviourBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfBusinessProcess) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfBusinessProcess {
        let result = new SearchBehaviourBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfBusinessProcess extends IBaseResultOfBusinessProcess {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class BusinessProcessSearchResult extends SearchBehaviourBaseResultOfBusinessProcess implements IBusinessProcessSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): BusinessProcessSearchResult {
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessSearchResult extends ISearchBehaviourBaseResultOfBusinessProcess {
    elapsedMilliseconds: number;
}

export class BusinessProcessWaitResult implements IBusinessProcessWaitResult {
    hasStateHit: boolean;
    stateHit?: string | undefined;
    hasLifeCycleHit: boolean;
    lifeCycleHit: BusinessProcessLifeCycle;
    finished: boolean;
    businessProcess?: BusinessProcess | undefined;

    constructor(data?: IBusinessProcessWaitResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasStateHit = data["hasStateHit"];
            this.stateHit = data["stateHit"];
            this.hasLifeCycleHit = data["hasLifeCycleHit"];
            this.lifeCycleHit = data["lifeCycleHit"];
            this.finished = data["finished"];
            this.businessProcess = data["businessProcess"] ? BusinessProcess.fromJS(data["businessProcess"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessWaitResult {
        let result = new BusinessProcessWaitResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasStateHit"] = this.hasStateHit;
        data["stateHit"] = this.stateHit;
        data["hasLifeCycleHit"] = this.hasLifeCycleHit;
        data["lifeCycleHit"] = this.lifeCycleHit;
        data["finished"] = this.finished;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBusinessProcessWaitResult {
    hasStateHit: boolean;
    stateHit?: string | undefined;
    hasLifeCycleHit: boolean;
    lifeCycleHit: BusinessProcessLifeCycle;
    finished: boolean;
    businessProcess?: BusinessProcess | undefined;
}

export class BusinessProcessDetails extends BusinessProcess implements IBusinessProcessDetails {
    details?: BusinessProcessDetailsDataBase | undefined;

    constructor(data?: IBusinessProcessDetails) {
        super(data);
        this._discriminator = "BusinessProcessDetails";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.details = data["details"] ? BusinessProcessDetailsDataBase.fromJS(data["details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessDetails {
        let result = new BusinessProcessDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetails extends IBusinessProcess {
    details?: BusinessProcessDetailsDataBase | undefined;
}

export abstract class BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBase {

    protected _discriminator: string;

    constructor(data?: IBusinessProcessDetailsDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessDetailsDataBase";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataBase {
        if (data["kind"] === "BusinessProcessDetailsDataBulkResponse") {
            let result = new BusinessProcessDetailsDataBulkResponse();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessProcessDetailsDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        return data; 
    }
}

export interface IBusinessProcessDetailsDataBase {
}

export class BusinessProcessDetailsDataBulkResponse extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBulkResponse {
    response?: BulkResponse | undefined;

    constructor(data?: IBusinessProcessDetailsDataBulkResponse) {
        super(data);
        this._discriminator = "BusinessProcessDetailsDataBulkResponse";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.response = data["response"] ? BulkResponse.fromJS(data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessDetailsDataBulkResponse {
        let result = new BusinessProcessDetailsDataBulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IBusinessProcessDetailsDataBulkResponse extends IBusinessProcessDetailsDataBase {
    response?: IBulkResponse | undefined;
}

export class DocumentHistorySearchRequest implements IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. Default to last 1 year. */
    from: Date;
    /** Limits the end date of the search request. Default to now. */
    to: Date;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document id. E.g. ContentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specifc document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo | undefined;

    constructor(data?: IDocumentHistorySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.sort = data.sort && !(<any>data.sort).toJSON ? new SortInfo(data.sort) : <SortInfo>this.sort; 
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.start = data["start"];
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
            this.sort = data["sort"] ? SortInfo.fromJS(data["sort"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentHistorySearchRequest {
        let result = new DocumentHistorySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. Default to last 1 year. */
    from: Date;
    /** Limits the end date of the search request. Default to now. */
    to: Date;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document id. E.g. ContentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specifc document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo | undefined;
}

export class DocumentHistorySearchResult implements IDocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[] | undefined;
    pageToken?: string | undefined;
    elapsedMilliseconds: number;

    constructor(data?: IDocumentHistorySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new DocumentHistory(item) : <DocumentHistory>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(DocumentHistory.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): DocumentHistorySearchResult {
        let result = new DocumentHistorySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        return data; 
    }
}

export interface IDocumentHistorySearchResult {
    totalResults: number;
    results?: IDocumentHistory[] | undefined;
    pageToken?: string | undefined;
    elapsedMilliseconds: number;
}

export class DocumentHistory implements IDocumentHistory {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentTypeContract?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: UserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;

    constructor(data?: IDocumentHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditHistory(data.audit) : <UserAuditHistory>this.audit; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.documentId = data["documentId"];
            this.documentVersion = data["documentVersion"];
            this.documentType = data["documentType"];
            this.documentTypeContract = data["documentTypeContract"];
            this.documentDate = data["documentDate"] ? new Date(data["documentDate"].toString()) : <any>undefined;
            this.document = data["document"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.audit = data["audit"] ? UserAuditHistory.fromJS(data["audit"]) : <any>undefined;
            this.deleted = data["deleted"];
            this.action = data["action"];
        }
    }

    static fromJS(data: any): DocumentHistory {
        let result = new DocumentHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["documentTypeContract"] = this.documentTypeContract;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["document"] = this.document;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["action"] = this.action;
        return data; 
    }
}

export interface IDocumentHistory {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentTypeContract?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: IUserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;
}

export class UserAuditHistory implements IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAuditHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAuditHistory {
        let result = new UserAuditHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser;
        return data; 
    }
}

export interface IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;
}

export enum DocumentChangeAction {
    Create = <any>"Create", 
    Update = <any>"Update", 
    Delete = <any>"Delete", 
    Activate = <any>"Activate", 
    Deactivate = <any>"Deactivate", 
}

export class DocumentHistoryDifference implements IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;

    constructor(data?: IDocumentHistoryDifference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.oldDocumentVersion = data["oldDocumentVersion"];
            this.newDocumentVersion = data["newDocumentVersion"];
            this.oldValues = data["oldValues"];
            this.newValues = data["newValues"];
        }
    }

    static fromJS(data: any): DocumentHistoryDifference {
        let result = new DocumentHistoryDifference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["oldDocumentVersion"] = this.oldDocumentVersion;
        data["newDocumentVersion"] = this.newDocumentVersion;
        data["oldValues"] = this.oldValues;
        data["newValues"] = this.newValues;
        return data; 
    }
}

export interface IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;
}

/** The detail view item for the list item. */
export class ListItemDetail implements IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemDetail {
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

/** The detail view item for the list item. */
export interface IListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
}

export class ListItemNotFoundException extends PictureparkBusinessException implements IListItemNotFoundException {
    listItemId?: string | undefined;

    constructor(data?: IListItemNotFoundException) {
        super(data);
        this._discriminator = "ListItemNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.listItemId = data["listItemId"];
        }
    }

    static fromJS(data: any): ListItemNotFoundException {
        let result = new ListItemNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemId"] = this.listItemId;
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemNotFoundException extends IPictureparkBusinessException {
    listItemId?: string | undefined;
}

export class ListItemSearchRequest implements IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IListItemSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["displayPatternIds"] && data["displayPatternIds"].constructor === Array) {
                this.displayPatternIds = [];
                for (let item of data["displayPatternIds"])
                    this.displayPatternIds.push(item);
            }
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["referencedFieldsDisplayPatternIds"] && data["referencedFieldsDisplayPatternIds"].constructor === Array) {
                this.referencedFieldsDisplayPatternIds = [];
                for (let item of data["referencedFieldsDisplayPatternIds"])
                    this.referencedFieldsDisplayPatternIds.push(item);
            }
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.includeMetadata = data["includeMetadata"];
            this.debugMode = data["debugMode"];
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ListItemSearchRequest {
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.displayPatternIds && this.displayPatternIds.constructor === Array) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.referencedFieldsDisplayPatternIds && this.referencedFieldsDisplayPatternIds.constructor === Array) {
            data["referencedFieldsDisplayPatternIds"] = [];
            for (let item of this.referencedFieldsDisplayPatternIds)
                data["referencedFieldsDisplayPatternIds"].push(item);
        }
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["includeMetadata"] = this.includeMetadata;
        data["debugMode"] = this.debugMode;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Filter the returned list items that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

export class BaseResultOfListItem implements IBaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ListItem(item) : <ListItem>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(ListItem.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfListItem {
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfListItem {
    totalResults: number;
    results?: IListItem[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

/** Encapsulates the result of a list item search. */
export class ListItemSearchResult extends BaseResultOfListItem implements IListItemSearchResult {

    constructor(data?: IListItemSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListItemSearchResult {
        let result = new ListItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

/** Encapsulates the result of a list item search. */
export interface IListItemSearchResult extends IBaseResultOfListItem {
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export class ListItem implements IListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItem {
        let result = new ListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface IListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The list item id. */
    id?: string | undefined;
}

export class ListItemAggregationRequest implements IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Filter the list items document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;

    constructor(data?: IListItemAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            this.brokenDependenciesFilter = data["brokenDependenciesFilter"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
            this.lifeCycleFilter = data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ListItemAggregationRequest {
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data; 
    }
}

export interface IListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Filter the list items document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the list item document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** A request structure for creating a list item document. */
export class ListItemCreateRequest implements IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;

    constructor(data?: IListItemCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.contentSchemaId = data["contentSchemaId"];
            this.listItemId = data["listItemId"];
        }
    }

    static fromJS(data: any): ListItemCreateRequest {
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentSchemaId"] = this.contentSchemaId;
        data["listItemId"] = this.listItemId;
        return data; 
    }
}

/** A request structure for creating a list item document. */
export interface IListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;
}

/** A request structure for creating multiple list items. */
export class ListItemCreateManyRequest implements IListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create requests */
    requests?: ListItemCreateRequest[] | undefined;

    constructor(data?: IListItemCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.requests) {
                this.requests = [];
                for (let i = 0; i < data.requests.length; i++) {
                    let item = data.requests[i];
                    this.requests[i] = item && !(<any>item).toJSON ? new ListItemCreateRequest(item) : <ListItemCreateRequest>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["requests"] && data["requests"].constructor === Array) {
                this.requests = [];
                for (let item of data["requests"])
                    this.requests.push(ListItemCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemCreateManyRequest {
        let result = new ListItemCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.requests && this.requests.constructor === Array) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for creating multiple list items. */
export interface IListItemCreateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Create requests */
    requests?: IListItemCreateRequest[] | undefined;
}

/** A request structure for updating a list item. */
export class ListItemUpdateRequest implements IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;

    constructor(data?: IListItemUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ListItemUpdateRequest {
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["id"] = this.id;
        return data; 
    }
}

/** A request structure for updating a list item. */
export interface IListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;
}

/** A request structure for updating multiple list items. */
export class ListItemUpdateManyRequest implements IListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update requests */
    requests?: ListItemUpdateRequest[] | undefined;

    constructor(data?: IListItemUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.requests) {
                this.requests = [];
                for (let i = 0; i < data.requests.length; i++) {
                    let item = data.requests[i];
                    this.requests[i] = item && !(<any>item).toJSON ? new ListItemUpdateRequest(item) : <ListItemUpdateRequest>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowMissingDependencies = data["allowMissingDependencies"];
            if (data["requests"] && data["requests"].constructor === Array) {
                this.requests = [];
                for (let item of data["requests"])
                    this.requests.push(ListItemUpdateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemUpdateManyRequest {
        let result = new ListItemUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (this.requests && this.requests.constructor === Array) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data; 
    }
}

/** A request structure for updating multiple list items. */
export interface IListItemUpdateManyRequest {
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
    /** Update requests */
    requests?: IListItemUpdateRequest[] | undefined;
}

export class ListItemDeactivateRequest implements IListItemDeactivateRequest {
    listItemIds?: string[] | undefined;
    forceReferenceRemoval: boolean;

    constructor(data?: IListItemDeactivateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            this.forceReferenceRemoval = data["forceReferenceRemoval"];
        }
    }

    static fromJS(data: any): ListItemDeactivateRequest {
        let result = new ListItemDeactivateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        return data; 
    }
}

export interface IListItemDeactivateRequest {
    listItemIds?: string[] | undefined;
    forceReferenceRemoval: boolean;
}

export class ListItemReactivateRequest implements IListItemReactivateRequest {
    listItemIds?: string[] | undefined;
    allowMissingDependencies: boolean;

    constructor(data?: IListItemReactivateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ListItemReactivateRequest {
        let result = new ListItemReactivateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IListItemReactivateRequest {
    listItemIds?: string[] | undefined;
    allowMissingDependencies: boolean;
}

export class ListItemFieldsUpdateRequest implements IListItemFieldsUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[] | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;

    constructor(data?: IListItemFieldsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["listItemIds"] && data["listItemIds"].constructor === Array) {
                this.listItemIds = [];
                for (let item of data["listItemIds"])
                    this.listItemIds.push(item);
            }
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ListItemFieldsUpdateRequest {
        let result = new ListItemFieldsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.listItemIds && this.listItemIds.constructor === Array) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

export interface IListItemFieldsUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[] | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
}

/** ListItemFieldsFilterUpdateRequest class */
export class ListItemFieldsFilterUpdateRequest implements IListItemFieldsFilterUpdateRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    listItemFilterRequest?: ListItemFilterRequest | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;

    constructor(data?: IListItemFieldsFilterUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.listItemFilterRequest = data.listItemFilterRequest && !(<any>data.listItemFilterRequest).toJSON ? new ListItemFilterRequest(data.listItemFilterRequest) : <ListItemFilterRequest>this.listItemFilterRequest; 
        }
    }

    init(data?: any) {
        if (data) {
            this.listItemFilterRequest = data["listItemFilterRequest"] ? ListItemFilterRequest.fromJS(data["listItemFilterRequest"]) : <any>undefined;
            if (data["changeCommands"] && data["changeCommands"].constructor === Array) {
                this.changeCommands = [];
                for (let item of data["changeCommands"])
                    this.changeCommands.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ListItemFieldsFilterUpdateRequest {
        let result = new ListItemFieldsFilterUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemFilterRequest"] = this.listItemFilterRequest ? this.listItemFilterRequest.toJSON() : <any>undefined;
        if (this.changeCommands && this.changeCommands.constructor === Array) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data; 
    }
}

/** ListItemFieldsFilterUpdateRequest class */
export interface IListItemFieldsFilterUpdateRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    listItemFilterRequest?: IListItemFilterRequest | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
    /** Allow storing references to missing list items / contents */
    allowMissingDependencies: boolean;
}

export class ListItemFilterRequest implements IListItemFilterRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IListItemFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = data["includeAllSchemaChildren"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.displayLanguage = data["displayLanguage"];
            if (data["searchLanguages"] && data["searchLanguages"].constructor === Array) {
                this.searchLanguages = [];
                for (let item of data["searchLanguages"])
                    this.searchLanguages.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemFilterRequest {
        let result = new ListItemFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["displayLanguage"] = this.displayLanguage;
        if (this.searchLanguages && this.searchLanguages.constructor === Array) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data; 
    }
}

export interface IListItemFilterRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
}

export class LiveStreamSearchRequest implements ILiveStreamSearchRequest {
    /** Limits the start date of the search request. */
    from: Date;
    /** Limits the end date of the search request. */
    to: Date;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;

    constructor(data?: ILiveStreamSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? new Date(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? new Date(data["to"].toString()) : <any>undefined;
            this.start = data["start"];
            this.limit = data["limit"];
            this.pageToken = data["pageToken"];
        }
    }

    static fromJS(data: any): LiveStreamSearchRequest {
        let result = new LiveStreamSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        return data; 
    }
}

export interface ILiveStreamSearchRequest {
    /** Limits the start date of the search request. */
    from: Date;
    /** Limits the end date of the search request. */
    to: Date;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
}

export class BaseResultOfObject implements IBaseResultOfObject {
    totalResults: number;
    results?: any[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(item);
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfObject {
        let result = new BaseResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfObject {
    totalResults: number;
    results?: any[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfObject extends BaseResultOfObject implements ISearchBehaviourBaseResultOfObject {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfObject) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfObject {
        let result = new SearchBehaviourBaseResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfObject extends IBaseResultOfObject {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class ObjectSearchResult extends SearchBehaviourBaseResultOfObject implements IObjectSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IObjectSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ObjectSearchResult {
        let result = new ObjectSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IObjectSearchResult extends ISearchBehaviourBaseResultOfObject {
    elapsedMilliseconds: number;
}

export class SchemaDetail implements ISchemaDetail {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: UserAudit | undefined;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount | undefined;

    constructor(data?: ISchemaDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            this.searchFieldCount = data.searchFieldCount && !(<any>data.searchFieldCount).toJSON ? new SearchFieldCount(data.searchFieldCount) : <SearchFieldCount>this.searchFieldCount; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            this.system = data["system"];
            this.ownerTokenId = data["ownerTokenId"];
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["descendantSchemaIds"] && data["descendantSchemaIds"].constructor === Array) {
                this.descendantSchemaIds = [];
                for (let item of data["descendantSchemaIds"])
                    this.descendantSchemaIds.push(item);
            }
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.searchFieldCount = data["searchFieldCount"] ? SearchFieldCount.fromJS(data["searchFieldCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaDetail {
        let result = new SchemaDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        data["system"] = this.system;
        data["ownerTokenId"] = this.ownerTokenId;
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.descendantSchemaIds && this.descendantSchemaIds.constructor === Array) {
            data["descendantSchemaIds"] = [];
            for (let item of this.descendantSchemaIds)
                data["descendantSchemaIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["searchFieldCount"] = this.searchFieldCount ? this.searchFieldCount.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchemaDetail {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: IUserAudit | undefined;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: ISearchFieldCount | undefined;
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export class DisplayPattern implements IDisplayPattern {
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;

    constructor(data?: IDisplayPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.templates = data.templates && !(<any>data.templates).toJSON ? new TranslatedStringDictionary(data.templates) : <TranslatedStringDictionary>this.templates; 
        }
    }

    init(data?: any) {
        if (data) {
            this.templateEngine = data["templateEngine"];
            this.displayPatternType = data["displayPatternType"];
            this.templates = data["templates"] ? TranslatedStringDictionary.fromJS(data["templates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DisplayPattern {
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateEngine"] = this.templateEngine;
        data["displayPatternType"] = this.displayPatternType;
        data["templates"] = this.templates ? this.templates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDisplayPattern {
    /** Defines the template engine for parsing the templates. */
    templateEngine: TemplateEngine;
    /** Defines the pattern type of the templates. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: ITranslatedStringDictionary | undefined;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

/** The field base class. */
export abstract class FieldBase implements IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** The index id is auto generated by the system. */
    indexId?: string | undefined;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
        }
        this._discriminator = "FieldBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.indexId = data["indexId"];
            this.fieldNamespace = data["fieldNamespace"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            this.required = data["required"];
            this.fixed = data["fixed"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
        }
    }

    static fromJS(data: any): FieldBase {
        if (data["kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["indexId"] = this.indexId;
        data["fieldNamespace"] = this.fieldNamespace;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["required"] = this.required;
        data["fixed"] = this.fixed;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        return data; 
    }
}

/** The field base class. */
export interface IFieldBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** The index id is auto generated by the system. */
    indexId?: string | undefined;
    /** The namespace is auto generated by the system. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
}

export class FieldBoolean extends FieldBase implements IFieldBoolean {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldBoolean) {
        super(data);
        this._discriminator = "FieldBoolean";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldBoolean {
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldBoolean extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldDate extends FieldBase implements IFieldDate {
    /** Defines the date format structure. */
    format?: string | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDate) {
        super(data);
        this._discriminator = "FieldDate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDate {
        let result = new FieldDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDate extends IFieldBase {
    /** Defines the date format structure. */
    format?: string | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldDateTime extends FieldBase implements IFieldDateTime {
    /** Defines the date time format structure. */
    format?: string | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDateTime) {
        super(data);
        this._discriminator = "FieldDateTime";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.format = data["format"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDateTime {
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDateTime extends IFieldBase {
    /** Defines the date time format structure. */
    format?: string | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this._discriminator = "FieldDateTimeArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDateTimeArray {
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDateTimeArray extends IFieldDateTime {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldDecimal extends FieldBase implements IFieldDecimal {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDecimal) {
        super(data);
        this._discriminator = "FieldDecimal";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDecimal {
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldDecimal extends IFieldBase {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDictionary extends FieldBase implements IFieldDictionary {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldDictionary) {
        super(data);
        this._discriminator = "FieldDictionary";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldDictionary {
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionary extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this._discriminator = "FieldDictionaryArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldDictionaryArray {
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldDictionaryArray extends IFieldDictionary {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this._discriminator = "FieldGeoPoint";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldGeoPoint {
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldGeoPoint extends IFieldBase {
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldLong extends FieldBase implements IFieldLong {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldLong) {
        super(data);
        this._discriminator = "FieldLong";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimum = data["minimum"];
            this.maximum = data["maximum"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldLong {
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldLong extends IFieldBase {
    pattern?: string | undefined;
    /** Defines the lowest possible value. */
    minimum?: number | undefined;
    /** Defines the highest possible value. */
    maximum?: number | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** For internal use only (system schemas) */
export class FieldLongArray extends FieldLong implements IFieldLongArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldLongArray) {
        super(data);
        this._discriminator = "FieldLongArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldLongArray {
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldLongArray extends IFieldLong {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        this._discriminator = "FieldSingleFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldSingleFieldset {
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
}

export class SchemaIndexingInfo implements ISchemaIndexingInfo {
    /** A collecction of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[] | undefined;

    constructor(data?: ISchemaIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.fields) {
                this.fields = [];
                for (let i = 0; i < data.fields.length; i++) {
                    let item = data.fields[i];
                    this.fields[i] = item && !(<any>item).toJSON ? new FieldIndexingInfo(item) : <FieldIndexingInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldIndexingInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaIndexingInfo {
        let result = new SchemaIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISchemaIndexingInfo {
    /** A collecction of indexing information for the fields of a schema */
    fields?: IFieldIndexingInfo[] | undefined;
}

export class FieldIndexingInfo implements IFieldIndexingInfo {
    /** The field Id */
    id?: string | undefined;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
    /** Indexing information of fields of the schema related to this field (if existing) */
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.relatedSchemaIndexing = data.relatedSchemaIndexing && !(<any>data.relatedSchemaIndexing).toJSON ? new SchemaIndexingInfo(data.relatedSchemaIndexing) : <SchemaIndexingInfo>this.relatedSchemaIndexing; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.index = data["index"];
            this.simpleSearch = data["simpleSearch"];
            this.boost = data["boost"];
            this.relatedSchemaIndexing = data["relatedSchemaIndexing"] ? SchemaIndexingInfo.fromJS(data["relatedSchemaIndexing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldIndexingInfo {
        let result = new FieldIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["boost"] = this.boost;
        data["relatedSchemaIndexing"] = this.relatedSchemaIndexing ? this.relatedSchemaIndexing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFieldIndexingInfo {
    /** The field Id */
    id?: string | undefined;
    /** Maps the field in the elastic search index and its values become searchable. */
    index: boolean;
    /** Includes fields in the simple search. Index must be true. */
    simpleSearch: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
    /** Indexing information of fields of the schema related to this field (if existing) */
    relatedSchemaIndexing?: ISchemaIndexingInfo | undefined;
}

export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        this._discriminator = "FieldMultiFieldset";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiFieldset {
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiFieldset extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible fieldset count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible fieldset count. */
    minimumItems?: number | undefined;
}

export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        this._discriminator = "FieldSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldSingleTagbox {
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;
}

export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible item count. */
    minimumItems?: number | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        this._discriminator = "FieldMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldMultiTagbox {
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiTagbox extends IFieldBase {
    /** The id of the schema with type list. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Defines the lowest possible item count. */
    minimumItems?: number | undefined;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;
}

export class FieldString extends FieldBase implements IFieldString {
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[] | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldString) {
        super(data);
        this._discriminator = "FieldString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.template = data["template"];
            this.keepFieldValue = data["keepFieldValue"];
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["analyzers"] && data["analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["grantedValues"] && data["grantedValues"].constructor === Array) {
                this.grantedValues = [];
                for (let item of data["grantedValues"])
                    this.grantedValues.push(item);
            }
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldString {
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["keepFieldValue"] = this.keepFieldValue;
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["analyzers"] = [];
            for (let item of this.analyzers)
                data["analyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.grantedValues && this.grantedValues.constructor === Array) {
            data["grantedValues"] = [];
            for (let item of this.grantedValues)
                data["grantedValues"].push(item);
        }
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldString extends IFieldBase {
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Similar to an enumeration valid field values are limited to values of this list. */
    grantedValues?: string[] | undefined;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

/** The analyzer base class. */
export abstract class AnalyzerBase implements IAnalyzerBase {
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;

    protected _discriminator: string;

    constructor(data?: IAnalyzerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnalyzerBase";
    }

    init(data?: any) {
        if (data) {
            this.simpleSearch = data["simpleSearch"];
        }
    }

    static fromJS(data: any): AnalyzerBase {
        if (data["kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AnalyzerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["simpleSearch"] = this.simpleSearch;
        return data; 
    }
}

/** The analyzer base class. */
export interface IAnalyzerBase {
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this._discriminator = "EdgeNGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): EdgeNGramAnalyzer {
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this._discriminator = "LanguageAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): LanguageAnalyzer {
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this._discriminator = "NGramAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): NGramAnalyzer {
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface INGramAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this._discriminator = "PathHierarchyAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): PathHierarchyAnalyzer {
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    fieldSuffix?: string | undefined;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this._discriminator = "SimpleAnalyzer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fieldSuffix = data["fieldSuffix"];
        }
    }

    static fromJS(data: any): SimpleAnalyzer {
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data; 
    }
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** For internal use only (system schemas) */
export class FieldStringArray extends FieldString implements IFieldStringArray {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;

    constructor(data?: IFieldStringArray) {
        super(data);
        this._discriminator = "FieldStringArray";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldStringArray {
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

/** For internal use only (system schemas) */
export interface IFieldStringArray extends IFieldString {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[] | undefined;
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        this._discriminator = "FieldTranslatedString";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pattern = data["pattern"];
            this.minimumLength = data["minimumLength"];
            this.maximumLength = data["maximumLength"];
            if (data["analyzers"] && data["analyzers"].constructor === Array) {
                this.analyzers = [];
                for (let item of data["analyzers"])
                    this.analyzers.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = data["multiLine"];
            if (data["requiredMetadataLanguages"] && data["requiredMetadataLanguages"].constructor === Array) {
                this.requiredMetadataLanguages = [];
                for (let item of data["requiredMetadataLanguages"])
                    this.requiredMetadataLanguages.push(item);
            }
            this.template = data["template"];
            this.keepFieldValue = data["keepFieldValue"];
            this.boost = data["boost"];
        }
    }

    static fromJS(data: any): FieldTranslatedString {
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (this.analyzers && this.analyzers.constructor === Array) {
            data["analyzers"] = [];
            for (let item of this.analyzers)
                data["analyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (this.requiredMetadataLanguages && this.requiredMetadataLanguages.constructor === Array) {
            data["requiredMetadataLanguages"] = [];
            for (let item of this.requiredMetadataLanguages)
                data["requiredMetadataLanguages"].push(item);
        }
        data["template"] = this.template;
        data["keepFieldValue"] = this.keepFieldValue;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldTranslatedString extends IFieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** Defines the minimal string length. */
    minimumLength?: number | undefined;
    /** Defines the maximal string length. */
    maximumLength?: number | undefined;
    /** A string field can have multiple analyzers, but only one per analyzer type. To have any effect the Index must be true. */
    analyzers?: AnalyzerBase[] | undefined;
    /** Displays the field value in a multiline component. */
    multiLine: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required, including x-default.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory, including x-default. */
    requiredMetadataLanguages?: string[] | undefined;
    /** It is a DotLiquid template. */
    template?: string | undefined;
    /** If true the Template will only render on item creation otherwise it will render on each update. */
    keepFieldValue: boolean;
    /** Priorizes search results. SimpleSearch must be true. */
    boost: number;
}

export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;

    constructor(data?: IFieldSingleRelation) {
        super(data);
        this._discriminator = "FieldSingleRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldSingleRelation {
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldSingleRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: IRelationType[] | undefined;
}

export class RelationType implements IRelationType {
    /** The id property. */
    id?: string | undefined;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the valid target context. */
    targetContext: TargetContext;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase | undefined;

    constructor(data?: IRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.targetContext = data["targetContext"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RelationType {
        let result = new RelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["targetContext"] = this.targetContext;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRelationType {
    /** The id property. */
    id?: string | undefined;
    /** Language specific relation names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Defines the valid target context. */
    targetContext: TargetContext;
    /** An optional search filter. Limits the content or the list item result set depending on the relation's target context. */
    filter?: FilterBase | undefined;
}

export enum TargetContext {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    User = <any>"User", 
    Custom = <any>"Custom", 
}

export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: RelationType[] | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Dfines the lowest possible item count. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        this._discriminator = "FieldMultiRelation";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            this.schemaIndexingInfo = data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(data["schemaIndexingInfo"]) : <any>undefined;
            if (data["relationTypes"] && data["relationTypes"].constructor === Array) {
                this.relationTypes = [];
                for (let item of data["relationTypes"])
                    this.relationTypes.push(RelationType.fromJS(item));
            }
            this.uniqueItems = data["uniqueItems"];
            this.maximumItems = data["maximumItems"];
            this.minimumItems = data["minimumItems"];
        }
    }

    static fromJS(data: any): FieldMultiRelation {
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (this.relationTypes && this.relationTypes.constructor === Array) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["uniqueItems"] = this.uniqueItems;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data; 
    }
}

export interface IFieldMultiRelation extends IFieldBase {
    /** The id of the schema with type struct. */
    schemaId?: string | undefined;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Defines the relation types supported by the field. */
    relationTypes?: IRelationType[] | undefined;
    /** Prevents duplicate values. */
    uniqueItems: boolean;
    /** Defines the highest possible item count. */
    maximumItems?: number | undefined;
    /** Dfines the lowest possible item count. */
    minimumItems?: number | undefined;
}

/** Base class for overwritten information on a field. */
export abstract class FieldOverwriteBase implements IFieldOverwriteBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldOverwriteBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldOverwriteBase";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.required = data["required"];
        }
    }

    static fromJS(data: any): FieldOverwriteBase {
        if (data["kind"] === "FieldOverwriteSingleTagbox") {
            let result = new FieldOverwriteSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldOverwriteMultiTagbox") {
            let result = new FieldOverwriteMultiTagbox();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldOverwriteBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["required"] = this.required;
        return data; 
    }
}

/** Base class for overwritten information on a field. */
export interface IFieldOverwriteBase {
    /** The field id. Can be a slug and must be unique within the schema. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
}

/** Overwritten information for Single Tagbox field. */
export class FieldOverwriteSingleTagbox extends FieldOverwriteBase implements IFieldOverwriteSingleTagbox {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldOverwriteSingleTagbox) {
        super(data);
        this._discriminator = "FieldOverwriteSingleTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldOverwriteSingleTagbox {
        let result = new FieldOverwriteSingleTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

/** Overwritten information for Single Tagbox field. */
export interface IFieldOverwriteSingleTagbox extends IFieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;
}

/** Overwritten information for Multi Tagbox field. */
export class FieldOverwriteMultiTagbox extends FieldOverwriteBase implements IFieldOverwriteMultiTagbox {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;

    constructor(data?: IFieldOverwriteMultiTagbox) {
        super(data);
        this._discriminator = "FieldOverwriteMultiTagbox";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = data["listItemCreateTemplate"];
        }
    }

    static fromJS(data: any): FieldOverwriteMultiTagbox {
        let result = new FieldOverwriteMultiTagbox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        super.toJSON(data);
        return data; 
    }
}

/** Overwritten information for Multi Tagbox field. */
export interface IFieldOverwriteMultiTagbox extends IFieldOverwriteBase {
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item */
    listItemCreateTemplate?: string | undefined;
}

/** Count info of fields for search operations */
export class SearchFieldCount implements ISearchFieldCount {
    /** The number of fields generated by the schema in the Search index. */
    dataField: number;
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;

    constructor(data?: ISearchFieldCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dataField = data["dataField"];
            this.indexedField = data["indexedField"];
            this.simpleSearchField = data["simpleSearchField"];
        }
    }

    static fromJS(data: any): SearchFieldCount {
        let result = new SearchFieldCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataField"] = this.dataField;
        data["indexedField"] = this.indexedField;
        data["simpleSearchField"] = this.simpleSearchField;
        return data; 
    }
}

/** Count info of fields for search operations */
export interface ISearchFieldCount {
    /** The number of fields generated by the schema in the Search index. */
    dataField: number;
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
}

export class SchemaSearchRequest implements ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: ISchemaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): SchemaSearchRequest {
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface ISchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export class BaseResultOfSchema implements IBaseResultOfSchema {
    totalResults: number;
    results?: Schema[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Schema(item) : <Schema>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Schema.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfSchema {
        let result = new BaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfSchema {
    totalResults: number;
    results?: ISchema[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfSchema extends BaseResultOfSchema implements ISearchBehaviourBaseResultOfSchema {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfSchema) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfSchema {
        let result = new SearchBehaviourBaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfSchema extends IBaseResultOfSchema {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class SchemaSearchResult extends SearchBehaviourBaseResultOfSchema implements ISchemaSearchResult {

    constructor(data?: ISchemaSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaSearchResult {
        let result = new SchemaSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaSearchResult extends ISearchBehaviourBaseResultOfSchema {
}

export class Schema implements ISchema {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;

    constructor(data?: ISchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.fieldCount = data["fieldCount"];
            this.childCount = data["childCount"];
            this.level = data["level"];
            this.system = data["system"];
        }
    }

    static fromJS(data: any): Schema {
        let result = new Schema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["fieldCount"] = this.fieldCount;
        data["childCount"] = this.childCount;
        data["level"] = this.level;
        data["system"] = this.system;
        return data; 
    }
}

export interface ISchema {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

/** Response that tells if exists */
export class ExistsResponse implements IExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;

    constructor(data?: IExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exists = data["exists"];
        }
    }

    static fromJS(data: any): ExistsResponse {
        let result = new ExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        return data; 
    }
}

/** Response that tells if exists */
export interface IExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;
}

export class SchemaCreateRequest implements ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentSchemaId = data["parentSchemaId"];
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCreateRequest {
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        return data; 
    }
}

export interface ISchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

export class DuplicateSchemaException extends PictureparkBusinessException implements IDuplicateSchemaException {
    schemaId?: string | undefined;

    constructor(data?: IDuplicateSchemaException) {
        super(data);
        this._discriminator = "DuplicateSchemaException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): DuplicateSchemaException {
        let result = new DuplicateSchemaException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface IDuplicateSchemaException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
}

export class SchemaValidationException extends PictureparkBusinessException implements ISchemaValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaValidationException) {
        super(data);
        this._discriminator = "SchemaValidationException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["exceptions"] && data["exceptions"].constructor === Array) {
                this.exceptions = [];
                for (let item of data["exceptions"])
                    this.exceptions.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaValidationException {
        let result = new SchemaValidationException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.exceptions && this.exceptions.constructor === Array) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaValidationException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class SchemaCyclicDependencyException extends PictureparkBusinessException implements ISchemaCyclicDependencyException {
    schemaIds?: string[] | undefined;

    constructor(data?: ISchemaCyclicDependencyException) {
        super(data);
        this._discriminator = "SchemaCyclicDependencyException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaCyclicDependencyException {
        let result = new SchemaCyclicDependencyException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaCyclicDependencyException extends IPictureparkBusinessException {
    schemaIds?: string[] | undefined;
}

export class SchemaUpdateRequest implements ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;

    constructor(data?: ISchemaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            if (data["displayPatterns"] && data["displayPatterns"].constructor === Array) {
                this.displayPatterns = [];
                for (let item of data["displayPatterns"])
                    this.displayPatterns.push(DisplayPattern.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(FieldBase.fromJS(item));
            }
            if (data["fieldsOverwrite"] && data["fieldsOverwrite"].constructor === Array) {
                this.fieldsOverwrite = [];
                for (let item of data["fieldsOverwrite"])
                    this.fieldsOverwrite.push(FieldOverwriteBase.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            this.sortOrder = data["sortOrder"];
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.public = data["public"];
            if (data["schemaPermissionSetIds"] && data["schemaPermissionSetIds"].constructor === Array) {
                this.schemaPermissionSetIds = [];
                for (let item of data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds.push(item);
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            if (data["referencedInContentSchemaIds"] && data["referencedInContentSchemaIds"].constructor === Array) {
                this.referencedInContentSchemaIds = [];
                for (let item of data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds.push(item);
            }
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaUpdateRequest {
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (this.displayPatterns && this.displayPatterns.constructor === Array) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (this.fieldsOverwrite && this.fieldsOverwrite.constructor === Array) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["public"] = this.public;
        if (this.schemaPermissionSetIds && this.schemaPermissionSetIds.constructor === Array) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.referencedInContentSchemaIds && this.referencedInContentSchemaIds.constructor === Array) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        return data; 
    }
}

export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** The schema fields overwrite information. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: ISortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;
}

export class SchemaNotFoundException extends PictureparkBusinessException implements ISchemaNotFoundException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNotFoundException) {
        super(data);
        this._discriminator = "SchemaNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
        }
    }

    static fromJS(data: any): SchemaNotFoundException {
        let result = new SchemaNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaNotFoundException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
}

export class SchemaInUseException extends PictureparkBusinessException implements ISchemaInUseException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaInUseException) {
        super(data);
        this._discriminator = "SchemaInUseException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.schemaId = data["schemaId"];
            if (data["exceptions"] && data["exceptions"].constructor === Array) {
                this.exceptions = [];
                for (let item of data["exceptions"])
                    this.exceptions.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaInUseException {
        let result = new SchemaInUseException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (this.exceptions && this.exceptions.constructor === Array) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaInUseException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class PermissionSetSearchRequest implements IPermissionSetSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IPermissionSetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.rightFilter = data["rightFilter"];
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): PermissionSetSearchRequest {
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["rightFilter"] = this.rightFilter;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IPermissionSetSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
}

export class BaseResultOfPermissionSet implements IBaseResultOfPermissionSet {
    totalResults: number;
    results?: PermissionSet[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new PermissionSet(item) : <PermissionSet>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(PermissionSet.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfPermissionSet {
        let result = new BaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfPermissionSet {
    totalResults: number;
    results?: IPermissionSet[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfPermissionSet extends BaseResultOfPermissionSet implements ISearchBehaviourBaseResultOfPermissionSet {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfPermissionSet) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfPermissionSet {
        let result = new SearchBehaviourBaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfPermissionSet extends IBaseResultOfPermissionSet {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class PermissionSetSearchResult extends SearchBehaviourBaseResultOfPermissionSet implements IPermissionSetSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IPermissionSetSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): PermissionSetSearchResult {
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IPermissionSetSearchResult extends ISearchBehaviourBaseResultOfPermissionSet {
    elapsedMilliseconds: number;
}

export class PermissionSet implements IPermissionSet {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;

    constructor(data?: IPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSet {
        let result = new PermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPermissionSet {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: ITranslatedStringDictionary | undefined;
}

export abstract class PermissionSetDetailOfContentRight implements IPermissionSetDetailOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfContentRight(item) : <PermissionUserRoleRightsOfContentRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfContentRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfContentRight {
        throw new Error("The abstract class 'PermissionSetDetailOfContentRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailOfContentRight {
    id?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: IPermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class ContentPermissionSetDetail extends PermissionSetDetailOfContentRight implements IContentPermissionSetDetail {

    constructor(data?: IContentPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ContentPermissionSetDetail {
        let result = new ContentPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContentPermissionSetDetail extends IPermissionSetDetailOfContentRight {
}

export class PermissionUserRoleRightsOfContentRight implements IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        let result = new PermissionUserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;
}

export class PermissionUserRoleRightsOfPermissionSetRight implements IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        let result = new PermissionUserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;
}

export abstract class PermissionSetDetailOfMetadataRight implements IPermissionSetDetailOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;

    constructor(data?: IPermissionSetDetailOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfMetadataRight(item) : <PermissionUserRoleRightsOfMetadataRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.trashed = data["trashed"];
            if (data["userRolesRights"] && data["userRolesRights"].constructor === Array) {
                this.userRolesRights = [];
                for (let item of data["userRolesRights"])
                    this.userRolesRights.push(PermissionUserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (data["userRolesPermissionSetRights"] && data["userRolesPermissionSetRights"].constructor === Array) {
                this.userRolesPermissionSetRights = [];
                for (let item of data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = data["exclusive"];
        }
    }

    static fromJS(data: any): PermissionSetDetailOfMetadataRight {
        throw new Error("The abstract class 'PermissionSetDetailOfMetadataRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["trashed"] = this.trashed;
        if (this.userRolesRights && this.userRolesRights.constructor === Array) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (this.userRolesPermissionSetRights && this.userRolesPermissionSetRights.constructor === Array) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        return data; 
    }
}

export interface IPermissionSetDetailOfMetadataRight {
    id?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: IPermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export class SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight implements ISchemaPermissionSetDetail {

    constructor(data?: ISchemaPermissionSetDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SchemaPermissionSetDetail {
        let result = new SchemaPermissionSetDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ISchemaPermissionSetDetail extends IPermissionSetDetailOfMetadataRight {
}

export class PermissionUserRoleRightsOfMetadataRight implements IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["userRoleId"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["rights"] && data["rights"].constructor === Array) {
                this.rights = [];
                for (let item of data["rights"])
                    this.rights.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        let result = new PermissionUserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.rights && this.rights.constructor === Array) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data; 
    }
}

export interface IPermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: ITranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageDrives = <any>"ManageDrives", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageRecipients = <any>"ManageRecipients", 
    ManageCollections = <any>"ManageCollections", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
    ManageEmbeds = <any>"ManageEmbeds", 
    ManageTemplates = <any>"ManageTemplates", 
}

/** The version view item for the environment. */
export class VersionInfo implements IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string | undefined;

    constructor(data?: IVersionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileVersion = data["fileVersion"];
            this.fileProductVersion = data["fileProductVersion"];
            this.contractVersion = data["contractVersion"];
            this.release = data["release"];
        }
    }

    static fromJS(data: any): VersionInfo {
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileVersion"] = this.fileVersion;
        data["fileProductVersion"] = this.fileProductVersion;
        data["contractVersion"] = this.contractVersion;
        data["release"] = this.release;
        return data; 
    }
}

/** The version view item for the environment. */
export interface IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string | undefined;
}

export class ShareDetail implements IShareDetail {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    creator?: ShareUser | undefined;
    audit?: UserAudit | undefined;
    contentSelections?: ShareContentDetail[] | undefined;
    layerSchemaIds?: string[] | undefined;
    data?: ShareDataBase | undefined;
    mailTemplateId?: string | undefined;
    expirationDate?: Date | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
    shareType: ShareType;

    constructor(data?: IShareDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.creator = data.creator && !(<any>data.creator).toJSON ? new ShareUser(data.creator) : <ShareUser>this.creator; 
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            if (data.contentSelections) {
                this.contentSelections = [];
                for (let i = 0; i < data.contentSelections.length; i++) {
                    let item = data.contentSelections[i];
                    this.contentSelections[i] = item && !(<any>item).toJSON ? new ShareContentDetail(item) : <ShareContentDetail>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.creator = data["creator"] ? ShareUser.fromJS(data["creator"]) : <any>undefined;
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            if (data["contentSelections"] && data["contentSelections"].constructor === Array) {
                this.contentSelections = [];
                for (let item of data["contentSelections"])
                    this.contentSelections.push(ShareContentDetail.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.data = data["data"] ? ShareDataBase.fromJS(data["data"]) : <any>undefined;
            this.mailTemplateId = data["mailTemplateId"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
            this.shareType = data["shareType"];
        }
    }

    static fromJS(data: any): ShareDetail {
        let result = new ShareDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        if (this.contentSelections && this.contentSelections.constructor === Array) {
            data["contentSelections"] = [];
            for (let item of this.contentSelections)
                data["contentSelections"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["mailTemplateId"] = this.mailTemplateId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        data["shareType"] = this.shareType;
        return data; 
    }
}

export interface IShareDetail {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    creator?: IShareUser | undefined;
    audit?: IUserAudit | undefined;
    contentSelections?: IShareContentDetail[] | undefined;
    layerSchemaIds?: string[] | undefined;
    data?: ShareDataBase | undefined;
    mailTemplateId?: string | undefined;
    expirationDate?: Date | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
    shareType: ShareType;
}

/** Reduced set of user information used for shares */
export class ShareUser implements IShareUser {
    /** Name of user */
    displayName?: string | undefined;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash?: string | undefined;

    constructor(data?: IShareUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.emailHash = data["emailHash"];
        }
    }

    static fromJS(data: any): ShareUser {
        let result = new ShareUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["emailHash"] = this.emailHash;
        return data; 
    }
}

/** Reduced set of user information used for shares */
export interface IShareUser {
    /** Name of user */
    displayName?: string | undefined;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash?: string | undefined;
}

export class ShareContentDetail implements IShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    outputs?: ShareOutputBase[] | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;

    constructor(data?: IShareContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.content = data.content && !(<any>data.content).toJSON ? new DataDictionary(data.content) : <DataDictionary>this.content; 
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues; 
        }
    }

    init(data?: any) {
        if (data) {
            this.contentSchemaId = data["contentSchemaId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.content = data["content"] ? DataDictionary.fromJS(data["content"]) : <any>undefined;
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            this.id = data["id"];
            if (data["outputs"] && data["outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["outputs"])
                    this.outputs.push(ShareOutputBase.fromJS(item));
            }
            this.contentType = data["contentType"];
            this.displayValues = data["displayValues"] ? DisplayValueDictionary.fromJS(data["displayValues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareContentDetail {
        let result = new ShareContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.outputs && this.outputs.constructor === Array) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: IDataDictionary | undefined;
    metadata?: IDataDictionary | undefined;
    id?: string | undefined;
    outputs?: ShareOutputBase[] | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
}

export abstract class ShareOutputBase implements IShareOutputBase {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    url?: string | undefined;
    detail?: OutputDataBase | undefined;

    protected _discriminator: string;

    constructor(data?: IShareOutputBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareOutputBase";
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            this.outputFormatId = data["outputFormatId"];
            this.url = data["url"];
            this.detail = data["detail"] ? OutputDataBase.fromJS(data["detail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShareOutputBase {
        if (data["kind"] === "ShareOutputBasic") {
            let result = new ShareOutputBasic();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputEmbed") {
            let result = new ShareOutputEmbed();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareOutputBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["url"] = this.url;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShareOutputBase {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    url?: string | undefined;
    detail?: OutputDataBase | undefined;
}

export abstract class OutputDataBase implements IOutputDataBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDataBase";
    }

    init(data?: any) {
        if (data) {
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
        }
    }

    static fromJS(data: any): OutputDataBase {
        if (data["kind"] === "OutputDataImage") {
            let result = new OutputDataImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataAudio") {
            let result = new OutputDataAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataVideo") {
            let result = new OutputDataVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDocument") {
            let result = new OutputDataDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDefault") {
            let result = new OutputDataDefault();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OutputDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        return data; 
    }
}

export interface IOutputDataBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
}

export class OutputDataImage extends OutputDataBase implements IOutputDataImage {
    width: number;
    height: number;

    constructor(data?: IOutputDataImage) {
        super(data);
        this._discriminator = "OutputDataImage";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): OutputDataImage {
        let result = new OutputDataImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataImage extends IOutputDataBase {
    width: number;
    height: number;
}

export class OutputDataAudio extends OutputDataBase implements IOutputDataAudio {
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDataAudio) {
        super(data);
        this._discriminator = "OutputDataAudio";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
        }
    }

    static fromJS(data: any): OutputDataAudio {
        let result = new OutputDataAudio();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataAudio extends IOutputDataBase {
    durationInSeconds?: number | undefined;
}

export class OutputDataVideo extends OutputDataBase implements IOutputDataVideo {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDataVideo) {
        super(data);
        this._discriminator = "OutputDataVideo";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.durationInSeconds = data["durationInSeconds"];
            this.width = data["width"];
            this.height = data["height"];
            if (data["sprites"] && data["sprites"].constructor === Array) {
                this.sprites = [];
                for (let item of data["sprites"])
                    this.sprites.push(Sprite.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputDataVideo {
        let result = new OutputDataVideo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        data["width"] = this.width;
        data["height"] = this.height;
        if (this.sprites && this.sprites.constructor === Array) {
            data["sprites"] = [];
            for (let item of this.sprites)
                data["sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataVideo extends IOutputDataBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: ISprite[] | undefined;
}

export class OutputDataDocument extends OutputDataBase implements IOutputDataDocument {
    pageCount: number;

    constructor(data?: IOutputDataDocument) {
        super(data);
        this._discriminator = "OutputDataDocument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pageCount = data["pageCount"];
        }
    }

    static fromJS(data: any): OutputDataDocument {
        let result = new OutputDataDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataDocument extends IOutputDataBase {
    pageCount: number;
}

export class OutputDataDefault extends OutputDataBase implements IOutputDataDefault {

    constructor(data?: IOutputDataDefault) {
        super(data);
        this._discriminator = "OutputDataDefault";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): OutputDataDefault {
        let result = new OutputDataDefault();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOutputDataDefault extends IOutputDataBase {
}

export class ShareOutputBasic extends ShareOutputBase implements IShareOutputBasic {

    constructor(data?: IShareOutputBasic) {
        super(data);
        this._discriminator = "ShareOutputBasic";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareOutputBasic {
        let result = new ShareOutputBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareOutputBasic extends IShareOutputBase {
}

export class ShareOutputEmbed extends ShareOutputBase implements IShareOutputEmbed {
    token?: string | undefined;

    constructor(data?: IShareOutputEmbed) {
        super(data);
        this._discriminator = "ShareOutputEmbed";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareOutputEmbed {
        let result = new ShareOutputEmbed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareOutputEmbed extends IShareOutputBase {
    token?: string | undefined;
}

export abstract class ShareDataBase implements IShareDataBase {
    url?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IShareDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareDataBase";
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ShareDataBase {
        if (data["kind"] === "ShareDataEmbed") {
            let result = new ShareDataEmbed();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareDataBasic") {
            let result = new ShareDataBasic();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["url"] = this.url;
        return data; 
    }
}

export interface IShareDataBase {
    url?: string | undefined;
}

export class ShareDataEmbed extends ShareDataBase implements IShareDataEmbed {
    token?: string | undefined;

    constructor(data?: IShareDataEmbed) {
        super(data);
        this._discriminator = "ShareDataEmbed";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): ShareDataEmbed {
        let result = new ShareDataEmbed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareDataEmbed extends IShareDataBase {
    token?: string | undefined;
}

export class ShareDataBasic extends ShareDataBase implements IShareDataBasic {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    languageCode?: string | undefined;

    constructor(data?: IShareDataBasic) {
        super(data);
        this._discriminator = "ShareDataBasic";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["mailRecipients"] && data["mailRecipients"].constructor === Array) {
                this.mailRecipients = [];
                for (let item of data["mailRecipients"])
                    this.mailRecipients.push(MailRecipient.fromJS(item));
            }
            if (data["internalRecipients"] && data["internalRecipients"].constructor === Array) {
                this.internalRecipients = [];
                for (let item of data["internalRecipients"])
                    this.internalRecipients.push(InternalRecipient.fromJS(item));
            }
            this.languageCode = data["languageCode"];
        }
    }

    static fromJS(data: any): ShareDataBasic {
        let result = new ShareDataBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.mailRecipients && this.mailRecipients.constructor === Array) {
            data["mailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["mailRecipients"].push(item.toJSON());
        }
        if (this.internalRecipients && this.internalRecipients.constructor === Array) {
            data["internalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["internalRecipients"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareDataBasic extends IShareDataBase {
    mailRecipients?: IMailRecipient[] | undefined;
    internalRecipients?: IInternalRecipient[] | undefined;
    languageCode?: string | undefined;
}

export class MailRecipient implements IMailRecipient {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMailRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userEmail = data.userEmail && !(<any>data.userEmail).toJSON ? new UserEmail(data.userEmail) : <UserEmail>this.userEmail; 
        }
    }

    init(data?: any) {
        if (data) {
            this.userEmail = data["userEmail"] ? UserEmail.fromJS(data["userEmail"]) : <any>undefined;
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MailRecipient {
        let result = new MailRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail ? this.userEmail.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMailRecipient {
    userEmail?: IUserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class UserEmail implements IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UserEmail {
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class InternalRecipient implements IInternalRecipient {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;

    constructor(data?: IInternalRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.recipient = data.recipient && !(<any>data.recipient).toJSON ? new UserItem(data.recipient) : <UserItem>this.recipient; 
        }
    }

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"] ? UserItem.fromJS(data["recipient"]) : <any>undefined;
            this.token = data["token"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): InternalRecipient {
        let result = new InternalRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data; 
    }
}

export interface IInternalRecipient {
    recipient?: IUserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export class UserItem implements IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUserItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UserItem {
        let result = new UserItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export abstract class TemplateBase implements ITemplateBase {
    width?: number | undefined;
    height?: number | undefined;

    protected _discriminator: string;

    constructor(data?: ITemplateBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "TemplateBase";
    }

    init(data?: any) {
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): TemplateBase {
        if (data["kind"] === "CardTemplate") {
            let result = new CardTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListTemplate") {
            let result = new ListTemplate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BasicTemplate") {
            let result = new BasicTemplate();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TemplateBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ITemplateBase {
    width?: number | undefined;
    height?: number | undefined;
}

export class CardTemplate extends TemplateBase implements ICardTemplate {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;

    constructor(data?: ICardTemplate) {
        super(data);
        this._discriminator = "CardTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.showNavigation = data["showNavigation"];
            this.showOverlay = data["showOverlay"];
            this.showLogo = data["showLogo"];
            this.showFooter = data["showFooter"];
        }
    }

    static fromJS(data: any): CardTemplate {
        let result = new CardTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showNavigation"] = this.showNavigation;
        data["showOverlay"] = this.showOverlay;
        data["showLogo"] = this.showLogo;
        data["showFooter"] = this.showFooter;
        super.toJSON(data);
        return data; 
    }
}

export interface ICardTemplate extends ITemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export class ListTemplate extends TemplateBase implements IListTemplate {

    constructor(data?: IListTemplate) {
        super(data);
        this._discriminator = "ListTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ListTemplate {
        let result = new ListTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IListTemplate extends ITemplateBase {
}

export class BasicTemplate extends TemplateBase implements IBasicTemplate {

    constructor(data?: IBasicTemplate) {
        super(data);
        this._discriminator = "BasicTemplate";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): BasicTemplate {
        let result = new BasicTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IBasicTemplate extends ITemplateBase {
}

export enum OutputAccess {
    Full = <any>"Full", 
    Preview = <any>"Preview", 
    None = <any>"None", 
}

export enum ShareType {
    Basic = <any>"Basic", 
    Embed = <any>"Embed", 
}

export class ShareNotFoundException extends PictureparkBusinessException implements IShareNotFoundException {
    shareId?: string | undefined;

    constructor(data?: IShareNotFoundException) {
        super(data);
        this._discriminator = "ShareNotFoundException";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.shareId = data["shareId"];
        }
    }

    static fromJS(data: any): ShareNotFoundException {
        let result = new ShareNotFoundException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareNotFoundException extends IPictureparkBusinessException {
    shareId?: string | undefined;
}

export class ShareSearchRequest implements IShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IShareSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): ShareSearchRequest {
        let result = new ShareSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export class BaseResultOfShare implements IBaseResultOfShare {
    totalResults: number;
    results?: Share[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Share(item) : <Share>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Share.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfShare {
        let result = new BaseResultOfShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfShare {
    totalResults: number;
    results?: IShare[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfShare extends BaseResultOfShare implements ISearchBehaviourBaseResultOfShare {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfShare) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfShare {
        let result = new SearchBehaviourBaseResultOfShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfShare extends IBaseResultOfShare {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class ShareSearchResult extends SearchBehaviourBaseResultOfShare implements IShareSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IShareSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): ShareSearchResult {
        let result = new ShareSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareSearchResult extends ISearchBehaviourBaseResultOfShare {
    elapsedMilliseconds: number;
}

export class Share implements IShare {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: UserAudit | undefined;
    expirationDate?: Date | undefined;
    shareType: ShareType;

    constructor(data?: IShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
            this.id = data["id"];
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.shareType = data["shareType"];
        }
    }

    static fromJS(data: any): Share {
        let result = new Share();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["id"] = this.id;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["shareType"] = this.shareType;
        return data; 
    }
}

export interface IShare {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: IUserAudit | undefined;
    expirationDate?: Date | undefined;
    shareType: ShareType;
}

export class ShareAggregationRequest implements IShareAggregationRequest {
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;

    constructor(data?: IShareAggregationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            if (data["aggregationFilters"] && data["aggregationFilters"].constructor === Array) {
                this.aggregationFilters = [];
                for (let item of data["aggregationFilters"])
                    this.aggregationFilters.push(AggregationFilter.fromJS(item));
            }
            if (data["aggregators"] && data["aggregators"].constructor === Array) {
                this.aggregators = [];
                for (let item of data["aggregators"])
                    this.aggregators.push(AggregatorBase.fromJS(item));
            }
            this.displayLanguage = data["displayLanguage"];
        }
    }

    static fromJS(data: any): ShareAggregationRequest {
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (this.aggregationFilters && this.aggregationFilters.constructor === Array) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (this.aggregators && this.aggregators.constructor === Array) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["displayLanguage"] = this.displayLanguage;
        return data; 
    }
}

export interface IShareAggregationRequest {
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;
}

export abstract class ShareBaseCreateRequest implements IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contents) {
                this.contents = [];
                for (let i = 0; i < data.contents.length; i++) {
                    let item = data.contents[i];
                    this.contents[i] = item && !(<any>item).toJSON ? new ShareContent(item) : <ShareContent>item;
                }
            }
        }
        this._discriminator = "ShareBaseCreateRequest";
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            if (data["contents"] && data["contents"].constructor === Array) {
                this.contents = [];
                for (let item of data["contents"])
                    this.contents.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseCreateRequest {
        if (data["kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseCreateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["name"] = this.name;
        data["description"] = this.description;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (this.contents && this.contents.constructor === Array) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: IShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export class ShareContent implements IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;

    constructor(data?: IShareContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentId = data["contentId"];
            if (data["outputFormatIds"] && data["outputFormatIds"].constructor === Array) {
                this.outputFormatIds = [];
                for (let item of data["outputFormatIds"])
                    this.outputFormatIds.push(item);
            }
        }
    }

    static fromJS(data: any): ShareContent {
        let result = new ShareContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (this.outputFormatIds && this.outputFormatIds.constructor === Array) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data; 
    }
}

export interface IShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRole[] | undefined;
    languageCode?: string | undefined;
    mailTemplateId?: string | undefined;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        this._discriminator = "ShareBasicCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["recipientsEmail"] && data["recipientsEmail"].constructor === Array) {
                this.recipientsEmail = [];
                for (let item of data["recipientsEmail"])
                    this.recipientsEmail.push(UserEmail.fromJS(item));
            }
            if (data["recipientsUser"] && data["recipientsUser"].constructor === Array) {
                this.recipientsUser = [];
                for (let item of data["recipientsUser"])
                    this.recipientsUser.push(UserItem.fromJS(item));
            }
            if (data["recipientsGroup"] && data["recipientsGroup"].constructor === Array) {
                this.recipientsGroup = [];
                for (let item of data["recipientsGroup"])
                    this.recipientsGroup.push(UserRole.fromJS(item));
            }
            this.languageCode = data["languageCode"];
            this.mailTemplateId = data["mailTemplateId"];
        }
    }

    static fromJS(data: any): ShareBasicCreateRequest {
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recipientsEmail && this.recipientsEmail.constructor === Array) {
            data["recipientsEmail"] = [];
            for (let item of this.recipientsEmail)
                data["recipientsEmail"].push(item.toJSON());
        }
        if (this.recipientsUser && this.recipientsUser.constructor === Array) {
            data["recipientsUser"] = [];
            for (let item of this.recipientsUser)
                data["recipientsUser"].push(item.toJSON());
        }
        if (this.recipientsGroup && this.recipientsGroup.constructor === Array) {
            data["recipientsGroup"] = [];
            for (let item of this.recipientsGroup)
                data["recipientsGroup"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        data["mailTemplateId"] = this.mailTemplateId;
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    recipientsEmail?: IUserEmail[] | undefined;
    recipientsUser?: IUserItem[] | undefined;
    recipientsGroup?: IUserRole[] | undefined;
    languageCode?: string | undefined;
    mailTemplateId?: string | undefined;
}

export class UserRole implements IUserRole {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.trashed = data["trashed"];
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["userRights"] && data["userRights"].constructor === Array) {
                this.userRights = [];
                for (let item of data["userRights"])
                    this.userRights.push(item);
            }
        }
    }

    static fromJS(data: any): UserRole {
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trashed"] = this.trashed;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.userRights && this.userRights.constructor === Array) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data; 
    }
}

export interface IUserRole {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;
}

export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);
        this._discriminator = "ShareEmbedCreateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedCreateRequest {
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

export class CreateShareResult implements ICreateShareResult {
    shareId?: string | undefined;

    constructor(data?: ICreateShareResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareId = data["shareId"];
        }
    }

    static fromJS(data: any): CreateShareResult {
        let result = new CreateShareResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        return data; 
    }
}

export interface ICreateShareResult {
    shareId?: string | undefined;
}

export abstract class ShareBaseUpdateRequest implements IShareBaseUpdateRequest {
    id?: string | undefined;
    name?: string | undefined;
    expirationDate?: Date | undefined;
    description?: string | undefined;
    shareContentItems?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.shareContentItems) {
                this.shareContentItems = [];
                for (let i = 0; i < data.shareContentItems.length; i++) {
                    let item = data.shareContentItems[i];
                    this.shareContentItems[i] = item && !(<any>item).toJSON ? new ShareContent(item) : <ShareContent>item;
                }
            }
        }
        this._discriminator = "ShareBaseUpdateRequest";
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.description = data["description"];
            if (data["shareContentItems"] && data["shareContentItems"].constructor === Array) {
                this.shareContentItems = [];
                for (let item of data["shareContentItems"])
                    this.shareContentItems.push(ShareContent.fromJS(item));
            }
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.template = data["template"] ? TemplateBase.fromJS(data["template"]) : <any>undefined;
            this.outputAccess = data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseUpdateRequest {
        if (data["kind"] === "ShareBasicUpdateRequest") {
            let result = new ShareBasicUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedUpdateRequest") {
            let result = new ShareEmbedUpdateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseUpdateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["id"] = this.id;
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (this.shareContentItems && this.shareContentItems.constructor === Array) {
            data["shareContentItems"] = [];
            for (let item of this.shareContentItems)
                data["shareContentItems"].push(item.toJSON());
        }
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["outputAccess"] = this.outputAccess;
        return data; 
    }
}

export interface IShareBaseUpdateRequest {
    id?: string | undefined;
    name?: string | undefined;
    expirationDate?: Date | undefined;
    description?: string | undefined;
    shareContentItems?: IShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export class ShareBasicUpdateRequest extends ShareBaseUpdateRequest implements IShareBasicUpdateRequest {

    constructor(data?: IShareBasicUpdateRequest) {
        super(data);
        this._discriminator = "ShareBasicUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareBasicUpdateRequest {
        let result = new ShareBasicUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareBasicUpdateRequest extends IShareBaseUpdateRequest {
}

export class ShareEmbedUpdateRequest extends ShareBaseUpdateRequest implements IShareEmbedUpdateRequest {

    constructor(data?: IShareEmbedUpdateRequest) {
        super(data);
        this._discriminator = "ShareEmbedUpdateRequest";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ShareEmbedUpdateRequest {
        let result = new ShareEmbedUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IShareEmbedUpdateRequest extends IShareBaseUpdateRequest {
}

export class CustomerServiceProviderConfiguration implements ICustomerServiceProviderConfiguration {
    serviceProviderId?: string | undefined;
    customerId?: string | undefined;
    userRoleIds?: string[] | undefined;
    settings?: string | undefined;

    constructor(data?: ICustomerServiceProviderConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.customerId = data["customerId"];
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.settings = data["settings"];
        }
    }

    static fromJS(data: any): CustomerServiceProviderConfiguration {
        let result = new CustomerServiceProviderConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["customerId"] = this.customerId;
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["settings"] = this.settings;
        return data; 
    }
}

export interface ICustomerServiceProviderConfiguration {
    serviceProviderId?: string | undefined;
    customerId?: string | undefined;
    userRoleIds?: string[] | undefined;
    settings?: string | undefined;
}

export class ServiceProviderConfigurationUpdateRequest implements IServiceProviderConfigurationUpdateRequest {
    customerId?: string | undefined;
    serviceProviderId?: string | undefined;
    settings?: string | undefined;
    userRoleIds?: string[] | undefined;

    constructor(data?: IServiceProviderConfigurationUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.serviceProviderId = data["serviceProviderId"];
            this.settings = data["settings"];
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
        }
    }

    static fromJS(data: any): ServiceProviderConfigurationUpdateRequest {
        let result = new ServiceProviderConfigurationUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["serviceProviderId"] = this.serviceProviderId;
        data["settings"] = this.settings;
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        return data; 
    }
}

export interface IServiceProviderConfigurationUpdateRequest {
    customerId?: string | undefined;
    serviceProviderId?: string | undefined;
    settings?: string | undefined;
    userRoleIds?: string[] | undefined;
}

export class TransferDetail implements ITransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: UserAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;
    collectionId?: string | undefined;

    constructor(data?: ITransferDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rev = data["rev"];
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.name = data["name"];
            this.state = data["state"];
            this.businessProcessId = data["businessProcessId"];
            this.transferType = data["transferType"];
            this.itemProgress = data["itemProgress"];
            this.itemCount = data["itemCount"];
            this.itemsFailed = data["itemsFailed"];
            this.itemsCancelled = data["itemsCancelled"];
            this.lastProgressStamp = data["lastProgressStamp"];
            this.fileTransferCount = data["fileTransferCount"];
            this.collectionId = data["collectionId"];
        }
    }

    static fromJS(data: any): TransferDetail {
        let result = new TransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rev"] = this.rev;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["state"] = this.state;
        data["businessProcessId"] = this.businessProcessId;
        data["transferType"] = this.transferType;
        data["itemProgress"] = this.itemProgress;
        data["itemCount"] = this.itemCount;
        data["itemsFailed"] = this.itemsFailed;
        data["itemsCancelled"] = this.itemsCancelled;
        data["lastProgressStamp"] = this.lastProgressStamp;
        data["fileTransferCount"] = this.fileTransferCount;
        data["collectionId"] = this.collectionId;
        return data; 
    }
}

export interface ITransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: IUserAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;
    collectionId?: string | undefined;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    FileUploadAutoImport = <any>"FileUploadAutoImport", 
    DriveImport = <any>"DriveImport", 
    DriveExport = <any>"DriveExport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export class TransferSearchRequest implements ITransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: ITransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransferSearchRequest {
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfTransfer implements IBaseResultOfTransfer {
    totalResults: number;
    results?: Transfer[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Transfer(item) : <Transfer>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(Transfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfTransfer {
        let result = new BaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfTransfer {
    totalResults: number;
    results?: ITransfer[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfTransfer extends BaseResultOfTransfer implements ISearchBehaviourBaseResultOfTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfTransfer) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfTransfer {
        let result = new SearchBehaviourBaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfTransfer extends IBaseResultOfTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class TransferSearchResult extends SearchBehaviourBaseResultOfTransfer implements ITransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: ITransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): TransferSearchResult {
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferSearchResult extends ISearchBehaviourBaseResultOfTransfer {
    elapsedMilliseconds: number;
}

export class Transfer implements ITransfer {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;
    collectionId?: string | undefined;

    constructor(data?: ITransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.state = data["state"];
            this.transferType = data["transferType"];
            this.businessProcessId = data["businessProcessId"];
            this.fileTransferCount = data["fileTransferCount"];
            this.collectionId = data["collectionId"];
        }
    }

    static fromJS(data: any): Transfer {
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["transferType"] = this.transferType;
        data["businessProcessId"] = this.businessProcessId;
        data["fileTransferCount"] = this.fileTransferCount;
        data["collectionId"] = this.collectionId;
        return data; 
    }
}

export interface ITransfer {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;
    collectionId?: string | undefined;
}

export class CreateTransferRequest implements ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;

    constructor(data?: ICreateTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.files) {
                this.files = [];
                for (let i = 0; i < data.files.length; i++) {
                    let item = data.files[i];
                    this.files[i] = item && !(<any>item).toJSON ? new TransferUploadFile(item) : <TransferUploadFile>item;
                }
            }
            if (data.driveFiles) {
                this.driveFiles = [];
                for (let i = 0; i < data.driveFiles.length; i++) {
                    let item = data.driveFiles[i];
                    this.driveFiles[i] = item && !(<any>item).toJSON ? new TransferDriveFile(item) : <TransferDriveFile>item;
                }
            }
            if (data.webLinks) {
                this.webLinks = [];
                for (let i = 0; i < data.webLinks.length; i++) {
                    let item = data.webLinks[i];
                    this.webLinks[i] = item && !(<any>item).toJSON ? new TransferWebLink(item) : <TransferWebLink>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.transferType = data["transferType"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(TransferUploadFile.fromJS(item));
            }
            if (data["driveFiles"] && data["driveFiles"].constructor === Array) {
                this.driveFiles = [];
                for (let item of data["driveFiles"])
                    this.driveFiles.push(TransferDriveFile.fromJS(item));
            }
            if (data["webLinks"] && data["webLinks"].constructor === Array) {
                this.webLinks = [];
                for (let item of data["webLinks"])
                    this.webLinks.push(TransferWebLink.fromJS(item));
            }
            this.collectionName = data["collectionName"];
            this.createCollection = data["createCollection"];
        }
    }

    static fromJS(data: any): CreateTransferRequest {
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["transferType"] = this.transferType;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (this.driveFiles && this.driveFiles.constructor === Array) {
            data["driveFiles"] = [];
            for (let item of this.driveFiles)
                data["driveFiles"].push(item.toJSON());
        }
        if (this.webLinks && this.webLinks.constructor === Array) {
            data["webLinks"] = [];
            for (let item of this.webLinks)
                data["webLinks"].push(item.toJSON());
        }
        data["collectionName"] = this.collectionName;
        data["createCollection"] = this.createCollection;
        return data; 
    }
}

export interface ICreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: ITransferUploadFile[] | undefined;
    driveFiles?: ITransferDriveFile[] | undefined;
    webLinks?: ITransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;
}

export abstract class TransferFile implements ITransferFile {
    identifier?: string | undefined;

    constructor(data?: ITransferFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.identifier = data["identifier"];
        }
    }

    static fromJS(data: any): TransferFile {
        throw new Error("The abstract class 'TransferFile' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        return data; 
    }
}

export interface ITransferFile {
    identifier?: string | undefined;
}

export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    fileName?: string | undefined;

    constructor(data?: ITransferUploadFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): TransferUploadFile {
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferUploadFile extends ITransferFile {
    fileName?: string | undefined;
}

export class TransferDriveFile extends TransferFile implements ITransferDriveFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;

    constructor(data?: ITransferDriveFile) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.driveId = data["driveId"];
            this.fileId = data["fileId"];
            this.name = data["name"];
            this.externalOutputFolderId = data["externalOutputFolderId"];
        }
    }

    static fromJS(data: any): TransferDriveFile {
        let result = new TransferDriveFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driveId"] = this.driveId;
        data["fileId"] = this.fileId;
        data["name"] = this.name;
        data["externalOutputFolderId"] = this.externalOutputFolderId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferDriveFile extends ITransferFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;
}

export class TransferWebLink extends TransferFile implements ITransferWebLink {
    url?: string | undefined;

    constructor(data?: ITransferWebLink) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): TransferWebLink {
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferWebLink extends ITransferFile {
    url?: string | undefined;
}

export class FileTransferDetail implements IFileTransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: UserAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;

    constructor(data?: IFileTransferDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit; 
            this.driveMetadata = data.driveMetadata && !(<any>data.driveMetadata).toJSON ? new DriveMetadata(data.driveMetadata) : <DriveMetadata>this.driveMetadata; 
            if (data.outputItems) {
                this.outputItems = [];
                for (let i = 0; i < data.outputItems.length; i++) {
                    let item = data.outputItems[i];
                    this.outputItems[i] = item && !(<any>item).toJSON ? new OutputItem(item) : <OutputItem>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.rev = data["rev"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.audit = data["audit"] ? UserAudit.fromJS(data["audit"]) : <any>undefined;
            this.transferId = data["transferId"];
            this.state = data["state"];
            this.fileMetadata = data["fileMetadata"] ? FileMetadata.fromJS(data["fileMetadata"]) : <any>undefined;
            this.driveMetadata = data["driveMetadata"] ? DriveMetadata.fromJS(data["driveMetadata"]) : <any>undefined;
            if (data["outputItems"] && data["outputItems"].constructor === Array) {
                this.outputItems = [];
                for (let item of data["outputItems"])
                    this.outputItems.push(OutputItem.fromJS(item));
            }
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): FileTransferDetail {
        let result = new FileTransferDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rev"] = this.rev;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["fileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>undefined;
        data["driveMetadata"] = this.driveMetadata ? this.driveMetadata.toJSON() : <any>undefined;
        if (this.outputItems && this.outputItems.constructor === Array) {
            data["outputItems"] = [];
            for (let item of this.outputItems)
                data["outputItems"].push(item.toJSON());
        }
        data["contentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: IUserAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: IDriveMetadata | undefined;
    outputItems?: IOutputItem[] | undefined;
    contentId?: string | undefined;
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

export class FileMetadata implements IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IFileMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions; 
            this.xmpMetadata = data.xmpMetadata && !(<any>data.xmpMetadata).toJSON ? new XmpMetadata(data.xmpMetadata) : <XmpMetadata>this.xmpMetadata; 
            this.exifMetadata = data.exifMetadata && !(<any>data.exifMetadata).toJSON ? new ExifMetadata(data.exifMetadata) : <ExifMetadata>this.exifMetadata; 
        }
        this._discriminator = "FileMetadata";
    }

    init(data?: any) {
        if (data) {
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            this.descriptions = data["descriptions"] ? TranslatedStringDictionary.fromJS(data["descriptions"]) : <any>undefined;
            this.fileExtension = data["fileExtension"];
            this.fileName = data["fileName"];
            this.filePath = data["filePath"];
            this.fileSizeInBytes = data["fileSizeInBytes"];
            this.sha1Hash = data["sha1Hash"];
            this.xmpMetadata = data["xmpMetadata"] ? XmpMetadata.fromJS(data["xmpMetadata"]) : <any>undefined;
            this.exifMetadata = data["exifMetadata"] ? ExifMetadata.fromJS(data["exifMetadata"]) : <any>undefined;
            this.language = data["language"];
        }
    }

    static fromJS(data: any): FileMetadata {
        if (data["kind"] === "AudioMetadata") {
            let result = new AudioMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentMetadata") {
            let result = new DocumentMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageMetadata") {
            let result = new ImageMetadata();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoMetadata") {
            let result = new VideoMetadata();
            result.init(data);
            return result;
        }
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator; 
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        data["xmpMetadata"] = this.xmpMetadata ? this.xmpMetadata.toJSON() : <any>undefined;
        data["exifMetadata"] = this.exifMetadata ? this.exifMetadata.toJSON() : <any>undefined;
        data["language"] = this.language;
        return data; 
    }
}

export interface IFileMetadata {
    names?: ITranslatedStringDictionary | undefined;
    descriptions?: ITranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: IXmpMetadata | undefined;
    exifMetadata?: IExifMetadata | undefined;
    language?: string | undefined;
}

export class XmpMetadata implements IXmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;

    constructor(data?: IXmpMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.dc = data.dc && !(<any>data.dc).toJSON ? new Dc(data.dc) : <Dc>this.dc; 
            this.crs = data.crs && !(<any>data.crs).toJSON ? new Crs(data.crs) : <Crs>this.crs; 
            this.iptcCore = data.iptcCore && !(<any>data.iptcCore).toJSON ? new IptcCore(data.iptcCore) : <IptcCore>this.iptcCore; 
            this.iptcExt = data.iptcExt && !(<any>data.iptcExt).toJSON ? new IptcExt(data.iptcExt) : <IptcExt>this.iptcExt; 
            this.iptcIIM = data.iptcIIM && !(<any>data.iptcIIM).toJSON ? new IptcIIM(data.iptcIIM) : <IptcIIM>this.iptcIIM; 
            this.lr = data.lr && !(<any>data.lr).toJSON ? new Lr(data.lr) : <Lr>this.lr; 
            this.pdf = data.pdf && !(<any>data.pdf).toJSON ? new Pdf(data.pdf) : <Pdf>this.pdf; 
            this.photoshop = data.photoshop && !(<any>data.photoshop).toJSON ? new Photoshop(data.photoshop) : <Photoshop>this.photoshop; 
            this.plus = data.plus && !(<any>data.plus).toJSON ? new Plus(data.plus) : <Plus>this.plus; 
            this.tiff = data.tiff && !(<any>data.tiff).toJSON ? new Tiff(data.tiff) : <Tiff>this.tiff; 
            this.xmp = data.xmp && !(<any>data.xmp).toJSON ? new Xmp(data.xmp) : <Xmp>this.xmp; 
            this.xmpBJ = data.xmpBJ && !(<any>data.xmpBJ).toJSON ? new XmpBJ(data.xmpBJ) : <XmpBJ>this.xmpBJ; 
            this.xmpDM = data.xmpDM && !(<any>data.xmpDM).toJSON ? new XmpDM(data.xmpDM) : <XmpDM>this.xmpDM; 
            this.xmpG = data.xmpG && !(<any>data.xmpG).toJSON ? new XmpG(data.xmpG) : <XmpG>this.xmpG; 
            this.xmpGImg = data.xmpGImg && !(<any>data.xmpGImg).toJSON ? new XmpGImg(data.xmpGImg) : <XmpGImg>this.xmpGImg; 
            this.xmpidq = data.xmpidq && !(<any>data.xmpidq).toJSON ? new Xmpidq(data.xmpidq) : <Xmpidq>this.xmpidq; 
            this.xmpMM = data.xmpMM && !(<any>data.xmpMM).toJSON ? new XmpMM(data.xmpMM) : <XmpMM>this.xmpMM; 
            this.xmpNote = data.xmpNote && !(<any>data.xmpNote).toJSON ? new XmpNote(data.xmpNote) : <XmpNote>this.xmpNote; 
            this.xmpRights = data.xmpRights && !(<any>data.xmpRights).toJSON ? new XmpRights(data.xmpRights) : <XmpRights>this.xmpRights; 
            this.xmpTPg = data.xmpTPg && !(<any>data.xmpTPg).toJSON ? new XmpTPg(data.xmpTPg) : <XmpTPg>this.xmpTPg; 
        }
    }

    init(data?: any) {
        if (data) {
            this.dc = data["dc"] ? Dc.fromJS(data["dc"]) : <any>undefined;
            this.crs = data["crs"] ? Crs.fromJS(data["crs"]) : <any>undefined;
            this.iptcCore = data["iptcCore"] ? IptcCore.fromJS(data["iptcCore"]) : <any>undefined;
            this.iptcExt = data["iptcExt"] ? IptcExt.fromJS(data["iptcExt"]) : <any>undefined;
            this.iptcIIM = data["iptcIIM"] ? IptcIIM.fromJS(data["iptcIIM"]) : <any>undefined;
            this.lr = data["lr"] ? Lr.fromJS(data["lr"]) : <any>undefined;
            this.pdf = data["pdf"] ? Pdf.fromJS(data["pdf"]) : <any>undefined;
            this.photoshop = data["photoshop"] ? Photoshop.fromJS(data["photoshop"]) : <any>undefined;
            this.plus = data["plus"] ? Plus.fromJS(data["plus"]) : <any>undefined;
            this.tiff = data["tiff"] ? Tiff.fromJS(data["tiff"]) : <any>undefined;
            this.xmp = data["xmp"] ? Xmp.fromJS(data["xmp"]) : <any>undefined;
            this.xmpBJ = data["xmpBJ"] ? XmpBJ.fromJS(data["xmpBJ"]) : <any>undefined;
            this.xmpDM = data["xmpDM"] ? XmpDM.fromJS(data["xmpDM"]) : <any>undefined;
            this.xmpG = data["xmpG"] ? XmpG.fromJS(data["xmpG"]) : <any>undefined;
            this.xmpGImg = data["xmpGImg"] ? XmpGImg.fromJS(data["xmpGImg"]) : <any>undefined;
            this.xmpidq = data["xmpidq"] ? Xmpidq.fromJS(data["xmpidq"]) : <any>undefined;
            this.xmpMM = data["xmpMM"] ? XmpMM.fromJS(data["xmpMM"]) : <any>undefined;
            this.xmpNote = data["xmpNote"] ? XmpNote.fromJS(data["xmpNote"]) : <any>undefined;
            this.xmpRights = data["xmpRights"] ? XmpRights.fromJS(data["xmpRights"]) : <any>undefined;
            this.xmpTPg = data["xmpTPg"] ? XmpTPg.fromJS(data["xmpTPg"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XmpMetadata {
        let result = new XmpMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dc"] = this.dc ? this.dc.toJSON() : <any>undefined;
        data["crs"] = this.crs ? this.crs.toJSON() : <any>undefined;
        data["iptcCore"] = this.iptcCore ? this.iptcCore.toJSON() : <any>undefined;
        data["iptcExt"] = this.iptcExt ? this.iptcExt.toJSON() : <any>undefined;
        data["iptcIIM"] = this.iptcIIM ? this.iptcIIM.toJSON() : <any>undefined;
        data["lr"] = this.lr ? this.lr.toJSON() : <any>undefined;
        data["pdf"] = this.pdf ? this.pdf.toJSON() : <any>undefined;
        data["photoshop"] = this.photoshop ? this.photoshop.toJSON() : <any>undefined;
        data["plus"] = this.plus ? this.plus.toJSON() : <any>undefined;
        data["tiff"] = this.tiff ? this.tiff.toJSON() : <any>undefined;
        data["xmp"] = this.xmp ? this.xmp.toJSON() : <any>undefined;
        data["xmpBJ"] = this.xmpBJ ? this.xmpBJ.toJSON() : <any>undefined;
        data["xmpDM"] = this.xmpDM ? this.xmpDM.toJSON() : <any>undefined;
        data["xmpG"] = this.xmpG ? this.xmpG.toJSON() : <any>undefined;
        data["xmpGImg"] = this.xmpGImg ? this.xmpGImg.toJSON() : <any>undefined;
        data["xmpidq"] = this.xmpidq ? this.xmpidq.toJSON() : <any>undefined;
        data["xmpMM"] = this.xmpMM ? this.xmpMM.toJSON() : <any>undefined;
        data["xmpNote"] = this.xmpNote ? this.xmpNote.toJSON() : <any>undefined;
        data["xmpRights"] = this.xmpRights ? this.xmpRights.toJSON() : <any>undefined;
        data["xmpTPg"] = this.xmpTPg ? this.xmpTPg.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IXmpMetadata {
    dc?: IDc | undefined;
    crs?: ICrs | undefined;
    iptcCore?: IIptcCore | undefined;
    iptcExt?: IIptcExt | undefined;
    iptcIIM?: IIptcIIM | undefined;
    lr?: ILr | undefined;
    pdf?: IPdf | undefined;
    photoshop?: IPhotoshop | undefined;
    plus?: IPlus | undefined;
    tiff?: ITiff | undefined;
    xmp?: IXmp | undefined;
    xmpBJ?: IXmpBJ | undefined;
    xmpDM?: IXmpDM | undefined;
    xmpG?: IXmpG | undefined;
    xmpGImg?: IXmpGImg | undefined;
    xmpidq?: IXmpidq | undefined;
    xmpMM?: IXmpMM | undefined;
    xmpNote?: IXmpNote | undefined;
    xmpRights?: IXmpRights | undefined;
    xmpTPg?: IXmpTPg | undefined;
}

export class Dc implements IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;

    constructor(data?: IDc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contributor"] && data["contributor"].constructor === Array) {
                this.contributor = [];
                for (let item of data["contributor"])
                    this.contributor.push(item);
            }
            this.coverage = data["coverage"];
            if (data["creator"] && data["creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["creator"])
                    this.creator.push(item);
            }
            if (data["date"] && data["date"].constructor === Array) {
                this.date = [];
                for (let item of data["date"])
                    this.date.push(new Date(item));
            }
            if (data["description"]) {
                this.description = {};
                for (let key in data["description"]) {
                    if (data["description"].hasOwnProperty(key))
                        this.description[key] = data["description"][key];
                }
            }
            this.format = data["format"];
            this.identifier = data["identifier"];
            if (data["language"] && data["language"].constructor === Array) {
                this.language = [];
                for (let item of data["language"])
                    this.language.push(item);
            }
            if (data["publisher"] && data["publisher"].constructor === Array) {
                this.publisher = [];
                for (let item of data["publisher"])
                    this.publisher.push(item);
            }
            if (data["relation"] && data["relation"].constructor === Array) {
                this.relation = [];
                for (let item of data["relation"])
                    this.relation.push(item);
            }
            if (data["rights"]) {
                this.rights = {};
                for (let key in data["rights"]) {
                    if (data["rights"].hasOwnProperty(key))
                        this.rights[key] = data["rights"][key];
                }
            }
            this.source = data["source"];
            if (data["subject"] && data["subject"].constructor === Array) {
                this.subject = [];
                for (let item of data["subject"])
                    this.subject.push(item);
            }
            if (data["title"]) {
                this.title = {};
                for (let key in data["title"]) {
                    if (data["title"].hasOwnProperty(key))
                        this.title[key] = data["title"][key];
                }
            }
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Dc {
        let result = new Dc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contributor && this.contributor.constructor === Array) {
            data["contributor"] = [];
            for (let item of this.contributor)
                data["contributor"].push(item);
        }
        data["coverage"] = this.coverage;
        if (this.creator && this.creator.constructor === Array) {
            data["creator"] = [];
            for (let item of this.creator)
                data["creator"].push(item);
        }
        if (this.date && this.date.constructor === Array) {
            data["date"] = [];
            for (let item of this.date)
                data["date"].push(item.toISOString());
        }
        if (this.description) {
            data["description"] = {};
            for (let key in this.description) {
                if (this.description.hasOwnProperty(key))
                    data["description"][key] = this.description[key];
            }
        }
        data["format"] = this.format;
        data["identifier"] = this.identifier;
        if (this.language && this.language.constructor === Array) {
            data["language"] = [];
            for (let item of this.language)
                data["language"].push(item);
        }
        if (this.publisher && this.publisher.constructor === Array) {
            data["publisher"] = [];
            for (let item of this.publisher)
                data["publisher"].push(item);
        }
        if (this.relation && this.relation.constructor === Array) {
            data["relation"] = [];
            for (let item of this.relation)
                data["relation"].push(item);
        }
        if (this.rights) {
            data["rights"] = {};
            for (let key in this.rights) {
                if (this.rights.hasOwnProperty(key))
                    data["rights"][key] = this.rights[key];
            }
        }
        data["source"] = this.source;
        if (this.subject && this.subject.constructor === Array) {
            data["subject"] = [];
            for (let item of this.subject)
                data["subject"].push(item);
        }
        if (this.title) {
            data["title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["title"][key] = this.title[key];
            }
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IDc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;
}

export class Crs implements ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;

    constructor(data?: ICrs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoBrightness = data["autoBrightness"];
            this.autoContrast = data["autoContrast"];
            this.autoExposure = data["autoExposure"];
            this.autoShadows = data["autoShadows"];
            this.blueHue = data["blueHue"];
            this.blueSaturation = data["blueSaturation"];
            this.brightness = data["brightness"];
            this.cameraProfile = data["cameraProfile"];
            this.chromaticAberrationB = data["chromaticAberrationB"];
            this.chromaticAberrationR = data["chromaticAberrationR"];
            this.colorNoiseReduction = data["colorNoiseReduction"];
            this.contrast = data["contrast"];
            this.cropTop = data["cropTop"];
            this.cropLeft = data["cropLeft"];
            this.cropBottom = data["cropBottom"];
            this.cropRight = data["cropRight"];
            this.cropAngle = data["cropAngle"];
            this.cropWidth = data["cropWidth"];
            this.cropHeight = data["cropHeight"];
            this.cropUnits = data["cropUnits"];
            this.exposure = data["exposure"];
            this.greenHue = data["greenHue"];
            this.greenSaturation = data["greenSaturation"];
            this.hasCrop = data["hasCrop"];
            this.hasSettings = data["hasSettings"];
            this.luminanceSmoothing = data["luminanceSmoothing"];
            this.rawFileName = data["rawFileName"];
            this.redHue = data["redHue"];
            this.redSaturation = data["redSaturation"];
            this.saturation = data["saturation"];
            this.shadows = data["shadows"];
            this.shadowTint = data["shadowTint"];
            this.sharpness = data["sharpness"];
            this.temperature = data["temperature"];
            this.tint = data["tint"];
            if (data["toneCurve"] && data["toneCurve"].constructor === Array) {
                this.toneCurve = [];
                for (let item of data["toneCurve"])
                    this.toneCurve.push(item);
            }
            this.toneCurveName = data["toneCurveName"];
            this.version = data["version"];
            this.vignetteAmount = data["vignetteAmount"];
            this.vignetteMidpoint = data["vignetteMidpoint"];
            this.whiteBalance = data["whiteBalance"];
        }
    }

    static fromJS(data: any): Crs {
        let result = new Crs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoBrightness"] = this.autoBrightness;
        data["autoContrast"] = this.autoContrast;
        data["autoExposure"] = this.autoExposure;
        data["autoShadows"] = this.autoShadows;
        data["blueHue"] = this.blueHue;
        data["blueSaturation"] = this.blueSaturation;
        data["brightness"] = this.brightness;
        data["cameraProfile"] = this.cameraProfile;
        data["chromaticAberrationB"] = this.chromaticAberrationB;
        data["chromaticAberrationR"] = this.chromaticAberrationR;
        data["colorNoiseReduction"] = this.colorNoiseReduction;
        data["contrast"] = this.contrast;
        data["cropTop"] = this.cropTop;
        data["cropLeft"] = this.cropLeft;
        data["cropBottom"] = this.cropBottom;
        data["cropRight"] = this.cropRight;
        data["cropAngle"] = this.cropAngle;
        data["cropWidth"] = this.cropWidth;
        data["cropHeight"] = this.cropHeight;
        data["cropUnits"] = this.cropUnits;
        data["exposure"] = this.exposure;
        data["greenHue"] = this.greenHue;
        data["greenSaturation"] = this.greenSaturation;
        data["hasCrop"] = this.hasCrop;
        data["hasSettings"] = this.hasSettings;
        data["luminanceSmoothing"] = this.luminanceSmoothing;
        data["rawFileName"] = this.rawFileName;
        data["redHue"] = this.redHue;
        data["redSaturation"] = this.redSaturation;
        data["saturation"] = this.saturation;
        data["shadows"] = this.shadows;
        data["shadowTint"] = this.shadowTint;
        data["sharpness"] = this.sharpness;
        data["temperature"] = this.temperature;
        data["tint"] = this.tint;
        if (this.toneCurve && this.toneCurve.constructor === Array) {
            data["toneCurve"] = [];
            for (let item of this.toneCurve)
                data["toneCurve"].push(item);
        }
        data["toneCurveName"] = this.toneCurveName;
        data["version"] = this.version;
        data["vignetteAmount"] = this.vignetteAmount;
        data["vignetteMidpoint"] = this.vignetteMidpoint;
        data["whiteBalance"] = this.whiteBalance;
        return data; 
    }
}

export interface ICrs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;
}

/** Corresponds to crs.CropUnitsChoice */
export enum CropUnit {
    Pixels = <any>"Pixels", 
    Inches = <any>"Inches", 
    Centimeters = <any>"Centimeters", 
}

/** Corresponds to crs.ToneCurveNameChoice */
export enum ToneCurve {
    Linear = <any>"Linear", 
    MediumContrast = <any>"MediumContrast", 
    StrongContrast = <any>"StrongContrast", 
    Custom = <any>"Custom", 
}

/** Corresponds to crs.WhiteBalanceChoice */
export enum WhiteBalance {
    AsShot = <any>"AsShot", 
    Auto = <any>"Auto", 
    Daylight = <any>"Daylight", 
    Cloudy = <any>"Cloudy", 
    Shade = <any>"Shade", 
    Tungsten = <any>"Tungsten", 
    Fluorescent = <any>"Fluorescent", 
    Flash = <any>"Flash", 
    Custom = <any>"Custom", 
}

export class IptcCore implements IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;

    constructor(data?: IIptcCore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.creatorContactInfo = data.creatorContactInfo && !(<any>data.creatorContactInfo).toJSON ? new CreatorContactInfo(data.creatorContactInfo) : <CreatorContactInfo>this.creatorContactInfo; 
        }
    }

    init(data?: any) {
        if (data) {
            this.countryCode = data["countryCode"];
            this.intellectualGenre = data["intellectualGenre"];
            if (data["scene"] && data["scene"].constructor === Array) {
                this.scene = [];
                for (let item of data["scene"])
                    this.scene.push(item);
            }
            if (data["subjectCode"] && data["subjectCode"].constructor === Array) {
                this.subjectCode = [];
                for (let item of data["subjectCode"])
                    this.subjectCode.push(item);
            }
            this.location = data["location"];
            this.creatorContactInfo = data["creatorContactInfo"] ? CreatorContactInfo.fromJS(data["creatorContactInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IptcCore {
        let result = new IptcCore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["intellectualGenre"] = this.intellectualGenre;
        if (this.scene && this.scene.constructor === Array) {
            data["scene"] = [];
            for (let item of this.scene)
                data["scene"].push(item);
        }
        if (this.subjectCode && this.subjectCode.constructor === Array) {
            data["subjectCode"] = [];
            for (let item of this.subjectCode)
                data["subjectCode"].push(item);
        }
        data["location"] = this.location;
        data["creatorContactInfo"] = this.creatorContactInfo ? this.creatorContactInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: ICreatorContactInfo | undefined;
}

export class CreatorContactInfo implements ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreatorContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"];
            this.city = data["city"];
            this.country = data["country"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.postalCode = data["postalCode"];
            this.region = data["region"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CreatorContactInfo {
        let result = new CreatorContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["country"] = this.country;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["postalCode"] = this.postalCode;
        data["region"] = this.region;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    url?: string | undefined;
}

export class IptcExt implements IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;

    constructor(data?: IIptcExt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.artworkOrObject) {
                this.artworkOrObject = [];
                for (let i = 0; i < data.artworkOrObject.length; i++) {
                    let item = data.artworkOrObject[i];
                    this.artworkOrObject[i] = item && !(<any>item).toJSON ? new ArtworkOrObjectInfo(item) : <ArtworkOrObjectInfo>item;
                }
            }
            if (data.locationShown) {
                this.locationShown = [];
                for (let i = 0; i < data.locationShown.length; i++) {
                    let item = data.locationShown[i];
                    this.locationShown[i] = item && !(<any>item).toJSON ? new LocationInfo(item) : <LocationInfo>item;
                }
            }
            if (data.imageRegistryEntry) {
                this.imageRegistryEntry = [];
                for (let i = 0; i < data.imageRegistryEntry.length; i++) {
                    let item = data.imageRegistryEntry[i];
                    this.imageRegistryEntry[i] = item && !(<any>item).toJSON ? new RegistryEntryInfo(item) : <RegistryEntryInfo>item;
                }
            }
            if (data.locationCreated) {
                this.locationCreated = [];
                for (let i = 0; i < data.locationCreated.length; i++) {
                    let item = data.locationCreated[i];
                    this.locationCreated[i] = item && !(<any>item).toJSON ? new LocationInfo(item) : <LocationInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additionalModelInformation = data["additionalModelInformation"];
            if (data["artworkOrObject"] && data["artworkOrObject"].constructor === Array) {
                this.artworkOrObject = [];
                for (let item of data["artworkOrObject"])
                    this.artworkOrObject.push(ArtworkOrObjectInfo.fromJS(item));
            }
            if (data["organisationInImageCode"] && data["organisationInImageCode"].constructor === Array) {
                this.organisationInImageCode = [];
                for (let item of data["organisationInImageCode"])
                    this.organisationInImageCode.push(item);
            }
            if (data["controlledVocabularyTerm"] && data["controlledVocabularyTerm"].constructor === Array) {
                this.controlledVocabularyTerm = [];
                for (let item of data["controlledVocabularyTerm"])
                    this.controlledVocabularyTerm.push(item);
            }
            if (data["locationShown"] && data["locationShown"].constructor === Array) {
                this.locationShown = [];
                for (let item of data["locationShown"])
                    this.locationShown.push(LocationInfo.fromJS(item));
            }
            if (data["modelAge"] && data["modelAge"].constructor === Array) {
                this.modelAge = [];
                for (let item of data["modelAge"])
                    this.modelAge.push(item);
            }
            if (data["organisationInImageName"] && data["organisationInImageName"].constructor === Array) {
                this.organisationInImageName = [];
                for (let item of data["organisationInImageName"])
                    this.organisationInImageName.push(item);
            }
            if (data["personInImage"] && data["personInImage"].constructor === Array) {
                this.personInImage = [];
                for (let item of data["personInImage"])
                    this.personInImage.push(item);
            }
            this.digitalImageGUID = data["digitalImageGUID"];
            this.digitalSourceType = data["digitalSourceType"];
            if (data["event"]) {
                this.event = {};
                for (let key in data["event"]) {
                    if (data["event"].hasOwnProperty(key))
                        this.event[key] = data["event"][key];
                }
            }
            if (data["imageRegistryEntry"] && data["imageRegistryEntry"].constructor === Array) {
                this.imageRegistryEntry = [];
                for (let item of data["imageRegistryEntry"])
                    this.imageRegistryEntry.push(RegistryEntryInfo.fromJS(item));
            }
            this.metadataLastEdited = data["metadataLastEdited"] ? new Date(data["metadataLastEdited"].toString()) : <any>undefined;
            if (data["locationCreated"] && data["locationCreated"].constructor === Array) {
                this.locationCreated = [];
                for (let item of data["locationCreated"])
                    this.locationCreated.push(LocationInfo.fromJS(item));
            }
            this.maxAvailHeight = data["maxAvailHeight"];
            this.maxAvailWidth = data["maxAvailWidth"];
        }
    }

    static fromJS(data: any): IptcExt {
        let result = new IptcExt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalModelInformation"] = this.additionalModelInformation;
        if (this.artworkOrObject && this.artworkOrObject.constructor === Array) {
            data["artworkOrObject"] = [];
            for (let item of this.artworkOrObject)
                data["artworkOrObject"].push(item.toJSON());
        }
        if (this.organisationInImageCode && this.organisationInImageCode.constructor === Array) {
            data["organisationInImageCode"] = [];
            for (let item of this.organisationInImageCode)
                data["organisationInImageCode"].push(item);
        }
        if (this.controlledVocabularyTerm && this.controlledVocabularyTerm.constructor === Array) {
            data["controlledVocabularyTerm"] = [];
            for (let item of this.controlledVocabularyTerm)
                data["controlledVocabularyTerm"].push(item);
        }
        if (this.locationShown && this.locationShown.constructor === Array) {
            data["locationShown"] = [];
            for (let item of this.locationShown)
                data["locationShown"].push(item.toJSON());
        }
        if (this.modelAge && this.modelAge.constructor === Array) {
            data["modelAge"] = [];
            for (let item of this.modelAge)
                data["modelAge"].push(item);
        }
        if (this.organisationInImageName && this.organisationInImageName.constructor === Array) {
            data["organisationInImageName"] = [];
            for (let item of this.organisationInImageName)
                data["organisationInImageName"].push(item);
        }
        if (this.personInImage && this.personInImage.constructor === Array) {
            data["personInImage"] = [];
            for (let item of this.personInImage)
                data["personInImage"].push(item);
        }
        data["digitalImageGUID"] = this.digitalImageGUID;
        data["digitalSourceType"] = this.digitalSourceType;
        if (this.event) {
            data["event"] = {};
            for (let key in this.event) {
                if (this.event.hasOwnProperty(key))
                    data["event"][key] = this.event[key];
            }
        }
        if (this.imageRegistryEntry && this.imageRegistryEntry.constructor === Array) {
            data["imageRegistryEntry"] = [];
            for (let item of this.imageRegistryEntry)
                data["imageRegistryEntry"].push(item.toJSON());
        }
        data["metadataLastEdited"] = this.metadataLastEdited ? this.metadataLastEdited.toISOString() : <any>undefined;
        if (this.locationCreated && this.locationCreated.constructor === Array) {
            data["locationCreated"] = [];
            for (let item of this.locationCreated)
                data["locationCreated"].push(item.toJSON());
        }
        data["maxAvailHeight"] = this.maxAvailHeight;
        data["maxAvailWidth"] = this.maxAvailWidth;
        return data; 
    }
}

export interface IIptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: IArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: ILocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: IRegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: ILocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;
}

/** Corresponds to Xmp.Structure.ArtworkOrObjectDetails */
export class ArtworkOrObjectInfo implements IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;

    constructor(data?: IArtworkOrObjectInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightNotice = data["copyrightNotice"];
            if (data["creator"] && data["creator"].constructor === Array) {
                this.creator = [];
                for (let item of data["creator"])
                    this.creator.push(item);
            }
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            this.source = data["source"];
            this.sourceInventoryNumber = data["sourceInventoryNumber"];
            if (data["title"]) {
                this.title = {};
                for (let key in data["title"]) {
                    if (data["title"].hasOwnProperty(key))
                        this.title[key] = data["title"][key];
                }
            }
        }
    }

    static fromJS(data: any): ArtworkOrObjectInfo {
        let result = new ArtworkOrObjectInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["copyrightNotice"] = this.copyrightNotice;
        if (this.creator && this.creator.constructor === Array) {
            data["creator"] = [];
            for (let item of this.creator)
                data["creator"].push(item);
        }
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["sourceInventoryNumber"] = this.sourceInventoryNumber;
        if (this.title) {
            data["title"] = {};
            for (let key in this.title) {
                if (this.title.hasOwnProperty(key))
                    data["title"][key] = this.title[key];
            }
        }
        return data; 
    }
}

/** Corresponds to Xmp.Structure.ArtworkOrObjectDetails */
export interface IArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;
}

export class LocationInfo implements ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;

    constructor(data?: ILocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.city = data["city"];
            this.countryCode = data["countryCode"];
            this.countryName = data["countryName"];
            this.provinceState = data["provinceState"];
            this.sublocation = data["sublocation"];
            this.worldRegion = data["worldRegion"];
        }
    }

    static fromJS(data: any): LocationInfo {
        let result = new LocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["provinceState"] = this.provinceState;
        data["sublocation"] = this.sublocation;
        data["worldRegion"] = this.worldRegion;
        return data; 
    }
}

export interface ILocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;
}

export class RegistryEntryInfo implements IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;

    constructor(data?: IRegistryEntryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registryItemIdentifier = data["registryItemIdentifier"];
            this.registryOrganisationIdentifier = data["registryOrganisationIdentifier"];
        }
    }

    static fromJS(data: any): RegistryEntryInfo {
        let result = new RegistryEntryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registryItemIdentifier"] = this.registryItemIdentifier;
        data["registryOrganisationIdentifier"] = this.registryOrganisationIdentifier;
        return data; 
    }
}

export interface IRegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;
}

export class IptcIIM implements IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uno?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;

    constructor(data?: IIptcIIM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modelVersion = data["modelVersion"];
            if (data["destination"] && data["destination"].constructor === Array) {
                this.destination = [];
                for (let item of data["destination"])
                    this.destination.push(item);
            }
            this.fileFormat = data["fileFormat"];
            this.fileFormatVersion = data["fileFormatVersion"];
            this.serviceIdentifier = data["serviceIdentifier"];
            this.envelopeNumber = data["envelopeNumber"];
            if (data["productID"] && data["productID"].constructor === Array) {
                this.productID = [];
                for (let item of data["productID"])
                    this.productID.push(item);
            }
            this.envelopePriority = data["envelopePriority"];
            this.dateSent = data["dateSent"] ? new Date(data["dateSent"].toString()) : <any>undefined;
            this.timeSent = data["timeSent"] ? new Date(data["timeSent"].toString()) : <any>undefined;
            this.uno = data["uno"];
            this.recordVersion = data["recordVersion"];
            this.objectTypeReference = data["objectTypeReference"];
            this.objectAttributeReference = data["objectAttributeReference"];
            if (data["objectName"]) {
                this.objectName = {};
                for (let key in data["objectName"]) {
                    if (data["objectName"].hasOwnProperty(key))
                        this.objectName[key] = data["objectName"][key];
                }
            }
            this.editStatus = data["editStatus"];
            this.urgency = data["urgency"];
            if (data["subjectReference"] && data["subjectReference"].constructor === Array) {
                this.subjectReference = [];
                for (let item of data["subjectReference"])
                    this.subjectReference.push(item);
            }
            this.category = data["category"];
            if (data["supplementalCategory"] && data["supplementalCategory"].constructor === Array) {
                this.supplementalCategory = [];
                for (let item of data["supplementalCategory"])
                    this.supplementalCategory.push(item);
            }
            this.fixtureIdentifier = data["fixtureIdentifier"];
            if (data["keywords"] && data["keywords"].constructor === Array) {
                this.keywords = [];
                for (let item of data["keywords"])
                    this.keywords.push(item);
            }
            if (data["contentLocationCode"] && data["contentLocationCode"].constructor === Array) {
                this.contentLocationCode = [];
                for (let item of data["contentLocationCode"])
                    this.contentLocationCode.push(item);
            }
            if (data["contentLocationName"] && data["contentLocationName"].constructor === Array) {
                this.contentLocationName = [];
                for (let item of data["contentLocationName"])
                    this.contentLocationName.push(item);
            }
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            this.releaseTime = data["releaseTime"] ? new Date(data["releaseTime"].toString()) : <any>undefined;
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.expirationTime = data["expirationTime"] ? new Date(data["expirationTime"].toString()) : <any>undefined;
            this.specialInstruction = data["specialInstruction"];
            this.actionAdvised = data["actionAdvised"];
            this.referenceService = data["referenceService"];
            this.referenceDate = data["referenceDate"] ? new Date(data["referenceDate"].toString()) : <any>undefined;
            this.referenceNumber = data["referenceNumber"];
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            this.timeCreated = data["timeCreated"] ? new Date(data["timeCreated"].toString()) : <any>undefined;
            this.digitalCreationDate = data["digitalCreationDate"] ? new Date(data["digitalCreationDate"].toString()) : <any>undefined;
            this.digitalCreationTime = data["digitalCreationTime"] ? new Date(data["digitalCreationTime"].toString()) : <any>undefined;
            this.originatingProgram = data["originatingProgram"];
            this.programVersion = data["programVersion"];
            if (data["byline"] && data["byline"].constructor === Array) {
                this.byline = [];
                for (let item of data["byline"])
                    this.byline.push(item);
            }
            this.bylineTitle = data["bylineTitle"];
            this.city = data["city"];
            this.sublocation = data["sublocation"];
            this.provinceState = data["provinceState"];
            this.countryPrimaryLocationCode = data["countryPrimaryLocationCode"];
            this.countryPrimaryLocationName = data["countryPrimaryLocationName"];
            this.originalTransmissionReference = data["originalTransmissionReference"];
            this.headline = data["headline"];
            this.credit = data["credit"];
            this.source = data["source"];
            if (data["copyrightNotice"]) {
                this.copyrightNotice = {};
                for (let key in data["copyrightNotice"]) {
                    if (data["copyrightNotice"].hasOwnProperty(key))
                        this.copyrightNotice[key] = data["copyrightNotice"][key];
                }
            }
            if (data["captionAbstract"]) {
                this.captionAbstract = {};
                for (let key in data["captionAbstract"]) {
                    if (data["captionAbstract"].hasOwnProperty(key))
                        this.captionAbstract[key] = data["captionAbstract"][key];
                }
            }
            this.writerEditor = data["writerEditor"];
            this.imageType = data["imageType"];
            this.imageOrientation = data["imageOrientation"];
            this.languageIdentifier = data["languageIdentifier"];
        }
    }

    static fromJS(data: any): IptcIIM {
        let result = new IptcIIM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelVersion"] = this.modelVersion;
        if (this.destination && this.destination.constructor === Array) {
            data["destination"] = [];
            for (let item of this.destination)
                data["destination"].push(item);
        }
        data["fileFormat"] = this.fileFormat;
        data["fileFormatVersion"] = this.fileFormatVersion;
        data["serviceIdentifier"] = this.serviceIdentifier;
        data["envelopeNumber"] = this.envelopeNumber;
        if (this.productID && this.productID.constructor === Array) {
            data["productID"] = [];
            for (let item of this.productID)
                data["productID"].push(item);
        }
        data["envelopePriority"] = this.envelopePriority;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["timeSent"] = this.timeSent ? this.timeSent.toISOString() : <any>undefined;
        data["uno"] = this.uno;
        data["recordVersion"] = this.recordVersion;
        data["objectTypeReference"] = this.objectTypeReference;
        data["objectAttributeReference"] = this.objectAttributeReference;
        if (this.objectName) {
            data["objectName"] = {};
            for (let key in this.objectName) {
                if (this.objectName.hasOwnProperty(key))
                    data["objectName"][key] = this.objectName[key];
            }
        }
        data["editStatus"] = this.editStatus;
        data["urgency"] = this.urgency;
        if (this.subjectReference && this.subjectReference.constructor === Array) {
            data["subjectReference"] = [];
            for (let item of this.subjectReference)
                data["subjectReference"].push(item);
        }
        data["category"] = this.category;
        if (this.supplementalCategory && this.supplementalCategory.constructor === Array) {
            data["supplementalCategory"] = [];
            for (let item of this.supplementalCategory)
                data["supplementalCategory"].push(item);
        }
        data["fixtureIdentifier"] = this.fixtureIdentifier;
        if (this.keywords && this.keywords.constructor === Array) {
            data["keywords"] = [];
            for (let item of this.keywords)
                data["keywords"].push(item);
        }
        if (this.contentLocationCode && this.contentLocationCode.constructor === Array) {
            data["contentLocationCode"] = [];
            for (let item of this.contentLocationCode)
                data["contentLocationCode"].push(item);
        }
        if (this.contentLocationName && this.contentLocationName.constructor === Array) {
            data["contentLocationName"] = [];
            for (let item of this.contentLocationName)
                data["contentLocationName"].push(item);
        }
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["releaseTime"] = this.releaseTime ? this.releaseTime.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["specialInstruction"] = this.specialInstruction;
        data["actionAdvised"] = this.actionAdvised;
        data["referenceService"] = this.referenceService;
        data["referenceDate"] = this.referenceDate ? this.referenceDate.toISOString() : <any>undefined;
        data["referenceNumber"] = this.referenceNumber;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["timeCreated"] = this.timeCreated ? this.timeCreated.toISOString() : <any>undefined;
        data["digitalCreationDate"] = this.digitalCreationDate ? this.digitalCreationDate.toISOString() : <any>undefined;
        data["digitalCreationTime"] = this.digitalCreationTime ? this.digitalCreationTime.toISOString() : <any>undefined;
        data["originatingProgram"] = this.originatingProgram;
        data["programVersion"] = this.programVersion;
        if (this.byline && this.byline.constructor === Array) {
            data["byline"] = [];
            for (let item of this.byline)
                data["byline"].push(item);
        }
        data["bylineTitle"] = this.bylineTitle;
        data["city"] = this.city;
        data["sublocation"] = this.sublocation;
        data["provinceState"] = this.provinceState;
        data["countryPrimaryLocationCode"] = this.countryPrimaryLocationCode;
        data["countryPrimaryLocationName"] = this.countryPrimaryLocationName;
        data["originalTransmissionReference"] = this.originalTransmissionReference;
        data["headline"] = this.headline;
        data["credit"] = this.credit;
        data["source"] = this.source;
        if (this.copyrightNotice) {
            data["copyrightNotice"] = {};
            for (let key in this.copyrightNotice) {
                if (this.copyrightNotice.hasOwnProperty(key))
                    data["copyrightNotice"][key] = this.copyrightNotice[key];
            }
        }
        if (this.captionAbstract) {
            data["captionAbstract"] = {};
            for (let key in this.captionAbstract) {
                if (this.captionAbstract.hasOwnProperty(key))
                    data["captionAbstract"][key] = this.captionAbstract[key];
            }
        }
        data["writerEditor"] = this.writerEditor;
        data["imageType"] = this.imageType;
        data["imageOrientation"] = this.imageOrientation;
        data["languageIdentifier"] = this.languageIdentifier;
        return data; 
    }
}

export interface IIptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uno?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;
}

export class Lr implements ILr {
    hierarchicalSubject?: string[] | undefined;

    constructor(data?: ILr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["hierarchicalSubject"] && data["hierarchicalSubject"].constructor === Array) {
                this.hierarchicalSubject = [];
                for (let item of data["hierarchicalSubject"])
                    this.hierarchicalSubject.push(item);
            }
        }
    }

    static fromJS(data: any): Lr {
        let result = new Lr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.hierarchicalSubject && this.hierarchicalSubject.constructor === Array) {
            data["hierarchicalSubject"] = [];
            for (let item of this.hierarchicalSubject)
                data["hierarchicalSubject"].push(item);
        }
        return data; 
    }
}

export interface ILr {
    hierarchicalSubject?: string[] | undefined;
}

export class Pdf implements IPdf {
    keywords?: string | undefined;
    pdfVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;

    constructor(data?: IPdf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keywords = data["keywords"];
            this.pdfVersion = data["pdfVersion"];
            this.producer = data["producer"];
            this.trapped = data["trapped"];
        }
    }

    static fromJS(data: any): Pdf {
        let result = new Pdf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords;
        data["pdfVersion"] = this.pdfVersion;
        data["producer"] = this.producer;
        data["trapped"] = this.trapped;
        return data; 
    }
}

export interface IPdf {
    keywords?: string | undefined;
    pdfVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;
}

export class Photoshop implements IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iccProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;

    constructor(data?: IPhotoshop) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.textLayers) {
                this.textLayers = [];
                for (let i = 0; i < data.textLayers.length; i++) {
                    let item = data.textLayers[i];
                    this.textLayers[i] = item && !(<any>item).toJSON ? new PhotoshopLayer(item) : <PhotoshopLayer>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authorsPosition = data["authorsPosition"];
            this.captionWriter = data["captionWriter"];
            this.category = data["category"];
            this.city = data["city"];
            this.colorMode = data["colorMode"];
            this.country = data["country"];
            this.credit = data["credit"];
            this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : <any>undefined;
            if (data["documentAncestors"] && data["documentAncestors"].constructor === Array) {
                this.documentAncestors = [];
                for (let item of data["documentAncestors"])
                    this.documentAncestors.push(item);
            }
            this.headline = data["headline"];
            this.history = data["history"];
            this.iccProfile = data["iccProfile"];
            this.instructions = data["instructions"];
            this.source = data["source"];
            this.state = data["state"];
            if (data["supplementalCategories"] && data["supplementalCategories"].constructor === Array) {
                this.supplementalCategories = [];
                for (let item of data["supplementalCategories"])
                    this.supplementalCategories.push(item);
            }
            if (data["textLayers"] && data["textLayers"].constructor === Array) {
                this.textLayers = [];
                for (let item of data["textLayers"])
                    this.textLayers.push(PhotoshopLayer.fromJS(item));
            }
            this.transmissionReference = data["transmissionReference"];
            this.urgency = data["urgency"];
            this.legacyIPTCDigest = data["legacyIPTCDigest"];
        }
    }

    static fromJS(data: any): Photoshop {
        let result = new Photoshop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorsPosition"] = this.authorsPosition;
        data["captionWriter"] = this.captionWriter;
        data["category"] = this.category;
        data["city"] = this.city;
        data["colorMode"] = this.colorMode;
        data["country"] = this.country;
        data["credit"] = this.credit;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        if (this.documentAncestors && this.documentAncestors.constructor === Array) {
            data["documentAncestors"] = [];
            for (let item of this.documentAncestors)
                data["documentAncestors"].push(item);
        }
        data["headline"] = this.headline;
        data["history"] = this.history;
        data["iccProfile"] = this.iccProfile;
        data["instructions"] = this.instructions;
        data["source"] = this.source;
        data["state"] = this.state;
        if (this.supplementalCategories && this.supplementalCategories.constructor === Array) {
            data["supplementalCategories"] = [];
            for (let item of this.supplementalCategories)
                data["supplementalCategories"].push(item);
        }
        if (this.textLayers && this.textLayers.constructor === Array) {
            data["textLayers"] = [];
            for (let item of this.textLayers)
                data["textLayers"].push(item.toJSON());
        }
        data["transmissionReference"] = this.transmissionReference;
        data["urgency"] = this.urgency;
        data["legacyIPTCDigest"] = this.legacyIPTCDigest;
        return data; 
    }
}

export interface IPhotoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iccProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: IPhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;
}

/** Corresponds to photoshop.ColorModeChoice */
export enum ColorMode {
    Bitmap = <any>"Bitmap", 
    Grayscale = <any>"Grayscale", 
    Indexed = <any>"Indexed", 
    RGB = <any>"RGB", 
    CMYK = <any>"CMYK", 
    Multichannel = <any>"Multichannel", 
    Duotone = <any>"Duotone", 
    LAB = <any>"LAB", 
}

export class PhotoshopLayer implements IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;

    constructor(data?: IPhotoshopLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layerName = data["layerName"];
            this.layerText = data["layerText"];
        }
    }

    static fromJS(data: any): PhotoshopLayer {
        let result = new PhotoshopLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerName"] = this.layerName;
        data["layerText"] = this.layerText;
        return data; 
    }
}

export interface IPhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;
}

export class Plus implements IPlus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;

    constructor(data?: IPlus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.licensee) {
                this.licensee = [];
                for (let i = 0; i < data.licensee.length; i++) {
                    let item = data.licensee[i];
                    this.licensee[i] = item && !(<any>item).toJSON ? new LicenseeInfo(item) : <LicenseeInfo>item;
                }
            }
            if (data.endUser) {
                this.endUser = [];
                for (let i = 0; i < data.endUser.length; i++) {
                    let item = data.endUser[i];
                    this.endUser[i] = item && !(<any>item).toJSON ? new EndUserInfo(item) : <EndUserInfo>item;
                }
            }
            if (data.licensor) {
                this.licensor = [];
                for (let i = 0; i < data.licensor.length; i++) {
                    let item = data.licensor[i];
                    this.licensor[i] = item && !(<any>item).toJSON ? new LicensorInfo(item) : <LicensorInfo>item;
                }
            }
            if (data.copyrightOwner) {
                this.copyrightOwner = [];
                for (let i = 0; i < data.copyrightOwner.length; i++) {
                    let item = data.copyrightOwner[i];
                    this.copyrightOwner[i] = item && !(<any>item).toJSON ? new CopyrightOwnerInfo(item) : <CopyrightOwnerInfo>item;
                }
            }
            if (data.imageCreator) {
                this.imageCreator = [];
                for (let i = 0; i < data.imageCreator.length; i++) {
                    let item = data.imageCreator[i];
                    this.imageCreator[i] = item && !(<any>item).toJSON ? new ImageCreatorInfo(item) : <ImageCreatorInfo>item;
                }
            }
            if (data.imageSupplier) {
                this.imageSupplier = [];
                for (let i = 0; i < data.imageSupplier.length; i++) {
                    let item = data.imageSupplier[i];
                    this.imageSupplier[i] = item && !(<any>item).toJSON ? new ImageSupplierInfo(item) : <ImageSupplierInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            if (data["licensee"] && data["licensee"].constructor === Array) {
                this.licensee = [];
                for (let item of data["licensee"])
                    this.licensee.push(LicenseeInfo.fromJS(item));
            }
            this.licenseeID = data["licenseeID"];
            this.licenseeName = data["licenseeName"];
            if (data["endUser"] && data["endUser"].constructor === Array) {
                this.endUser = [];
                for (let item of data["endUser"])
                    this.endUser.push(EndUserInfo.fromJS(item));
            }
            this.endUserID = data["endUserID"];
            this.endUserName = data["endUserName"];
            if (data["licensor"] && data["licensor"].constructor === Array) {
                this.licensor = [];
                for (let item of data["licensor"])
                    this.licensor.push(LicensorInfo.fromJS(item));
            }
            if (data["licensorNotes"]) {
                this.licensorNotes = {};
                for (let key in data["licensorNotes"]) {
                    if (data["licensorNotes"].hasOwnProperty(key))
                        this.licensorNotes[key] = data["licensorNotes"][key];
                }
            }
            this.mediaSummaryCode = data["mediaSummaryCode"];
            this.licenseStartDate = data["licenseStartDate"] ? new Date(data["licenseStartDate"].toString()) : <any>undefined;
            this.licenseEndDate = data["licenseEndDate"] ? new Date(data["licenseEndDate"].toString()) : <any>undefined;
            if (data["mediaConstraints"]) {
                this.mediaConstraints = {};
                for (let key in data["mediaConstraints"]) {
                    if (data["mediaConstraints"].hasOwnProperty(key))
                        this.mediaConstraints[key] = data["mediaConstraints"][key];
                }
            }
            if (data["regionConstraints"]) {
                this.regionConstraints = {};
                for (let key in data["regionConstraints"]) {
                    if (data["regionConstraints"].hasOwnProperty(key))
                        this.regionConstraints[key] = data["regionConstraints"][key];
                }
            }
            if (data["productOrServiceConstraints"]) {
                this.productOrServiceConstraints = {};
                for (let key in data["productOrServiceConstraints"]) {
                    if (data["productOrServiceConstraints"].hasOwnProperty(key))
                        this.productOrServiceConstraints[key] = data["productOrServiceConstraints"][key];
                }
            }
            if (data["imageFileConstraints"] && data["imageFileConstraints"].constructor === Array) {
                this.imageFileConstraints = [];
                for (let item of data["imageFileConstraints"])
                    this.imageFileConstraints.push(item);
            }
            if (data["imageAlterationConstraints"] && data["imageAlterationConstraints"].constructor === Array) {
                this.imageAlterationConstraints = [];
                for (let item of data["imageAlterationConstraints"])
                    this.imageAlterationConstraints.push(item);
            }
            this.imageDuplicationConstraints = data["imageDuplicationConstraints"];
            this.modelReleaseStatus = data["modelReleaseStatus"];
            if (data["modelReleaseID"] && data["modelReleaseID"].constructor === Array) {
                this.modelReleaseID = [];
                for (let item of data["modelReleaseID"])
                    this.modelReleaseID.push(item);
            }
            this.minorModelAgeDisclosure = data["minorModelAgeDisclosure"];
            this.propertyReleaseStatus = data["propertyReleaseStatus"];
            if (data["propertyReleaseID"] && data["propertyReleaseID"].constructor === Array) {
                this.propertyReleaseID = [];
                for (let item of data["propertyReleaseID"])
                    this.propertyReleaseID.push(item);
            }
            if (data["otherConstraints"]) {
                this.otherConstraints = {};
                for (let key in data["otherConstraints"]) {
                    if (data["otherConstraints"].hasOwnProperty(key))
                        this.otherConstraints[key] = data["otherConstraints"][key];
                }
            }
            this.creditLineRequired = data["creditLineRequired"];
            this.adultContentWarning = data["adultContentWarning"];
            if (data["otherLicenseRequirements"]) {
                this.otherLicenseRequirements = {};
                for (let key in data["otherLicenseRequirements"]) {
                    if (data["otherLicenseRequirements"].hasOwnProperty(key))
                        this.otherLicenseRequirements[key] = data["otherLicenseRequirements"][key];
                }
            }
            if (data["termsAndConditionsText"]) {
                this.termsAndConditionsText = {};
                for (let key in data["termsAndConditionsText"]) {
                    if (data["termsAndConditionsText"].hasOwnProperty(key))
                        this.termsAndConditionsText[key] = data["termsAndConditionsText"][key];
                }
            }
            this.termsAndConditionsURL = data["termsAndConditionsURL"];
            if (data["otherConditions"]) {
                this.otherConditions = {};
                for (let key in data["otherConditions"]) {
                    if (data["otherConditions"].hasOwnProperty(key))
                        this.otherConditions[key] = data["otherConditions"][key];
                }
            }
            this.imageType = data["imageType"];
            this.licensorImageID = data["licensorImageID"];
            this.fileNameAsDelivered = data["fileNameAsDelivered"];
            this.imageFileFormatAsDelivered = data["imageFileFormatAsDelivered"];
            this.imageFileSizeAsDelivered = data["imageFileSizeAsDelivered"];
            this.copyrightStatus = data["copyrightStatus"];
            this.copyrightRegistrationNumber = data["copyrightRegistrationNumber"];
            this.firstPublicationDate = data["firstPublicationDate"] ? new Date(data["firstPublicationDate"].toString()) : <any>undefined;
            if (data["copyrightOwner"] && data["copyrightOwner"].constructor === Array) {
                this.copyrightOwner = [];
                for (let item of data["copyrightOwner"])
                    this.copyrightOwner.push(CopyrightOwnerInfo.fromJS(item));
            }
            this.copyrightOwnerImageID = data["copyrightOwnerImageID"];
            if (data["imageCreator"] && data["imageCreator"].constructor === Array) {
                this.imageCreator = [];
                for (let item of data["imageCreator"])
                    this.imageCreator.push(ImageCreatorInfo.fromJS(item));
            }
            this.imageCreatorImageID = data["imageCreatorImageID"];
            if (data["imageSupplier"] && data["imageSupplier"].constructor === Array) {
                this.imageSupplier = [];
                for (let item of data["imageSupplier"])
                    this.imageSupplier.push(ImageSupplierInfo.fromJS(item));
            }
            this.imageSupplierImageID = data["imageSupplierImageID"];
            this.licenseeImageID = data["licenseeImageID"];
            if (data["licenseeImageNotes"]) {
                this.licenseeImageNotes = {};
                for (let key in data["licenseeImageNotes"]) {
                    if (data["licenseeImageNotes"].hasOwnProperty(key))
                        this.licenseeImageNotes[key] = data["licenseeImageNotes"][key];
                }
            }
            if (data["otherImageInfo"]) {
                this.otherImageInfo = {};
                for (let key in data["otherImageInfo"]) {
                    if (data["otherImageInfo"].hasOwnProperty(key))
                        this.otherImageInfo[key] = data["otherImageInfo"][key];
                }
            }
            this.licenseID = data["licenseID"];
            if (data["licensorTransactionID"] && data["licensorTransactionID"].constructor === Array) {
                this.licensorTransactionID = [];
                for (let item of data["licensorTransactionID"])
                    this.licensorTransactionID.push(item);
            }
            if (data["licenseeTransactionID"] && data["licenseeTransactionID"].constructor === Array) {
                this.licenseeTransactionID = [];
                for (let item of data["licenseeTransactionID"])
                    this.licenseeTransactionID.push(item);
            }
            if (data["licenseeProjectReference"] && data["licenseeProjectReference"].constructor === Array) {
                this.licenseeProjectReference = [];
                for (let item of data["licenseeProjectReference"])
                    this.licenseeProjectReference.push(item);
            }
            this.licenseTransactionDate = data["licenseTransactionDate"] ? new Date(data["licenseTransactionDate"].toString()) : <any>undefined;
            this.reuse = data["reuse"];
            if (data["otherLicenseDocuments"] && data["otherLicenseDocuments"].constructor === Array) {
                this.otherLicenseDocuments = [];
                for (let item of data["otherLicenseDocuments"])
                    this.otherLicenseDocuments.push(item);
            }
            if (data["otherLicenseInfo"]) {
                this.otherLicenseInfo = {};
                for (let key in data["otherLicenseInfo"]) {
                    if (data["otherLicenseInfo"].hasOwnProperty(key))
                        this.otherLicenseInfo[key] = data["otherLicenseInfo"][key];
                }
            }
            if (data["custom1"] && data["custom1"].constructor === Array) {
                this.custom1 = [];
                for (let item of data["custom1"])
                    this.custom1.push(item);
            }
            if (data["custom2"] && data["custom2"].constructor === Array) {
                this.custom2 = [];
                for (let item of data["custom2"])
                    this.custom2.push(item);
            }
            if (data["custom3"] && data["custom3"].constructor === Array) {
                this.custom3 = [];
                for (let item of data["custom3"])
                    this.custom3.push(item);
            }
            if (data["custom4"] && data["custom4"].constructor === Array) {
                this.custom4 = [];
                for (let item of data["custom4"])
                    this.custom4.push(item);
            }
            if (data["custom5"] && data["custom5"].constructor === Array) {
                this.custom5 = [];
                for (let item of data["custom5"])
                    this.custom5.push(item);
            }
            if (data["custom6"] && data["custom6"].constructor === Array) {
                this.custom6 = [];
                for (let item of data["custom6"])
                    this.custom6.push(item);
            }
            if (data["custom7"] && data["custom7"].constructor === Array) {
                this.custom7 = [];
                for (let item of data["custom7"])
                    this.custom7.push(item);
            }
            if (data["custom8"] && data["custom8"].constructor === Array) {
                this.custom8 = [];
                for (let item of data["custom8"])
                    this.custom8.push(item);
            }
            if (data["custom9"] && data["custom9"].constructor === Array) {
                this.custom9 = [];
                for (let item of data["custom9"])
                    this.custom9.push(item);
            }
            if (data["custom10"] && data["custom10"].constructor === Array) {
                this.custom10 = [];
                for (let item of data["custom10"])
                    this.custom10.push(item);
            }
        }
    }

    static fromJS(data: any): Plus {
        let result = new Plus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        if (this.licensee && this.licensee.constructor === Array) {
            data["licensee"] = [];
            for (let item of this.licensee)
                data["licensee"].push(item.toJSON());
        }
        data["licenseeID"] = this.licenseeID;
        data["licenseeName"] = this.licenseeName;
        if (this.endUser && this.endUser.constructor === Array) {
            data["endUser"] = [];
            for (let item of this.endUser)
                data["endUser"].push(item.toJSON());
        }
        data["endUserID"] = this.endUserID;
        data["endUserName"] = this.endUserName;
        if (this.licensor && this.licensor.constructor === Array) {
            data["licensor"] = [];
            for (let item of this.licensor)
                data["licensor"].push(item.toJSON());
        }
        if (this.licensorNotes) {
            data["licensorNotes"] = {};
            for (let key in this.licensorNotes) {
                if (this.licensorNotes.hasOwnProperty(key))
                    data["licensorNotes"][key] = this.licensorNotes[key];
            }
        }
        data["mediaSummaryCode"] = this.mediaSummaryCode;
        data["licenseStartDate"] = this.licenseStartDate ? this.licenseStartDate.toISOString() : <any>undefined;
        data["licenseEndDate"] = this.licenseEndDate ? this.licenseEndDate.toISOString() : <any>undefined;
        if (this.mediaConstraints) {
            data["mediaConstraints"] = {};
            for (let key in this.mediaConstraints) {
                if (this.mediaConstraints.hasOwnProperty(key))
                    data["mediaConstraints"][key] = this.mediaConstraints[key];
            }
        }
        if (this.regionConstraints) {
            data["regionConstraints"] = {};
            for (let key in this.regionConstraints) {
                if (this.regionConstraints.hasOwnProperty(key))
                    data["regionConstraints"][key] = this.regionConstraints[key];
            }
        }
        if (this.productOrServiceConstraints) {
            data["productOrServiceConstraints"] = {};
            for (let key in this.productOrServiceConstraints) {
                if (this.productOrServiceConstraints.hasOwnProperty(key))
                    data["productOrServiceConstraints"][key] = this.productOrServiceConstraints[key];
            }
        }
        if (this.imageFileConstraints && this.imageFileConstraints.constructor === Array) {
            data["imageFileConstraints"] = [];
            for (let item of this.imageFileConstraints)
                data["imageFileConstraints"].push(item);
        }
        if (this.imageAlterationConstraints && this.imageAlterationConstraints.constructor === Array) {
            data["imageAlterationConstraints"] = [];
            for (let item of this.imageAlterationConstraints)
                data["imageAlterationConstraints"].push(item);
        }
        data["imageDuplicationConstraints"] = this.imageDuplicationConstraints;
        data["modelReleaseStatus"] = this.modelReleaseStatus;
        if (this.modelReleaseID && this.modelReleaseID.constructor === Array) {
            data["modelReleaseID"] = [];
            for (let item of this.modelReleaseID)
                data["modelReleaseID"].push(item);
        }
        data["minorModelAgeDisclosure"] = this.minorModelAgeDisclosure;
        data["propertyReleaseStatus"] = this.propertyReleaseStatus;
        if (this.propertyReleaseID && this.propertyReleaseID.constructor === Array) {
            data["propertyReleaseID"] = [];
            for (let item of this.propertyReleaseID)
                data["propertyReleaseID"].push(item);
        }
        if (this.otherConstraints) {
            data["otherConstraints"] = {};
            for (let key in this.otherConstraints) {
                if (this.otherConstraints.hasOwnProperty(key))
                    data["otherConstraints"][key] = this.otherConstraints[key];
            }
        }
        data["creditLineRequired"] = this.creditLineRequired;
        data["adultContentWarning"] = this.adultContentWarning;
        if (this.otherLicenseRequirements) {
            data["otherLicenseRequirements"] = {};
            for (let key in this.otherLicenseRequirements) {
                if (this.otherLicenseRequirements.hasOwnProperty(key))
                    data["otherLicenseRequirements"][key] = this.otherLicenseRequirements[key];
            }
        }
        if (this.termsAndConditionsText) {
            data["termsAndConditionsText"] = {};
            for (let key in this.termsAndConditionsText) {
                if (this.termsAndConditionsText.hasOwnProperty(key))
                    data["termsAndConditionsText"][key] = this.termsAndConditionsText[key];
            }
        }
        data["termsAndConditionsURL"] = this.termsAndConditionsURL;
        if (this.otherConditions) {
            data["otherConditions"] = {};
            for (let key in this.otherConditions) {
                if (this.otherConditions.hasOwnProperty(key))
                    data["otherConditions"][key] = this.otherConditions[key];
            }
        }
        data["imageType"] = this.imageType;
        data["licensorImageID"] = this.licensorImageID;
        data["fileNameAsDelivered"] = this.fileNameAsDelivered;
        data["imageFileFormatAsDelivered"] = this.imageFileFormatAsDelivered;
        data["imageFileSizeAsDelivered"] = this.imageFileSizeAsDelivered;
        data["copyrightStatus"] = this.copyrightStatus;
        data["copyrightRegistrationNumber"] = this.copyrightRegistrationNumber;
        data["firstPublicationDate"] = this.firstPublicationDate ? this.firstPublicationDate.toISOString() : <any>undefined;
        if (this.copyrightOwner && this.copyrightOwner.constructor === Array) {
            data["copyrightOwner"] = [];
            for (let item of this.copyrightOwner)
                data["copyrightOwner"].push(item.toJSON());
        }
        data["copyrightOwnerImageID"] = this.copyrightOwnerImageID;
        if (this.imageCreator && this.imageCreator.constructor === Array) {
            data["imageCreator"] = [];
            for (let item of this.imageCreator)
                data["imageCreator"].push(item.toJSON());
        }
        data["imageCreatorImageID"] = this.imageCreatorImageID;
        if (this.imageSupplier && this.imageSupplier.constructor === Array) {
            data["imageSupplier"] = [];
            for (let item of this.imageSupplier)
                data["imageSupplier"].push(item.toJSON());
        }
        data["imageSupplierImageID"] = this.imageSupplierImageID;
        data["licenseeImageID"] = this.licenseeImageID;
        if (this.licenseeImageNotes) {
            data["licenseeImageNotes"] = {};
            for (let key in this.licenseeImageNotes) {
                if (this.licenseeImageNotes.hasOwnProperty(key))
                    data["licenseeImageNotes"][key] = this.licenseeImageNotes[key];
            }
        }
        if (this.otherImageInfo) {
            data["otherImageInfo"] = {};
            for (let key in this.otherImageInfo) {
                if (this.otherImageInfo.hasOwnProperty(key))
                    data["otherImageInfo"][key] = this.otherImageInfo[key];
            }
        }
        data["licenseID"] = this.licenseID;
        if (this.licensorTransactionID && this.licensorTransactionID.constructor === Array) {
            data["licensorTransactionID"] = [];
            for (let item of this.licensorTransactionID)
                data["licensorTransactionID"].push(item);
        }
        if (this.licenseeTransactionID && this.licenseeTransactionID.constructor === Array) {
            data["licenseeTransactionID"] = [];
            for (let item of this.licenseeTransactionID)
                data["licenseeTransactionID"].push(item);
        }
        if (this.licenseeProjectReference && this.licenseeProjectReference.constructor === Array) {
            data["licenseeProjectReference"] = [];
            for (let item of this.licenseeProjectReference)
                data["licenseeProjectReference"].push(item);
        }
        data["licenseTransactionDate"] = this.licenseTransactionDate ? this.licenseTransactionDate.toISOString() : <any>undefined;
        data["reuse"] = this.reuse;
        if (this.otherLicenseDocuments && this.otherLicenseDocuments.constructor === Array) {
            data["otherLicenseDocuments"] = [];
            for (let item of this.otherLicenseDocuments)
                data["otherLicenseDocuments"].push(item);
        }
        if (this.otherLicenseInfo) {
            data["otherLicenseInfo"] = {};
            for (let key in this.otherLicenseInfo) {
                if (this.otherLicenseInfo.hasOwnProperty(key))
                    data["otherLicenseInfo"][key] = this.otherLicenseInfo[key];
            }
        }
        if (this.custom1 && this.custom1.constructor === Array) {
            data["custom1"] = [];
            for (let item of this.custom1)
                data["custom1"].push(item);
        }
        if (this.custom2 && this.custom2.constructor === Array) {
            data["custom2"] = [];
            for (let item of this.custom2)
                data["custom2"].push(item);
        }
        if (this.custom3 && this.custom3.constructor === Array) {
            data["custom3"] = [];
            for (let item of this.custom3)
                data["custom3"].push(item);
        }
        if (this.custom4 && this.custom4.constructor === Array) {
            data["custom4"] = [];
            for (let item of this.custom4)
                data["custom4"].push(item);
        }
        if (this.custom5 && this.custom5.constructor === Array) {
            data["custom5"] = [];
            for (let item of this.custom5)
                data["custom5"].push(item);
        }
        if (this.custom6 && this.custom6.constructor === Array) {
            data["custom6"] = [];
            for (let item of this.custom6)
                data["custom6"].push(item);
        }
        if (this.custom7 && this.custom7.constructor === Array) {
            data["custom7"] = [];
            for (let item of this.custom7)
                data["custom7"].push(item);
        }
        if (this.custom8 && this.custom8.constructor === Array) {
            data["custom8"] = [];
            for (let item of this.custom8)
                data["custom8"].push(item);
        }
        if (this.custom9 && this.custom9.constructor === Array) {
            data["custom9"] = [];
            for (let item of this.custom9)
                data["custom9"].push(item);
        }
        if (this.custom10 && this.custom10.constructor === Array) {
            data["custom10"] = [];
            for (let item of this.custom10)
                data["custom10"].push(item);
        }
        return data; 
    }
}

export interface IPlus {
    version?: string | undefined;
    licensee?: ILicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: IEndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: ILicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: ICopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: IImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: IImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;
}

export class LicenseeInfo implements ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;

    constructor(data?: ILicenseeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licenseeName = data["licenseeName"];
            this.licenseeID = data["licenseeID"];
        }
    }

    static fromJS(data: any): LicenseeInfo {
        let result = new LicenseeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licenseeName"] = this.licenseeName;
        data["licenseeID"] = this.licenseeID;
        return data; 
    }
}

export interface ILicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;
}

export class EndUserInfo implements IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;

    constructor(data?: IEndUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.endUserName = data["endUserName"];
            this.endUserID = data["endUserID"];
        }
    }

    static fromJS(data: any): EndUserInfo {
        let result = new EndUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endUserName"] = this.endUserName;
        data["endUserID"] = this.endUserID;
        return data; 
    }
}

export interface IEndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;
}

export class LicensorInfo implements ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;

    constructor(data?: ILicensorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.licensorName = data["licensorName"];
            this.licensorID = data["licensorID"];
            this.licensorStreetAddress = data["licensorStreetAddress"];
            this.licensorExtendedAddress = data["licensorExtendedAddress"];
            this.licensorCity = data["licensorCity"];
            this.licensorRegion = data["licensorRegion"];
            this.licensorPostalCode = data["licensorPostalCode"];
            this.licensorCountry = data["licensorCountry"];
            this.licensorTelephoneType1 = data["licensorTelephoneType1"];
            this.licensorTelephone1 = data["licensorTelephone1"];
            this.licensorTelephoneType2 = data["licensorTelephoneType2"];
            this.licensorTelephone2 = data["licensorTelephone2"];
            this.licensorEmail = data["licensorEmail"];
            this.licensorURL = data["licensorURL"];
        }
    }

    static fromJS(data: any): LicensorInfo {
        let result = new LicensorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["licensorName"] = this.licensorName;
        data["licensorID"] = this.licensorID;
        data["licensorStreetAddress"] = this.licensorStreetAddress;
        data["licensorExtendedAddress"] = this.licensorExtendedAddress;
        data["licensorCity"] = this.licensorCity;
        data["licensorRegion"] = this.licensorRegion;
        data["licensorPostalCode"] = this.licensorPostalCode;
        data["licensorCountry"] = this.licensorCountry;
        data["licensorTelephoneType1"] = this.licensorTelephoneType1;
        data["licensorTelephone1"] = this.licensorTelephone1;
        data["licensorTelephoneType2"] = this.licensorTelephoneType2;
        data["licensorTelephone2"] = this.licensorTelephone2;
        data["licensorEmail"] = this.licensorEmail;
        data["licensorURL"] = this.licensorURL;
        return data; 
    }
}

export interface ILicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;
}

export class CopyrightOwnerInfo implements ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;

    constructor(data?: ICopyrightOwnerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.copyrightOwnerName = data["copyrightOwnerName"];
            this.copyrightOwnerID = data["copyrightOwnerID"];
        }
    }

    static fromJS(data: any): CopyrightOwnerInfo {
        let result = new CopyrightOwnerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["copyrightOwnerName"] = this.copyrightOwnerName;
        data["copyrightOwnerID"] = this.copyrightOwnerID;
        return data; 
    }
}

export interface ICopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;
}

export class ImageCreatorInfo implements IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;

    constructor(data?: IImageCreatorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageCreatorName = data["imageCreatorName"];
            this.imageCreatorID = data["imageCreatorID"];
        }
    }

    static fromJS(data: any): ImageCreatorInfo {
        let result = new ImageCreatorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageCreatorName"] = this.imageCreatorName;
        data["imageCreatorID"] = this.imageCreatorID;
        return data; 
    }
}

export interface IImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;
}

export class ImageSupplierInfo implements IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;

    constructor(data?: IImageSupplierInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageSupplierName = data["imageSupplierName"];
            this.imageSupplierID = data["imageSupplierID"];
        }
    }

    static fromJS(data: any): ImageSupplierInfo {
        let result = new ImageSupplierInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageSupplierName"] = this.imageSupplierName;
        data["imageSupplierID"] = this.imageSupplierID;
        return data; 
    }
}

export interface IImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;
}

export class Tiff implements ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: ITiff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.artist = data["artist"];
            if (data["bitsPerSample"] && data["bitsPerSample"].constructor === Array) {
                this.bitsPerSample = [];
                for (let item of data["bitsPerSample"])
                    this.bitsPerSample.push(item);
            }
            this.compression = data["compression"];
            if (data["copyright"]) {
                this.copyright = {};
                for (let key in data["copyright"]) {
                    if (data["copyright"].hasOwnProperty(key))
                        this.copyright[key] = data["copyright"][key];
                }
            }
            this.dateTime = data["dateTime"] ? new Date(data["dateTime"].toString()) : <any>undefined;
            if (data["imageDescription"]) {
                this.imageDescription = {};
                for (let key in data["imageDescription"]) {
                    if (data["imageDescription"].hasOwnProperty(key))
                        this.imageDescription[key] = data["imageDescription"][key];
                }
            }
            this.imageLength = data["imageLength"];
            this.imageWidth = data["imageWidth"];
            this.make = data["make"];
            this.model = data["model"];
            this.orientation = data["orientation"];
            this.photometricInterpretation = data["photometricInterpretation"];
            this.planarConfiguration = data["planarConfiguration"];
            if (data["primaryChromaticities"] && data["primaryChromaticities"].constructor === Array) {
                this.primaryChromaticities = [];
                for (let item of data["primaryChromaticities"])
                    this.primaryChromaticities.push(item);
            }
            if (data["referenceBlackWhite"] && data["referenceBlackWhite"].constructor === Array) {
                this.referenceBlackWhite = [];
                for (let item of data["referenceBlackWhite"])
                    this.referenceBlackWhite.push(item);
            }
            this.resolutionUnit = data["resolutionUnit"];
            this.samplesPerPixel = data["samplesPerPixel"];
            this.software = data["software"];
            if (data["transferFunction"] && data["transferFunction"].constructor === Array) {
                this.transferFunction = [];
                for (let item of data["transferFunction"])
                    this.transferFunction.push(item);
            }
            if (data["whitePoint"] && data["whitePoint"].constructor === Array) {
                this.whitePoint = [];
                for (let item of data["whitePoint"])
                    this.whitePoint.push(item);
            }
            this.xResolution = data["xResolution"];
            this.yResolution = data["yResolution"];
            if (data["yCbCrCoefficients"] && data["yCbCrCoefficients"].constructor === Array) {
                this.yCbCrCoefficients = [];
                for (let item of data["yCbCrCoefficients"])
                    this.yCbCrCoefficients.push(item);
            }
            this.yCbCrPositioning = data["yCbCrPositioning"];
            this.yCbCrSubSampling = data["yCbCrSubSampling"];
            this.nativeDigest = data["nativeDigest"];
        }
    }

    static fromJS(data: any): Tiff {
        let result = new Tiff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["artist"] = this.artist;
        if (this.bitsPerSample && this.bitsPerSample.constructor === Array) {
            data["bitsPerSample"] = [];
            for (let item of this.bitsPerSample)
                data["bitsPerSample"].push(item);
        }
        data["compression"] = this.compression;
        if (this.copyright) {
            data["copyright"] = {};
            for (let key in this.copyright) {
                if (this.copyright.hasOwnProperty(key))
                    data["copyright"][key] = this.copyright[key];
            }
        }
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        if (this.imageDescription) {
            data["imageDescription"] = {};
            for (let key in this.imageDescription) {
                if (this.imageDescription.hasOwnProperty(key))
                    data["imageDescription"][key] = this.imageDescription[key];
            }
        }
        data["imageLength"] = this.imageLength;
        data["imageWidth"] = this.imageWidth;
        data["make"] = this.make;
        data["model"] = this.model;
        data["orientation"] = this.orientation;
        data["photometricInterpretation"] = this.photometricInterpretation;
        data["planarConfiguration"] = this.planarConfiguration;
        if (this.primaryChromaticities && this.primaryChromaticities.constructor === Array) {
            data["primaryChromaticities"] = [];
            for (let item of this.primaryChromaticities)
                data["primaryChromaticities"].push(item);
        }
        if (this.referenceBlackWhite && this.referenceBlackWhite.constructor === Array) {
            data["referenceBlackWhite"] = [];
            for (let item of this.referenceBlackWhite)
                data["referenceBlackWhite"].push(item);
        }
        data["resolutionUnit"] = this.resolutionUnit;
        data["samplesPerPixel"] = this.samplesPerPixel;
        data["software"] = this.software;
        if (this.transferFunction && this.transferFunction.constructor === Array) {
            data["transferFunction"] = [];
            for (let item of this.transferFunction)
                data["transferFunction"].push(item);
        }
        if (this.whitePoint && this.whitePoint.constructor === Array) {
            data["whitePoint"] = [];
            for (let item of this.whitePoint)
                data["whitePoint"].push(item);
        }
        data["xResolution"] = this.xResolution;
        data["yResolution"] = this.yResolution;
        if (this.yCbCrCoefficients && this.yCbCrCoefficients.constructor === Array) {
            data["yCbCrCoefficients"] = [];
            for (let item of this.yCbCrCoefficients)
                data["yCbCrCoefficients"].push(item);
        }
        data["yCbCrPositioning"] = this.yCbCrPositioning;
        data["yCbCrSubSampling"] = this.yCbCrSubSampling;
        data["nativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface ITiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;
}

/** Corresponds to tiff.CompressionChoice */
export enum Compression {
    Uncompressed = <any>"Uncompressed", 
    CCITT = <any>"CCITT", 
    T4 = <any>"T4", 
    T6 = <any>"T6", 
    LZW = <any>"LZW", 
    OJPEG = <any>"OJPEG", 
    JPEG = <any>"JPEG", 
    Deflate = <any>"Deflate", 
    T82 = <any>"T82", 
    T43 = <any>"T43", 
    NeXT = <any>"NeXT", 
    ARW = <any>"ARW", 
    RAW = <any>"RAW", 
    SRW = <any>"SRW", 
    Group3_1D = <any>"Group3_1D", 
    PackBits = <any>"PackBits", 
    ThunderScan = <any>"ThunderScan", 
    KDC = <any>"KDC", 
    RasterPadding = <any>"RasterPadding", 
    LineWork = <any>"LineWork", 
    HighContinuous = <any>"HighContinuous", 
    BinaryLineWork = <any>"BinaryLineWork", 
    PixarFilm = <any>"PixarFilm", 
    PixarLog = <any>"PixarLog", 
    DCS = <any>"DCS", 
    JBIG = <any>"JBIG", 
    JPEG2000 = <any>"JPEG2000", 
    NEF = <any>"NEF", 
    JBIG2 = <any>"JBIG2", 
    DCR = <any>"DCR", 
    PEF = <any>"PEF", 
}

/** Corresponds to tiff.OrientationChoice */
export enum Orientation {
    None = <any>"None", 
    TopRowLeftColumn = <any>"TopRowLeftColumn", 
    TopRowRightColumn = <any>"TopRowRightColumn", 
    BottomRowLeftColumn = <any>"BottomRowLeftColumn", 
    BottomRowRightColumn = <any>"BottomRowRightColumn", 
    LeftRowTopColumn = <any>"LeftRowTopColumn", 
    RightRowTopColumn = <any>"RightRowTopColumn", 
    RightRowBottomColumn = <any>"RightRowBottomColumn", 
    LeftRowBottomColumn = <any>"LeftRowBottomColumn", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to tiff.PhotometricInterpretationChoice */
export enum PhotometricInterpretation {
    WhiteIsZero = <any>"WhiteIsZero", 
    BlackIsZero = <any>"BlackIsZero", 
    RGB = <any>"RGB", 
    Palette = <any>"Palette", 
    TransparencyMask = <any>"TransparencyMask", 
    CMYK = <any>"CMYK", 
    YCbCr = <any>"YCbCr", 
    CIELab = <any>"CIELab", 
    ICCLab = <any>"ICCLab", 
    ITULab = <any>"ITULab", 
    ColorFilterArray = <any>"ColorFilterArray", 
    LogL = <any>"LogL", 
    LogLUV = <any>"LogLUV", 
    LinearRaw = <any>"LinearRaw", 
}

/** Corresponds to tiff.PlanarConfigurationChoice */
export enum PlanarConfiguration {
    Chunky = <any>"Chunky", 
    Planar = <any>"Planar", 
    Line = <any>"Line", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum ResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Centimeter = <any>"Centimeter", 
}

/** Corresponds to tiff.YCbCrPositioningChoice */
export enum YCbCrPositioning {
    Centered = <any>"Centered", 
    Cosited = <any>"Cosited", 
}

/** Corresponds to tiff.YCbCrSubSamplingChoice */
export enum YCbCrSubSampling {
    YCbCr111 = <any>"YCbCr111", 
    YCbCr422 = <any>"YCbCr422", 
    YCbCr420 = <any>"YCbCr420", 
}

export class Xmp implements IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;

    constructor(data?: IXmp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.thumbnails) {
                this.thumbnails = [];
                for (let i = 0; i < data.thumbnails.length; i++) {
                    let item = data.thumbnails[i];
                    this.thumbnails[i] = item && !(<any>item).toJSON ? new XmpGImg(item) : <XmpGImg>item;
                }
            }
            if (data.pageInfo) {
                this.pageInfo = [];
                for (let i = 0; i < data.pageInfo.length; i++) {
                    let item = data.pageInfo[i];
                    this.pageInfo[i] = item && !(<any>item).toJSON ? new XmpGImg(item) : <XmpGImg>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseURL = data["baseURL"];
            this.createDate = data["createDate"] ? new Date(data["createDate"].toString()) : <any>undefined;
            this.creatorTool = data["creatorTool"];
            if (data["identifier"] && data["identifier"].constructor === Array) {
                this.identifier = [];
                for (let item of data["identifier"])
                    this.identifier.push(item);
            }
            this.label = data["label"];
            this.metadataDate = data["metadataDate"] ? new Date(data["metadataDate"].toString()) : <any>undefined;
            this.modifyDate = data["modifyDate"] ? new Date(data["modifyDate"].toString()) : <any>undefined;
            this.nickname = data["nickname"];
            this.rating = data["rating"];
            if (data["thumbnails"] && data["thumbnails"].constructor === Array) {
                this.thumbnails = [];
                for (let item of data["thumbnails"])
                    this.thumbnails.push(XmpGImg.fromJS(item));
            }
            if (data["pageInfo"] && data["pageInfo"].constructor === Array) {
                this.pageInfo = [];
                for (let item of data["pageInfo"])
                    this.pageInfo.push(XmpGImg.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Xmp {
        let result = new Xmp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseURL"] = this.baseURL;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["creatorTool"] = this.creatorTool;
        if (this.identifier && this.identifier.constructor === Array) {
            data["identifier"] = [];
            for (let item of this.identifier)
                data["identifier"].push(item);
        }
        data["label"] = this.label;
        data["metadataDate"] = this.metadataDate ? this.metadataDate.toISOString() : <any>undefined;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["nickname"] = this.nickname;
        data["rating"] = this.rating;
        if (this.thumbnails && this.thumbnails.constructor === Array) {
            data["thumbnails"] = [];
            for (let item of this.thumbnails)
                data["thumbnails"].push(item.toJSON());
        }
        if (this.pageInfo && this.pageInfo.constructor === Array) {
            data["pageInfo"] = [];
            for (let item of this.pageInfo)
                data["pageInfo"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: IXmpGImg[] | undefined;
    pageInfo?: IXmpGImg[] | undefined;
}

/** Corresponds to xmp.RatingChoice */
export enum Rating {
    Rejected = <any>"Rejected", 
    Unrated = <any>"Unrated", 
    One = <any>"One", 
    Two = <any>"Two", 
    Three = <any>"Three", 
    Four = <any>"Four", 
    Five = <any>"Five", 
}

export class XmpGImg implements IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;

    constructor(data?: IXmpGImg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.format = data["format"];
            this.width = data["width"];
            this.height = data["height"];
            this.image = data["image"];
        }
    }

    static fromJS(data: any): XmpGImg {
        let result = new XmpGImg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["width"] = this.width;
        data["height"] = this.height;
        data["image"] = this.image;
        return data; 
    }
}

export interface IXmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;
}

/** Corresponds to xmpGImg.FormatChoice */
export enum ImgFormat {
    JPEG = <any>"JPEG", 
}

export class XmpBJ implements IXmpBJ {
    jobRef?: Job[] | undefined;

    constructor(data?: IXmpBJ) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.jobRef) {
                this.jobRef = [];
                for (let i = 0; i < data.jobRef.length; i++) {
                    let item = data.jobRef[i];
                    this.jobRef[i] = item && !(<any>item).toJSON ? new Job(item) : <Job>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["jobRef"] && data["jobRef"].constructor === Array) {
                this.jobRef = [];
                for (let item of data["jobRef"])
                    this.jobRef.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpBJ {
        let result = new XmpBJ();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobRef && this.jobRef.constructor === Array) {
            data["jobRef"] = [];
            for (let item of this.jobRef)
                data["jobRef"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpBJ {
    jobRef?: IJob[] | undefined;
}

export class Job implements IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Job {
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IJob {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class XmpDM implements IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;

    constructor(data?: IXmpDM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.altTimecode = data.altTimecode && !(<any>data.altTimecode).toJSON ? new TimeCode(data.altTimecode) : <TimeCode>this.altTimecode; 
            this.beatSpliceParams = data.beatSpliceParams && !(<any>data.beatSpliceParams).toJSON ? new BeatSpliceStretch(data.beatSpliceParams) : <BeatSpliceStretch>this.beatSpliceParams; 
            if (data.contributedMedia) {
                this.contributedMedia = [];
                for (let i = 0; i < data.contributedMedia.length; i++) {
                    let item = data.contributedMedia[i];
                    this.contributedMedia[i] = item && !(<any>item).toJSON ? new Media(item) : <Media>item;
                }
            }
            this.duration = data.duration && !(<any>data.duration).toJSON ? new Time(data.duration) : <Time>this.duration; 
            this.introTime = data.introTime && !(<any>data.introTime).toJSON ? new Time(data.introTime) : <Time>this.introTime; 
            if (data.markers) {
                this.markers = [];
                for (let i = 0; i < data.markers.length; i++) {
                    let item = data.markers[i];
                    this.markers[i] = item && !(<any>item).toJSON ? new Marker(item) : <Marker>item;
                }
            }
            this.outCue = data.outCue && !(<any>data.outCue).toJSON ? new Time(data.outCue) : <Time>this.outCue; 
            this.projectRef = data.projectRef && !(<any>data.projectRef).toJSON ? new ProjectLink(data.projectRef) : <ProjectLink>this.projectRef; 
            this.relativeTimestamp = data.relativeTimestamp && !(<any>data.relativeTimestamp).toJSON ? new Time(data.relativeTimestamp) : <Time>this.relativeTimestamp; 
            this.resampleParams = data.resampleParams && !(<any>data.resampleParams).toJSON ? new ResampleStretch(data.resampleParams) : <ResampleStretch>this.resampleParams; 
            this.startTimecode = data.startTimecode && !(<any>data.startTimecode).toJSON ? new TimeCode(data.startTimecode) : <TimeCode>this.startTimecode; 
            this.timeScaleParams = data.timeScaleParams && !(<any>data.timeScaleParams).toJSON ? new TimeScaleStretch(data.timeScaleParams) : <TimeScaleStretch>this.timeScaleParams; 
            if (data.tracks) {
                this.tracks = [];
                for (let i = 0; i < data.tracks.length; i++) {
                    let item = data.tracks[i];
                    this.tracks[i] = item && !(<any>item).toJSON ? new Track(item) : <Track>item;
                }
            }
            this.videoAlphaPremultipleColor = data.videoAlphaPremultipleColor && !(<any>data.videoAlphaPremultipleColor).toJSON ? new XmpG(data.videoAlphaPremultipleColor) : <XmpG>this.videoAlphaPremultipleColor; 
            this.videoFrameSize = data.videoFrameSize && !(<any>data.videoFrameSize).toJSON ? new Dimension(data.videoFrameSize) : <Dimension>this.videoFrameSize; 
        }
    }

    init(data?: any) {
        if (data) {
            this.absPeakAudioFilePath = data["absPeakAudioFilePath"];
            this.artist = data["artist"];
            this.album = data["album"];
            this.altTapeName = data["altTapeName"];
            this.altTimecode = data["altTimecode"] ? TimeCode.fromJS(data["altTimecode"]) : <any>undefined;
            this.audioChannelType = data["audioChannelType"];
            this.audioCompressor = data["audioCompressor"];
            this.audioSampleRate = data["audioSampleRate"];
            this.audioSampleType = data["audioSampleType"];
            this.beatSpliceParams = data["beatSpliceParams"] ? BeatSpliceStretch.fromJS(data["beatSpliceParams"]) : <any>undefined;
            this.cameraAngle = data["cameraAngle"];
            this.cameraLabel = data["cameraLabel"];
            this.cameraModel = data["cameraModel"];
            this.cameraMove = data["cameraMove"];
            this.client = data["client"];
            this.comment = data["comment"];
            this.composer = data["composer"];
            if (data["contributedMedia"] && data["contributedMedia"].constructor === Array) {
                this.contributedMedia = [];
                for (let item of data["contributedMedia"])
                    this.contributedMedia.push(Media.fromJS(item));
            }
            this.director = data["director"];
            this.directorPhotography = data["directorPhotography"];
            this.duration = data["duration"] ? Time.fromJS(data["duration"]) : <any>undefined;
            this.engineer = data["engineer"];
            this.fileDataRate = data["fileDataRate"];
            this.genre = data["genre"];
            this.good = data["good"];
            this.instrument = data["instrument"];
            this.introTime = data["introTime"] ? Time.fromJS(data["introTime"]) : <any>undefined;
            this.key = data["key"];
            this.logComment = data["logComment"];
            this.loop = data["loop"];
            this.numberOfBeats = data["numberOfBeats"];
            if (data["markers"] && data["markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.outCue = data["outCue"] ? Time.fromJS(data["outCue"]) : <any>undefined;
            this.projectName = data["projectName"];
            this.projectRef = data["projectRef"] ? ProjectLink.fromJS(data["projectRef"]) : <any>undefined;
            this.pullDown = data["pullDown"];
            this.relativePeakAudioFilePath = data["relativePeakAudioFilePath"];
            this.relativeTimestamp = data["relativeTimestamp"] ? Time.fromJS(data["relativeTimestamp"]) : <any>undefined;
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            this.resampleParams = data["resampleParams"] ? ResampleStretch.fromJS(data["resampleParams"]) : <any>undefined;
            this.scaleType = data["scaleType"];
            this.scene = data["scene"];
            this.shotDate = data["shotDate"] ? new Date(data["shotDate"].toString()) : <any>undefined;
            this.shotDay = data["shotDay"];
            this.shotLocation = data["shotLocation"];
            this.shotName = data["shotName"];
            this.shotNumber = data["shotNumber"];
            this.shotSize = data["shotSize"];
            this.speakerPlacement = data["speakerPlacement"];
            this.startTimecode = data["startTimecode"] ? TimeCode.fromJS(data["startTimecode"]) : <any>undefined;
            this.stretchMode = data["stretchMode"];
            this.takeNumber = data["takeNumber"];
            this.tapeName = data["tapeName"];
            this.tempo = data["tempo"];
            this.timeScaleParams = data["timeScaleParams"] ? TimeScaleStretch.fromJS(data["timeScaleParams"]) : <any>undefined;
            this.timeSignature = data["timeSignature"];
            this.trackNumber = data["trackNumber"];
            if (data["tracks"] && data["tracks"].constructor === Array) {
                this.tracks = [];
                for (let item of data["tracks"])
                    this.tracks.push(Track.fromJS(item));
            }
            this.videoAlphaMode = data["videoAlphaMode"];
            this.videoAlphaPremultipleColor = data["videoAlphaPremultipleColor"] ? XmpG.fromJS(data["videoAlphaPremultipleColor"]) : <any>undefined;
            this.videoAlphaUnityIsTransparent = data["videoAlphaUnityIsTransparent"];
            this.videoColorSpace = data["videoColorSpace"];
            this.videoCompressor = data["videoCompressor"];
            this.videoFieldOrder = data["videoFieldOrder"];
            this.videoFrameRate = data["videoFrameRate"];
            this.videoFrameSize = data["videoFrameSize"] ? Dimension.fromJS(data["videoFrameSize"]) : <any>undefined;
            this.videoPixelDepth = data["videoPixelDepth"];
            this.videoPixelAspectRatio = data["videoPixelAspectRatio"];
        }
    }

    static fromJS(data: any): XmpDM {
        let result = new XmpDM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absPeakAudioFilePath"] = this.absPeakAudioFilePath;
        data["artist"] = this.artist;
        data["album"] = this.album;
        data["altTapeName"] = this.altTapeName;
        data["altTimecode"] = this.altTimecode ? this.altTimecode.toJSON() : <any>undefined;
        data["audioChannelType"] = this.audioChannelType;
        data["audioCompressor"] = this.audioCompressor;
        data["audioSampleRate"] = this.audioSampleRate;
        data["audioSampleType"] = this.audioSampleType;
        data["beatSpliceParams"] = this.beatSpliceParams ? this.beatSpliceParams.toJSON() : <any>undefined;
        data["cameraAngle"] = this.cameraAngle;
        data["cameraLabel"] = this.cameraLabel;
        data["cameraModel"] = this.cameraModel;
        data["cameraMove"] = this.cameraMove;
        data["client"] = this.client;
        data["comment"] = this.comment;
        data["composer"] = this.composer;
        if (this.contributedMedia && this.contributedMedia.constructor === Array) {
            data["contributedMedia"] = [];
            for (let item of this.contributedMedia)
                data["contributedMedia"].push(item.toJSON());
        }
        data["director"] = this.director;
        data["directorPhotography"] = this.directorPhotography;
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["engineer"] = this.engineer;
        data["fileDataRate"] = this.fileDataRate;
        data["genre"] = this.genre;
        data["good"] = this.good;
        data["instrument"] = this.instrument;
        data["introTime"] = this.introTime ? this.introTime.toJSON() : <any>undefined;
        data["key"] = this.key;
        data["logComment"] = this.logComment;
        data["loop"] = this.loop;
        data["numberOfBeats"] = this.numberOfBeats;
        if (this.markers && this.markers.constructor === Array) {
            data["markers"] = [];
            for (let item of this.markers)
                data["markers"].push(item.toJSON());
        }
        data["outCue"] = this.outCue ? this.outCue.toJSON() : <any>undefined;
        data["projectName"] = this.projectName;
        data["projectRef"] = this.projectRef ? this.projectRef.toJSON() : <any>undefined;
        data["pullDown"] = this.pullDown;
        data["relativePeakAudioFilePath"] = this.relativePeakAudioFilePath;
        data["relativeTimestamp"] = this.relativeTimestamp ? this.relativeTimestamp.toJSON() : <any>undefined;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["resampleParams"] = this.resampleParams ? this.resampleParams.toJSON() : <any>undefined;
        data["scaleType"] = this.scaleType;
        data["scene"] = this.scene;
        data["shotDate"] = this.shotDate ? this.shotDate.toISOString() : <any>undefined;
        data["shotDay"] = this.shotDay;
        data["shotLocation"] = this.shotLocation;
        data["shotName"] = this.shotName;
        data["shotNumber"] = this.shotNumber;
        data["shotSize"] = this.shotSize;
        data["speakerPlacement"] = this.speakerPlacement;
        data["startTimecode"] = this.startTimecode ? this.startTimecode.toJSON() : <any>undefined;
        data["stretchMode"] = this.stretchMode;
        data["takeNumber"] = this.takeNumber;
        data["tapeName"] = this.tapeName;
        data["tempo"] = this.tempo;
        data["timeScaleParams"] = this.timeScaleParams ? this.timeScaleParams.toJSON() : <any>undefined;
        data["timeSignature"] = this.timeSignature;
        data["trackNumber"] = this.trackNumber;
        if (this.tracks && this.tracks.constructor === Array) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        data["videoAlphaMode"] = this.videoAlphaMode;
        data["videoAlphaPremultipleColor"] = this.videoAlphaPremultipleColor ? this.videoAlphaPremultipleColor.toJSON() : <any>undefined;
        data["videoAlphaUnityIsTransparent"] = this.videoAlphaUnityIsTransparent;
        data["videoColorSpace"] = this.videoColorSpace;
        data["videoCompressor"] = this.videoCompressor;
        data["videoFieldOrder"] = this.videoFieldOrder;
        data["videoFrameRate"] = this.videoFrameRate;
        data["videoFrameSize"] = this.videoFrameSize ? this.videoFrameSize.toJSON() : <any>undefined;
        data["videoPixelDepth"] = this.videoPixelDepth;
        data["videoPixelAspectRatio"] = this.videoPixelAspectRatio;
        return data; 
    }
}

export interface IXmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: ITimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: IBeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: IMedia[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: ITime | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: ITime | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: IMarker[] | undefined;
    outCue?: ITime | undefined;
    projectName?: string | undefined;
    projectRef?: IProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: ITime | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: IResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: ITimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: ITimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: ITrack[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: IXmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: IDimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;
}

export class TimeCode implements ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;

    constructor(data?: ITimeCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeFormat = data["timeFormat"];
            this.timeValue = data["timeValue"];
        }
    }

    static fromJS(data: any): TimeCode {
        let result = new TimeCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeFormat"] = this.timeFormat;
        data["timeValue"] = this.timeValue;
        return data; 
    }
}

export interface ITimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;
}

/** Corresponds to Timecode.TimeFormatChoice */
export enum TimeFormat {
    Timecode24 = <any>"Timecode24", 
    Timecode25 = <any>"Timecode25", 
    Timecode2997Drop = <any>"Timecode2997Drop", 
    Timecode2997NonDrop = <any>"Timecode2997NonDrop", 
    Timecode30 = <any>"Timecode30", 
    Timecode50 = <any>"Timecode50", 
    Timecode5994Drop = <any>"Timecode5994Drop", 
    Timecode5994NonDrop = <any>"Timecode5994NonDrop", 
    Timecode60 = <any>"Timecode60", 
    Timecode23976 = <any>"Timecode23976", 
}

/** Corresponds to xmpDM.AudioChannelTypeChoice */
export enum AudioChannelType {
    CHANNEL_MONO = <any>"CHANNEL_MONO", 
    CHANNEL_STEREO = <any>"CHANNEL_STEREO", 
    CHANNEL_5_1 = <any>"CHANNEL_5_1", 
    CHANNEL_7_1 = <any>"CHANNEL_7_1", 
    CHANNEL_16 = <any>"CHANNEL_16", 
    CHANNEL_OTHER = <any>"CHANNEL_OTHER", 
}

/** Corresponds to xmpDM.AudioSampleTypeChoice */
export enum AudioSampleType {
    SAMPLE_8_INT = <any>"SAMPLE_8_INT", 
    SAMPLE_16_INT = <any>"SAMPLE_16_INT", 
    SAMPLE_24_INT = <any>"SAMPLE_24_INT", 
    SAMPLE_32_INT = <any>"SAMPLE_32_INT", 
    SAMPLE_32_FLOAT = <any>"SAMPLE_32_FLOAT", 
    SAMPLE_COMPRESSED = <any>"SAMPLE_COMPRESSED", 
    SAMPLE_PACKED = <any>"SAMPLE_PACKED", 
    SAMPLE_OTHER = <any>"SAMPLE_OTHER", 
}

export class BeatSpliceStretch implements IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;

    constructor(data?: IBeatSpliceStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.riseInTimeDuration = data.riseInTimeDuration && !(<any>data.riseInTimeDuration).toJSON ? new Time(data.riseInTimeDuration) : <Time>this.riseInTimeDuration; 
        }
    }

    init(data?: any) {
        if (data) {
            this.riseInDecibel = data["riseInDecibel"];
            this.riseInTimeDuration = data["riseInTimeDuration"] ? Time.fromJS(data["riseInTimeDuration"]) : <any>undefined;
            this.useFileBeatsMarker = data["useFileBeatsMarker"];
        }
    }

    static fromJS(data: any): BeatSpliceStretch {
        let result = new BeatSpliceStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riseInDecibel"] = this.riseInDecibel;
        data["riseInTimeDuration"] = this.riseInTimeDuration ? this.riseInTimeDuration.toJSON() : <any>undefined;
        data["useFileBeatsMarker"] = this.useFileBeatsMarker;
        return data; 
    }
}

export interface IBeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: ITime | undefined;
    useFileBeatsMarker?: boolean | undefined;
}

export class Time implements ITime {
    scale?: string | undefined;
    value?: number | undefined;

    constructor(data?: ITime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scale = data["scale"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Time {
        let result = new Time();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scale"] = this.scale;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITime {
    scale?: string | undefined;
    value?: number | undefined;
}

/** Corresponds to xmpDM.CameraAngleChoice */
export enum CameraAngle {
    ANGLE_LOW = <any>"ANGLE_LOW", 
    ANGLE_EYE_LEVEL = <any>"ANGLE_EYE_LEVEL", 
    ANGLE_HIGH = <any>"ANGLE_HIGH", 
    ANGLE_OVERHEAD_SHOT = <any>"ANGLE_OVERHEAD_SHOT", 
    ANGLE_BIRDS_EYE_SHOT = <any>"ANGLE_BIRDS_EYE_SHOT", 
    ANGLE_DUTCH = <any>"ANGLE_DUTCH", 
    ANGLE_POV = <any>"ANGLE_POV", 
    ANGLE_OVER_THE_SHOULDER = <any>"ANGLE_OVER_THE_SHOULDER", 
    ANGLE_REACTION_SHOT = <any>"ANGLE_REACTION_SHOT", 
}

/** Corresponds to xmpDM.CameraMoveChoice */
export enum CameraMove {
    MOVE_AERIAL = <any>"MOVE_AERIAL", 
    MOVE_BOOM_UP = <any>"MOVE_BOOM_UP", 
    MOVE_BOOM_DOWN = <any>"MOVE_BOOM_DOWN", 
    MOVE_CRANE_UP = <any>"MOVE_CRANE_UP", 
    MOVE_CRANE_DOWN = <any>"MOVE_CRANE_DOWN", 
    MOVE_DOLLY_IN = <any>"MOVE_DOLLY_IN", 
    MOVE_DOLLY_OUT = <any>"MOVE_DOLLY_OUT", 
    MOVE_PAN_LEFT = <any>"MOVE_PAN_LEFT", 
    MOVE_PAN_RIGHT = <any>"MOVE_PAN_RIGHT", 
    MOVE_PEDESTAL_UP = <any>"MOVE_PEDESTAL_UP", 
    MOVE_PEDESTAL_DOWN = <any>"MOVE_PEDESTAL_DOWN", 
    MOVE_TILT_UP = <any>"MOVE_TILT_UP", 
    MOVE_TILT_DOWN = <any>"MOVE_TILT_DOWN", 
    MOVE_TRACKING = <any>"MOVE_TRACKING", 
    MOVE_TRUCK_LEFT = <any>"MOVE_TRUCK_LEFT", 
    MOVE_TRUCK_RIGHT = <any>"MOVE_TRUCK_RIGHT", 
    MOVE_ZOOM_IN = <any>"MOVE_ZOOM_IN", 
    MOVE_ZOOM_OUT = <any>"MOVE_ZOOM_OUT", 
}

export class Media implements IMedia {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.duration = data.duration && !(<any>data.duration).toJSON ? new Time(data.duration) : <Time>this.duration; 
            this.startTime = data.startTime && !(<any>data.startTime).toJSON ? new Time(data.startTime) : <Time>this.startTime; 
        }
    }

    init(data?: any) {
        if (data) {
            this.duration = data["duration"] ? Time.fromJS(data["duration"]) : <any>undefined;
            this.managed = data["managed"];
            this.path = data["path"];
            this.startTime = data["startTime"] ? Time.fromJS(data["startTime"]) : <any>undefined;
            this.track = data["track"];
            this.webStatement = data["webStatement"];
        }
    }

    static fromJS(data: any): Media {
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duration"] = this.duration ? this.duration.toJSON() : <any>undefined;
        data["managed"] = this.managed;
        data["path"] = this.path;
        data["startTime"] = this.startTime ? this.startTime.toJSON() : <any>undefined;
        data["track"] = this.track;
        data["webStatement"] = this.webStatement;
        return data; 
    }
}

export interface IMedia {
    duration?: ITime | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: ITime | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;
}

/** Corresponds to xmpDM.AudioMusicalKeyChoice */
export enum AudioMusicalKey {
    KEY_C = <any>"KEY_C", 
    KEY_C_SHARP = <any>"KEY_C_SHARP", 
    KEY_D = <any>"KEY_D", 
    KEY_D_SHARP = <any>"KEY_D_SHARP", 
    KEY_E = <any>"KEY_E", 
    KEY_F = <any>"KEY_F", 
    KEY_F_SHARP = <any>"KEY_F_SHARP", 
    KEY_G = <any>"KEY_G", 
    KEY_G_SHARP = <any>"KEY_G_SHARP", 
    KEY_A = <any>"KEY_A", 
    KEY_A_SHARP = <any>"KEY_A_SHARP", 
    KEY_B = <any>"KEY_B", 
}

export class Marker implements IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;

    constructor(data?: IMarker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            if (data["cuePointParams"]) {
                this.cuePointParams = {};
                for (let key in data["cuePointParams"]) {
                    if (data["cuePointParams"].hasOwnProperty(key))
                        this.cuePointParams[key] = data["cuePointParams"][key];
                }
            }
            this.cuePointType = data["cuePointType"];
            this.duration = data["duration"];
            this.location = data["location"];
            this.name = data["name"];
            this.probability = data["probability"];
            this.speaker = data["speaker"];
            this.startTime = data["startTime"];
            this.target = data["target"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Marker {
        let result = new Marker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        if (this.cuePointParams) {
            data["cuePointParams"] = {};
            for (let key in this.cuePointParams) {
                if (this.cuePointParams.hasOwnProperty(key))
                    data["cuePointParams"][key] = this.cuePointParams[key];
            }
        }
        data["cuePointType"] = this.cuePointType;
        data["duration"] = this.duration;
        data["location"] = this.location;
        data["name"] = this.name;
        data["probability"] = this.probability;
        data["speaker"] = this.speaker;
        data["startTime"] = this.startTime;
        data["target"] = this.target;
        data["type"] = this.type;
        return data; 
    }
}

export interface IMarker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;
}

/** Corresponds to Xmp.Media.Marker.TypeChoice */
export enum MarkerType {
    Chapter = <any>"Chapter", 
    Cue = <any>"Cue", 
    Index = <any>"Index", 
    Speech = <any>"Speech", 
    Track = <any>"Track", 
}

export class ProjectLink implements IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;

    constructor(data?: IProjectLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["path"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ProjectLink {
        let result = new ProjectLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["type"] = this.type;
        return data; 
    }
}

export interface IProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;
}

/** Corresponds to Xmp.Media.ProjectLink.TypeChoice */
export enum ProjectLinkType {
    Movie = <any>"Movie", 
    Still = <any>"Still", 
    Audio = <any>"Audio", 
    Custom = <any>"Custom", 
}

/** Corresponds to xmpDM.VideoPullDownChoice */
export enum VideoPullDown {
    PULLDOWN_WSSWW = <any>"PULLDOWN_WSSWW", 
    PULLDOWN_SSWWW = <any>"PULLDOWN_SSWWW", 
    PULLDOWN_SWWWS = <any>"PULLDOWN_SWWWS", 
    PULLDOWN_WWWSS = <any>"PULLDOWN_WWWSS", 
    PULLDOWN_WWSSW = <any>"PULLDOWN_WWSSW", 
    PULLDOWN_WWWSW = <any>"PULLDOWN_WWWSW", 
    PULLDOWN_WWSWW = <any>"PULLDOWN_WWSWW", 
    PULLDOWN_WSWWW = <any>"PULLDOWN_WSWWW", 
    PULLDOWN_SWWWW = <any>"PULLDOWN_SWWWW", 
    PULLDOWN_WWWWS = <any>"PULLDOWN_WWWWS", 
}

export class ResampleStretch implements IResampleStretch {
    quality?: Quality | undefined;

    constructor(data?: IResampleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quality = data["quality"];
        }
    }

    static fromJS(data: any): ResampleStretch {
        let result = new ResampleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quality"] = this.quality;
        return data; 
    }
}

export interface IResampleStretch {
    quality?: Quality | undefined;
}

/** Corresponds to Xmp.Media.resampleStretch.QualityChoice and Xmp.Media.timeScaleStretch.QualityChoice */
export enum Quality {
    High = <any>"High", 
    Medium = <any>"Medium", 
    Low = <any>"Low", 
}

/** Corresponds to xmpDM.AudioMusicalScaleTypeChoice */
export enum AudioMusicalScaleType {
    SCALE_MAJOR = <any>"SCALE_MAJOR", 
    SCALE_MINOR = <any>"SCALE_MINOR", 
    SCALE_BOTH = <any>"SCALE_BOTH", 
    SCALE_NEITHER = <any>"SCALE_NEITHER", 
}

/** Corresponds to xmpDM.ShotSizeChoice */
export enum ShotSize {
    SHOT_ECU = <any>"SHOT_ECU", 
    SHOT_MCU = <any>"SHOT_MCU", 
    SHOT_CU = <any>"SHOT_CU", 
    SHOT_MS = <any>"SHOT_MS", 
    SHOT_WS = <any>"SHOT_WS", 
    SHOT_MWS = <any>"SHOT_MWS", 
    SHOT_EWS = <any>"SHOT_EWS", 
}

/** Corresponds to xmpDM.AudioStretchModeChoice */
export enum AudioStretchMode {
    STRETCH_FIXED_LENGTH = <any>"STRETCH_FIXED_LENGTH", 
    STRETCH_TIME_SCALE = <any>"STRETCH_TIME_SCALE", 
    STRETCH_RESAMPLE = <any>"STRETCH_RESAMPLE", 
    STRETCH_BEAT_SPLICE = <any>"STRETCH_BEAT_SPLICE", 
    STRETCH_HYBRID = <any>"STRETCH_HYBRID", 
}

export class TimeScaleStretch implements ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;

    constructor(data?: ITimeScaleStretch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameOverlappingPercentage = data["frameOverlappingPercentage"];
            this.frameSize = data["frameSize"];
            this.quality = data["quality"];
        }
    }

    static fromJS(data: any): TimeScaleStretch {
        let result = new TimeScaleStretch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameOverlappingPercentage"] = this.frameOverlappingPercentage;
        data["frameSize"] = this.frameSize;
        data["quality"] = this.quality;
        return data; 
    }
}

export interface ITimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;
}

/** Corresponds to xmpDM.TimeSignatureChoice */
export enum TimeSignature {
    TIME_2_4 = <any>"TIME_2_4", 
    TIME_3_4 = <any>"TIME_3_4", 
    TIME_4_4 = <any>"TIME_4_4", 
    TIME_5_4 = <any>"TIME_5_4", 
    TIME_7_4 = <any>"TIME_7_4", 
    TIME_6_8 = <any>"TIME_6_8", 
    TIME_9_8 = <any>"TIME_9_8", 
    TIME_12_8 = <any>"TIME_12_8", 
    TIME_OTHER = <any>"TIME_OTHER", 
}

export class Track implements ITrack {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;

    constructor(data?: ITrack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.markers) {
                this.markers = [];
                for (let i = 0; i < data.markers.length; i++) {
                    let item = data.markers[i];
                    this.markers[i] = item && !(<any>item).toJSON ? new Marker(item) : <Marker>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameRate = data["frameRate"];
            if (data["markers"] && data["markers"].constructor === Array) {
                this.markers = [];
                for (let item of data["markers"])
                    this.markers.push(Marker.fromJS(item));
            }
            this.trackName = data["trackName"];
            this.trackType = data["trackType"];
        }
    }

    static fromJS(data: any): Track {
        let result = new Track();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameRate"] = this.frameRate;
        if (this.markers && this.markers.constructor === Array) {
            data["markers"] = [];
            for (let item of this.markers)
                data["markers"].push(item.toJSON());
        }
        data["trackName"] = this.trackName;
        data["trackType"] = this.trackType;
        return data; 
    }
}

export interface ITrack {
    frameRate?: string | undefined;
    markers?: IMarker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;
}

/** Corresponds to xmpDM.VideoAlphaModeChoice */
export enum VideoAlphaMode {
    ALPHA_MODE_STRAIGHT = <any>"ALPHA_MODE_STRAIGHT", 
    ALPHA_MODE_PREMULTIPLIED = <any>"ALPHA_MODE_PREMULTIPLIED", 
    ALPHA_MODE_NONE = <any>"ALPHA_MODE_NONE", 
}

export class XmpG implements IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;

    constructor(data?: IXmpG) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a = data["a"];
            this.b = data["b"];
            this.l = data["l"];
            this.black = data["black"];
            this.cyan = data["cyan"];
            this.magenta = data["magenta"];
            this.yellow = data["yellow"];
            this.blue = data["blue"];
            this.green = data["green"];
            this.red = data["red"];
            this.mode = data["mode"];
            this.swatchName = data["swatchName"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): XmpG {
        let result = new XmpG();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["b"] = this.b;
        data["l"] = this.l;
        data["black"] = this.black;
        data["cyan"] = this.cyan;
        data["magenta"] = this.magenta;
        data["yellow"] = this.yellow;
        data["blue"] = this.blue;
        data["green"] = this.green;
        data["red"] = this.red;
        data["mode"] = this.mode;
        data["swatchName"] = this.swatchName;
        data["type"] = this.type;
        return data; 
    }
}

export interface IXmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;
}

/** Corresponds to xmpG.ModeChoice */
export enum ColorantMode {
    CMYK = <any>"CMYK", 
    RGB = <any>"RGB", 
    LAB = <any>"LAB", 
}

/** Corresponds to xmpG.TypeChoice */
export enum ColorantType {
    Process = <any>"Process", 
    Spot = <any>"Spot", 
}

/** Corresponds to xmpDM.VideoColorSpaceChoice */
export enum VideoColorSpace {
    COLOR_SPACE_SRGB = <any>"COLOR_SPACE_SRGB", 
    COLOR_SPACE_CCIR_601 = <any>"COLOR_SPACE_CCIR_601", 
    COLOR_SPACE_CCIR_709 = <any>"COLOR_SPACE_CCIR_709", 
}

/** Corresponds to xmpDM.VideoFieldOrderChoice */
export enum VideoFieldOrder {
    FIELD_ORDER_UPPER = <any>"FIELD_ORDER_UPPER", 
    FIELD_ORDER_LOWER = <any>"FIELD_ORDER_LOWER", 
    FIELD_ORDER_PROGRESSIVE = <any>"FIELD_ORDER_PROGRESSIVE", 
}

/** Corresponds to xmpDM.VideoFrameRateChoice */
export enum VideoFrameRate {
    FRAME_RATE_24 = <any>"FRAME_RATE_24", 
    FRAME_RATE_NTSC = <any>"FRAME_RATE_NTSC", 
    FRAME_RATE_PAL = <any>"FRAME_RATE_PAL", 
}

export class Dimension implements IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;

    constructor(data?: IDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.height = data["height"];
            this.width = data["width"];
            this.unit = data["unit"];
        }
    }

    static fromJS(data: any): Dimension {
        let result = new Dimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["height"] = this.height;
        data["width"] = this.width;
        data["unit"] = this.unit;
        return data; 
    }
}

export interface IDimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;
}

/** Corresponds to stDim.UnitChoice */
export enum Unit {
    Inch = <any>"Inch", 
    Millimeter = <any>"Millimeter", 
    Centimeter = <any>"Centimeter", 
    Pixel = <any>"Pixel", 
    Pica = <any>"Pica", 
    Point = <any>"Point", 
}

/** Corresponds to xmpDM.VideoPixelDepthChoice */
export enum VideoPixelDepth {
    PIXEL_DEPTH_8_INT = <any>"PIXEL_DEPTH_8_INT", 
    PIXEL_DEPTH_16_INT = <any>"PIXEL_DEPTH_16_INT", 
    PIXEL_DEPTH_24_INT = <any>"PIXEL_DEPTH_24_INT", 
    PIXEL_DEPTH_32_INT = <any>"PIXEL_DEPTH_32_INT", 
    PIXEL_DEPTH_32_FLOAT = <any>"PIXEL_DEPTH_32_FLOAT", 
    PIXEL_DEPTH_OTHER = <any>"PIXEL_DEPTH_OTHER", 
}

export class Xmpidq implements IXmpidq {
    scheme?: string | undefined;

    constructor(data?: IXmpidq) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheme = data["scheme"];
        }
    }

    static fromJS(data: any): Xmpidq {
        let result = new Xmpidq();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        return data; 
    }
}

export interface IXmpidq {
    scheme?: string | undefined;
}

export class XmpMM implements IXmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo2[] | undefined;

    constructor(data?: IXmpMM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.derivedFrom = data.derivedFrom && !(<any>data.derivedFrom).toJSON ? new Reference(data.derivedFrom) : <Reference>this.derivedFrom; 
            if (data.history) {
                this.history = [];
                for (let i = 0; i < data.history.length; i++) {
                    let item = data.history[i];
                    this.history[i] = item && !(<any>item).toJSON ? new Event(item) : <Event>item;
                }
            }
            if (data.ingredients) {
                this.ingredients = [];
                for (let i = 0; i < data.ingredients.length; i++) {
                    let item = data.ingredients[i];
                    this.ingredients[i] = item && !(<any>item).toJSON ? new Reference(item) : <Reference>item;
                }
            }
            this.managedFrom = data.managedFrom && !(<any>data.managedFrom).toJSON ? new Reference(data.managedFrom) : <Reference>this.managedFrom; 
            if (data.versions) {
                this.versions = [];
                for (let i = 0; i < data.versions.length; i++) {
                    let item = data.versions[i];
                    this.versions[i] = item && !(<any>item).toJSON ? new VersionInfo2(item) : <VersionInfo2>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.derivedFrom = data["derivedFrom"] ? Reference.fromJS(data["derivedFrom"]) : <any>undefined;
            this.documentID = data["documentID"];
            if (data["history"] && data["history"].constructor === Array) {
                this.history = [];
                for (let item of data["history"])
                    this.history.push(Event.fromJS(item));
            }
            if (data["ingredients"] && data["ingredients"].constructor === Array) {
                this.ingredients = [];
                for (let item of data["ingredients"])
                    this.ingredients.push(Reference.fromJS(item));
            }
            this.instanceID = data["instanceID"];
            this.managedFrom = data["managedFrom"] ? Reference.fromJS(data["managedFrom"]) : <any>undefined;
            this.manager = data["manager"];
            this.manageTo = data["manageTo"];
            this.manageUI = data["manageUI"];
            this.managerVariant = data["managerVariant"];
            this.originalDocumentID = data["originalDocumentID"];
            this.renditionClass = data["renditionClass"];
            this.renditionParams = data["renditionParams"];
            this.versionID = data["versionID"];
            if (data["versions"] && data["versions"].constructor === Array) {
                this.versions = [];
                for (let item of data["versions"])
                    this.versions.push(VersionInfo2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMM {
        let result = new XmpMM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["derivedFrom"] = this.derivedFrom ? this.derivedFrom.toJSON() : <any>undefined;
        data["documentID"] = this.documentID;
        if (this.history && this.history.constructor === Array) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        if (this.ingredients && this.ingredients.constructor === Array) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item.toJSON());
        }
        data["instanceID"] = this.instanceID;
        data["managedFrom"] = this.managedFrom ? this.managedFrom.toJSON() : <any>undefined;
        data["manager"] = this.manager;
        data["manageTo"] = this.manageTo;
        data["manageUI"] = this.manageUI;
        data["managerVariant"] = this.managerVariant;
        data["originalDocumentID"] = this.originalDocumentID;
        data["renditionClass"] = this.renditionClass;
        data["renditionParams"] = this.renditionParams;
        data["versionID"] = this.versionID;
        if (this.versions && this.versions.constructor === Array) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IXmpMM {
    derivedFrom?: IReference | undefined;
    documentID?: string | undefined;
    history?: IEvent[] | undefined;
    ingredients?: IReference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: IReference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: IVersionInfo2[] | undefined;
}

export class Reference implements IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["alternatePaths"] && data["alternatePaths"].constructor === Array) {
                this.alternatePaths = [];
                for (let item of data["alternatePaths"])
                    this.alternatePaths.push(item);
            }
            this.documentID = data["documentID"];
            this.filePath = data["filePath"];
            this.fromPart = data["fromPart"];
            this.instanceID = data["instanceID"];
            this.lastModifyDate = data["lastModifyDate"] ? new Date(data["lastModifyDate"].toString()) : <any>undefined;
            this.manager = data["manager"];
            this.managerVariant = data["managerVariant"];
            this.manageTo = data["manageTo"];
            this.manageUI = data["manageUI"];
            this.maskMarkers = data["maskMarkers"];
            this.originalDocumentID = data["originalDocumentID"];
            this.partMapping = data["partMapping"];
            this.renditionClass = data["renditionClass"];
            this.renditionParams = data["renditionParams"];
            this.toPart = data["toPart"];
            this.versionID = data["versionID"];
        }
    }

    static fromJS(data: any): Reference {
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.alternatePaths && this.alternatePaths.constructor === Array) {
            data["alternatePaths"] = [];
            for (let item of this.alternatePaths)
                data["alternatePaths"].push(item);
        }
        data["documentID"] = this.documentID;
        data["filePath"] = this.filePath;
        data["fromPart"] = this.fromPart;
        data["instanceID"] = this.instanceID;
        data["lastModifyDate"] = this.lastModifyDate ? this.lastModifyDate.toISOString() : <any>undefined;
        data["manager"] = this.manager;
        data["managerVariant"] = this.managerVariant;
        data["manageTo"] = this.manageTo;
        data["manageUI"] = this.manageUI;
        data["maskMarkers"] = this.maskMarkers;
        data["originalDocumentID"] = this.originalDocumentID;
        data["partMapping"] = this.partMapping;
        data["renditionClass"] = this.renditionClass;
        data["renditionParams"] = this.renditionParams;
        data["toPart"] = this.toPart;
        data["versionID"] = this.versionID;
        return data; 
    }
}

export interface IReference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;
}

/** Corresponds to stRef.MaskMarkersChoice */
export enum MaskMarkers {
    All = <any>"All", 
    None = <any>"None", 
}

export class Event implements IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.changed = data["changed"];
            this.instanceID = data["instanceID"];
            this.parameters = data["parameters"];
            this.softwareAgent = data["softwareAgent"];
            this.when = data["when"] ? new Date(data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["changed"] = this.changed;
        data["instanceID"] = this.instanceID;
        data["parameters"] = this.parameters;
        data["softwareAgent"] = this.softwareAgent;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEvent {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;
}

/** Corresponds to stEvt.ActionChoice */
export enum EventAction {
    Converted = <any>"Converted", 
    Copied = <any>"Copied", 
    Created = <any>"Created", 
    Cropped = <any>"Cropped", 
    Edited = <any>"Edited", 
    Filtered = <any>"Filtered", 
    Formatted = <any>"Formatted", 
    VersionUpdated = <any>"VersionUpdated", 
    Printed = <any>"Printed", 
    Published = <any>"Published", 
    Managed = <any>"Managed", 
    Produced = <any>"Produced", 
    Resized = <any>"Resized", 
    Saved = <any>"Saved", 
    Derived = <any>"Derived", 
}

export class VersionInfo2 implements IVersionInfo2 {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;

    constructor(data?: IVersionInfo2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.event = data.event && !(<any>data.event).toJSON ? new Event(data.event) : <Event>this.event; 
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.modifier = data["modifier"];
            this.modifyDate = data["modifyDate"] ? new Date(data["modifyDate"].toString()) : <any>undefined;
            this.version = data["version"];
        }
    }

    static fromJS(data: any): VersionInfo2 {
        let result = new VersionInfo2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["modifier"] = this.modifier;
        data["modifyDate"] = this.modifyDate ? this.modifyDate.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IVersionInfo2 {
    comments?: string | undefined;
    event?: IEvent | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;
}

export class XmpNote implements IXmpNote {
    hasExtendedXMP?: string | undefined;

    constructor(data?: IXmpNote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasExtendedXMP = data["hasExtendedXMP"];
        }
    }

    static fromJS(data: any): XmpNote {
        let result = new XmpNote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasExtendedXMP"] = this.hasExtendedXMP;
        return data; 
    }
}

export interface IXmpNote {
    hasExtendedXMP?: string | undefined;
}

export class XmpRights implements IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;

    constructor(data?: IXmpRights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.certificate = data["certificate"];
            this.marked = data["marked"];
            if (data["owner"] && data["owner"].constructor === Array) {
                this.owner = [];
                for (let item of data["owner"])
                    this.owner.push(item);
            }
            if (data["usageTerms"]) {
                this.usageTerms = {};
                for (let key in data["usageTerms"]) {
                    if (data["usageTerms"].hasOwnProperty(key))
                        this.usageTerms[key] = data["usageTerms"][key];
                }
            }
            this.webStatement = data["webStatement"];
        }
    }

    static fromJS(data: any): XmpRights {
        let result = new XmpRights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificate"] = this.certificate;
        data["marked"] = this.marked;
        if (this.owner && this.owner.constructor === Array) {
            data["owner"] = [];
            for (let item of this.owner)
                data["owner"].push(item);
        }
        if (this.usageTerms) {
            data["usageTerms"] = {};
            for (let key in this.usageTerms) {
                if (this.usageTerms.hasOwnProperty(key))
                    data["usageTerms"][key] = this.usageTerms[key];
            }
        }
        data["webStatement"] = this.webStatement;
        return data; 
    }
}

export interface IXmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;
}

export class XmpTPg implements IXmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;

    constructor(data?: IXmpTPg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.colorants) {
                this.colorants = [];
                for (let i = 0; i < data.colorants.length; i++) {
                    let item = data.colorants[i];
                    this.colorants[i] = item && !(<any>item).toJSON ? new XmpG(item) : <XmpG>item;
                }
            }
            if (data.fonts) {
                this.fonts = [];
                for (let i = 0; i < data.fonts.length; i++) {
                    let item = data.fonts[i];
                    this.fonts[i] = item && !(<any>item).toJSON ? new Font(item) : <Font>item;
                }
            }
            this.maxPageSize = data.maxPageSize && !(<any>data.maxPageSize).toJSON ? new Dimension(data.maxPageSize) : <Dimension>this.maxPageSize; 
        }
    }

    init(data?: any) {
        if (data) {
            if (data["colorants"] && data["colorants"].constructor === Array) {
                this.colorants = [];
                for (let item of data["colorants"])
                    this.colorants.push(XmpG.fromJS(item));
            }
            if (data["fonts"] && data["fonts"].constructor === Array) {
                this.fonts = [];
                for (let item of data["fonts"])
                    this.fonts.push(Font.fromJS(item));
            }
            this.maxPageSize = data["maxPageSize"] ? Dimension.fromJS(data["maxPageSize"]) : <any>undefined;
            this.nPages = data["nPages"];
            if (data["plateNames"] && data["plateNames"].constructor === Array) {
                this.plateNames = [];
                for (let item of data["plateNames"])
                    this.plateNames.push(item);
            }
        }
    }

    static fromJS(data: any): XmpTPg {
        let result = new XmpTPg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.colorants && this.colorants.constructor === Array) {
            data["colorants"] = [];
            for (let item of this.colorants)
                data["colorants"].push(item.toJSON());
        }
        if (this.fonts && this.fonts.constructor === Array) {
            data["fonts"] = [];
            for (let item of this.fonts)
                data["fonts"].push(item.toJSON());
        }
        data["maxPageSize"] = this.maxPageSize ? this.maxPageSize.toJSON() : <any>undefined;
        data["nPages"] = this.nPages;
        if (this.plateNames && this.plateNames.constructor === Array) {
            data["plateNames"] = [];
            for (let item of this.plateNames)
                data["plateNames"].push(item);
        }
        return data; 
    }
}

export interface IXmpTPg {
    colorants?: IXmpG[] | undefined;
    fonts?: IFont[] | undefined;
    maxPageSize?: IDimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;
}

export class Font implements IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;

    constructor(data?: IFont) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["childFontFiles"] && data["childFontFiles"].constructor === Array) {
                this.childFontFiles = [];
                for (let item of data["childFontFiles"])
                    this.childFontFiles.push(item);
            }
            this.composite = data["composite"];
            this.fontFace = data["fontFace"];
            this.fontFamily = data["fontFamily"];
            this.fontFileName = data["fontFileName"];
            this.fontName = data["fontName"];
            this.fontType = data["fontType"];
            this.versionString = data["versionString"];
        }
    }

    static fromJS(data: any): Font {
        let result = new Font();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.childFontFiles && this.childFontFiles.constructor === Array) {
            data["childFontFiles"] = [];
            for (let item of this.childFontFiles)
                data["childFontFiles"].push(item);
        }
        data["composite"] = this.composite;
        data["fontFace"] = this.fontFace;
        data["fontFamily"] = this.fontFamily;
        data["fontFileName"] = this.fontFileName;
        data["fontName"] = this.fontName;
        data["fontType"] = this.fontType;
        data["versionString"] = this.versionString;
        return data; 
    }
}

export interface IFont {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;
}

/** Corresponds to stFnt.FontTypeChoice */
export enum FontType {
    TrueType = <any>"TrueType", 
    Type1 = <any>"Type1", 
    OpenType = <any>"OpenType", 
    OpenTypeCFF = <any>"OpenTypeCFF", 
}

export class ExifMetadata implements IExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;

    constructor(data?: IExifMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.exif = data.exif && !(<any>data.exif).toJSON ? new Exif(data.exif) : <Exif>this.exif; 
            this.exifAux = data.exifAux && !(<any>data.exifAux).toJSON ? new ExifAux(data.exifAux) : <ExifAux>this.exifAux; 
        }
    }

    init(data?: any) {
        if (data) {
            this.exif = data["exif"] ? Exif.fromJS(data["exif"]) : <any>undefined;
            this.exifAux = data["exifAux"] ? ExifAux.fromJS(data["exifAux"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExifMetadata {
        let result = new ExifMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exif"] = this.exif ? this.exif.toJSON() : <any>undefined;
        data["exifAux"] = this.exifAux ? this.exifAux.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IExifMetadata {
    exif?: IExif | undefined;
    exifAux?: IExifAux | undefined;
}

export class Exif implements IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cfaPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gpsAltitude?: string | undefined;
    gpsAltitudeRef?: GPSAltitudeRef | undefined;
    gpsAreaInformation?: string | undefined;
    gpsDestBearing?: string | undefined;
    gpsDestBearingRef?: GPSDestBearingRef | undefined;
    gpsDestDistance?: string | undefined;
    gpsDestDistanceRef?: GPSDestDistanceRef | undefined;
    gpsDestLatitude?: string | undefined;
    gpsDestLongitude?: string | undefined;
    gpsDifferential?: GPSDifferential | undefined;
    gpsdop?: string | undefined;
    gpsImgDirection?: string | undefined;
    gpsImgDirectionRef?: GPSImgDirectionRef | undefined;
    gpsCoordinate?: GPSCoordinate | undefined;
    gpsLatitude?: string | undefined;
    gpsLongitude?: string | undefined;
    gpsMapDatum?: string | undefined;
    gpsMeasureMode?: string | undefined;
    gpsProcessingMethod?: string | undefined;
    gpsSatellites?: string | undefined;
    gpsSpeed?: string | undefined;
    gpsSpeedRef?: GPSSpeedRef | undefined;
    gpsStatus?: GPSStatus | undefined;
    gpsTimeStamp?: Date | undefined;
    gpsTrack?: string | undefined;
    gpsTrackRef?: string | undefined;
    gpsVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    isoSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oecf?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;

    constructor(data?: IExif) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.cfaPattern = data.cfaPattern && !(<any>data.cfaPattern).toJSON ? new CFAPattern(data.cfaPattern) : <CFAPattern>this.cfaPattern; 
            this.deviceSettingDescription = data.deviceSettingDescription && !(<any>data.deviceSettingDescription).toJSON ? new DeviceSettings(data.deviceSettingDescription) : <DeviceSettings>this.deviceSettingDescription; 
            this.flash = data.flash && !(<any>data.flash).toJSON ? new Flash(data.flash) : <Flash>this.flash; 
            this.gpsCoordinate = data.gpsCoordinate && !(<any>data.gpsCoordinate).toJSON ? new GPSCoordinate(data.gpsCoordinate) : <GPSCoordinate>this.gpsCoordinate; 
            this.oecf = data.oecf && !(<any>data.oecf).toJSON ? new OECF(data.oecf) : <OECF>this.oecf; 
            this.spatialFrequencyResponse = data.spatialFrequencyResponse && !(<any>data.spatialFrequencyResponse).toJSON ? new SFR(data.spatialFrequencyResponse) : <SFR>this.spatialFrequencyResponse; 
        }
    }

    init(data?: any) {
        if (data) {
            this.apertureValue = data["apertureValue"];
            this.brightnessValue = data["brightnessValue"];
            this.cfaPattern = data["cfaPattern"] ? CFAPattern.fromJS(data["cfaPattern"]) : <any>undefined;
            this.colorSpace = data["colorSpace"];
            if (data["componentsConfiguration"] && data["componentsConfiguration"].constructor === Array) {
                this.componentsConfiguration = [];
                for (let item of data["componentsConfiguration"])
                    this.componentsConfiguration.push(item);
            }
            this.compressedBitsPerPixel = data["compressedBitsPerPixel"];
            this.contrast = data["contrast"];
            this.customRendered = data["customRendered"];
            this.dateTimeOriginal = data["dateTimeOriginal"] ? new Date(data["dateTimeOriginal"].toString()) : <any>undefined;
            this.dateTimeDigitized = data["dateTimeDigitized"] ? new Date(data["dateTimeDigitized"].toString()) : <any>undefined;
            this.deviceSettingDescription = data["deviceSettingDescription"] ? DeviceSettings.fromJS(data["deviceSettingDescription"]) : <any>undefined;
            this.digitalZoomRatio = data["digitalZoomRatio"];
            this.exifVersion = data["exifVersion"];
            this.exposureBiasValue = data["exposureBiasValue"];
            this.exposureIndex = data["exposureIndex"];
            this.exposureMode = data["exposureMode"];
            this.exposureProgram = data["exposureProgram"];
            this.exposureTime = data["exposureTime"];
            this.fileSource = data["fileSource"];
            this.flash = data["flash"] ? Flash.fromJS(data["flash"]) : <any>undefined;
            this.flashEnergy = data["flashEnergy"];
            this.flashpixVersion = data["flashpixVersion"];
            this.fNumber = data["fNumber"];
            this.focalLength = data["focalLength"];
            this.focalLengthIn35mmFilm = data["focalLengthIn35mmFilm"];
            this.focalPlaneResolutionUnit = data["focalPlaneResolutionUnit"];
            this.focalPlaneXResolution = data["focalPlaneXResolution"];
            this.focalPlaneYResolution = data["focalPlaneYResolution"];
            this.gainControl = data["gainControl"];
            this.gpsAltitude = data["gpsAltitude"];
            this.gpsAltitudeRef = data["gpsAltitudeRef"];
            this.gpsAreaInformation = data["gpsAreaInformation"];
            this.gpsDestBearing = data["gpsDestBearing"];
            this.gpsDestBearingRef = data["gpsDestBearingRef"];
            this.gpsDestDistance = data["gpsDestDistance"];
            this.gpsDestDistanceRef = data["gpsDestDistanceRef"];
            this.gpsDestLatitude = data["gpsDestLatitude"];
            this.gpsDestLongitude = data["gpsDestLongitude"];
            this.gpsDifferential = data["gpsDifferential"];
            this.gpsdop = data["gpsdop"];
            this.gpsImgDirection = data["gpsImgDirection"];
            this.gpsImgDirectionRef = data["gpsImgDirectionRef"];
            this.gpsCoordinate = data["gpsCoordinate"] ? GPSCoordinate.fromJS(data["gpsCoordinate"]) : <any>undefined;
            this.gpsLatitude = data["gpsLatitude"];
            this.gpsLongitude = data["gpsLongitude"];
            this.gpsMapDatum = data["gpsMapDatum"];
            this.gpsMeasureMode = data["gpsMeasureMode"];
            this.gpsProcessingMethod = data["gpsProcessingMethod"];
            this.gpsSatellites = data["gpsSatellites"];
            this.gpsSpeed = data["gpsSpeed"];
            this.gpsSpeedRef = data["gpsSpeedRef"];
            this.gpsStatus = data["gpsStatus"];
            this.gpsTimeStamp = data["gpsTimeStamp"] ? new Date(data["gpsTimeStamp"].toString()) : <any>undefined;
            this.gpsTrack = data["gpsTrack"];
            this.gpsTrackRef = data["gpsTrackRef"];
            this.gpsVersionID = data["gpsVersionID"];
            this.imageUniqueID = data["imageUniqueID"];
            if (data["isoSpeedRatings"] && data["isoSpeedRatings"].constructor === Array) {
                this.isoSpeedRatings = [];
                for (let item of data["isoSpeedRatings"])
                    this.isoSpeedRatings.push(item);
            }
            this.lightSource = data["lightSource"];
            this.maxApertureValue = data["maxApertureValue"];
            this.meteringMode = data["meteringMode"];
            this.oecf = data["oecf"] ? OECF.fromJS(data["oecf"]) : <any>undefined;
            this.pixelXDimension = data["pixelXDimension"];
            this.pixelYDimension = data["pixelYDimension"];
            this.relatedSoundFile = data["relatedSoundFile"];
            this.saturation = data["saturation"];
            this.sceneCaptureType = data["sceneCaptureType"];
            this.sceneType = data["sceneType"];
            this.sensingMethod = data["sensingMethod"];
            this.sharpness = data["sharpness"];
            this.shutterSpeedValue = data["shutterSpeedValue"];
            this.spatialFrequencyResponse = data["spatialFrequencyResponse"] ? SFR.fromJS(data["spatialFrequencyResponse"]) : <any>undefined;
            this.spectralSensitivity = data["spectralSensitivity"];
            if (data["subjectArea"] && data["subjectArea"].constructor === Array) {
                this.subjectArea = [];
                for (let item of data["subjectArea"])
                    this.subjectArea.push(item);
            }
            this.subjectDistance = data["subjectDistance"];
            this.subjectDistanceRange = data["subjectDistanceRange"];
            if (data["subjectLocation"] && data["subjectLocation"].constructor === Array) {
                this.subjectLocation = [];
                for (let item of data["subjectLocation"])
                    this.subjectLocation.push(item);
            }
            if (data["userComment"]) {
                this.userComment = {};
                for (let key in data["userComment"]) {
                    if (data["userComment"].hasOwnProperty(key))
                        this.userComment[key] = data["userComment"][key];
                }
            }
            this.whiteBalance = data["whiteBalance"];
            this.nativeDigest = data["nativeDigest"];
        }
    }

    static fromJS(data: any): Exif {
        let result = new Exif();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apertureValue"] = this.apertureValue;
        data["brightnessValue"] = this.brightnessValue;
        data["cfaPattern"] = this.cfaPattern ? this.cfaPattern.toJSON() : <any>undefined;
        data["colorSpace"] = this.colorSpace;
        if (this.componentsConfiguration && this.componentsConfiguration.constructor === Array) {
            data["componentsConfiguration"] = [];
            for (let item of this.componentsConfiguration)
                data["componentsConfiguration"].push(item);
        }
        data["compressedBitsPerPixel"] = this.compressedBitsPerPixel;
        data["contrast"] = this.contrast;
        data["customRendered"] = this.customRendered;
        data["dateTimeOriginal"] = this.dateTimeOriginal ? this.dateTimeOriginal.toISOString() : <any>undefined;
        data["dateTimeDigitized"] = this.dateTimeDigitized ? this.dateTimeDigitized.toISOString() : <any>undefined;
        data["deviceSettingDescription"] = this.deviceSettingDescription ? this.deviceSettingDescription.toJSON() : <any>undefined;
        data["digitalZoomRatio"] = this.digitalZoomRatio;
        data["exifVersion"] = this.exifVersion;
        data["exposureBiasValue"] = this.exposureBiasValue;
        data["exposureIndex"] = this.exposureIndex;
        data["exposureMode"] = this.exposureMode;
        data["exposureProgram"] = this.exposureProgram;
        data["exposureTime"] = this.exposureTime;
        data["fileSource"] = this.fileSource;
        data["flash"] = this.flash ? this.flash.toJSON() : <any>undefined;
        data["flashEnergy"] = this.flashEnergy;
        data["flashpixVersion"] = this.flashpixVersion;
        data["fNumber"] = this.fNumber;
        data["focalLength"] = this.focalLength;
        data["focalLengthIn35mmFilm"] = this.focalLengthIn35mmFilm;
        data["focalPlaneResolutionUnit"] = this.focalPlaneResolutionUnit;
        data["focalPlaneXResolution"] = this.focalPlaneXResolution;
        data["focalPlaneYResolution"] = this.focalPlaneYResolution;
        data["gainControl"] = this.gainControl;
        data["gpsAltitude"] = this.gpsAltitude;
        data["gpsAltitudeRef"] = this.gpsAltitudeRef;
        data["gpsAreaInformation"] = this.gpsAreaInformation;
        data["gpsDestBearing"] = this.gpsDestBearing;
        data["gpsDestBearingRef"] = this.gpsDestBearingRef;
        data["gpsDestDistance"] = this.gpsDestDistance;
        data["gpsDestDistanceRef"] = this.gpsDestDistanceRef;
        data["gpsDestLatitude"] = this.gpsDestLatitude;
        data["gpsDestLongitude"] = this.gpsDestLongitude;
        data["gpsDifferential"] = this.gpsDifferential;
        data["gpsdop"] = this.gpsdop;
        data["gpsImgDirection"] = this.gpsImgDirection;
        data["gpsImgDirectionRef"] = this.gpsImgDirectionRef;
        data["gpsCoordinate"] = this.gpsCoordinate ? this.gpsCoordinate.toJSON() : <any>undefined;
        data["gpsLatitude"] = this.gpsLatitude;
        data["gpsLongitude"] = this.gpsLongitude;
        data["gpsMapDatum"] = this.gpsMapDatum;
        data["gpsMeasureMode"] = this.gpsMeasureMode;
        data["gpsProcessingMethod"] = this.gpsProcessingMethod;
        data["gpsSatellites"] = this.gpsSatellites;
        data["gpsSpeed"] = this.gpsSpeed;
        data["gpsSpeedRef"] = this.gpsSpeedRef;
        data["gpsStatus"] = this.gpsStatus;
        data["gpsTimeStamp"] = this.gpsTimeStamp ? this.gpsTimeStamp.toISOString() : <any>undefined;
        data["gpsTrack"] = this.gpsTrack;
        data["gpsTrackRef"] = this.gpsTrackRef;
        data["gpsVersionID"] = this.gpsVersionID;
        data["imageUniqueID"] = this.imageUniqueID;
        if (this.isoSpeedRatings && this.isoSpeedRatings.constructor === Array) {
            data["isoSpeedRatings"] = [];
            for (let item of this.isoSpeedRatings)
                data["isoSpeedRatings"].push(item);
        }
        data["lightSource"] = this.lightSource;
        data["maxApertureValue"] = this.maxApertureValue;
        data["meteringMode"] = this.meteringMode;
        data["oecf"] = this.oecf ? this.oecf.toJSON() : <any>undefined;
        data["pixelXDimension"] = this.pixelXDimension;
        data["pixelYDimension"] = this.pixelYDimension;
        data["relatedSoundFile"] = this.relatedSoundFile;
        data["saturation"] = this.saturation;
        data["sceneCaptureType"] = this.sceneCaptureType;
        data["sceneType"] = this.sceneType;
        data["sensingMethod"] = this.sensingMethod;
        data["sharpness"] = this.sharpness;
        data["shutterSpeedValue"] = this.shutterSpeedValue;
        data["spatialFrequencyResponse"] = this.spatialFrequencyResponse ? this.spatialFrequencyResponse.toJSON() : <any>undefined;
        data["spectralSensitivity"] = this.spectralSensitivity;
        if (this.subjectArea && this.subjectArea.constructor === Array) {
            data["subjectArea"] = [];
            for (let item of this.subjectArea)
                data["subjectArea"].push(item);
        }
        data["subjectDistance"] = this.subjectDistance;
        data["subjectDistanceRange"] = this.subjectDistanceRange;
        if (this.subjectLocation && this.subjectLocation.constructor === Array) {
            data["subjectLocation"] = [];
            for (let item of this.subjectLocation)
                data["subjectLocation"].push(item);
        }
        if (this.userComment) {
            data["userComment"] = {};
            for (let key in this.userComment) {
                if (this.userComment.hasOwnProperty(key))
                    data["userComment"][key] = this.userComment[key];
            }
        }
        data["whiteBalance"] = this.whiteBalance;
        data["nativeDigest"] = this.nativeDigest;
        return data; 
    }
}

export interface IExif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cfaPattern?: ICFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: IDeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: IFlash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gpsAltitude?: string | undefined;
    gpsAltitudeRef?: GPSAltitudeRef | undefined;
    gpsAreaInformation?: string | undefined;
    gpsDestBearing?: string | undefined;
    gpsDestBearingRef?: GPSDestBearingRef | undefined;
    gpsDestDistance?: string | undefined;
    gpsDestDistanceRef?: GPSDestDistanceRef | undefined;
    gpsDestLatitude?: string | undefined;
    gpsDestLongitude?: string | undefined;
    gpsDifferential?: GPSDifferential | undefined;
    gpsdop?: string | undefined;
    gpsImgDirection?: string | undefined;
    gpsImgDirectionRef?: GPSImgDirectionRef | undefined;
    gpsCoordinate?: IGPSCoordinate | undefined;
    gpsLatitude?: string | undefined;
    gpsLongitude?: string | undefined;
    gpsMapDatum?: string | undefined;
    gpsMeasureMode?: string | undefined;
    gpsProcessingMethod?: string | undefined;
    gpsSatellites?: string | undefined;
    gpsSpeed?: string | undefined;
    gpsSpeedRef?: GPSSpeedRef | undefined;
    gpsStatus?: GPSStatus | undefined;
    gpsTimeStamp?: Date | undefined;
    gpsTrack?: string | undefined;
    gpsTrackRef?: string | undefined;
    gpsVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    isoSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oecf?: IOECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: ISFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;
}

export class CFAPattern implements ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;

    constructor(data?: ICFAPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
        }
    }

    static fromJS(data: any): CFAPattern {
        let result = new CFAPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface ICFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;
}

/** Corresponds to exif.ColorSpaceChoice */
export enum ColorSpace {
    None = <any>"None", 
    SRGB = <any>"sRGB", 
    AdobeRGB = <any>"AdobeRGB", 
    Uncalibrated = <any>"Uncalibrated", 
}

/** Corresponds to exif.ContrastChoice */
export enum Contrast {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.CustomRenderedChoice */
export enum CustomRendered {
    NormalProcess = <any>"NormalProcess", 
    CustomProcess = <any>"CustomProcess", 
}

export class DeviceSettings implements IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;

    constructor(data?: IDeviceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["settings"])
                    this.settings.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceSettings {
        let result = new DeviceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item);
        }
        return data; 
    }
}

export interface IDeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;
}

/** Corresponds to exif.ExifVersionChoice */
export enum ExifVersion {
    V210 = <any>"V210", 
    V220 = <any>"V220", 
    V221 = <any>"V221", 
    V222 = <any>"V222", 
    V230 = <any>"V230", 
}

/** Corresponds to exif.ExposureModeChoice */
export enum ExposureMode {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    AutoBracket = <any>"AutoBracket", 
}

/** Corresponds to exif.ExposureProgramChoice */
export enum ExposureProgram {
    Undefined = <any>"Undefined", 
    Manual = <any>"Manual", 
    NormalProgram = <any>"NormalProgram", 
    AperturePriority = <any>"AperturePriority", 
    ShutterPriority = <any>"ShutterPriority", 
    CreativeProgram = <any>"CreativeProgram", 
    ActionProgram = <any>"ActionProgram", 
    PortraitMode = <any>"PortraitMode", 
    LandscapeMode = <any>"LandscapeMode", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.FileSourceChoice */
export enum FileSource {
    Other = <any>"Other", 
    TransparentScanner = <any>"TransparentScanner", 
    ReflexScanner = <any>"ReflexScanner", 
    DSC = <any>"DSC", 
}

export class Flash implements IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;

    constructor(data?: IFlash) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fired = data["fired"];
            this.return = data["return"];
            this.mode = data["mode"];
            this.function = data["function"];
            this.redEyeMode = data["redEyeMode"];
        }
    }

    static fromJS(data: any): Flash {
        let result = new Flash();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fired"] = this.fired;
        data["return"] = this.return;
        data["mode"] = this.mode;
        data["function"] = this.function;
        data["redEyeMode"] = this.redEyeMode;
        return data; 
    }
}

export interface IFlash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;
}

/** Corresponds to Xmp.Structure.Flash.ReturnChoice */
export enum FlashReturn {
    NoStrobeReturnDetection = <any>"NoStrobeReturnDetection", 
    StrobeReturnLightNotDetected = <any>"StrobeReturnLightNotDetected", 
    StrobeReturnLightDetected = <any>"StrobeReturnLightDetected", 
}

/** Corresponds to Xmp.Structure.Flash.ModeChoice */
export enum FlashMode {
    Unknown = <any>"Unknown", 
    CompulsoryFlashFiring = <any>"CompulsoryFlashFiring", 
    CompulsoryFlashSuppression = <any>"CompulsoryFlashSuppression", 
    AutoMode = <any>"AutoMode", 
}

/** Corresponds to exif.FlashpixVersionChoice */
export enum FlashpixVersion {
    V100 = <any>"V100", 
    V101 = <any>"V101", 
    V110 = <any>"V110", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum FocalPlaneResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Meter = <any>"Meter", 
    Centimeter = <any>"Centimeter", 
    Millimeter = <any>"Millimeter", 
    Micrometer = <any>"Micrometer", 
}

/** Corresponds to exif.GainControlChoice */
export enum GainControl {
    None = <any>"None", 
    LowGainUp = <any>"LowGainUp", 
    HighGainUp = <any>"HighGainUp", 
    LowGainDown = <any>"LowGainDown", 
    HighGainDown = <any>"HighGainDown", 
}

/** Corresponds to exif.GPSAltitudeRefChoice */
export enum GPSAltitudeRef {
    AboveSeaLevel = <any>"AboveSeaLevel", 
    BelowSeaLevel = <any>"BelowSeaLevel", 
}

/** Corresponds to exif.GPSDestBearingRefChoice */
export enum GPSDestBearingRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

/** Corresponds to exif.GPSDestDistanceRefChoice */
export enum GPSDestDistanceRef {
    Kilometers = <any>"Kilometers", 
    Miles = <any>"Miles", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSDifferentialChoice */
export enum GPSDifferential {
    WithoutCorrection = <any>"WithoutCorrection", 
    WithCorrection = <any>"WithCorrection", 
}

/** Corresponds to exif.GPSImgDirectionRefChoice */
export enum GPSImgDirectionRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

export class GPSCoordinate implements IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;

    constructor(data?: IGPSCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lon = data["lon"];
            this.lat = data["lat"];
        }
    }

    static fromJS(data: any): GPSCoordinate {
        let result = new GPSCoordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lon"] = this.lon;
        data["lat"] = this.lat;
        return data; 
    }
}

export interface IGPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;
}

/** Corresponds to exif.GPSSpeedRefChoice */
export enum GPSSpeedRef {
    KilometersPerHour = <any>"KilometersPerHour", 
    MilesPerHour = <any>"MilesPerHour", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSStatusChoice */
export enum GPSStatus {
    MeasurementInProgress = <any>"MeasurementInProgress", 
    MeasurementIsInteroperability = <any>"MeasurementIsInteroperability", 
}

/** Corresponds to exif.LightSourceChoice */
export enum LightSource {
    Unidentified = <any>"Unidentified", 
    Daylight = <any>"Daylight", 
    Fluorescent = <any>"Fluorescent", 
    Tungsten = <any>"Tungsten", 
    Flash = <any>"Flash", 
    FineWeather = <any>"FineWeather", 
    CloudyWeather = <any>"CloudyWeather", 
    Shade = <any>"Shade", 
    DaylightFluorescent = <any>"DaylightFluorescent", 
    DayWhiteFluorescent = <any>"DayWhiteFluorescent", 
    CoolWhiteFluorescent = <any>"CoolWhiteFluorescent", 
    WhiteFluorescent = <any>"WhiteFluorescent", 
    StandardIlluminantA = <any>"StandardIlluminantA", 
    StandardIlluminantB = <any>"StandardIlluminantB", 
    StandardIlluminantC = <any>"StandardIlluminantC", 
    D55Illuminant = <any>"D55Illuminant", 
    D65Illuminant = <any>"D65Illuminant", 
    D75Illuminant = <any>"D75Illuminant", 
    D50Illuminant = <any>"D50Illuminant", 
    ISOStudioTungsten = <any>"ISOStudioTungsten", 
    Other = <any>"Other", 
}

/** Corresponds to exif.MeteringModeChoice */
export enum MeteringMode {
    Unidentified = <any>"Unidentified", 
    Average = <any>"Average", 
    CenterWeightedAverage = <any>"CenterWeightedAverage", 
    Spot = <any>"Spot", 
    MultiSpot = <any>"MultiSpot", 
    Pattern = <any>"Pattern", 
    Partial = <any>"Partial", 
    Reserved = <any>"Reserved", 
    Other = <any>"Other", 
}

export class OECF implements IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: IOECF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
            if (data["names"] && data["names"].constructor === Array) {
                this.names = [];
                for (let item of data["names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): OECF {
        let result = new OECF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item);
        }
        return data; 
    }
}

export interface IOECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SaturationChoice */
export enum Saturation {
    Normal = <any>"Normal", 
    Low = <any>"Low", 
    High = <any>"High", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.SceneCaptureTypeChoice */
export enum SceneCaptureType {
    Standard = <any>"Standard", 
    Landscape = <any>"Landscape", 
    Portrait = <any>"Portrait", 
    NightScene = <any>"NightScene", 
}

/** Corresponds to exif.SceneTypeChoice */
export enum SceneType {
    DirectlyPhotographedImage = <any>"DirectlyPhotographedImage", 
}

/** Corresponds to exif.SensingMethodChoice */
export enum SensingMethod {
    Undefined = <any>"Undefined", 
    MonochromeArea = <any>"MonochromeArea", 
    OneChipColourAreaSensor = <any>"OneChipColourAreaSensor", 
    TwoChipColourAreaSensor = <any>"TwoChipColourAreaSensor", 
    ThreeChipColourAreaSensor = <any>"ThreeChipColourAreaSensor", 
    ColourSequentialAreaSensor = <any>"ColourSequentialAreaSensor", 
    MonochromeLinearArea = <any>"MonochromeLinearArea", 
    TrilinearSensor = <any>"TrilinearSensor", 
    ColourSequentialLinearSensor = <any>"ColourSequentialLinearSensor", 
}

/** Corresponds to exif.SharpnessChoice */
export enum Sharpness {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

export class SFR implements ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;

    constructor(data?: ISFR) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columns = data["columns"];
            this.rows = data["rows"];
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(item);
            }
            if (data["names"] && data["names"].constructor === Array) {
                this.names = [];
                for (let item of data["names"])
                    this.names.push(item);
            }
        }
    }

    static fromJS(data: any): SFR {
        let result = new SFR();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        if (this.names && this.names.constructor === Array) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item);
        }
        return data; 
    }
}

export interface ISFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SubjectDistanceRangeChoice */
export enum SubjectDistanceRange {
    Unknown = <any>"Unknown", 
    Macro = <any>"Macro", 
    CloseView = <any>"CloseView", 
    DistantView = <any>"DistantView", 
}

/** Corresponds to exif.WhiteBalanceChoice */
export enum WhiteBalanceExif {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    Unknown = <any>"Unknown", 
}

export class ExifAux implements IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;

    constructor(data?: IExifAux) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lens = data["lens"];
            this.serialNumber = data["serialNumber"];
        }
    }

    static fromJS(data: any): ExifAux {
        let result = new ExifAux();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lens"] = this.lens;
        data["serialNumber"] = this.serialNumber;
        return data; 
    }
}

export interface IExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IAudioMetadata) {
        super(data);
        this._discriminator = "AudioMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AudioMetadata {
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: IAudioStream[] | undefined;
}

export class AudioStream implements IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;

    constructor(data?: IAudioStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.bitRateMode = data["bitRateMode"];
            this.channels = data["channels"];
            this.channelPositions = data["channelPositions"];
            this.codec = data["codec"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.language = data["language"];
            this.resolution = data["resolution"];
            this.samplingRate = data["samplingRate"];
            this.streamSize = data["streamSize"];
        }
    }

    static fromJS(data: any): AudioStream {
        let result = new AudioStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["bitRateMode"] = this.bitRateMode;
        data["channels"] = this.channels;
        data["channelPositions"] = this.channelPositions;
        data["codec"] = this.codec;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["language"] = this.language;
        data["resolution"] = this.resolution;
        data["samplingRate"] = this.samplingRate;
        data["streamSize"] = this.streamSize;
        return data; 
    }
}

export interface IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;

    constructor(data?: IDocumentMetadata) {
        super(data);
        this._discriminator = "DocumentMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.applicationName = data["applicationName"];
            this.applicationVersion = data["applicationVersion"];
            this.author = data["author"];
            this.creator = data["creator"];
            this.publisher = data["publisher"];
            this.company = data["company"];
            this.documentTitle = data["documentTitle"];
            this.characterCount = data["characterCount"];
            this.characterCountWithSpaces = data["characterCountWithSpaces"];
            this.lineCount = data["lineCount"];
            this.pageCount = data["pageCount"];
            this.slideCount = data["slideCount"];
            this.paragraphCount = data["paragraphCount"];
            this.revisionNumber = data["revisionNumber"];
            if (data["titles"] && data["titles"].constructor === Array) {
                this.titles = [];
                for (let item of data["titles"])
                    this.titles.push(item);
            }
            if (data["imageTitles"] && data["imageTitles"].constructor === Array) {
                this.imageTitles = [];
                for (let item of data["imageTitles"])
                    this.imageTitles.push(item);
            }
            this.epsInfo = data["epsInfo"] ? EpsMetadata.fromJS(data["epsInfo"]) : <any>undefined;
            if (data["embeddedFiles"] && data["embeddedFiles"].constructor === Array) {
                this.embeddedFiles = [];
                for (let item of data["embeddedFiles"])
                    this.embeddedFiles.push(FileMetadata.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentMetadata {
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["applicationVersion"] = this.applicationVersion;
        data["author"] = this.author;
        data["creator"] = this.creator;
        data["publisher"] = this.publisher;
        data["company"] = this.company;
        data["documentTitle"] = this.documentTitle;
        data["characterCount"] = this.characterCount;
        data["characterCountWithSpaces"] = this.characterCountWithSpaces;
        data["lineCount"] = this.lineCount;
        data["pageCount"] = this.pageCount;
        data["slideCount"] = this.slideCount;
        data["paragraphCount"] = this.paragraphCount;
        data["revisionNumber"] = this.revisionNumber;
        if (this.titles && this.titles.constructor === Array) {
            data["titles"] = [];
            for (let item of this.titles)
                data["titles"].push(item);
        }
        if (this.imageTitles && this.imageTitles.constructor === Array) {
            data["imageTitles"] = [];
            for (let item of this.imageTitles)
                data["imageTitles"].push(item);
        }
        data["epsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        if (this.embeddedFiles && this.embeddedFiles.constructor === Array) {
            data["embeddedFiles"] = [];
            for (let item of this.embeddedFiles)
                data["embeddedFiles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: IEpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;
}

export class EpsMetadata implements IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;

    constructor(data?: IEpsMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isRasterized = data["isRasterized"];
            this.widthInPoints = data["widthInPoints"];
            this.heightInPoints = data["heightInPoints"];
        }
    }

    static fromJS(data: any): EpsMetadata {
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRasterized"] = this.isRasterized;
        data["widthInPoints"] = this.widthInPoints;
        data["heightInPoints"] = this.heightInPoints;
        return data; 
    }
}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;

    constructor(data?: IImageMetadata) {
        super(data);
        this._discriminator = "ImageMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.widthInInch = data["widthInInch"];
            this.heightInInch = data["heightInInch"];
            this.widthInCm = data["widthInCm"];
            this.heightInCm = data["heightInCm"];
            this.colorSpace = data["colorSpace"];
            this.colorProfile = data["colorProfile"];
            this.bitsPerPixel = data["bitsPerPixel"];
            this.bitsPerChannel = data["bitsPerChannel"];
            this.channels = data["channels"];
            this.pixelFormat = data["pixelFormat"];
            this.hasAlpha = data["hasAlpha"];
            this.isIndexed = data["isIndexed"];
            this.isExtended = data["isExtended"];
            this.horizontalResolution = data["horizontalResolution"];
            this.verticalResolution = data["verticalResolution"];
            this.totalFrames = data["totalFrames"];
            this.totalUnspecifiedTiffExtraChannels = data["totalUnspecifiedTiffExtraChannels"];
            this.hasExifData = data["hasExifData"];
            this.hasIptcData = data["hasIptcData"];
            this.hasAdobeResourceData = data["hasAdobeResourceData"];
            this.hasXmpData = data["hasXmpData"];
            this.uncompressedSizeInBytes = data["uncompressedSizeInBytes"];
        }
    }

    static fromJS(data: any): ImageMetadata {
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["widthInInch"] = this.widthInInch;
        data["heightInInch"] = this.heightInInch;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["colorSpace"] = this.colorSpace;
        data["colorProfile"] = this.colorProfile;
        data["bitsPerPixel"] = this.bitsPerPixel;
        data["bitsPerChannel"] = this.bitsPerChannel;
        data["channels"] = this.channels;
        data["pixelFormat"] = this.pixelFormat;
        data["hasAlpha"] = this.hasAlpha;
        data["isIndexed"] = this.isIndexed;
        data["isExtended"] = this.isExtended;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["totalFrames"] = this.totalFrames;
        data["totalUnspecifiedTiffExtraChannels"] = this.totalUnspecifiedTiffExtraChannels;
        data["hasExifData"] = this.hasExifData;
        data["hasIptcData"] = this.hasIptcData;
        data["hasAdobeResourceData"] = this.hasAdobeResourceData;
        data["hasXmpData"] = this.hasXmpData;
        data["uncompressedSizeInBytes"] = this.uncompressedSizeInBytes;
        super.toJSON(data);
        return data; 
    }
}

export interface IImageMetadata extends IFileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IVideoMetadata) {
        super(data);
        this._discriminator = "VideoMetadata";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.width = data["width"];
            this.height = data["height"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.codec = data["codec"];
            this.overallBitrate = data["overallBitrate"];
            if (data["videoStreams"] && data["videoStreams"].constructor === Array) {
                this.videoStreams = [];
                for (let item of data["videoStreams"])
                    this.videoStreams.push(VideoStream.fromJS(item));
            }
            if (data["audioStreams"] && data["audioStreams"].constructor === Array) {
                this.audioStreams = [];
                for (let item of data["audioStreams"])
                    this.audioStreams.push(AudioStream.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoMetadata {
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["codec"] = this.codec;
        data["overallBitrate"] = this.overallBitrate;
        if (this.videoStreams && this.videoStreams.constructor === Array) {
            data["videoStreams"] = [];
            for (let item of this.videoStreams)
                data["videoStreams"].push(item.toJSON());
        }
        if (this.audioStreams && this.audioStreams.constructor === Array) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IVideoMetadata extends IFileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: IVideoStream[] | undefined;
    audioStreams?: IAudioStream[] | undefined;
}

export class VideoStream implements IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;

    constructor(data?: IVideoStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bitRate = data["bitRate"];
            this.codec = data["codec"];
            this.displayAspectRatio = data["displayAspectRatio"];
            this.durationInSeconds = data["durationInSeconds"];
            this.format = data["format"];
            this.frameCount = data["frameCount"];
            this.frameRate = data["frameRate"];
            this.height = data["height"];
            this.language = data["language"];
            this.pixelAspectRatio = data["pixelAspectRatio"];
            this.resolution = data["resolution"];
            this.streamSize = data["streamSize"];
            this.width = data["width"];
            this.rotation = data["rotation"];
        }
    }

    static fromJS(data: any): VideoStream {
        let result = new VideoStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["codec"] = this.codec;
        data["displayAspectRatio"] = this.displayAspectRatio;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["frameCount"] = this.frameCount;
        data["frameRate"] = this.frameRate;
        data["height"] = this.height;
        data["language"] = this.language;
        data["pixelAspectRatio"] = this.pixelAspectRatio;
        data["resolution"] = this.resolution;
        data["streamSize"] = this.streamSize;
        data["width"] = this.width;
        data["rotation"] = this.rotation;
        return data; 
    }
}

export interface IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export class DriveMetadata implements IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;

    constructor(data?: IDriveMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new DriveMetadataAudit(data.audit) : <DriveMetadataAudit>this.audit; 
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"];
            this.fileType = data["fileType"];
            this.audit = data["audit"] ? DriveMetadataAudit.fromJS(data["audit"]) : <any>undefined;
            this.description = data["description"];
        }
    }

    static fromJS(data: any): DriveMetadata {
        let result = new DriveMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["fileType"] = this.fileType;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }
}

export interface IDriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: IDriveMetadataAudit | undefined;
    description?: string | undefined;
}

export class DriveMetadataAudit implements IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;

    constructor(data?: IDriveMetadataAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.owner = data["owner"];
            this.modified = data["modified"];
            this.opened = data["opened"];
            this.created = data["created"];
        }
    }

    static fromJS(data: any): DriveMetadataAudit {
        let result = new DriveMetadataAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owner"] = this.owner;
        data["modified"] = this.modified;
        data["opened"] = this.opened;
        data["created"] = this.created;
        return data; 
    }
}

export interface IDriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;
}

export class OutputItem implements IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;

    constructor(data?: IOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.filePath = data["filePath"];
            this.outputSource = data["outputSource"];
        }
    }

    static fromJS(data: any): OutputItem {
        let result = new OutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["outputSource"] = this.outputSource;
        return data; 
    }
}

export interface IOutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export class FileTransferSearchRequest implements IFileTransferSearchRequest {
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;

    constructor(data?: IFileTransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileTransferSearchRequest {
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFileTransferSearchRequest {
    searchString?: string | undefined;
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
}

export class BaseResultOfFileTransfer implements IBaseResultOfFileTransfer {
    totalResults: number;
    results?: FileTransfer[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new FileTransfer(item) : <FileTransfer>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(FileTransfer.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfFileTransfer {
        let result = new BaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfFileTransfer {
    totalResults: number;
    results?: IFileTransfer[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfFileTransfer extends BaseResultOfFileTransfer implements ISearchBehaviourBaseResultOfFileTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfFileTransfer) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfFileTransfer {
        let result = new SearchBehaviourBaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfFileTransfer extends IBaseResultOfFileTransfer {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class FileTransferSearchResult extends SearchBehaviourBaseResultOfFileTransfer implements IFileTransferSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IFileTransferSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): FileTransferSearchResult {
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IFileTransferSearchResult extends ISearchBehaviourBaseResultOfFileTransfer {
    elapsedMilliseconds: number;
}

export class FileTransfer implements IFileTransfer {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    contentId?: string | undefined;

    constructor(data?: IFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.transferId = data["transferId"];
            this.state = data["state"];
            this.contentId = data["contentId"];
        }
    }

    static fromJS(data: any): FileTransfer {
        let result = new FileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["contentId"] = this.contentId;
        return data; 
    }
}

export interface IFileTransfer {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    contentId?: string | undefined;
}

export class Blacklist implements IBlacklist {
    items?: BlacklistItem[] | undefined;

    constructor(data?: IBlacklist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new BlacklistItem(item) : <BlacklistItem>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BlacklistItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blacklist {
        let result = new Blacklist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBlacklist {
    items?: IBlacklistItem[] | undefined;
}

export class BlacklistItem implements IBlacklistItem {
    name?: string | undefined;
    match?: string | undefined;

    constructor(data?: IBlacklistItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.match = data["match"];
        }
    }

    static fromJS(data: any): BlacklistItem {
        let result = new BlacklistItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["match"] = this.match;
        return data; 
    }
}

export interface IBlacklistItem {
    name?: string | undefined;
    match?: string | undefined;
}

export class FileTransferDeleteRequest implements IFileTransferDeleteRequest {
    transferId?: string | undefined;
    fileTransferIds?: string[] | undefined;

    constructor(data?: IFileTransferDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["fileTransferIds"] && data["fileTransferIds"].constructor === Array) {
                this.fileTransferIds = [];
                for (let item of data["fileTransferIds"])
                    this.fileTransferIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferDeleteRequest {
        let result = new FileTransferDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.fileTransferIds && this.fileTransferIds.constructor === Array) {
            data["fileTransferIds"] = [];
            for (let item of this.fileTransferIds)
                data["fileTransferIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferDeleteRequest {
    transferId?: string | undefined;
    fileTransferIds?: string[] | undefined;
}

export class FileTransfer2ContentCreateRequest implements IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransfer2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransfer2ContentCreateRequest {
        let result = new FileTransfer2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class FileTransferPartial2ContentCreateRequest implements IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;

    constructor(data?: IFileTransferPartial2ContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new FileTransferCreateItem(item) : <FileTransferCreateItem>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transferId = data["transferId"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FileTransferCreateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FileTransferPartial2ContentCreateRequest {
        let result = new FileTransferPartial2ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: IFileTransferCreateItem[] | undefined;
}

export class FileTransferCreateItem implements IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransferCreateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadata = data.metadata && !(<any>data.metadata).toJSON ? new DataDictionary(data.metadata) : <DataDictionary>this.metadata; 
        }
    }

    init(data?: any) {
        if (data) {
            this.fileId = data["fileId"];
            if (data["layerSchemaIds"] && data["layerSchemaIds"].constructor === Array) {
                this.layerSchemaIds = [];
                for (let item of data["layerSchemaIds"])
                    this.layerSchemaIds.push(item);
            }
            this.metadata = data["metadata"] ? DataDictionary.fromJS(data["metadata"]) : <any>undefined;
            if (data["contentPermissionSetIds"] && data["contentPermissionSetIds"].constructor === Array) {
                this.contentPermissionSetIds = [];
                for (let item of data["contentPermissionSetIds"])
                    this.contentPermissionSetIds.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferCreateItem {
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        if (this.layerSchemaIds && this.layerSchemaIds.constructor === Array) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        if (this.contentPermissionSetIds && this.contentPermissionSetIds.constructor === Array) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data; 
    }
}

export interface IFileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: IDataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class UserDetail extends UserItem implements IUserDetail {
    userRoles?: UserRole[] | undefined;
    comment?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    drives?: Drive[] | undefined;
    ownerTokens?: OwnerToken[] | undefined;
    authorizationState: AuthorizationState;

    constructor(data?: IUserDetail) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["userRoles"] && data["userRoles"].constructor === Array) {
                this.userRoles = [];
                for (let item of data["userRoles"])
                    this.userRoles.push(UserRole.fromJS(item));
            }
            this.comment = data["comment"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : <any>undefined;
            if (data["drives"] && data["drives"].constructor === Array) {
                this.drives = [];
                for (let item of data["drives"])
                    this.drives.push(Drive.fromJS(item));
            }
            if (data["ownerTokens"] && data["ownerTokens"].constructor === Array) {
                this.ownerTokens = [];
                for (let item of data["ownerTokens"])
                    this.ownerTokens.push(OwnerToken.fromJS(item));
            }
            this.authorizationState = data["authorizationState"];
        }
    }

    static fromJS(data: any): UserDetail {
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userRoles && this.userRoles.constructor === Array) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (this.drives && this.drives.constructor === Array) {
            data["drives"] = [];
            for (let item of this.drives)
                data["drives"].push(item.toJSON());
        }
        if (this.ownerTokens && this.ownerTokens.constructor === Array) {
            data["ownerTokens"] = [];
            for (let item of this.ownerTokens)
                data["ownerTokens"].push(item.toJSON());
        }
        data["authorizationState"] = this.authorizationState;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserDetail extends IUserItem {
    userRoles?: IUserRole[] | undefined;
    comment?: string | undefined;
    languageCode?: string | undefined;
    address?: IUserAddress | undefined;
    drives?: IDrive[] | undefined;
    ownerTokens?: IOwnerToken[] | undefined;
    authorizationState: AuthorizationState;
}

export class UserAddress implements IUserAddress {
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.address = data["address"];
            this.alternativeAddress = data["alternativeAddress"];
            this.department = data["department"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.phone = data["phone"];
            this.countryCode = data["countryCode"];
        }
    }

    static fromJS(data: any): UserAddress {
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["address"] = this.address;
        data["alternativeAddress"] = this.alternativeAddress;
        data["department"] = this.department;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        return data; 
    }
}

export interface IUserAddress {
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
    countryCode?: string | undefined;
}

export class Drive implements IDrive {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDrive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Drive {
        let result = new Drive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDrive {
    id?: string | undefined;
    name?: string | undefined;
}

export class OwnerToken implements IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;

    constructor(data?: IOwnerToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): OwnerToken {
        let result = new OwnerToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

export enum AuthorizationState {
    Active = <any>"Active", 
    Review = <any>"Review", 
    Locked = <any>"Locked", 
    Invited = <any>"Invited", 
}

export class UserSearchRequest implements IUserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    lifeCycleFilter: LifeCycleFilter;
    userRightsFilter?: UserRight[] | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;

    constructor(data?: IUserSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchString = data["searchString"];
            if (data["searchBehaviours"] && data["searchBehaviours"].constructor === Array) {
                this.searchBehaviours = [];
                for (let item of data["searchBehaviours"])
                    this.searchBehaviours.push(item);
            }
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            this.start = data["start"];
            this.limit = data["limit"];
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.lifeCycleFilter = data["lifeCycleFilter"];
            if (data["userRightsFilter"] && data["userRightsFilter"].constructor === Array) {
                this.userRightsFilter = [];
                for (let item of data["userRightsFilter"])
                    this.userRightsFilter.push(item);
            }
            this.debugMode = data["debugMode"];
        }
    }

    static fromJS(data: any): UserSearchRequest {
        let result = new UserSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (this.searchBehaviours && this.searchBehaviours.constructor === Array) {
            data["searchBehaviours"] = [];
            for (let item of this.searchBehaviours)
                data["searchBehaviours"].push(item);
        }
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["start"] = this.start;
        data["limit"] = this.limit;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        if (this.userRightsFilter && this.userRightsFilter.constructor === Array) {
            data["userRightsFilter"] = [];
            for (let item of this.userRightsFilter)
                data["userRightsFilter"].push(item);
        }
        data["debugMode"] = this.debugMode;
        return data; 
    }
}

export interface IUserSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviours. All the passed behaviours will be applied */
    searchBehaviours?: SearchBehaviour[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    filter?: FilterBase | undefined;
    lifeCycleFilter: LifeCycleFilter;
    userRightsFilter?: UserRight[] | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
}

export class BaseResultOfUser implements IBaseResultOfUser {
    totalResults: number;
    results?: User[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: QueryDebugInformation | undefined;

    constructor(data?: IBaseResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new User(item) : <User>item;
                }
            }
            this.queryDebugInformation = data.queryDebugInformation && !(<any>data.queryDebugInformation).toJSON ? new QueryDebugInformation(data.queryDebugInformation) : <QueryDebugInformation>this.queryDebugInformation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.totalResults = data["totalResults"];
            if (data["results"] && data["results"].constructor === Array) {
                this.results = [];
                for (let item of data["results"])
                    this.results.push(User.fromJS(item));
            }
            this.pageToken = data["pageToken"];
            this.queryDebugInformation = data["queryDebugInformation"] ? QueryDebugInformation.fromJS(data["queryDebugInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseResultOfUser {
        let result = new BaseResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (this.results && this.results.constructor === Array) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["queryDebugInformation"] = this.queryDebugInformation ? this.queryDebugInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseResultOfUser {
    totalResults: number;
    results?: IUser[] | undefined;
    pageToken?: string | undefined;
    queryDebugInformation?: IQueryDebugInformation | undefined;
}

export class SearchBehaviourBaseResultOfUser extends BaseResultOfUser implements ISearchBehaviourBaseResultOfUser {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;

    constructor(data?: ISearchBehaviourBaseResultOfUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.searchString = data["searchString"];
            this.isSearchStringRewritten = data["isSearchStringRewritten"];
        }
    }

    static fromJS(data: any): SearchBehaviourBaseResultOfUser {
        let result = new SearchBehaviourBaseResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        super.toJSON(data);
        return data; 
    }
}

export interface ISearchBehaviourBaseResultOfUser extends IBaseResultOfUser {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export class UserSearchResult extends SearchBehaviourBaseResultOfUser implements IUserSearchResult {
    elapsedMilliseconds: number;

    constructor(data?: IUserSearchResult) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.elapsedMilliseconds = data["elapsedMilliseconds"];
        }
    }

    static fromJS(data: any): UserSearchResult {
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserSearchResult extends ISearchBehaviourBaseResultOfUser {
    elapsedMilliseconds: number;
}

export class User implements IUser {
    userRoleIds?: string[] | undefined;
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userRoleIds"] && data["userRoleIds"].constructor === Array) {
                this.userRoleIds = [];
                for (let item of data["userRoleIds"])
                    this.userRoleIds.push(item);
            }
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userRoleIds && this.userRoleIds.constructor === Array) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUser {
    userRoleIds?: string[] | undefined;
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export class Channel implements IChannel {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names; 
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.missingResultsDisplayPatterns = data.missingResultsDisplayPatterns && !(<any>data.missingResultsDisplayPatterns).toJSON ? new TranslatedStringDictionary(data.missingResultsDisplayPatterns) : <TranslatedStringDictionary>this.missingResultsDisplayPatterns; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.searchIndexId = data["searchIndexId"];
            if (data["schemaIds"] && data["schemaIds"].constructor === Array) {
                this.schemaIds = [];
                for (let item of data["schemaIds"])
                    this.schemaIds.push(item);
            }
            this.filter = data["filter"] ? FilterBase.fromJS(data["filter"]) : <any>undefined;
            this.names = data["names"] ? TranslatedStringDictionary.fromJS(data["names"]) : <any>undefined;
            if (data["sort"] && data["sort"].constructor === Array) {
                this.sort = [];
                for (let item of data["sort"])
                    this.sort.push(SortInfo.fromJS(item));
            }
            if (data["aggregations"] && data["aggregations"].constructor === Array) {
                this.aggregations = [];
                for (let item of data["aggregations"])
                    this.aggregations.push(AggregatorBase.fromJS(item));
            }
            if (data["extendedSimpleSearchFields"] && data["extendedSimpleSearchFields"].constructor === Array) {
                this.extendedSimpleSearchFields = [];
                for (let item of data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields.push(item);
            }
            this.missingResultsDisplayPatterns = data["missingResultsDisplayPatterns"] ? TranslatedStringDictionary.fromJS(data["missingResultsDisplayPatterns"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Channel {
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["searchIndexId"] = this.searchIndexId;
        if (this.schemaIds && this.schemaIds.constructor === Array) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (this.sort && this.sort.constructor === Array) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (this.aggregations && this.aggregations.constructor === Array) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (this.extendedSimpleSearchFields && this.extendedSimpleSearchFields.constructor === Array) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        data["missingResultsDisplayPatterns"] = this.missingResultsDisplayPatterns ? this.missingResultsDisplayPatterns.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChannel {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: ITranslatedStringDictionary | undefined;
    sort?: ISortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary | undefined;
}

export class ContentsByIdsRequest implements IContentsByIdsRequest {
    contentIds?: string[] | undefined;

    constructor(data?: IContentsByIdsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contentIds"] && data["contentIds"].constructor === Array) {
                this.contentIds = [];
                for (let item of data["contentIds"])
                    this.contentIds.push(item);
            }
        }
    }

    static fromJS(data: any): ContentsByIdsRequest {
        let result = new ContentsByIdsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contentIds && this.contentIds.constructor === Array) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        return data; 
    }
}

export interface IContentsByIdsRequest {
    contentIds?: string[] | undefined;
}

export class UserProfile implements IUserProfile {
    id?: string | undefined;
    emailAddress?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    authorizationState: AuthorizationState;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address; 
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.languageCode = data["languageCode"];
            this.address = data["address"] ? UserAddress.fromJS(data["address"]) : <any>undefined;
            this.authorizationState = data["authorizationState"];
        }
    }

    static fromJS(data: any): UserProfile {
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["authorizationState"] = this.authorizationState;
        return data; 
    }
}

export interface IUserProfile {
    id?: string | undefined;
    emailAddress?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    languageCode?: string | undefined;
    address?: IUserAddress | undefined;
    authorizationState: AuthorizationState;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}