(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.picturepark = {}));
})(this, (function (exports) { 'use strict';

    /* tslint:disable */
    /* eslint-disable */
    //----------------------
    // <auto-generated>
    //     Generated using the NSwag toolchain v13.8.1.0 (NJsonSchema v10.2.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
    // </auto-generated>
    //----------------------
    // ReSharper disable InconsistentNaming
    class AuthClient {
        constructor(pictureparkApiUrl, customerAlias) {
            this.pictureparkApiUrl = pictureparkApiUrl;
            this.customerAlias = customerAlias;
        }
        getBaseUrl(defaultUrl, requestedUrl) {
            return requestedUrl ? requestedUrl : this.pictureparkApiUrl;
        }
        transformHttpRequestOptions(options) {
            if (options.headers && this.customerAlias) {
                options.headers['Picturepark-CustomerAlias'] = this.customerAlias;
            }
            return Promise.resolve(options);
        }
    }
    class PictureparkClientBase {
        constructor(authClient) {
            this.authClient = authClient;
        }
        getBaseUrl(defaultUrl, baseUrl) {
            return this.authClient ? this.authClient.getBaseUrl(defaultUrl) : baseUrl;
        }
        transformOptions(options) {
            return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options);
        }
    }
    class BusinessProcessClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get business process
         * @param id The business process id.
         * @return BusinessProcess
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create business process
         * @param request The business process create request.
         * @return BusinessProcess
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Change business process state
         * @param id The business process id.
         * @param request The business process state change request.
         * @return BusinessProcess
         */
        changeState(id, request) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/state";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processChangeState(_response);
            });
        }
        processChangeState(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update business process notification
         * @param id The business process id.
         * @param request The business process notification update request.
         */
        updateNotification(id, request) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/notification";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateNotification(_response);
            });
        }
        processUpdateNotification(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Cancel business process
         * @param id The business process id.
         */
        cancel(id) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/cancel";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCancel(_response);
            });
        }
        processCancel(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Wait for states
         * @param id The business process id.
         * @param states (optional) Business process states to wait for.
         * @param timeout (optional) The timeout to wait for completion.
         * @return BusinessProcessWaitResult
         */
        waitForStates(id, states, timeout) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitStates?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (states !== undefined && states !== null)
                states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processWaitForStates(_response);
            });
        }
        processWaitForStates(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Wait for life cycles
         * @param id The business process id.
         * @param lifeCycles (optional) Business process life cycles to wait for.
         * @param timeout (optional) The timeout to wait for completion.
         * @return BusinessProcessWaitForLifeCycleResult
         */
        waitForLifeCycles(id, lifeCycles, timeout) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitLifeCycles?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (lifeCycles !== undefined && lifeCycles !== null)
                lifeCycles && lifeCycles.forEach(item => { url_ += "lifeCycles=" + encodeURIComponent("" + item) + "&"; });
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processWaitForLifeCycles(_response);
            });
        }
        processWaitForLifeCycles(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Wait for completion
         * @param id The business process id.
         * @param timeout (optional) The timeout to wait for completion.
         * @param waitForContinuationCompletion (optional) Waits for the completion of the continuation business process (if existing, recursively). Default to true.
         * @return BusinessProcessWaitResult
         */
        waitForCompletion(id, timeout, waitForContinuationCompletion) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitCompletion?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitForContinuationCompletion === null)
                throw new Error("The parameter 'waitForContinuationCompletion' cannot be null.");
            else if (waitForContinuationCompletion !== undefined)
                url_ += "waitForContinuationCompletion=" + encodeURIComponent("" + waitForContinuationCompletion) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processWaitForCompletion(_response);
            });
        }
        processWaitForCompletion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get details
         * @param id The business process id.
         * @return BusinessProcessDetails
         * @deprecated
         */
        getDetails(id) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/details";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetDetails(_response);
            });
        }
        processGetDetails(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Returns a summary of the business process.
        Depending on the type of the business process, this can be not available at all or contain just a minimal set of information.
        If business process produces a batch based response, page over successful and failed items using respective endpoints.
         * @param id Business process id.
         * @return BusinessProcessSummaryBaseViewItem
         */
        getSummary(id) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/summary";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetSummary(_response);
            });
        }
        processGetSummary(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Gets a page of successful items of a batch based business process.
        Use the page token to fetch next page.
         * @param id Business process id.
         * @param limit Number of items to fetch.
         * @param pageToken (optional) PageToken for paging.
         * @return BusinessProcessBatchViewItem
         */
        getSuccessfulItems(id, limit, pageToken) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/items/successful?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (limit === undefined || limit === null)
                throw new Error("The parameter 'limit' must be defined and cannot be null.");
            else
                url_ += "limit=" + encodeURIComponent("" + limit) + "&";
            if (pageToken !== undefined && pageToken !== null)
                url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetSuccessfulItems(_response);
            });
        }
        processGetSuccessfulItems(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Gets a page of failed items of a batch based business process.
        Use the page token to fetch next page.
         * @param id Business process id.
         * @param limit Number of items to fetch.
         * @param pageToken (optional) PageToken for paging.
         * @return BusinessProcessBatchViewItem
         */
        getFailedItems(id, limit, pageToken) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/items/failed?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (limit === undefined || limit === null)
                throw new Error("The parameter 'limit' must be defined and cannot be null.");
            else
                url_ += "limit=" + encodeURIComponent("" + limit) + "&";
            if (pageToken !== undefined && pageToken !== null)
                url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetFailedItems(_response);
            });
        }
        processGetFailedItems(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search
         * @param request The business process request.
         * @return BusinessProcessSearchResult
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/BusinessProcesses/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class BusinessRuleClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get the current business rule configuration
         * @return BusinessRuleConfiguration
         */
        getConfiguration() {
            let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetConfiguration(_response);
            });
        }
        processGetConfiguration(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Updates the business rule configuration.
         * @param request Request containing the new configuration.
         * @return Business process
         */
        updateConfiguration(request) {
            let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateConfiguration(_response);
            });
        }
        processUpdateConfiguration(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Searches for trace logs produces by business rule execution.
         * @param request Request
         * @return Holds results of trace log search.
         */
        searchTraces(request) {
            let url_ = this.baseUrl + "/v1/BusinessRules/traceLog/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearchTraces(_response);
            });
        }
        processSearchTraces(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Runs the supplied business rule schedule immediately.
        Allows for testing of schedules.
         * @param schedule BusinessRuleSchedule
         * @return BusinessProcess of the metadata operation triggered by the schedule.
         */
        runSchedule(schedule) {
            let url_ = this.baseUrl + "/v1/BusinessRules/schedule/run";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(schedule);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRunSchedule(_response);
            });
        }
        processRunSchedule(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ChannelClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get all channels
         * @return List of channel
         */
        getAll() {
            let url_ = this.baseUrl + "/v1/Channels";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAll(_response);
            });
        }
        processGetAll(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create channel
         * @param request The request containing information needed to create new channel.
         * @return Created channel
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/Channels";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get channel
         * @param id The channel ID.
         * @return Requested channel
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Channels/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update channel
         * @param id ID of channel to update
         * @param request The request containing information needed to update the channel.
         * @return Updated channel
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/Channels/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete channel
         * @param id ID of the channel that should be deleted.
         * @return OK
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/Channels/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used in an aggregator on any channel.
         * @return The list of fields
         */
        getAggregationFields() {
            let url_ = this.baseUrl + "/v1/Channels/fields/aggregation";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAggregationFields(_response);
            });
        }
        processGetAggregationFields(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used as sort fields on any channel.
         * @return The list of fields
         */
        getSortFields() {
            let url_ = this.baseUrl + "/v1/Channels/fields/sort";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetSortFields(_response);
            });
        }
        processGetSortFields(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used as filter fields on any channel.
         * @return The list of fields
         */
        getFilterFields() {
            let url_ = this.baseUrl + "/v1/Channels/fields/filter";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetFilterFields(_response);
            });
        }
        processGetFilterFields(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ContentPermissionSetClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get content permission set
         * @param id Content permission set ID.
         * @return Detail of a content permission set
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update content permission set
         * @param id Content permission set ID.
         * @param permissionSet Permission set
         * @return Detail of a content permission set
         */
        update(id, permissionSet) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(permissionSet);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete content permission set
         * @param id Content permission set ID.
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create content permission set
         * @param permissionSet Permission set
         * @return Detail of a content permission set
         */
        create(permissionSet) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(permissionSet);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple content permission sets
         * @param ids (optional) Ids
         * @return Array of Detail of a content permission set
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership of content permission set
         * @param id Content permission set ID.
         * @param request Request to transfer the ownership of a permission set.
         */
        transferOwnership(id, request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/ownership";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnership(_response);
            });
        }
        processTransferOwnership(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get permissions for content permission set
         * @param id Content permission set ID.
         * @return Array of Permission set rights
         */
        getPermissions(id) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/permissions";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetPermissions(_response);
            });
        }
        processGetPermissions(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple content permission sets
         * @param request Request to create multiple content permission sets.
         * @return Response to a bulk operation
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple content permission sets
         * @param request Request to update multiple content permission sets.
         * @return Response to a bulk operation
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple content permission sets
         * @param request Request to delete multiple permission sets.
         * @return Response to a bulk operation
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership of multiple content permission sets
         * @param request Request to transfer the ownership of multiple permission sets.
         */
        transferOwnershipMany(request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/ownership";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnershipMany(_response);
            });
        }
        processTransferOwnershipMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get permissions for multiple content permission sets
         * @param ids (optional) Ids
         * @return Array of Rights that the current user has on a permission set
         */
        getPermissionsMany(ids) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/permissions?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetPermissionsMany(_response);
            });
        }
        processGetPermissionsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search content permission set
         * @param request Request to search permission sets.
         * @return Result of a permission set search operation
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/ContentPermissionSets/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ContentClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get content
         * @param id The content ID.
         * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
         * @return Content detail
         */
        get(id, resolveBehaviors) {
            let url_ = this.baseUrl + "/v1/Contents/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete content
         * @param id The ID of the content to delete.
         * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Ok
         */
        delete(id, forceReferenceRemoval, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (forceReferenceRemoval === null)
                throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
            else if (forceReferenceRemoval !== undefined)
                url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download content
         * @param contentId The content ID.
         * @param outputFormatId The output format ID.
         * @param width (optional) Optional width in pixels to resize image.
         * @param height (optional) Optional height in pixels to resize image.
         * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000).
         */
        download(contentId, outputFormatId, width, height, range) {
            let url_ = this.baseUrl + "/v1/Contents/downloads/{contentId}/{outputFormatId}?";
            if (contentId === undefined || contentId === null)
                throw new Error("The parameter 'contentId' must be defined.");
            url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
            if (outputFormatId === undefined || outputFormatId === null)
                throw new Error("The parameter 'outputFormatId' must be defined.");
            url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
            if (width !== undefined && width !== null)
                url_ += "width=" + encodeURIComponent("" + width) + "&";
            if (height !== undefined && height !== null)
                url_ += "height=" + encodeURIComponent("" + height) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "range": range !== undefined && range !== null ? "" + range : "",
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDownload(_response);
            });
        }
        processDownload(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Edit output
         * @param contentId The content ID.
         * @param outputFormatId The output format ID.
         * @param conversionPreset The conversion preset.
         */
        editOutput(contentId, outputFormatId, conversionPreset) {
            let url_ = this.baseUrl + "/v1/Contents/downloads/{contentId}/{outputFormatId}/{conversionPreset}";
            if (contentId === undefined || contentId === null)
                throw new Error("The parameter 'contentId' must be defined.");
            url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
            if (outputFormatId === undefined || outputFormatId === null)
                throw new Error("The parameter 'outputFormatId' must be defined.");
            url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
            if (conversionPreset === undefined || conversionPreset === null)
                throw new Error("The parameter 'conversionPreset' must be defined.");
            url_ = url_.replace("{conversionPreset}", encodeURIComponent("" + conversionPreset));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processEditOutput(_response);
            });
        }
        processEditOutput(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download thumbnail
         * @param id The content ID.
         * @param size Thumbnail size. Either small, medium or large.
         * @param width (optional) Optional width in pixels to resize image.
         * @param height (optional) Optional height in pixels to resize image.
         */
        downloadThumbnail(id, size, width, height) {
            let url_ = this.baseUrl + "/v1/Contents/thumbnails/{id}/{size}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (size === undefined || size === null)
                throw new Error("The parameter 'size' must be defined.");
            url_ = url_.replace("{size}", encodeURIComponent("" + size));
            if (width !== undefined && width !== null)
                url_ += "width=" + encodeURIComponent("" + width) + "&";
            if (height !== undefined && height !== null)
                url_ += "height=" + encodeURIComponent("" + height) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDownloadThumbnail(_response);
            });
        }
        processDownloadThumbnail(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create content
         * @param request Content create request.
         * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
         * @param allowMissingDependencies (optional) Allows creating contents that refer to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return The content details
         */
        create(request, resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents?";
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple contents
         * @param ids List of content IDs
         * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
         * @return List of Content detail
         */
        getMany(ids, resolveBehaviors) {
            let url_ = this.baseUrl + "/v1/Contents?";
            if (ids === undefined)
                throw new Error("The parameter 'ids' must be defined.");
            else if (ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update content metadata
         * @param id The content ID.
         * @param request Content metadata update request.
         * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
         * @param allowMissingDependencies (optional) Allows storing references to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Content detail
         */
        updateMetadata(id, request, resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/metadata?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMetadata(_response);
            });
        }
        processUpdateMetadata(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update content permissions
         * @param id The content ID.
         * @param request Content permissions update request.
         * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Content detail
         */
        updatePermissions(id, request, resolveBehaviors, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/permissions?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdatePermissions(_response);
            });
        }
        processUpdatePermissions(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Restore content
         * @param id The content ID.
         * @param allowMissingDependencies (optional) Allows restoring contents that refer to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Ok
         */
        restore(id, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/restore?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRestore(_response);
            });
        }
        processRestore(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer content ownership
         * @param id The content ID.
         * @param request Content ownership transfer request.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Ok
         */
        transferOwnership(id, request, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/ownership?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnership(_response);
            });
        }
        processTransferOwnership(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Check if given changes of ContentSchemaId are possible without incurring data loss (due to assigned Layers and LayerSchemaIds)
         * @param request Changes to check
         * @return Result indicating if data loss would occur for given requests
         */
        checkContentSchemaChange(request) {
            let url_ = this.baseUrl + "/v1/Contents/checkContentSchemaChange";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCheckContentSchemaChange(_response);
            });
        }
        processCheckContentSchemaChange(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Check if a file update is possible without incurring data loss
         * @param id The ID of the content to replace.
         * @param request Content file update request
         * @return Information about data loss, if any
         */
        checkUpdateFile(id, request) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/file/check";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCheckUpdateFile(_response);
            });
        }
        processCheckUpdateFile(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update content file
         * @param id The ID of the content to replace.
         * @param request Content file update request
         * @return Business process
         */
        updateFile(id, request) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/file";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateFile(_response);
            });
        }
        processUpdateFile(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get content references
         * @param id The content ID whose references to retrieve.
         * @param request Content references request.
         * @return ContentReferencesResult
         */
        getReferences(id, request) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/references/search";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetReferences(_response);
            });
        }
        processGetReferences(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get outputs
         * @param id ID of content.
         * @return Array of Result of output resolution.
         */
        getOutputs(id) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/outputs";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetOutputs(_response);
            });
        }
        processGetOutputs(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create download link
         * @param request Content download link request
         * @return Download link
         */
        createDownloadLink(request) {
            let url_ = this.baseUrl + "/v1/Contents/downloadLinks";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateDownloadLink(_response);
            });
        }
        processCreateDownloadLink(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Resolve download token to Url
         * @param token Token
         * @return Download link information
         */
        getDownloadLink(token) {
            let url_ = this.baseUrl + "/v1/Contents/downloadLink/{token}";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetDownloadLink(_response);
            });
        }
        processGetDownloadLink(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple contents
         * @param request Content create many request.
         * @return Business process
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple content metadata
         * @param request Content metadata update many request.
         * @return Business process
         */
        updateMetadataMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/metadata";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMetadataMany(_response);
            });
        }
        processUpdateMetadataMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple contents permissions
         * @param request Content permissions update many request.
         * @return Business process
         */
        updatePermissionsMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/permissions";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdatePermissionsMany(_response);
            });
        }
        processUpdatePermissionsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer multiple contents ownerships
         * @param request Content ownership transfer many request.
         * @return Business process
         */
        transferOwnershipMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/ownership";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnershipMany(_response);
            });
        }
        processTransferOwnershipMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple contents
         * @param request Delete many request.
         * @return Business process
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple contents - by filter
         * @param request Delete many by filter request.
         * @return Business process
         */
        deleteManyByFilter(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/delete/filter";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteManyByFilter(_response);
            });
        }
        processDeleteManyByFilter(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Restore multiple contents
         * @param request Content restore many request.
         * @return Business process
         */
        restoreMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/restore";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRestoreMany(_response);
            });
        }
        processRestoreMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get many content references
         * @param request Content many references request.
         * @return Content references result
         */
        getReferencesMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/references/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetReferencesMany(_response);
            });
        }
        processGetReferencesMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get outputs
         * @param request Output resolve many request.
         * @return Array of Result of output resolution.
         */
        getOutputsMany(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/outputs";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetOutputsMany(_response);
            });
        }
        processGetOutputsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Repair contents by filter
         * @param request Content repair request.
         * @return Business process
         */
        repairContentsByFilter(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/repair/filter";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRepairContentsByFilter(_response);
            });
        }
        processRepairContentsByFilter(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Repair contents
         * @param request Content repair request.
         * @return Business process
         */
        repairContentsBatch(request) {
            let url_ = this.baseUrl + "/v1/Contents/many/repair/batch";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRepairContentsBatch(_response);
            });
        }
        processRepairContentsBatch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Batch update content fields - by IDs
         * @param request Content fields batch update request.
         * @return Business process
         */
        batchUpdateFieldsByIds(request) {
            let url_ = this.baseUrl + "/v1/Contents/batches/fields/ids";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processBatchUpdateFieldsByIds(_response);
            });
        }
        processBatchUpdateFieldsByIds(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Batch update fields - by filter
         * @param request Content fields batch update filter request. It contains the changes that need to be applied to the contents and the filter request to identify the contents.
         * @return Business process
         */
        batchUpdateFieldsByFilter(request) {
            let url_ = this.baseUrl + "/v1/Contents/batches/fields/filter";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processBatchUpdateFieldsByFilter(_response);
            });
        }
        processBatchUpdateFieldsByFilter(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search contents
         * @param request Content search request.
         * @return Result for content search operation
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Contents/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate contents on channel
         * @param request Content aggregation on channel request.
         * @return Object aggregation result
         */
        aggregateOnChannel(request) {
            let url_ = this.baseUrl + "/v1/Contents/aggregateOnChannel";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregateOnChannel(_response);
            });
        }
        processAggregateOnChannel(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate contents
         * @param request Content aggregation request.
         * @return Object aggregation result
         */
        aggregate(request) {
            let url_ = this.baseUrl + "/v1/Contents/aggregate";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregate(_response);
            });
        }
        processAggregate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get historic versions
         * @param id Content ID.
         * @param request Request allowing for paging
         * @return Historic versions
         */
        getVersions(id, request) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/versions";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetVersions(_response);
            });
        }
        processGetVersions(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get historic version download link
         * @param id Content ID.
         * @param versionId Version ID.
         * @return Download token to be used with download/{token} endpoint
         */
        createVersionDownloadLink(id, versionId) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/versions/{versionId}/file";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (versionId === undefined || versionId === null)
                throw new Error("The parameter 'versionId' must be defined.");
            url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateVersionDownloadLink(_response);
            });
        }
        processCreateVersionDownloadLink(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete historic version
         * @param id Content ID.
         * @param versionId Version ID.
         * @return OK
         */
        deleteVersion(id, versionId) {
            let url_ = this.baseUrl + "/v1/Contents/{id}/versions/{versionId}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (versionId === undefined || versionId === null)
                throw new Error("The parameter 'versionId' must be defined.");
            url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteVersion(_response);
            });
        }
        processDeleteVersion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class DisplayValueClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get status
         * @return VersionInfo
         */
        getStatus() {
            let url_ = this.baseUrl + "/v1/DisplayValues/status";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetStatus(_response);
            });
        }
        processGetStatus(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Re-render the display values
         * @return VersionInfo
         */
        rerender() {
            let url_ = this.baseUrl + "/v1/DisplayValues/rerender";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRerender(_response);
            });
        }
        processRerender(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class DocumentHistoryClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get current
         * @param documentType The type of the document (e.g. Content).
         * @param documentId The ID of the document (e.g. contentId).
         * @return Document history item
         */
        getCurrent(documentType, documentId) {
            let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current";
            if (documentType === undefined || documentType === null)
                throw new Error("The parameter 'documentType' must be defined.");
            url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
            if (documentId === undefined || documentId === null)
                throw new Error("The parameter 'documentId' must be defined.");
            url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetCurrent(_response);
            });
        }
        processGetCurrent(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get version
         * @param documentType The type of the document (e.g. Content).
         * @param documentId The ID of the document (e.g. contentId).
         * @param documentVersion The version of the document.
         * @return Document history item
         */
        getVersion(documentType, documentId, documentVersion) {
            let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}";
            if (documentType === undefined || documentType === null)
                throw new Error("The parameter 'documentType' must be defined.");
            url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
            if (documentId === undefined || documentId === null)
                throw new Error("The parameter 'documentId' must be defined.");
            url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
            if (documentVersion === undefined || documentVersion === null)
                throw new Error("The parameter 'documentVersion' must be defined.");
            url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetVersion(_response);
            });
        }
        processGetVersion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Compare with current
         * @param documentType The type of the document (e.g. Content).
         * @param documentId The ID of the document (e.g. contentId).
         * @param version (optional) The version of the document to compare with.
         * @return Document history difference.
         */
        compareWithCurrent(documentType, documentId, version) {
            let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current/compare?";
            if (documentType === undefined || documentType === null)
                throw new Error("The parameter 'documentType' must be defined.");
            url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
            if (documentId === undefined || documentId === null)
                throw new Error("The parameter 'documentId' must be defined.");
            url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
            if (version === null)
                throw new Error("The parameter 'version' cannot be null.");
            else if (version !== undefined)
                url_ += "version=" + encodeURIComponent("" + version) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCompareWithCurrent(_response);
            });
        }
        processCompareWithCurrent(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Compare with version
         * @param documentType The type of the document (e.g. Content).
         * @param documentId The ID of the document (e.g. contentId).
         * @param documentVersion The version of the document to use for the comparison.
         * @param version (optional) The version of the document to compare with.
         * @return Document history difference
         */
        compareWithVersion(documentType, documentId, documentVersion, version) {
            let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}/compare?";
            if (documentType === undefined || documentType === null)
                throw new Error("The parameter 'documentType' must be defined.");
            url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
            if (documentId === undefined || documentId === null)
                throw new Error("The parameter 'documentId' must be defined.");
            url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
            if (documentVersion === undefined || documentVersion === null)
                throw new Error("The parameter 'documentVersion' must be defined.");
            url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion));
            if (version === null)
                throw new Error("The parameter 'version' cannot be null.");
            else if (version !== undefined)
                url_ += "version=" + encodeURIComponent("" + version) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCompareWithVersion(_response);
            });
        }
        processCompareWithVersion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search
         * @param request The document history search request.
         * @return Document history search result.
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/history/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class IdentityProviderClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get all identity providers
         * @return Array of identity providers
         */
        getAll() {
            let url_ = this.baseUrl + "/v1/IdentityProviders";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAll(_response);
            });
        }
        processGetAll(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get basic info for all providers
         * @return Array of identity provider basic information
         */
        getAllBasicInfos() {
            let url_ = this.baseUrl + "/v1/IdentityProviders/basicInfo";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAllBasicInfos(_response);
            });
        }
        processGetAllBasicInfos(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get identity provider
         * @param id Identity provider ID.
         * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update identity provider
         * @param id Identity provider ID.
         * @param provider Update request
         * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
         */
        update(id, provider) {
            let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(provider);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get synchronizable attributes
         * @return Names of user attributes
         */
        getSynchronizableAttributes() {
            let url_ = this.baseUrl + "/v1/IdentityProviders/synchronizableAttributes";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetSynchronizableAttributes(_response);
            });
        }
        processGetSynchronizableAttributes(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class InfoClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get version
         * @return VersionInfo
         */
        getVersion() {
            let url_ = this.baseUrl + "/v1/Info/version";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetVersion(_response);
            });
        }
        processGetVersion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get info
         * @return CustomerInfo
         */
        getInfo() {
            let url_ = this.baseUrl + "/v1/Info/customer";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetInfo(_response);
            });
        }
        processGetInfo(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get status
         * @return SystemStatus
         */
        getStatus() {
            let url_ = this.baseUrl + "/v1/Info/status";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetStatus(_response);
            });
        }
        processGetStatus(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class JsonSchemaClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get json schema
         * @param id The ID of the schema whose json schema to retrieve.
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/JsonSchemas/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ListItemClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get list item
         * @param id The list item ID.
         * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
         * @return List item detail
         */
        get(id, resolveBehaviors) {
            let url_ = this.baseUrl + "/v1/ListItems/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update list item
         * @param id The list item ID.
         * @param request The list item update request.
         * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
         * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return List item detail
         */
        update(id, request, resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/ListItems/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete list item
         * @param id The ID of the list item to delete.
         * @param forceReferenceRemoval (optional) A value indicating whether references to the list item should be removed.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Ok
         */
        delete(id, forceReferenceRemoval, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/ListItems/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (forceReferenceRemoval === null)
                throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
            else if (forceReferenceRemoval !== undefined)
                url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Restore list item
         * @param id The list item ID.
         * @param allowMissingDependencies (optional) Allows restoring list items that refer to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return Ok
         */
        restore(id, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/ListItems/{id}/restore?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRestore(_response);
            });
        }
        processRestore(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get list item references
         * @param id The ID of the list item.
         * @param request Request options to specify how many references to fetch.
         * @return List item references
         */
        getReferences(id, request) {
            let url_ = this.baseUrl + "/v1/ListItems/{id}/references/search";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetReferences(_response);
            });
        }
        processGetReferences(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create list item
         * @param request List item create request.
         * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
         * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                    By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
         * @return List item detail
         */
        create(request, resolveBehaviors, allowMissingDependencies, timeout, waitSearchDocCreation) {
            let url_ = this.baseUrl + "/v1/ListItems?";
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (allowMissingDependencies === null)
                throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
            else if (allowMissingDependencies !== undefined)
                url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            if (waitSearchDocCreation === null)
                throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
            else if (waitSearchDocCreation !== undefined)
                url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple list items
         * @param ids (optional) List of list item IDs.
         * @param resolveBehaviors (optional) List of enums that control which parts of the list items are resolved and returned.
         * @return List of list item details
         */
        getMany(ids, resolveBehaviors) {
            let url_ = this.baseUrl + "/v1/ListItems?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple list items
         * @param request List item create many request.
         * @return Business process
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple list items
         * @param request List item update many request.
         * @return Business process
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple list items
         * @param request List item delete many request.
         * @return Business process
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple list items - by filter
         * @param request Delete many by filter request.
         * @return Business process
         */
        deleteManyByFilter(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many/delete/filter";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteManyByFilter(_response);
            });
        }
        processDeleteManyByFilter(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Restore multiple list items
         * @param request List item restore many request.
         * @return Business process
         */
        restoreMany(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many/restore";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRestoreMany(_response);
            });
        }
        processRestoreMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple list items references
         * @param request ListItemManyReferencesRequest
         * @return A list of references per list item.
         */
        getReferencesMany(request) {
            let url_ = this.baseUrl + "/v1/ListItems/many/references/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetReferencesMany(_response);
            });
        }
        processGetReferencesMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Batch update fields - by IDs
         * @param request List item fields batch update request.
         * @return Business process
         */
        batchUpdateFieldsByIds(request) {
            let url_ = this.baseUrl + "/v1/ListItems/batches/fields/ids";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processBatchUpdateFieldsByIds(_response);
            });
        }
        processBatchUpdateFieldsByIds(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Batch update fields - by filter
         * @param request List item fields batch update by filter request.
         * @return Business process
         */
        batchUpdateFieldsByFilter(request) {
            let url_ = this.baseUrl + "/v1/ListItems/batches/fields/filter";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processBatchUpdateFieldsByFilter(_response);
            });
        }
        processBatchUpdateFieldsByFilter(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search list items
         * @param request The list item search request.
         * @return List item search result
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/ListItems/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate list items
         * @param request The list item aggregation request.
         * @return Object aggregation result
         */
        aggregate(request) {
            let url_ = this.baseUrl + "/v1/ListItems/aggregate";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregate(_response);
            });
        }
        processAggregate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class LiveStreamClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Search
         * @param request Parameters for the search
         * @return Resulting live stream events
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/LiveStream/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class MetadataClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get status
         * @return The overall status of the contents and list items in comparison to the actual schemas' structure
         */
        getStatus() {
            let url_ = this.baseUrl + "/v1/Metadata/status";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetStatus(_response);
            });
        }
        processGetStatus(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update outdated
         * @return Business process
         */
        updateOutdated() {
            let url_ = this.baseUrl + "/v1/Metadata/many/updateOutdated";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateOutdated(_response);
            });
        }
        processUpdateOutdated(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class NotificationClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get notification
         * @param id ID of notification
         * @return Notification
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Notifications/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Mark notification as read
         * @param id ID of notification
         * @return Notification
         */
        markAsRead(id) {
            let url_ = this.baseUrl + "/v1/Notifications/{id}/markAsRead";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processMarkAsRead(_response);
            });
        }
        processMarkAsRead(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search notifications
         * @param request Notification search request
         * @return Notification search result
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Notifications/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate on notifications
         * @param request Notification aggregation request
         * @return Aggregation result
         */
        aggregate(request) {
            let url_ = this.baseUrl + "/v1/Notifications/aggregate";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregate(_response);
            });
        }
        processAggregate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Mark all notifications as read
         */
        markAllAsRead() {
            let url_ = this.baseUrl + "/v1/Notifications/markAllAsRead";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processMarkAllAsRead(_response);
            });
        }
        processMarkAllAsRead(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get email notification settings
         * @return Email notification settings
         */
        getEmailNotificationSettings() {
            let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/settings";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetEmailNotificationSettings(_response);
            });
        }
        processGetEmailNotificationSettings(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update email notification settings
         * @param configuration Email notification settings
         * @return Email notification settings
         */
        putEmailNotificationSettings(configuration) {
            let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/settings";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(configuration);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processPutEmailNotificationSettings(_response);
            });
        }
        processPutEmailNotificationSettings(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get notification types available for email settings.
         * @return Array of Notification that is available for email settings.
         */
        getAvailableNotificationTypes() {
            let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/types";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAvailableNotificationTypes(_response);
            });
        }
        processGetAvailableNotificationTypes(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class OutputFormatClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Sets the download file name patterns for an output format
         * @param id ID of the output format.
         * @param patterns Dictionary containing patterns per metadata language.
        If this is set, at least the customer's default language is required.
        Set any other language to an empty string and a fallback to the default language will occur.
        Set parameter to null to clear any already set patterns.
         * @return Business process
         */
        setDownloadFileNamePatterns(id, patterns) {
            let url_ = this.baseUrl + "/v1/OutputFormats/{id}/downloadFileNamePatterns";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(patterns);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSetDownloadFileNamePatterns(_response);
            });
        }
        processSetDownloadFileNamePatterns(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Sets the download file name patterns for multiple output formats
         * @param request The request containing the patterns for each output format.
         * @return Business process
         */
        setDownloadFileNamePatternsMany(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/many/downloadFileNamePatterns";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSetDownloadFileNamePatternsMany(_response);
            });
        }
        processSetDownloadFileNamePatternsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Enables or disables XMP writeback for an output format
         * @param id ID of the output format.
         * @param request The request containing the state to be set for the output format.
         * @return Business process
         */
        setXmpWritebackState(id, request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/{id}/xmpWriteback";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSetXmpWritebackState(_response);
            });
        }
        processSetXmpWritebackState(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Enables or disables XMP writeback for multiple output formats
         * @param request The request containing the state changes for each output format.
         * @return Business process
         */
        setXmpWritebackState2(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/many/xmpWriteback";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSetXmpWritebackState2(_response);
            });
        }
        processSetXmpWritebackState2(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Render output format preview
         * @param request Information about the OutputFormat as well as which Content to use for the preview.
         * @return Rendered file
         */
        renderFormatPreview(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/preview";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRenderFormatPreview(_response);
            });
        }
        processRenderFormatPreview(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple output formats
         * @param ids (optional) Output format IDs to get information about. If this is omitted, all output formats in the system will be returned.
         * @return Array of Represents an output format.
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/OutputFormats?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create output format
         * @param request Request containing information needed to create new output format.
         * @return Business process
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get output format
         * @param id Output format ID.
         * @return Represents an output format.
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update output format
         * @param id Output format ID.
         * @param request Request containing information needed to update the output format.
         * @return Business process
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete output format
         * @param id Output format ID.
         * @return Business process
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple output formats
         * @param request Request containing information needed to create new output format.
         * @return Business process
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple output formats
         * @param request Request containing information needed to update the output format.
         * @return Business process
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple output formats
         * @param request The request with output format IDs to delete.
         * @return Business process
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/OutputFormats/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class OutputClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get output
         * @param id Output ID.
         * @return Output detail
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Outputs/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search output documents
         * @param request The output search request.
         * @return Output result set
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Outputs/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Resets retry attempt counters.
         * @param request Request containing options to filter which outputs should be reset.
         * @return Business process tracking the resetting
         */
        resetRetryAttempts(request) {
            let url_ = this.baseUrl + "/v1/Outputs/resetRetryAttempts";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processResetRetryAttempts(_response);
            });
        }
        processResetRetryAttempts(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ProfileClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get
         * @return User profile
         */
        get() {
            let url_ = this.baseUrl + "/v1/Profile";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update
         * @param request Request to update a user profile..
         * @return Updated user profile
         */
        update(request) {
            let url_ = this.baseUrl + "/v1/Profile";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Request deletion
         * @return OK
         */
        requestDeletion() {
            let url_ = this.baseUrl + "/v1/Profile/requestDeletion";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRequestDeletion(_response);
            });
        }
        processRequestDeletion(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class SchemaPermissionSetClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get schema permission set
         * @param id Schema permission set ID.
         * @return Detail of a schema permission set
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update schema permission set
         * @param id Schema permission set ID.
         * @param permissionSet Permission set
         * @return Detail of a schema permission set
         */
        update(id, permissionSet) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(permissionSet);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete schema permission set
         * @param id Schema permission set ID.
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create schema permission set
         * @param permissionSet Permission set
         * @return Detail of a schema permission set
         */
        create(permissionSet) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(permissionSet);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple schema permission sets
         * @param ids (optional) Ids
         * @return Array of Detail of a schema permission set
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership of schema permission set
         * @param id Schema permission set ID.
         * @param request Request to transfer the ownership of a permission set.
         */
        transferOwnership(id, request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/ownership";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnership(_response);
            });
        }
        processTransferOwnership(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get permissions for schema permission set
         * @param id Schema permission set ID.
         * @return Array of Permission set rights
         */
        getPermissions(id) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/permissions";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetPermissions(_response);
            });
        }
        processGetPermissions(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple schema permission sets
         * @param request Request to update multiple schema permission sets.
         * @return Response to a bulk operation
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple schema permission sets
         * @param request Request to update multiple schema permissions sets.
         * @return Response to a bulk operation
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple schema permission sets
         * @param request Request to delete multiple permission sets.
         * @return Response to a bulk operation
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership of multiple schema permission sets
         * @param request Request to transfer the ownership of multiple permission sets.
         */
        transferOwnershipMany(request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/ownership";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnershipMany(_response);
            });
        }
        processTransferOwnershipMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get permissions for multiple schema permission sets
         * @param ids (optional) Ids
         * @return Array of Rights that the current user has on a permission set
         */
        getPermissionsMany(ids) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/permissions?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetPermissionsMany(_response);
            });
        }
        processGetPermissionsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search schema permission set
         * @param request Request to search permission sets.
         * @return Result of a permission set search operation
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/SchemaPermissionSets/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class SchemaClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get schema
         * @param id The schema ID.
         * @return Schema detail
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update schema
         * @param id The schema ID.
         * @param request The schema update request.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @return Schema update result, containing the updated schema
         */
        update(id, request, timeout) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete schema
         * @param id The schema ID.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @return Schema delete result
         */
        delete(id, timeout) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Exists schema
         * @param id The schema ID.
         * @return Schema Exists response
         */
        exists(id) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}/exists";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processExists(_response);
            });
        }
        processExists(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Exists field in schema
         * @param schemaId The schema ID.
         * @param fieldId The field ID.
         * @return Field Exists response
         */
        fieldExists(schemaId, fieldId) {
            let url_ = this.baseUrl + "/v1/Schemas/{schemaId}/{fieldId}/exists";
            if (schemaId === undefined || schemaId === null)
                throw new Error("The parameter 'schemaId' must be defined.");
            url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
            if (fieldId === undefined || fieldId === null)
                throw new Error("The parameter 'fieldId' must be defined.");
            url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processFieldExists(_response);
            });
        }
        processFieldExists(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Gets all schemas referenced by the schema specified in id
         * @param id The schema ID.
         * @param sourceSchema (optional) If true, the returned schemas contain also the source schema for which the referenced schemas were requested. If false, the source schema is not returned (default behavior).
         * @return Referenced schema details
         */
        getReferenced(id, sourceSchema) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}/referenced?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (sourceSchema === null)
                throw new Error("The parameter 'sourceSchema' cannot be null.");
            else if (sourceSchema !== undefined)
                url_ += "sourceSchema=" + encodeURIComponent("" + sourceSchema) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetReferenced(_response);
            });
        }
        processGetReferenced(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership
         * @param id The schema ID.
         * @param request Request detailing which user to transfer to.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @return OK
         */
        transferOwnership(id, request, timeout) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}/ownership?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnership(_response);
            });
        }
        processTransferOwnership(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create schema
         * @param request The schema create request.
         * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                    Only the waiting is aborted, and the calls returned.
         * @return Schema create result, containing the created schema
         */
        create(request, timeout) {
            let url_ = this.baseUrl + "/v1/Schemas?";
            if (timeout !== undefined && timeout !== null)
                url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple schemas
         * @param ids (optional) Comma separated list of schema IDs.
         * @return List of schema details
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/Schemas?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple schemas
         * @param request The schema create many request.
         * @return BusinessProcess which can be awaited
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/Schemas/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple schema
         * @param request Request to update multiple schemas.
         * @return BusinessProcess which can be awaited
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/Schemas/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Gets all schemas referenced by the schemas specified in ids
         * @param ids (optional) The schema IDs.
         * @param sourceSchema (optional) If true, the returned schemas contain also the source schemas for which the referenced schemas were requested. If false, the source schemas are not returned (default behavior).
         * @return Referenced schema details
         */
        getManyReferenced(ids, sourceSchema) {
            let url_ = this.baseUrl + "/v1/Schemas/many/referenced?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            if (sourceSchema === null)
                throw new Error("The parameter 'sourceSchema' cannot be null.");
            else if (sourceSchema !== undefined)
                url_ += "sourceSchema=" + encodeURIComponent("" + sourceSchema) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetManyReferenced(_response);
            });
        }
        processGetManyReferenced(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Transfer ownership of multiple schemas
         * @param request Schema ownership transfer many request.
         * @return Business process
         */
        transferOwnershipMany(request) {
            let url_ = this.baseUrl + "/v1/Schemas/many/ownership";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processTransferOwnershipMany(_response);
            });
        }
        processTransferOwnershipMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search schemas
         * @param request The schema search request.
         * @return Schema search result
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Schemas/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used in an aggregator on a schema.
         * @param id The ID of the schema.
         * @return The list of fields
         */
        getAggregationFields(id) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}/aggregationFields";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAggregationFields(_response);
            });
        }
        processGetAggregationFields(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used in an aggregator on multiple schemas.
         * @param ids (optional) The IDs of the schemas.
         * @return The list of fields
         */
        getAggregationFieldsMany(ids) {
            let url_ = this.baseUrl + "/v1/Schemas/many/aggregationFields?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAggregationFieldsMany(_response);
            });
        }
        processGetAggregationFieldsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used in a filter on a schema.
         * @param id The ID of the schema.
         * @return The list of fields
         */
        getFilterFields(id) {
            let url_ = this.baseUrl + "/v1/Schemas/{id}/filterFields";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetFilterFields(_response);
            });
        }
        processGetFilterFields(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Retrieve the fields that can be used in a filter on multiple schemas.
         * @param ids (optional) The IDs of the schemas.
         * @return The list of fields
         */
        getFilterFieldsMany(ids) {
            let url_ = this.baseUrl + "/v1/Schemas/many/filterFields?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetFilterFieldsMany(_response);
            });
        }
        processGetFilterFieldsMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class SchemaTransferClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Import schemas
         * @param request The schema import request.
         * @return Transfer
         */
        import(request) {
            let url_ = this.baseUrl + "/v1/SchemaTransfers/import";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processImport(_response);
            });
        }
        processImport(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("A server side error occurred.", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class ShareClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get share json
         * @param token Share token
         * @param lang (optional) Language code
         * @param resolveBehaviors (optional) List of enums that control which parts of the share are resolved and returned.
         * @param contentResolveLimit (optional) Optional limit the number of contents to resolve. Use a lower value for higher performance. If nothing is specified, everything is resolved.
         * @return ShareDetail
         */
        getShareJson(token, lang, resolveBehaviors, contentResolveLimit) {
            let url_ = this.baseUrl + "/v1/Shares/json/{token}?";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            if (lang !== undefined && lang !== null)
                url_ += "lang=" + encodeURIComponent("" + lang) + "&";
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (contentResolveLimit !== undefined && contentResolveLimit !== null)
                url_ += "contentResolveLimit=" + encodeURIComponent("" + contentResolveLimit) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetShareJson(_response);
            });
        }
        processGetShareJson(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get share contents
         * @param token Share token
         * @param lang (optional) Language code
         * @param limit (optional) Number of contents to return
         * @param pageToken (optional) PageToken to page over contents
         * @return ShareContentDetailResult
         */
        getShareContents(token, lang, limit, pageToken) {
            let url_ = this.baseUrl + "/v1/Shares/json/{token}/contents?";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            if (lang !== undefined && lang !== null)
                url_ += "lang=" + encodeURIComponent("" + lang) + "&";
            if (limit === null)
                throw new Error("The parameter 'limit' cannot be null.");
            else if (limit !== undefined)
                url_ += "limit=" + encodeURIComponent("" + limit) + "&";
            if (pageToken !== undefined && pageToken !== null)
                url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetShareContents(_response);
            });
        }
        processGetShareContents(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get shared outputs
         * @param token Share token
         * @return List of OutputResolveResult
         */
        getOutputsInShare(token) {
            let url_ = this.baseUrl + "/v1/Shares/json/{token}/outputs";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetOutputsInShare(_response);
            });
        }
        processGetOutputsInShare(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download shared outputs
         * @param token Share token
         * @param width (optional) Optional width in pixels to resize image
         * @param height (optional) Optional height in pixels to resize image
         * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
         */
        download(token, width, height, range) {
            let url_ = this.baseUrl + "/v1/Shares/d/{token}?";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            if (width !== undefined && width !== null)
                url_ += "width=" + encodeURIComponent("" + width) + "&";
            if (height !== undefined && height !== null)
                url_ += "height=" + encodeURIComponent("" + height) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "range": range !== undefined && range !== null ? "" + range : "",
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDownload(_response);
            });
        }
        processDownload(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download selection of a share
         * @param token Share token
         * @param request Share download request
         * @return DownloadLink
         */
        createShareSelectionDownloadLink(token, request) {
            let url_ = this.baseUrl + "/v1/Shares/d/{token}";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateShareSelectionDownloadLink(_response);
            });
        }
        processCreateShareSelectionDownloadLink(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download shared output
         * @param token Share token
         * @param contentId The content id
         * @param outputFormatId The output format id
         * @param width (optional) Optional width in pixels to resize image
         * @param height (optional) Optional height in pixels to resize image
         * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
         */
        downloadSingleContent(token, contentId, outputFormatId, width, height, range) {
            let url_ = this.baseUrl + "/v1/Shares/d/{token}/{contentId}/{outputFormatId}?";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            if (contentId === undefined || contentId === null)
                throw new Error("The parameter 'contentId' must be defined.");
            url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
            if (outputFormatId === undefined || outputFormatId === null)
                throw new Error("The parameter 'outputFormatId' must be defined.");
            url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
            if (width !== undefined && width !== null)
                url_ += "width=" + encodeURIComponent("" + width) + "&";
            if (height !== undefined && height !== null)
                url_ += "height=" + encodeURIComponent("" + height) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "range": range !== undefined && range !== null ? "" + range : "",
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDownloadSingleContent(_response);
            });
        }
        processDownloadSingleContent(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Download shared outputs
         * @param token Share token
         * @param conversionPreset Image editing specification
         * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
         */
        downloadWithConversionPreset(token, conversionPreset, range) {
            let url_ = this.baseUrl + "/v1/Shares/d/{token}/{conversionPreset}";
            if (token === undefined || token === null)
                throw new Error("The parameter 'token' must be defined.");
            url_ = url_.replace("{token}", encodeURIComponent("" + token));
            if (conversionPreset === undefined || conversionPreset === null)
                throw new Error("The parameter 'conversionPreset' must be defined.");
            url_ = url_.replace("{conversionPreset}", encodeURIComponent("" + conversionPreset));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "range": range !== undefined && range !== null ? "" + range : "",
                    "Accept": "application/octet-stream"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDownloadWithConversionPreset(_response);
            });
        }
        processDownloadWithConversionPreset(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status === 412) {
                return response.text().then((_responseText) => {
                    return throwException("A server side error occurred.", status, _responseText, _headers);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get
         * @param id Share Id (not token, use [GetShareJson](#operation/Share_GetShareJson) to get share by token)
         * @param resolveBehaviors (optional) List of enums that control which parts of the share are resolved and returned.
         * @param contentResolveLimit (optional) Optional limit the number of contents to resolve. Use a lower value for higher performance. If nothing is specified, everything is resolved.
         * @return Share detail
         */
        get(id, resolveBehaviors, contentResolveLimit) {
            let url_ = this.baseUrl + "/v1/Shares/{id}?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (resolveBehaviors !== undefined && resolveBehaviors !== null)
                resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
            if (contentResolveLimit !== undefined && contentResolveLimit !== null)
                url_ += "contentResolveLimit=" + encodeURIComponent("" + contentResolveLimit) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update
         * @param id The share id.
         * @param request The share update request.
         * @return BusinessProcess
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/Shares/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get contents in share
         * @param id Share Id
         * @param limit (optional) Number of contents to return
         * @param pageToken (optional) PageToken to page over contents
         * @return ShareContentDetailResult
         */
        getContentsInShare(id, limit, pageToken) {
            let url_ = this.baseUrl + "/v1/Shares/{id}/contents?";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            if (limit === null)
                throw new Error("The parameter 'limit' cannot be null.");
            else if (limit !== undefined)
                url_ += "limit=" + encodeURIComponent("" + limit) + "&";
            if (pageToken !== undefined && pageToken !== null)
                url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetContentsInShare(_response);
            });
        }
        processGetContentsInShare(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create
         * @param request Polymorphic create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
         * @return BusinessProcess
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/Shares";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("A server side error occurred.", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple shares
         * @param request A delete many request containing the ids of the shares to delete.
         * @return BusinessProcess
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/Shares/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Revokes multiple shares
         * @param request A revoke many request containing the ids of the shares to revoke.
         * @return BusinessProcess
         */
        revoke(request) {
            let url_ = this.baseUrl + "/v1/Shares/many/revoke";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRevoke(_response);
            });
        }
        processRevoke(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate
         * @param request Aggregation request
         * @return Share aggregation result
         */
        aggregate(request) {
            let url_ = this.baseUrl + "/v1/Shares/aggregate";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregate(_response);
            });
        }
        processAggregate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search
         * @param request Search request
         * @return Share search result
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Shares/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class StatisticClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Retrieve single content statistics
         * @param contentId Id of Content
         * @param timeFrames (optional) Optionally aggregate data for given time frames
         */
        getSingleContentStatistics(contentId, timeFrames) {
            let url_ = this.baseUrl + "/v1/Statistics/contents/{contentId}?";
            if (contentId === undefined || contentId === null)
                throw new Error("The parameter 'contentId' must be defined.");
            url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
            if (timeFrames !== undefined && timeFrames !== null)
                timeFrames && timeFrames.forEach(item => { url_ += "timeFrames=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetSingleContentStatistics(_response);
            });
        }
        processGetSingleContentStatistics(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Export content statistics
         * @param request Request
         * @return Business process
         */
        exportContentStatistics(request) {
            let url_ = this.baseUrl + "/v1/Statistics/contents/export";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processExportContentStatistics(_response);
            });
        }
        processExportContentStatistics(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Resolve download link
         * @param referenceId Reference id
         * @return Download link information
         */
        resolveDownloadLink(referenceId) {
            let url_ = this.baseUrl + "/v1/Statistics/downloadLink/{referenceId}";
            if (referenceId === undefined || referenceId === null)
                throw new Error("The parameter 'referenceId' must be defined.");
            url_ = url_.replace("{referenceId}", encodeURIComponent("" + referenceId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processResolveDownloadLink(_response);
            });
        }
        processResolveDownloadLink(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Add content events
         * @param request Request
         * @return Business process
         */
        addContentEvents(request) {
            let url_ = this.baseUrl + "/v1/Statistics/contents/events";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAddContentEvents(_response);
            });
        }
        processAddContentEvents(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class TemplateClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get template
         * @param id ID of template.
         * @return Template
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Templates/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update template
         * @param id ID of template.
         * @param request Template
         * @return Template
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/Templates/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete template
         * @param id ID of template
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/Templates/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create template
         * @param request TemplateCreateRequest
         * @return Template
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/Templates";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get all templates
         * @return All templates
         */
        getAll() {
            let url_ = this.baseUrl + "/v1/Templates";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAll(_response);
            });
        }
        processGetAll(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class TransferClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Create transfer
         * @param request The create transfer request
         * @return Transfer
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/Transfers";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get transfer details
         * @param id ID of transfer.
         * @return TransferDetail
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Transfers/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete transfer
         * @param id ID of transfer.
         * @return OK
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/Transfers/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Import transfer
         * @param id ID of transfer.
         * @param request The ImportTransfer request.
         * @return Transfer
         */
        import(id, request) {
            let url_ = this.baseUrl + "/v1/Transfers/{id}/import";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processImport(_response);
            });
        }
        processImport(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Import transfer partially
         * @param id ID of transfer.
         * @param request The ImportTransferPartial request.
         * @return Transfer
         */
        partialImport(id, request) {
            let url_ = this.baseUrl + "/v1/Transfers/{id}/partialImport";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processPartialImport(_response);
            });
        }
        processPartialImport(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Cancel transfer
         * @param id ID of transfer.
         * @return OK
         */
        cancel(id) {
            let url_ = this.baseUrl + "/v1/Transfers/{id}/cancel";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCancel(_response);
            });
        }
        processCancel(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search
         * @param request The transfer search request
         * @return TransferSearchResult
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Transfers/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get file
         * @param id ID of file transfer.
         * @return FileTransferDetail
         */
        getFile(id) {
            let url_ = this.baseUrl + "/v1/Transfers/files/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetFile(_response);
            });
        }
        processGetFile(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search for files
         * @param request The file transfer search request
         * @return FileTransferSearchResult
         */
        searchFiles(request) {
            let url_ = this.baseUrl + "/v1/Transfers/files/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearchFiles(_response);
            });
        }
        processSearchFiles(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete files
         * @param request The file transfer delete request
         */
        deleteFiles(request) {
            let url_ = this.baseUrl + "/v1/Transfers/files/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteFiles(_response);
            });
        }
        processDeleteFiles(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get blacklist
         * @return Blacklist
         */
        getBlacklist() {
            let url_ = this.baseUrl + "/v1/Transfers/files/blacklist";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetBlacklist(_response);
            });
        }
        processGetBlacklist(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Upload file
         * @param chunkNumber Information about chunk.
         * @param currentChunkSize Information about chunk.
         * @param totalSize Information about chunk.
         * @param totalChunks Information about chunk.
         * @param transferId ID of transfer.
         * @param requestId Identifier of file.
         * @param body (optional) Body
         * @return OK
         */
        uploadFile(chunkNumber, currentChunkSize, totalSize, totalChunks, transferId, requestId, body) {
            let url_ = this.baseUrl + "/v1/Transfers/{transferId}/files/{requestId}/upload?";
            if (transferId === undefined || transferId === null)
                throw new Error("The parameter 'transferId' must be defined.");
            url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId));
            if (requestId === undefined || requestId === null)
                throw new Error("The parameter 'requestId' must be defined.");
            url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
            if (chunkNumber === undefined || chunkNumber === null)
                throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
            else
                url_ += "ChunkNumber=" + encodeURIComponent("" + chunkNumber) + "&";
            if (currentChunkSize === undefined || currentChunkSize === null)
                throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
            else
                url_ += "CurrentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&";
            if (totalSize === undefined || totalSize === null)
                throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
            else
                url_ += "TotalSize=" + encodeURIComponent("" + totalSize) + "&";
            if (totalChunks === undefined || totalChunks === null)
                throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
            else
                url_ += "TotalChunks=" + encodeURIComponent("" + totalChunks) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = body;
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/octet-stream",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUploadFile(_response);
            });
        }
        processUploadFile(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class UserRoleClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Search user roles
         * @param request User role search request.
         * @return Result of the user role search
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/UserRoles/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple user roles
         * @param ids (optional) User role IDs to get information about.
         * @return Array of Represents a user role, which associates users with user rights.
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/UserRoles?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create user role
         * @param request Request containing information needed to create new user role.
         * @return Represents a user role, which associates users with user rights.
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/UserRoles";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple user roles
         * @param request Request containing information needed to create new user role.
         * @return Response to a bulk operation
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/UserRoles/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple user roles
         * @param request Request containing information needed to update the user role.
         * @return Response to a bulk operation
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/UserRoles/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple user roles
         * @param request The request with user role IDs to delete.
         * @return Response to a bulk operation
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/UserRoles/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get user role
         * @param id User role ID.
         * @return Represents a user role, which associates users with user rights.
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/UserRoles/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update user role
         * @param id User role ID.
         * @param request Request containing information needed to update the user role.
         * @return Represents a user role, which associates users with user rights.
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/UserRoles/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete user role
         * @param id User role ID.
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/UserRoles/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class UserClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Get user
         * @param id User ID to search for.
         * @return Requested user details
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update user
         * @param id User ID to action on.
         * @param request New user information.
         * @return User details after the update of the user
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/Users/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Lock / unlock user
         * @param id User ID to action on.
         * @param request Request detailing if the user should be locked or unlocked.
         * @return OK
         */
        lock(id, request) {
            let url_ = this.baseUrl + "/v1/Users/{id}/lock";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processLock(_response);
            });
        }
        processLock(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Change lock state of multiple users
         * @param request Information about users to update and the desired lock state
         * @return Business process
         */
        lockMany(request) {
            let url_ = this.baseUrl + "/v1/Users/many/lock";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processLockMany(_response);
            });
        }
        processLockMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Change user's review state
         * @param id User ID to action on.
         * @param request Request detailing if the user should be set as _reviewed_ or _to be reviewed_.
         * @return OK
         */
        review(id, request) {
            let url_ = this.baseUrl + "/v1/Users/{id}/review";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processReview(_response);
            });
        }
        processReview(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Change Review state of multiple users
         * @param request Information about users to update and the desired review state
         * @return Business process
         */
        reviewMany(request) {
            let url_ = this.baseUrl + "/v1/Users/many/review";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processReviewMany(_response);
            });
        }
        processReviewMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Invite user
         * @param id User ID to action on.
         * @return OK
         */
        invite(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}/invite";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processInvite(_response);
            });
        }
        processInvite(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Invite multiple users
         * @param request Information about users to invite
         * @return Business process
         */
        inviteMany(request) {
            let url_ = this.baseUrl + "/v1/Users/many/invite";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processInviteMany(_response);
            });
        }
        processInviteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Reinvite user
         * @param id User ID to action on.
         * @return OK
         */
        reinvite(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}/reinvite";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processReinvite(_response);
            });
        }
        processReinvite(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Reinvite users
         * @param request Information about users to reinvite
         * @return Business process
         */
        reInviteMany(request) {
            let url_ = this.baseUrl + "/v1/Users/many/reinvite";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processReInviteMany(_response);
            });
        }
        processReInviteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Assign or unassign userRoles
         * @param request Information about users to modify and kind of operation
         * @return Business process
         */
        assignUserRoles(request) {
            let url_ = this.baseUrl + "/v1/Users/many/assignUserRoles";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAssignUserRoles(_response);
            });
        }
        processAssignUserRoles(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete user
         * @param id User ID
         * @param request Request with details about deletion
         * @return OK
         */
        delete(id, request) {
            let url_ = this.baseUrl + "/v1/Users/{id}/delete";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Archive user
         * @param id User ID
         * @return OK
         */
        archive(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}/archive";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processArchive(_response);
            });
        }
        processArchive(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Restore user
         * @param id User ID to action on.
         * @return OK
         */
        restore(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}/restore";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processRestore(_response);
            });
        }
        processRestore(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Cancels a user triggered deletion request and returns user to _Reviewed_ state.
         * @param id User ID to action on.
         * @return OK
         */
        cancelDeletionRequest(id) {
            let url_ = this.baseUrl + "/v1/Users/{id}/cancelDeletionRequest";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {}
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCancelDeletionRequest(_response);
            });
        }
        processCancelDeletionRequest(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get user by owner token
         * @param tokenId ID of the owner token.
         * @return User details of the user referenced by the owner token
         */
        getByOwnerToken(tokenId) {
            let url_ = this.baseUrl + "/v1/Users/owner/{tokenId}";
            if (tokenId === undefined || tokenId === null)
                throw new Error("The parameter 'tokenId' must be defined.");
            url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetByOwnerToken(_response);
            });
        }
        processGetByOwnerToken(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create user
         * @param request Requested user information.
         * @return Newly created user
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/Users";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple users
         * @param ids (optional) User IDs.
         * @return Details of all the users who were found
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/Users/many?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Search users
         * @param request User search request.
         * @return Result of the user search
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/Users/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Aggregate users
         * @param request User aggregation request.
         * @return Aggregation based on the request
         */
        aggregate(request) {
            let url_ = this.baseUrl + "/v1/Users/aggregate";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processAggregate(_response);
            });
        }
        processAggregate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update identity provider on multiple users
         * @param request User update identity provider request.
         * @return Business process
         */
        updateIdentityProviderMany(request) {
            let url_ = this.baseUrl + "/v1/Users/many/updateIdentityProvider";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateIdentityProviderMany(_response);
            });
        }
        processUpdateIdentityProviderMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    class XmpMappingClient extends PictureparkClientBase {
        constructor(configuration, baseUrl, http) {
            super(configuration);
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = this.getBaseUrl("", baseUrl);
        }
        /**
         * Gets fields available for XMP mapping.
         * @return XmpMappingTargets containing both XMP fields and metadata fields that are available for mapping.
         */
        getAvailableTargets() {
            let url_ = this.baseUrl + "/v1/XmpMappings/targets";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetAvailableTargets(_response);
            });
        }
        processGetAvailableTargets(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Searches for XMP mappings
         * @param request Search request for getting configured XMP mappings.
         * @return Holds results of search for XMP mappings
         */
        search(request) {
            let url_ = this.baseUrl + "/v1/XmpMappings/search";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processSearch(_response);
            });
        }
        processSearch(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get xmp mapping
         * @param id Xmp mapping ID.
         * @return XMP mapping entry
         */
        get(id) {
            let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update xmp mapping
         * @param id Xmp mapping ID.
         * @param request Request containing information needed to update the xmp mapping.
         * @return Business process
         */
        update(id, request) {
            let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdate(_response);
            });
        }
        processUpdate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete xmp mapping
         * @param id Xmp mapping ID.
         * @return Business process
         */
        delete(id) {
            let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "DELETE",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDelete(_response);
            });
        }
        processDelete(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create xmp mapping
         * @param request Request containing information needed to create new xmp mapping.
         * @return Business process
         */
        create(request) {
            let url_ = this.baseUrl + "/v1/XmpMappings";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Get multiple xmp mappings
         * @param ids (optional) Xmp mapping IDs to get information about.
         * @return Array of XMP mapping entry
         */
        getMany(ids) {
            let url_ = this.baseUrl + "/v1/XmpMappings?";
            if (ids !== undefined && ids !== null)
                ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processGetMany(_response);
            });
        }
        processGetMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Create multiple xmp mappings
         * @param request Request containing information needed to create new xmp mapping.
         * @return Business process
         */
        createMany(request) {
            let url_ = this.baseUrl + "/v1/XmpMappings/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processCreateMany(_response);
            });
        }
        processCreateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Update multiple xmp mappings
         * @param request Request containing information needed to update the xmp mapping.
         * @return Business process
         */
        updateMany(request) {
            let url_ = this.baseUrl + "/v1/XmpMappings/many";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processUpdateMany(_response);
            });
        }
        processUpdateMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * Delete multiple xmp mappings
         * @param request The request with xmp mapping IDs to delete.
         * @return Business process
         */
        deleteMany(request) {
            let url_ = this.baseUrl + "/v1/XmpMappings/many/delete";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response) => {
                return this.processDeleteMany(_response);
            });
        }
        processDeleteMany(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Validation exception", status, _responseText, _headers, result400);
                });
            }
            else if (status === 401) {
                return response.text().then((_responseText) => {
                    return throwException("Unauthorized", status, _responseText, _headers);
                });
            }
            else if (status === 403) {
                return response.text().then((_responseText) => {
                    let result403 = null;
                    result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Forbidden", status, _responseText, _headers, result403);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Entity not found", status, _responseText, _headers, result404);
                });
            }
            else if (status === 405) {
                return response.text().then((_responseText) => {
                    return throwException("Method not allowed", status, _responseText, _headers);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Version conflict", status, _responseText, _headers, result409);
                });
            }
            else if (status === 429) {
                return response.text().then((_responseText) => {
                    return throwException("Too many requests", status, _responseText, _headers);
                });
            }
            else if (status === 500) {
                return response.text().then((_responseText) => {
                    let result500 = null;
                    result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    return throwException("Internal server error", status, _responseText, _headers, result500);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    /** Scope of the business process */
    exports.BusinessProcessScope = void 0;
    (function (BusinessProcessScope) {
        BusinessProcessScope[BusinessProcessScope["System"] = "System"] = "System";
        BusinessProcessScope[BusinessProcessScope["User"] = "User"] = "User";
    })(exports.BusinessProcessScope || (exports.BusinessProcessScope = {}));
    /** Life cycle of the business process */
    exports.BusinessProcessLifeCycle = void 0;
    (function (BusinessProcessLifeCycle) {
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["Draft"] = "Draft"] = "Draft";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["InProgress"] = "InProgress"] = "InProgress";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["Succeeded"] = "Succeeded"] = "Succeeded";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["Cancelled"] = "Cancelled"] = "Cancelled";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["CancellationInProgress"] = "CancellationInProgress"] = "CancellationInProgress";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["Failed"] = "Failed"] = "Failed";
        BusinessProcessLifeCycle[BusinessProcessLifeCycle["SucceededWithErrors"] = "SucceededWithErrors"] = "SucceededWithErrors";
    })(exports.BusinessProcessLifeCycle || (exports.BusinessProcessLifeCycle = {}));
    exports.TraceLevel = void 0;
    (function (TraceLevel) {
        TraceLevel[TraceLevel["Critical"] = "Critical"] = "Critical";
        TraceLevel[TraceLevel["Error"] = "Error"] = "Error";
        TraceLevel[TraceLevel["Warning"] = "Warning"] = "Warning";
        TraceLevel[TraceLevel["Information"] = "Information"] = "Information";
        TraceLevel[TraceLevel["Verbose"] = "Verbose"] = "Verbose";
    })(exports.TraceLevel || (exports.TraceLevel = {}));
    /** User authorization state */
    exports.AuthorizationState = void 0;
    (function (AuthorizationState) {
        AuthorizationState[AuthorizationState["Reviewed"] = "Reviewed"] = "Reviewed";
        AuthorizationState[AuthorizationState["ToBeReviewed"] = "ToBeReviewed"] = "ToBeReviewed";
        AuthorizationState[AuthorizationState["Invited"] = "Invited"] = "Invited";
        AuthorizationState[AuthorizationState["UserTriggeredDeactivation"] = "UserTriggeredDeactivation"] = "UserTriggeredDeactivation";
    })(exports.AuthorizationState || (exports.AuthorizationState = {}));
    exports.RenderingCategory = void 0;
    (function (RenderingCategory) {
        RenderingCategory[RenderingCategory["Unknown"] = "Unknown"] = "Unknown";
        RenderingCategory[RenderingCategory["Image"] = "Image"] = "Image";
        RenderingCategory[RenderingCategory["Document"] = "Document"] = "Document";
        RenderingCategory[RenderingCategory["Video"] = "Video"] = "Video";
        RenderingCategory[RenderingCategory["Audio"] = "Audio"] = "Audio";
        RenderingCategory[RenderingCategory["Vector"] = "Vector"] = "Vector";
    })(exports.RenderingCategory || (exports.RenderingCategory = {}));
    exports.LeaseResourceType = void 0;
    (function (LeaseResourceType) {
        LeaseResourceType[LeaseResourceType["SchemaEditing"] = "SchemaEditing"] = "SchemaEditing";
    })(exports.LeaseResourceType || (exports.LeaseResourceType = {}));
    exports.UserRight = void 0;
    (function (UserRight) {
        UserRight[UserRight["ManageContent"] = "ManageContent"] = "ManageContent";
        UserRight[UserRight["ManageSharings"] = "ManageSharings"] = "ManageSharings";
        UserRight[UserRight["ManageTransfer"] = "ManageTransfer"] = "ManageTransfer";
        UserRight[UserRight["ManageChannels"] = "ManageChannels"] = "ManageChannels";
        UserRight[UserRight["ManageSchemas"] = "ManageSchemas"] = "ManageSchemas";
        UserRight[UserRight["ManageUsers"] = "ManageUsers"] = "ManageUsers";
        UserRight[UserRight["ManageUserRoles"] = "ManageUserRoles"] = "ManageUserRoles";
        UserRight[UserRight["ManagePermissions"] = "ManagePermissions"] = "ManagePermissions";
        UserRight[UserRight["ManageSearchIndexes"] = "ManageSearchIndexes"] = "ManageSearchIndexes";
        UserRight[UserRight["ManageListItems"] = "ManageListItems"] = "ManageListItems";
        UserRight[UserRight["ManageServiceProviders"] = "ManageServiceProviders"] = "ManageServiceProviders";
        UserRight[UserRight["ManageEmbeds"] = "ManageEmbeds"] = "ManageEmbeds";
        UserRight[UserRight["ManageTemplates"] = "ManageTemplates"] = "ManageTemplates";
        UserRight[UserRight["ManageTermsOfService"] = "ManageTermsOfService"] = "ManageTermsOfService";
        UserRight[UserRight["ManageLiveStream"] = "ManageLiveStream"] = "ManageLiveStream";
        UserRight[UserRight["ManageDocumentHistory"] = "ManageDocumentHistory"] = "ManageDocumentHistory";
        UserRight[UserRight["ManageAllShares"] = "ManageAllShares"] = "ManageAllShares";
        UserRight[UserRight["ManageOutputFormats"] = "ManageOutputFormats"] = "ManageOutputFormats";
        UserRight[UserRight["ManageBusinessProcesses"] = "ManageBusinessProcesses"] = "ManageBusinessProcesses";
        UserRight[UserRight["ManageIdentityProviders"] = "ManageIdentityProviders"] = "ManageIdentityProviders";
        UserRight[UserRight["ManageXmpMappings"] = "ManageXmpMappings"] = "ManageXmpMappings";
        UserRight[UserRight["ReadStatistics"] = "ReadStatistics"] = "ReadStatistics";
        UserRight[UserRight["WriteStatistics"] = "WriteStatistics"] = "WriteStatistics";
        UserRight[UserRight["ExportStatistics"] = "ExportStatistics"] = "ExportStatistics";
        UserRight[UserRight["EditImages"] = "EditImages"] = "EditImages";
    })(exports.UserRight || (exports.UserRight = {}));
    /** Content rights */
    exports.ContentRight = void 0;
    (function (ContentRight) {
        ContentRight[ContentRight["View"] = "View"] = "View";
        ContentRight[ContentRight["AccessOriginal"] = "AccessOriginal"] = "AccessOriginal";
        ContentRight[ContentRight["EditMetadata"] = "EditMetadata"] = "EditMetadata";
        ContentRight[ContentRight["EditContent"] = "EditContent"] = "EditContent";
        ContentRight[ContentRight["ManagePermissions"] = "ManagePermissions"] = "ManagePermissions";
        ContentRight[ContentRight["Delete"] = "Delete"] = "Delete";
        ContentRight[ContentRight["ManageHistoricVersions"] = "ManageHistoricVersions"] = "ManageHistoricVersions";
    })(exports.ContentRight || (exports.ContentRight = {}));
    /** Metadata rights */
    exports.MetadataRight = void 0;
    (function (MetadataRight) {
        MetadataRight[MetadataRight["View"] = "View"] = "View";
        MetadataRight[MetadataRight["ManageItems"] = "ManageItems"] = "ManageItems";
        MetadataRight[MetadataRight["ManageSchema"] = "ManageSchema"] = "ManageSchema";
    })(exports.MetadataRight || (exports.MetadataRight = {}));
    /** Type of the transfer */
    exports.TransferType = void 0;
    (function (TransferType) {
        TransferType[TransferType["FileUpload"] = "FileUpload"] = "FileUpload";
        TransferType[TransferType["FileUploadAutoImport"] = "FileUploadAutoImport"] = "FileUploadAutoImport";
        TransferType[TransferType["WebDownload"] = "WebDownload"] = "WebDownload";
        TransferType[TransferType["SchemaImport"] = "SchemaImport"] = "SchemaImport";
    })(exports.TransferType || (exports.TransferType = {}));
    /** Type of the schema */
    exports.SchemaType = void 0;
    (function (SchemaType) {
        SchemaType[SchemaType["Content"] = "Content"] = "Content";
        SchemaType[SchemaType["Layer"] = "Layer"] = "Layer";
        SchemaType[SchemaType["List"] = "List"] = "List";
        SchemaType[SchemaType["Struct"] = "Struct"] = "Struct";
    })(exports.SchemaType || (exports.SchemaType = {}));
    /** The display pattern type */
    exports.DisplayPatternType = void 0;
    (function (DisplayPatternType) {
        DisplayPatternType[DisplayPatternType["Thumbnail"] = "Thumbnail"] = "Thumbnail";
        DisplayPatternType[DisplayPatternType["List"] = "List"] = "List";
        DisplayPatternType[DisplayPatternType["Detail"] = "Detail"] = "Detail";
        DisplayPatternType[DisplayPatternType["Name"] = "Name"] = "Name";
        DisplayPatternType[DisplayPatternType["DownloadFileName"] = "DownloadFileName"] = "DownloadFileName";
    })(exports.DisplayPatternType || (exports.DisplayPatternType = {}));
    exports.Analyzer = void 0;
    (function (Analyzer) {
        Analyzer[Analyzer["None"] = "None"] = "None";
        Analyzer[Analyzer["Simple"] = "Simple"] = "Simple";
        Analyzer[Analyzer["Language"] = "Language"] = "Language";
        Analyzer[Analyzer["PathHierarchy"] = "PathHierarchy"] = "PathHierarchy";
        Analyzer[Analyzer["EdgeNGram"] = "EdgeNGram"] = "EdgeNGram";
        Analyzer[Analyzer["NGram"] = "NGram"] = "NGram";
        Analyzer[Analyzer["NoDiacritics"] = "NoDiacritics"] = "NoDiacritics";
    })(exports.Analyzer || (exports.Analyzer = {}));
    /** Content types */
    exports.ContentType = void 0;
    (function (ContentType) {
        ContentType[ContentType["Unknown"] = "Unknown"] = "Unknown";
        ContentType[ContentType["Bitmap"] = "Bitmap"] = "Bitmap";
        ContentType[ContentType["VectorGraphic"] = "VectorGraphic"] = "VectorGraphic";
        ContentType[ContentType["RawImage"] = "RawImage"] = "RawImage";
        ContentType[ContentType["InterchangeDocument"] = "InterchangeDocument"] = "InterchangeDocument";
        ContentType[ContentType["WordProcessingDocument"] = "WordProcessingDocument"] = "WordProcessingDocument";
        ContentType[ContentType["TextDocument"] = "TextDocument"] = "TextDocument";
        ContentType[ContentType["DesktopPublishingDocument"] = "DesktopPublishingDocument"] = "DesktopPublishingDocument";
        ContentType[ContentType["Presentation"] = "Presentation"] = "Presentation";
        ContentType[ContentType["Spreadsheet"] = "Spreadsheet"] = "Spreadsheet";
        ContentType[ContentType["Archive"] = "Archive"] = "Archive";
        ContentType[ContentType["Audio"] = "Audio"] = "Audio";
        ContentType[ContentType["Video"] = "Video"] = "Video";
        ContentType[ContentType["Font"] = "Font"] = "Font";
        ContentType[ContentType["Multimedia"] = "Multimedia"] = "Multimedia";
        ContentType[ContentType["Application"] = "Application"] = "Application";
        ContentType[ContentType["SourceCode"] = "SourceCode"] = "SourceCode";
        ContentType[ContentType["Database"] = "Database"] = "Database";
        ContentType[ContentType["Cad"] = "Cad"] = "Cad";
        ContentType[ContentType["Model3d"] = "Model3d"] = "Model3d";
        ContentType[ContentType["Virtual"] = "Virtual"] = "Virtual";
    })(exports.ContentType || (exports.ContentType = {}));
    exports.EnvironmentProcessType = void 0;
    (function (EnvironmentProcessType) {
        EnvironmentProcessType[EnvironmentProcessType["AddMetadataLanguage"] = "AddMetadataLanguage"] = "AddMetadataLanguage";
        EnvironmentProcessType[EnvironmentProcessType["CustomerUpdate"] = "CustomerUpdate"] = "CustomerUpdate";
        EnvironmentProcessType[EnvironmentProcessType["EnvironmentUpdate"] = "EnvironmentUpdate"] = "EnvironmentUpdate";
        EnvironmentProcessType[EnvironmentProcessType["CustomerBoostValuesUpdate"] = "CustomerBoostValuesUpdate"] = "CustomerBoostValuesUpdate";
        EnvironmentProcessType[EnvironmentProcessType["CustomerReshard"] = "CustomerReshard"] = "CustomerReshard";
    })(exports.EnvironmentProcessType || (exports.EnvironmentProcessType = {}));
    exports.BusinessRuleTriggerDocType = void 0;
    (function (BusinessRuleTriggerDocType) {
        BusinessRuleTriggerDocType[BusinessRuleTriggerDocType["Content"] = "Content"] = "Content";
        BusinessRuleTriggerDocType[BusinessRuleTriggerDocType["ListItem"] = "ListItem"] = "ListItem";
    })(exports.BusinessRuleTriggerDocType || (exports.BusinessRuleTriggerDocType = {}));
    exports.BusinessRuleTriggerAction = void 0;
    (function (BusinessRuleTriggerAction) {
        BusinessRuleTriggerAction[BusinessRuleTriggerAction["Create"] = "Create"] = "Create";
        BusinessRuleTriggerAction[BusinessRuleTriggerAction["Update"] = "Update"] = "Update";
        BusinessRuleTriggerAction[BusinessRuleTriggerAction["FileReplacement"] = "FileReplacement"] = "FileReplacement";
        BusinessRuleTriggerAction[BusinessRuleTriggerAction["Schedule"] = "Schedule"] = "Schedule";
    })(exports.BusinessRuleTriggerAction || (exports.BusinessRuleTriggerAction = {}));
    exports.NotificationEventType = void 0;
    (function (NotificationEventType) {
        NotificationEventType[NotificationEventType["Pending"] = "Pending"] = "Pending";
        NotificationEventType[NotificationEventType["InProgress"] = "InProgress"] = "InProgress";
        NotificationEventType[NotificationEventType["Success"] = "Success"] = "Success";
        NotificationEventType[NotificationEventType["Error"] = "Error"] = "Error";
        NotificationEventType[NotificationEventType["Warning"] = "Warning"] = "Warning";
        NotificationEventType[NotificationEventType["Information"] = "Information"] = "Information";
    })(exports.NotificationEventType || (exports.NotificationEventType = {}));
    /** Search behaviors */
    exports.SearchBehavior = void 0;
    (function (SearchBehavior) {
        SearchBehavior[SearchBehavior["DropInvalidCharactersOnFailure"] = "DropInvalidCharactersOnFailure"] = "DropInvalidCharactersOnFailure";
        SearchBehavior[SearchBehavior["WildcardOnSingleTerm"] = "WildcardOnSingleTerm"] = "WildcardOnSingleTerm";
        SearchBehavior[SearchBehavior["SimplifiedSearch"] = "SimplifiedSearch"] = "SimplifiedSearch";
        SearchBehavior[SearchBehavior["WildcardOnEveryTerm"] = "WildcardOnEveryTerm"] = "WildcardOnEveryTerm";
        SearchBehavior[SearchBehavior["SimplifiedSearchOr"] = "SimplifiedSearchOr"] = "SimplifiedSearchOr";
    })(exports.SearchBehavior || (exports.SearchBehavior = {}));
    exports.BusinessRuleExecutionScope = void 0;
    (function (BusinessRuleExecutionScope) {
        BusinessRuleExecutionScope[BusinessRuleExecutionScope["MainDoc"] = "MainDoc"] = "MainDoc";
        BusinessRuleExecutionScope[BusinessRuleExecutionScope["SearchDoc"] = "SearchDoc"] = "SearchDoc";
    })(exports.BusinessRuleExecutionScope || (exports.BusinessRuleExecutionScope = {}));
    exports.BusinessRuleNumberCompareConditionMode = void 0;
    (function (BusinessRuleNumberCompareConditionMode) {
        BusinessRuleNumberCompareConditionMode[BusinessRuleNumberCompareConditionMode["LessThan"] = "LessThan"] = "LessThan";
        BusinessRuleNumberCompareConditionMode[BusinessRuleNumberCompareConditionMode["LessThanEqual"] = "LessThanEqual"] = "LessThanEqual";
        BusinessRuleNumberCompareConditionMode[BusinessRuleNumberCompareConditionMode["Equal"] = "Equal"] = "Equal";
        BusinessRuleNumberCompareConditionMode[BusinessRuleNumberCompareConditionMode["GreaterThanEqual"] = "GreaterThanEqual"] = "GreaterThanEqual";
        BusinessRuleNumberCompareConditionMode[BusinessRuleNumberCompareConditionMode["GreaterThan"] = "GreaterThan"] = "GreaterThan";
    })(exports.BusinessRuleNumberCompareConditionMode || (exports.BusinessRuleNumberCompareConditionMode = {}));
    /** The sort direction */
    exports.SortDirection = void 0;
    (function (SortDirection) {
        SortDirection[SortDirection["Asc"] = "Asc"] = "Asc";
        SortDirection[SortDirection["Desc"] = "Desc"] = "Desc";
    })(exports.SortDirection || (exports.SortDirection = {}));
    exports.TermsRelationAggregatorDocumentType = void 0;
    (function (TermsRelationAggregatorDocumentType) {
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["Content"] = "Content"] = "Content";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["ListItem"] = "ListItem"] = "ListItem";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["Schema"] = "Schema"] = "Schema";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["User"] = "User"] = "User";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["ContentPermissionSet"] = "ContentPermissionSet"] = "ContentPermissionSet";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["Owner"] = "Owner"] = "Owner";
        TermsRelationAggregatorDocumentType[TermsRelationAggregatorDocumentType["UserRole"] = "UserRole"] = "UserRole";
    })(exports.TermsRelationAggregatorDocumentType || (exports.TermsRelationAggregatorDocumentType = {}));
    /** Permission set rights */
    exports.PermissionSetRight = void 0;
    (function (PermissionSetRight) {
        PermissionSetRight[PermissionSetRight["Apply"] = "Apply"] = "Apply";
        PermissionSetRight[PermissionSetRight["Manage"] = "Manage"] = "Manage";
    })(exports.PermissionSetRight || (exports.PermissionSetRight = {}));
    exports.OutputRenderingState = void 0;
    (function (OutputRenderingState) {
        OutputRenderingState[OutputRenderingState["InProgress"] = "InProgress"] = "InProgress";
        OutputRenderingState[OutputRenderingState["Completed"] = "Completed"] = "Completed";
        OutputRenderingState[OutputRenderingState["Failed"] = "Failed"] = "Failed";
        OutputRenderingState[OutputRenderingState["Skipped"] = "Skipped"] = "Skipped";
        OutputRenderingState[OutputRenderingState["NoLicense"] = "NoLicense"] = "NoLicense";
        OutputRenderingState[OutputRenderingState["RerenderRequested"] = "RerenderRequested"] = "RerenderRequested";
    })(exports.OutputRenderingState || (exports.OutputRenderingState = {}));
    /** Lifecycle */
    exports.LifeCycle = void 0;
    (function (LifeCycle) {
        LifeCycle[LifeCycle["Draft"] = "Draft"] = "Draft";
        LifeCycle[LifeCycle["Active"] = "Active"] = "Active";
        LifeCycle[LifeCycle["Inactive"] = "Inactive"] = "Inactive";
        LifeCycle[LifeCycle["Deleted"] = "Deleted"] = "Deleted";
    })(exports.LifeCycle || (exports.LifeCycle = {}));
    exports.ContentResolveBehavior = void 0;
    (function (ContentResolveBehavior) {
        ContentResolveBehavior[ContentResolveBehavior["Content"] = "Content"] = "Content";
        ContentResolveBehavior[ContentResolveBehavior["LinkedListItems"] = "LinkedListItems"] = "LinkedListItems";
        ContentResolveBehavior[ContentResolveBehavior["Metadata"] = "Metadata"] = "Metadata";
        ContentResolveBehavior[ContentResolveBehavior["Outputs"] = "Outputs"] = "Outputs";
        ContentResolveBehavior[ContentResolveBehavior["InnerDisplayValueThumbnail"] = "InnerDisplayValueThumbnail"] = "InnerDisplayValueThumbnail";
        ContentResolveBehavior[ContentResolveBehavior["InnerDisplayValueList"] = "InnerDisplayValueList"] = "InnerDisplayValueList";
        ContentResolveBehavior[ContentResolveBehavior["InnerDisplayValueDetail"] = "InnerDisplayValueDetail"] = "InnerDisplayValueDetail";
        ContentResolveBehavior[ContentResolveBehavior["InnerDisplayValueName"] = "InnerDisplayValueName"] = "InnerDisplayValueName";
        ContentResolveBehavior[ContentResolveBehavior["Owner"] = "Owner"] = "Owner";
        ContentResolveBehavior[ContentResolveBehavior["Permissions"] = "Permissions"] = "Permissions";
        ContentResolveBehavior[ContentResolveBehavior["OuterDisplayValueThumbnail"] = "OuterDisplayValueThumbnail"] = "OuterDisplayValueThumbnail";
        ContentResolveBehavior[ContentResolveBehavior["OuterDisplayValueList"] = "OuterDisplayValueList"] = "OuterDisplayValueList";
        ContentResolveBehavior[ContentResolveBehavior["OuterDisplayValueDetail"] = "OuterDisplayValueDetail"] = "OuterDisplayValueDetail";
        ContentResolveBehavior[ContentResolveBehavior["OuterDisplayValueName"] = "OuterDisplayValueName"] = "OuterDisplayValueName";
        ContentResolveBehavior[ContentResolveBehavior["HistoricVersionCount"] = "HistoricVersionCount"] = "HistoricVersionCount";
    })(exports.ContentResolveBehavior || (exports.ContentResolveBehavior = {}));
    /** Values that represent thumbnail sizes. */
    exports.ThumbnailSize = void 0;
    (function (ThumbnailSize) {
        ThumbnailSize[ThumbnailSize["Small"] = "Small"] = "Small";
        ThumbnailSize[ThumbnailSize["Medium"] = "Medium"] = "Medium";
        ThumbnailSize[ThumbnailSize["Large"] = "Large"] = "Large";
        ThumbnailSize[ThumbnailSize["Preview"] = "Preview"] = "Preview";
        ThumbnailSize[ThumbnailSize["ExtraLarge"] = "ExtraLarge"] = "ExtraLarge";
    })(exports.ThumbnailSize || (exports.ThumbnailSize = {}));
    /** Controls the update of metadata */
    exports.UpdateOption = void 0;
    (function (UpdateOption) {
        UpdateOption[UpdateOption["Merge"] = "Merge"] = "Merge";
        UpdateOption[UpdateOption["Replace"] = "Replace"] = "Replace";
    })(exports.UpdateOption || (exports.UpdateOption = {}));
    exports.ShareType = void 0;
    (function (ShareType) {
        ShareType[ShareType["Basic"] = "Basic"] = "Basic";
        ShareType[ShareType["Embed"] = "Embed"] = "Embed";
    })(exports.ShareType || (exports.ShareType = {}));
    exports.ContentSearchType = void 0;
    (function (ContentSearchType) {
        ContentSearchType[ContentSearchType["Metadata"] = "Metadata"] = "Metadata";
        ContentSearchType[ContentSearchType["FullText"] = "FullText"] = "FullText";
        ContentSearchType[ContentSearchType["MetadataAndFullText"] = "MetadataAndFullText"] = "MetadataAndFullText";
    })(exports.ContentSearchType || (exports.ContentSearchType = {}));
    exports.LifeCycleFilter = void 0;
    (function (LifeCycleFilter) {
        LifeCycleFilter[LifeCycleFilter["ActiveOnly"] = "ActiveOnly"] = "ActiveOnly";
        LifeCycleFilter[LifeCycleFilter["All"] = "All"] = "All";
        LifeCycleFilter[LifeCycleFilter["InactiveOnly"] = "InactiveOnly"] = "InactiveOnly";
        LifeCycleFilter[LifeCycleFilter["ActiveInactiveOnly"] = "ActiveInactiveOnly"] = "ActiveInactiveOnly";
    })(exports.LifeCycleFilter || (exports.LifeCycleFilter = {}));
    /** Filter items with broken or not broken dependencies */
    exports.BrokenDependenciesFilter = void 0;
    (function (BrokenDependenciesFilter) {
        BrokenDependenciesFilter[BrokenDependenciesFilter["All"] = "All"] = "All";
        BrokenDependenciesFilter[BrokenDependenciesFilter["NotBrokenOnly"] = "NotBrokenOnly"] = "NotBrokenOnly";
        BrokenDependenciesFilter[BrokenDependenciesFilter["BrokenOnly"] = "BrokenOnly"] = "BrokenOnly";
    })(exports.BrokenDependenciesFilter || (exports.BrokenDependenciesFilter = {}));
    /** Enum that allow additional resolutions on top of the standard Content result */
    exports.ContentSearchResolveBehavior = void 0;
    (function (ContentSearchResolveBehavior) {
        ContentSearchResolveBehavior[ContentSearchResolveBehavior["Permissions"] = "Permissions"] = "Permissions";
    })(exports.ContentSearchResolveBehavior || (exports.ContentSearchResolveBehavior = {}));
    exports.DisplayValuesState = void 0;
    (function (DisplayValuesState) {
        DisplayValuesState[DisplayValuesState["UpToDate"] = "UpToDate"] = "UpToDate";
        DisplayValuesState[DisplayValuesState["Outdated"] = "Outdated"] = "Outdated";
        DisplayValuesState[DisplayValuesState["RerenderingInProgress"] = "RerenderingInProgress"] = "RerenderingInProgress";
    })(exports.DisplayValuesState || (exports.DisplayValuesState = {}));
    exports.DocumentChangeAction = void 0;
    (function (DocumentChangeAction) {
        DocumentChangeAction[DocumentChangeAction["Create"] = "Create"] = "Create";
        DocumentChangeAction[DocumentChangeAction["Update"] = "Update"] = "Update";
        DocumentChangeAction[DocumentChangeAction["Delete"] = "Delete"] = "Delete";
        DocumentChangeAction[DocumentChangeAction["Activate"] = "Activate"] = "Activate";
        DocumentChangeAction[DocumentChangeAction["Deactivate"] = "Deactivate"] = "Deactivate";
    })(exports.DocumentChangeAction || (exports.DocumentChangeAction = {}));
    exports.HistoricVersioningState = void 0;
    (function (HistoricVersioningState) {
        HistoricVersioningState[HistoricVersioningState["Disabled"] = "Disabled"] = "Disabled";
        HistoricVersioningState[HistoricVersioningState["Suspended"] = "Suspended"] = "Suspended";
        HistoricVersioningState[HistoricVersioningState["Enabled"] = "Enabled"] = "Enabled";
    })(exports.HistoricVersioningState || (exports.HistoricVersioningState = {}));
    exports.SearchIndexState = void 0;
    (function (SearchIndexState) {
        SearchIndexState[SearchIndexState["Green"] = "Green"] = "Green";
        SearchIndexState[SearchIndexState["Yellow"] = "Yellow"] = "Yellow";
        SearchIndexState[SearchIndexState["Red"] = "Red"] = "Red";
    })(exports.SearchIndexState || (exports.SearchIndexState = {}));
    /** The state of the contents and list items */
    exports.MetadataState = void 0;
    (function (MetadataState) {
        MetadataState[MetadataState["UpToDate"] = "UpToDate"] = "UpToDate";
        MetadataState[MetadataState["Outdated"] = "Outdated"] = "Outdated";
        MetadataState[MetadataState["UpdateInProgress"] = "UpdateInProgress"] = "UpdateInProgress";
    })(exports.MetadataState || (exports.MetadataState = {}));
    exports.ListItemResolveBehavior = void 0;
    (function (ListItemResolveBehavior) {
        ListItemResolveBehavior[ListItemResolveBehavior["Content"] = "Content"] = "Content";
        ListItemResolveBehavior[ListItemResolveBehavior["LinkedListItems"] = "LinkedListItems"] = "LinkedListItems";
        ListItemResolveBehavior[ListItemResolveBehavior["InnerDisplayValueThumbnail"] = "InnerDisplayValueThumbnail"] = "InnerDisplayValueThumbnail";
        ListItemResolveBehavior[ListItemResolveBehavior["InnerDisplayValueList"] = "InnerDisplayValueList"] = "InnerDisplayValueList";
        ListItemResolveBehavior[ListItemResolveBehavior["InnerDisplayValueDetail"] = "InnerDisplayValueDetail"] = "InnerDisplayValueDetail";
        ListItemResolveBehavior[ListItemResolveBehavior["InnerDisplayValueName"] = "InnerDisplayValueName"] = "InnerDisplayValueName";
        ListItemResolveBehavior[ListItemResolveBehavior["OuterDisplayValueThumbnail"] = "OuterDisplayValueThumbnail"] = "OuterDisplayValueThumbnail";
        ListItemResolveBehavior[ListItemResolveBehavior["OuterDisplayValueList"] = "OuterDisplayValueList"] = "OuterDisplayValueList";
        ListItemResolveBehavior[ListItemResolveBehavior["OuterDisplayValueDetail"] = "OuterDisplayValueDetail"] = "OuterDisplayValueDetail";
        ListItemResolveBehavior[ListItemResolveBehavior["OuterDisplayValueName"] = "OuterDisplayValueName"] = "OuterDisplayValueName";
    })(exports.ListItemResolveBehavior || (exports.ListItemResolveBehavior = {}));
    exports.TitleCode = void 0;
    (function (TitleCode) {
        TitleCode[TitleCode["TransferInProgressTitle"] = "TransferInProgressTitle"] = "TransferInProgressTitle";
        TitleCode[TitleCode["TransferCompletedTitle"] = "TransferCompletedTitle"] = "TransferCompletedTitle";
        TitleCode[TitleCode["ImportInProgressTitle"] = "ImportInProgressTitle"] = "ImportInProgressTitle";
        TitleCode[TitleCode["ImportCompletedTitle"] = "ImportCompletedTitle"] = "ImportCompletedTitle";
        TitleCode[TitleCode["ShareNewShareTitle"] = "ShareNewShareTitle"] = "ShareNewShareTitle";
        TitleCode[TitleCode["TransferCancelledTitle"] = "TransferCancelledTitle"] = "TransferCancelledTitle";
        TitleCode[TitleCode["ImportCancelledTitle"] = "ImportCancelledTitle"] = "ImportCancelledTitle";
        TitleCode[TitleCode["ImportCompletedWithErrors"] = "ImportCompletedWithErrors"] = "ImportCompletedWithErrors";
        TitleCode[TitleCode["SchemaImportInProgressTitle"] = "SchemaImportInProgressTitle"] = "SchemaImportInProgressTitle";
        TitleCode[TitleCode["SchemaImportCompletedTitle"] = "SchemaImportCompletedTitle"] = "SchemaImportCompletedTitle";
        TitleCode[TitleCode["SchemaImportFailedTitle"] = "SchemaImportFailedTitle"] = "SchemaImportFailedTitle";
        TitleCode[TitleCode["UserRegisteredTitle"] = "UserRegisteredTitle"] = "UserRegisteredTitle";
        TitleCode[TitleCode["NewUserRegisteredEmailSubject"] = "NewUserRegisteredEmailSubject"] = "NewUserRegisteredEmailSubject";
        TitleCode[TitleCode["UserLockedEmailSubject"] = "UserLockedEmailSubject"] = "UserLockedEmailSubject";
        TitleCode[TitleCode["UserUnlockedEmailSubject"] = "UserUnlockedEmailSubject"] = "UserUnlockedEmailSubject";
        TitleCode[TitleCode["UserReviewedEmailSubject"] = "UserReviewedEmailSubject"] = "UserReviewedEmailSubject";
        TitleCode[TitleCode["UserInvitationEmailSubject"] = "UserInvitationEmailSubject"] = "UserInvitationEmailSubject";
        TitleCode[TitleCode["UserTriggeredDeactivationRequest"] = "UserTriggeredDeactivationRequest"] = "UserTriggeredDeactivationRequest";
        TitleCode[TitleCode["UserTriggeredDeactivationRequestMailSubject"] = "UserTriggeredDeactivationRequestMailSubject"] = "UserTriggeredDeactivationRequestMailSubject";
        TitleCode[TitleCode["IndexDraft"] = "IndexDraft"] = "IndexDraft";
        TitleCode[TitleCode["IndexCreate"] = "IndexCreate"] = "IndexCreate";
        TitleCode[TitleCode["IndexInactive"] = "IndexInactive"] = "IndexInactive";
        TitleCode[TitleCode["IndexActive"] = "IndexActive"] = "IndexActive";
        TitleCode[TitleCode["IndexClosed"] = "IndexClosed"] = "IndexClosed";
        TitleCode[TitleCode["IndexReindexInProgress"] = "IndexReindexInProgress"] = "IndexReindexInProgress";
        TitleCode[TitleCode["IndexCancelled"] = "IndexCancelled"] = "IndexCancelled";
        TitleCode[TitleCode["ReindexProgressDraft"] = "ReindexProgressDraft"] = "ReindexProgressDraft";
        TitleCode[TitleCode["ReindexProgressInProgress"] = "ReindexProgressInProgress"] = "ReindexProgressInProgress";
        TitleCode[TitleCode["ReindexProgressCompleted"] = "ReindexProgressCompleted"] = "ReindexProgressCompleted";
        TitleCode[TitleCode["ReindexProgressCancelled"] = "ReindexProgressCancelled"] = "ReindexProgressCancelled";
        TitleCode[TitleCode["ReindexProgressFailed"] = "ReindexProgressFailed"] = "ReindexProgressFailed";
        TitleCode[TitleCode["ReindexProgressCompletedWithErrors"] = "ReindexProgressCompletedWithErrors"] = "ReindexProgressCompletedWithErrors";
        TitleCode[TitleCode["ContentBatchEditInProgress"] = "ContentBatchEditInProgress"] = "ContentBatchEditInProgress";
        TitleCode[TitleCode["ContentBatchEditCompleted"] = "ContentBatchEditCompleted"] = "ContentBatchEditCompleted";
        TitleCode[TitleCode["ContentBatchEditProgressFailed"] = "ContentBatchEditProgressFailed"] = "ContentBatchEditProgressFailed";
        TitleCode[TitleCode["ContentBatchEditProgressCompletedWithErrors"] = "ContentBatchEditProgressCompletedWithErrors"] = "ContentBatchEditProgressCompletedWithErrors";
        TitleCode[TitleCode["ListItemBatchEditInProgress"] = "ListItemBatchEditInProgress"] = "ListItemBatchEditInProgress";
        TitleCode[TitleCode["ListItemBatchEditCompleted"] = "ListItemBatchEditCompleted"] = "ListItemBatchEditCompleted";
        TitleCode[TitleCode["ListItemBatchEditProgressFailed"] = "ListItemBatchEditProgressFailed"] = "ListItemBatchEditProgressFailed";
        TitleCode[TitleCode["ListItemBatchEditProgressCompletedWithErrors"] = "ListItemBatchEditProgressCompletedWithErrors"] = "ListItemBatchEditProgressCompletedWithErrors";
        TitleCode[TitleCode["ContentBackupRecoveryDraft"] = "ContentBackupRecoveryDraft"] = "ContentBackupRecoveryDraft";
        TitleCode[TitleCode["ContentBackupRecoveryInProgress"] = "ContentBackupRecoveryInProgress"] = "ContentBackupRecoveryInProgress";
        TitleCode[TitleCode["ContentBackupRecoveryCompleted"] = "ContentBackupRecoveryCompleted"] = "ContentBackupRecoveryCompleted";
        TitleCode[TitleCode["ContentBackupRecoveryForcefullyCompleted"] = "ContentBackupRecoveryForcefullyCompleted"] = "ContentBackupRecoveryForcefullyCompleted";
        TitleCode[TitleCode["ContentBackupRecoveryCancelled"] = "ContentBackupRecoveryCancelled"] = "ContentBackupRecoveryCancelled";
        TitleCode[TitleCode["ContentBackupRecoveryFailed"] = "ContentBackupRecoveryFailed"] = "ContentBackupRecoveryFailed";
        TitleCode[TitleCode["ContentOwnershipBatchEditInProgress"] = "ContentOwnershipBatchEditInProgress"] = "ContentOwnershipBatchEditInProgress";
        TitleCode[TitleCode["ContentOwnershipBatchEditCompleted"] = "ContentOwnershipBatchEditCompleted"] = "ContentOwnershipBatchEditCompleted";
        TitleCode[TitleCode["ContentOwnershipBatchEditProgressFailed"] = "ContentOwnershipBatchEditProgressFailed"] = "ContentOwnershipBatchEditProgressFailed";
        TitleCode[TitleCode["ContentOwnershipBatchEditProgressCompletedWithErrors"] = "ContentOwnershipBatchEditProgressCompletedWithErrors"] = "ContentOwnershipBatchEditProgressCompletedWithErrors";
        TitleCode[TitleCode["ContentPermissionsBatchEditInProgress"] = "ContentPermissionsBatchEditInProgress"] = "ContentPermissionsBatchEditInProgress";
        TitleCode[TitleCode["ContentPermissionsBatchEditCompleted"] = "ContentPermissionsBatchEditCompleted"] = "ContentPermissionsBatchEditCompleted";
        TitleCode[TitleCode["ContentPermissionsBatchEditProgressFailed"] = "ContentPermissionsBatchEditProgressFailed"] = "ContentPermissionsBatchEditProgressFailed";
        TitleCode[TitleCode["ContentPermissionsBatchEditProgressCompletedWithErrors"] = "ContentPermissionsBatchEditProgressCompletedWithErrors"] = "ContentPermissionsBatchEditProgressCompletedWithErrors";
        TitleCode[TitleCode["ListItemDeactivateManyInProgress"] = "ListItemDeactivateManyInProgress"] = "ListItemDeactivateManyInProgress";
        TitleCode[TitleCode["ListItemDeactivateManyCompleted"] = "ListItemDeactivateManyCompleted"] = "ListItemDeactivateManyCompleted";
        TitleCode[TitleCode["ListItemDeactivateManyProgressFailed"] = "ListItemDeactivateManyProgressFailed"] = "ListItemDeactivateManyProgressFailed";
        TitleCode[TitleCode["ListItemDeactivateManyProgressCompletedWithErrors"] = "ListItemDeactivateManyProgressCompletedWithErrors"] = "ListItemDeactivateManyProgressCompletedWithErrors";
        TitleCode[TitleCode["ContentDeactivateManyInProgress"] = "ContentDeactivateManyInProgress"] = "ContentDeactivateManyInProgress";
        TitleCode[TitleCode["ContentDeactivateManyCompleted"] = "ContentDeactivateManyCompleted"] = "ContentDeactivateManyCompleted";
        TitleCode[TitleCode["ContentDeactivateManyProgressFailed"] = "ContentDeactivateManyProgressFailed"] = "ContentDeactivateManyProgressFailed";
        TitleCode[TitleCode["ContentDeactivateManyProgressCompletedWithErrors"] = "ContentDeactivateManyProgressCompletedWithErrors"] = "ContentDeactivateManyProgressCompletedWithErrors";
        TitleCode[TitleCode["ExternalBusinessProcessTitle"] = "ExternalBusinessProcessTitle"] = "ExternalBusinessProcessTitle";
        TitleCode[TitleCode["MetadataRelatedItemsInProgress"] = "MetadataRelatedItemsInProgress"] = "MetadataRelatedItemsInProgress";
        TitleCode[TitleCode["MetadataRelatedItemsProgressFailed"] = "MetadataRelatedItemsProgressFailed"] = "MetadataRelatedItemsProgressFailed";
        TitleCode[TitleCode["MetadataRelatedItemsProgressCompletedWithErrors"] = "MetadataRelatedItemsProgressCompletedWithErrors"] = "MetadataRelatedItemsProgressCompletedWithErrors";
        TitleCode[TitleCode["MetadataRelatedItemsCompleted"] = "MetadataRelatedItemsCompleted"] = "MetadataRelatedItemsCompleted";
        TitleCode[TitleCode["AutoTaggingInProgress"] = "AutoTaggingInProgress"] = "AutoTaggingInProgress";
        TitleCode[TitleCode["AutoTaggingSucceeded"] = "AutoTaggingSucceeded"] = "AutoTaggingSucceeded";
        TitleCode[TitleCode["AutoTaggingSucceededWithErrors"] = "AutoTaggingSucceededWithErrors"] = "AutoTaggingSucceededWithErrors";
        TitleCode[TitleCode["AutoTaggingFailed"] = "AutoTaggingFailed"] = "AutoTaggingFailed";
        TitleCode[TitleCode["AutoTaggingCancelled"] = "AutoTaggingCancelled"] = "AutoTaggingCancelled";
        TitleCode[TitleCode["ContentUpdateManyInProgress"] = "ContentUpdateManyInProgress"] = "ContentUpdateManyInProgress";
        TitleCode[TitleCode["ContentUpdateManyCompleted"] = "ContentUpdateManyCompleted"] = "ContentUpdateManyCompleted";
        TitleCode[TitleCode["ContentUpdateManyCompletedWithErrors"] = "ContentUpdateManyCompletedWithErrors"] = "ContentUpdateManyCompletedWithErrors";
        TitleCode[TitleCode["ContentUpdateManyFailed"] = "ContentUpdateManyFailed"] = "ContentUpdateManyFailed";
        TitleCode[TitleCode["MetadataRelatedItemsBySchemaInProgress"] = "MetadataRelatedItemsBySchemaInProgress"] = "MetadataRelatedItemsBySchemaInProgress";
        TitleCode[TitleCode["MetadataRelatedItemsBySchemaFailed"] = "MetadataRelatedItemsBySchemaFailed"] = "MetadataRelatedItemsBySchemaFailed";
        TitleCode[TitleCode["MetadataRelatedItemsBySchemaCompletedWithErrors"] = "MetadataRelatedItemsBySchemaCompletedWithErrors"] = "MetadataRelatedItemsBySchemaCompletedWithErrors";
        TitleCode[TitleCode["MetadataRelatedItemsBySchemaCompleted"] = "MetadataRelatedItemsBySchemaCompleted"] = "MetadataRelatedItemsBySchemaCompleted";
        TitleCode[TitleCode["MetadataOutdatedItemsUpdateInProgress"] = "MetadataOutdatedItemsUpdateInProgress"] = "MetadataOutdatedItemsUpdateInProgress";
        TitleCode[TitleCode["MetadataOutdatedItemsUpdateCompleted"] = "MetadataOutdatedItemsUpdateCompleted"] = "MetadataOutdatedItemsUpdateCompleted";
        TitleCode[TitleCode["MetadataOutdatedItemsUpdateCompletedWithErrors"] = "MetadataOutdatedItemsUpdateCompletedWithErrors"] = "MetadataOutdatedItemsUpdateCompletedWithErrors";
        TitleCode[TitleCode["MetadataOutdatedItemsUpdateFailed"] = "MetadataOutdatedItemsUpdateFailed"] = "MetadataOutdatedItemsUpdateFailed";
        TitleCode[TitleCode["BatchRenderingInProgress"] = "BatchRenderingInProgress"] = "BatchRenderingInProgress";
        TitleCode[TitleCode["BatchRenderingCompleted"] = "BatchRenderingCompleted"] = "BatchRenderingCompleted";
        TitleCode[TitleCode["BatchRenderingCompletedWithErrors"] = "BatchRenderingCompletedWithErrors"] = "BatchRenderingCompletedWithErrors";
        TitleCode[TitleCode["BatchRenderingFailed"] = "BatchRenderingFailed"] = "BatchRenderingFailed";
        TitleCode[TitleCode["BusinessRuleTitle"] = "BusinessRuleTitle"] = "BusinessRuleTitle";
        TitleCode[TitleCode["StatisticsExportDraft"] = "StatisticsExportDraft"] = "StatisticsExportDraft";
        TitleCode[TitleCode["StatisticsExportInProgress"] = "StatisticsExportInProgress"] = "StatisticsExportInProgress";
        TitleCode[TitleCode["StatisticsExportCompleted"] = "StatisticsExportCompleted"] = "StatisticsExportCompleted";
        TitleCode[TitleCode["StatisticsExportFailed"] = "StatisticsExportFailed"] = "StatisticsExportFailed";
        TitleCode[TitleCode["StatisticsExportCancelled"] = "StatisticsExportCancelled"] = "StatisticsExportCancelled";
        TitleCode[TitleCode["UserEmailConflictSolved"] = "UserEmailConflictSolved"] = "UserEmailConflictSolved";
        TitleCode[TitleCode["UserEmailConflictSolvedSubject"] = "UserEmailConflictSolvedSubject"] = "UserEmailConflictSolvedSubject";
        TitleCode[TitleCode["SupportUserDeactivation"] = "SupportUserDeactivation"] = "SupportUserDeactivation";
        TitleCode[TitleCode["ImportFailedTitle"] = "ImportFailedTitle"] = "ImportFailedTitle";
    })(exports.TitleCode || (exports.TitleCode = {}));
    exports.MessageCode = void 0;
    (function (MessageCode) {
        MessageCode[MessageCode["TransferInProgressMessage"] = "TransferInProgressMessage"] = "TransferInProgressMessage";
        MessageCode[MessageCode["TransferCompletedMessage"] = "TransferCompletedMessage"] = "TransferCompletedMessage";
        MessageCode[MessageCode["ImportInProgressMessage"] = "ImportInProgressMessage"] = "ImportInProgressMessage";
        MessageCode[MessageCode["ImportCompletedMessage"] = "ImportCompletedMessage"] = "ImportCompletedMessage";
        MessageCode[MessageCode["ShareNewShareMessage"] = "ShareNewShareMessage"] = "ShareNewShareMessage";
        MessageCode[MessageCode["TransferCancelledMessage"] = "TransferCancelledMessage"] = "TransferCancelledMessage";
        MessageCode[MessageCode["ImportCancelledMessage"] = "ImportCancelledMessage"] = "ImportCancelledMessage";
        MessageCode[MessageCode["ImportFailedMessage"] = "ImportFailedMessage"] = "ImportFailedMessage";
        MessageCode[MessageCode["TransferInProgressWithFailedMessage"] = "TransferInProgressWithFailedMessage"] = "TransferInProgressWithFailedMessage";
        MessageCode[MessageCode["TransferCompletedWithFailedMessage"] = "TransferCompletedWithFailedMessage"] = "TransferCompletedWithFailedMessage";
        MessageCode[MessageCode["TransferCancelledWithFailedMessage"] = "TransferCancelledWithFailedMessage"] = "TransferCancelledWithFailedMessage";
        MessageCode[MessageCode["ImportInProgressWithFailedMessage"] = "ImportInProgressWithFailedMessage"] = "ImportInProgressWithFailedMessage";
        MessageCode[MessageCode["ImportCompletedWithFailedMessage"] = "ImportCompletedWithFailedMessage"] = "ImportCompletedWithFailedMessage";
        MessageCode[MessageCode["ImportCancelledWithFailedMessage"] = "ImportCancelledWithFailedMessage"] = "ImportCancelledWithFailedMessage";
        MessageCode[MessageCode["SchemaImportInProgressMessage"] = "SchemaImportInProgressMessage"] = "SchemaImportInProgressMessage";
        MessageCode[MessageCode["SchemaImportCompletedMessage"] = "SchemaImportCompletedMessage"] = "SchemaImportCompletedMessage";
        MessageCode[MessageCode["SchemaImportFailedMessage"] = "SchemaImportFailedMessage"] = "SchemaImportFailedMessage";
        MessageCode[MessageCode["UserRegisteredMessage"] = "UserRegisteredMessage"] = "UserRegisteredMessage";
        MessageCode[MessageCode["UserLockedMessage"] = "UserLockedMessage"] = "UserLockedMessage";
        MessageCode[MessageCode["UserReviewedMessage"] = "UserReviewedMessage"] = "UserReviewedMessage";
        MessageCode[MessageCode["IndexDraft"] = "IndexDraft"] = "IndexDraft";
        MessageCode[MessageCode["IndexCreate"] = "IndexCreate"] = "IndexCreate";
        MessageCode[MessageCode["IndexInactive"] = "IndexInactive"] = "IndexInactive";
        MessageCode[MessageCode["IndexActive"] = "IndexActive"] = "IndexActive";
        MessageCode[MessageCode["IndexClosed"] = "IndexClosed"] = "IndexClosed";
        MessageCode[MessageCode["IndexReindexInProgress"] = "IndexReindexInProgress"] = "IndexReindexInProgress";
        MessageCode[MessageCode["IndexCancelled"] = "IndexCancelled"] = "IndexCancelled";
        MessageCode[MessageCode["ReindexProgressDraft"] = "ReindexProgressDraft"] = "ReindexProgressDraft";
        MessageCode[MessageCode["ReindexProgressInProgress"] = "ReindexProgressInProgress"] = "ReindexProgressInProgress";
        MessageCode[MessageCode["ReindexProgressCompleted"] = "ReindexProgressCompleted"] = "ReindexProgressCompleted";
        MessageCode[MessageCode["ReindexProgressCancelled"] = "ReindexProgressCancelled"] = "ReindexProgressCancelled";
        MessageCode[MessageCode["ReindexProgressFailed"] = "ReindexProgressFailed"] = "ReindexProgressFailed";
        MessageCode[MessageCode["ReindexProgressCompletedWithErrors"] = "ReindexProgressCompletedWithErrors"] = "ReindexProgressCompletedWithErrors";
        MessageCode[MessageCode["ContentBatchEditInProgress"] = "ContentBatchEditInProgress"] = "ContentBatchEditInProgress";
        MessageCode[MessageCode["ContentBatchEditCompleted"] = "ContentBatchEditCompleted"] = "ContentBatchEditCompleted";
        MessageCode[MessageCode["ContentBatchEditProgressFailed"] = "ContentBatchEditProgressFailed"] = "ContentBatchEditProgressFailed";
        MessageCode[MessageCode["ContentBatchEditProgressCompletedWithErrors"] = "ContentBatchEditProgressCompletedWithErrors"] = "ContentBatchEditProgressCompletedWithErrors";
        MessageCode[MessageCode["ListItemBatchEditInProgress"] = "ListItemBatchEditInProgress"] = "ListItemBatchEditInProgress";
        MessageCode[MessageCode["ListItemBatchEditCompleted"] = "ListItemBatchEditCompleted"] = "ListItemBatchEditCompleted";
        MessageCode[MessageCode["ListItemBatchEditProgressFailed"] = "ListItemBatchEditProgressFailed"] = "ListItemBatchEditProgressFailed";
        MessageCode[MessageCode["ListItemBatchEditProgressCompletedWithErrors"] = "ListItemBatchEditProgressCompletedWithErrors"] = "ListItemBatchEditProgressCompletedWithErrors";
        MessageCode[MessageCode["ContentBackupRecoveryDraft"] = "ContentBackupRecoveryDraft"] = "ContentBackupRecoveryDraft";
        MessageCode[MessageCode["ContentBackupRecoveryInProgress"] = "ContentBackupRecoveryInProgress"] = "ContentBackupRecoveryInProgress";
        MessageCode[MessageCode["ContentBackupRecoveryCompleted"] = "ContentBackupRecoveryCompleted"] = "ContentBackupRecoveryCompleted";
        MessageCode[MessageCode["ContentBackupRecoveryForcefullyCompleted"] = "ContentBackupRecoveryForcefullyCompleted"] = "ContentBackupRecoveryForcefullyCompleted";
        MessageCode[MessageCode["ContentBackupRecoveryCancelled"] = "ContentBackupRecoveryCancelled"] = "ContentBackupRecoveryCancelled";
        MessageCode[MessageCode["ContentBackupRecoveryFailed"] = "ContentBackupRecoveryFailed"] = "ContentBackupRecoveryFailed";
        MessageCode[MessageCode["ContentOwnershipBatchEditInProgress"] = "ContentOwnershipBatchEditInProgress"] = "ContentOwnershipBatchEditInProgress";
        MessageCode[MessageCode["ContentOwnershipBatchEditCompleted"] = "ContentOwnershipBatchEditCompleted"] = "ContentOwnershipBatchEditCompleted";
        MessageCode[MessageCode["ContentOwnershipBatchEditProgressFailed"] = "ContentOwnershipBatchEditProgressFailed"] = "ContentOwnershipBatchEditProgressFailed";
        MessageCode[MessageCode["ContentOwnershipBatchEditProgressCompletedWithErrors"] = "ContentOwnershipBatchEditProgressCompletedWithErrors"] = "ContentOwnershipBatchEditProgressCompletedWithErrors";
        MessageCode[MessageCode["ContentPermissionsBatchEditInProgress"] = "ContentPermissionsBatchEditInProgress"] = "ContentPermissionsBatchEditInProgress";
        MessageCode[MessageCode["ContentPermissionsBatchEditCompleted"] = "ContentPermissionsBatchEditCompleted"] = "ContentPermissionsBatchEditCompleted";
        MessageCode[MessageCode["ContentPermissionsBatchEditProgressFailed"] = "ContentPermissionsBatchEditProgressFailed"] = "ContentPermissionsBatchEditProgressFailed";
        MessageCode[MessageCode["ContentPermissionsBatchEditProgressCompletedWithErrors"] = "ContentPermissionsBatchEditProgressCompletedWithErrors"] = "ContentPermissionsBatchEditProgressCompletedWithErrors";
        MessageCode[MessageCode["UserTriggeredDeactivationRequestMessage"] = "UserTriggeredDeactivationRequestMessage"] = "UserTriggeredDeactivationRequestMessage";
        MessageCode[MessageCode["UserEmailConflictSolved"] = "UserEmailConflictSolved"] = "UserEmailConflictSolved";
        MessageCode[MessageCode["ListItemDeactivateManyInProgress"] = "ListItemDeactivateManyInProgress"] = "ListItemDeactivateManyInProgress";
        MessageCode[MessageCode["ListItemDeactivateManyCompleted"] = "ListItemDeactivateManyCompleted"] = "ListItemDeactivateManyCompleted";
        MessageCode[MessageCode["ListItemDeactivateManyProgressFailed"] = "ListItemDeactivateManyProgressFailed"] = "ListItemDeactivateManyProgressFailed";
        MessageCode[MessageCode["ListItemDeactivateManyProgressCompletedWithErrors"] = "ListItemDeactivateManyProgressCompletedWithErrors"] = "ListItemDeactivateManyProgressCompletedWithErrors";
        MessageCode[MessageCode["ContentDeactivateManyInProgress"] = "ContentDeactivateManyInProgress"] = "ContentDeactivateManyInProgress";
        MessageCode[MessageCode["ContentDeactivateManyCompleted"] = "ContentDeactivateManyCompleted"] = "ContentDeactivateManyCompleted";
        MessageCode[MessageCode["ContentDeactivateManyProgressFailed"] = "ContentDeactivateManyProgressFailed"] = "ContentDeactivateManyProgressFailed";
        MessageCode[MessageCode["ContentDeactivateManyProgressCompletedWithErrors"] = "ContentDeactivateManyProgressCompletedWithErrors"] = "ContentDeactivateManyProgressCompletedWithErrors";
        MessageCode[MessageCode["ExternalBusinessProcessMessage"] = "ExternalBusinessProcessMessage"] = "ExternalBusinessProcessMessage";
        MessageCode[MessageCode["MetadataRelatedItemsInProgress"] = "MetadataRelatedItemsInProgress"] = "MetadataRelatedItemsInProgress";
        MessageCode[MessageCode["MetadataRelatedItemsProgressFailed"] = "MetadataRelatedItemsProgressFailed"] = "MetadataRelatedItemsProgressFailed";
        MessageCode[MessageCode["MetadataRelatedItemsProgressCompletedWithErrors"] = "MetadataRelatedItemsProgressCompletedWithErrors"] = "MetadataRelatedItemsProgressCompletedWithErrors";
        MessageCode[MessageCode["MetadataRelatedItemsCompleted"] = "MetadataRelatedItemsCompleted"] = "MetadataRelatedItemsCompleted";
        MessageCode[MessageCode["AutoTaggingInProgress"] = "AutoTaggingInProgress"] = "AutoTaggingInProgress";
        MessageCode[MessageCode["AutoTaggingSucceeded"] = "AutoTaggingSucceeded"] = "AutoTaggingSucceeded";
        MessageCode[MessageCode["AutoTaggingSucceededWithErrors"] = "AutoTaggingSucceededWithErrors"] = "AutoTaggingSucceededWithErrors";
        MessageCode[MessageCode["AutoTaggingFailed"] = "AutoTaggingFailed"] = "AutoTaggingFailed";
        MessageCode[MessageCode["AutoTaggingCancelled"] = "AutoTaggingCancelled"] = "AutoTaggingCancelled";
        MessageCode[MessageCode["ContentUpdateManyInProgress"] = "ContentUpdateManyInProgress"] = "ContentUpdateManyInProgress";
        MessageCode[MessageCode["ContentUpdateManyCompleted"] = "ContentUpdateManyCompleted"] = "ContentUpdateManyCompleted";
        MessageCode[MessageCode["ContentUpdateManyCompletedWithErrors"] = "ContentUpdateManyCompletedWithErrors"] = "ContentUpdateManyCompletedWithErrors";
        MessageCode[MessageCode["ContentUpdateManyFailed"] = "ContentUpdateManyFailed"] = "ContentUpdateManyFailed";
        MessageCode[MessageCode["MetadataRelatedItemsBySchemaInProgress"] = "MetadataRelatedItemsBySchemaInProgress"] = "MetadataRelatedItemsBySchemaInProgress";
        MessageCode[MessageCode["MetadataRelatedItemsBySchemaFailed"] = "MetadataRelatedItemsBySchemaFailed"] = "MetadataRelatedItemsBySchemaFailed";
        MessageCode[MessageCode["MetadataRelatedItemsBySchemaCompletedWithErrors"] = "MetadataRelatedItemsBySchemaCompletedWithErrors"] = "MetadataRelatedItemsBySchemaCompletedWithErrors";
        MessageCode[MessageCode["MetadataRelatedItemsBySchemaCompleted"] = "MetadataRelatedItemsBySchemaCompleted"] = "MetadataRelatedItemsBySchemaCompleted";
        MessageCode[MessageCode["MetadataOutdatedItemsUpdateInProgress"] = "MetadataOutdatedItemsUpdateInProgress"] = "MetadataOutdatedItemsUpdateInProgress";
        MessageCode[MessageCode["MetadataOutdatedItemsUpdateCompleted"] = "MetadataOutdatedItemsUpdateCompleted"] = "MetadataOutdatedItemsUpdateCompleted";
        MessageCode[MessageCode["MetadataOutdatedItemsUpdateCompletedWithErrors"] = "MetadataOutdatedItemsUpdateCompletedWithErrors"] = "MetadataOutdatedItemsUpdateCompletedWithErrors";
        MessageCode[MessageCode["MetadataOutdatedItemsUpdateFailed"] = "MetadataOutdatedItemsUpdateFailed"] = "MetadataOutdatedItemsUpdateFailed";
        MessageCode[MessageCode["BatchRenderingInProgress"] = "BatchRenderingInProgress"] = "BatchRenderingInProgress";
        MessageCode[MessageCode["BatchRenderingCompleted"] = "BatchRenderingCompleted"] = "BatchRenderingCompleted";
        MessageCode[MessageCode["BatchRenderingCompletedWithErrors"] = "BatchRenderingCompletedWithErrors"] = "BatchRenderingCompletedWithErrors";
        MessageCode[MessageCode["BatchRenderingFailed"] = "BatchRenderingFailed"] = "BatchRenderingFailed";
        MessageCode[MessageCode["BusinessRuleMessage"] = "BusinessRuleMessage"] = "BusinessRuleMessage";
        MessageCode[MessageCode["StatisticsExportDraft"] = "StatisticsExportDraft"] = "StatisticsExportDraft";
        MessageCode[MessageCode["StatisticsExportInProgress"] = "StatisticsExportInProgress"] = "StatisticsExportInProgress";
        MessageCode[MessageCode["StatisticsExportCompleted"] = "StatisticsExportCompleted"] = "StatisticsExportCompleted";
        MessageCode[MessageCode["StatisticsExportFailed"] = "StatisticsExportFailed"] = "StatisticsExportFailed";
        MessageCode[MessageCode["StatisticsExportCancelled"] = "StatisticsExportCancelled"] = "StatisticsExportCancelled";
    })(exports.MessageCode || (exports.MessageCode = {}));
    exports.NotificationState = void 0;
    (function (NotificationState) {
        NotificationState[NotificationState["Draft"] = "Draft"] = "Draft";
        NotificationState[NotificationState["Unread"] = "Unread"] = "Unread";
        NotificationState[NotificationState["Read"] = "Read"] = "Read";
        NotificationState[NotificationState["Deleted"] = "Deleted"] = "Deleted";
        NotificationState[NotificationState["Null"] = "Null"] = "Null";
    })(exports.NotificationState || (exports.NotificationState = {}));
    /** Interval for email notifications */
    exports.EmailNotificationsInterval = void 0;
    (function (EmailNotificationsInterval) {
        EmailNotificationsInterval[EmailNotificationsInterval["Daily"] = "Daily"] = "Daily";
        EmailNotificationsInterval[EmailNotificationsInterval["Hourly"] = "Hourly"] = "Hourly";
        EmailNotificationsInterval[EmailNotificationsInterval["QuarterHourly"] = "QuarterHourly"] = "QuarterHourly";
        EmailNotificationsInterval[EmailNotificationsInterval["Off"] = "Off"] = "Off";
    })(exports.EmailNotificationsInterval || (exports.EmailNotificationsInterval = {}));
    /** Available color profiles */
    exports.ColorProfile = void 0;
    (function (ColorProfile) {
        ColorProfile[ColorProfile["AdobeRgb1998"] = "AdobeRgb1998"] = "AdobeRgb1998";
        ColorProfile[ColorProfile["AppleRgb"] = "AppleRgb"] = "AppleRgb";
        ColorProfile[ColorProfile["ColorMatchRgb"] = "ColorMatchRgb"] = "ColorMatchRgb";
        ColorProfile[ColorProfile["EciRgbV1"] = "EciRgbV1"] = "EciRgbV1";
        ColorProfile[ColorProfile["EciRgbV2"] = "EciRgbV2"] = "EciRgbV2";
        ColorProfile[ColorProfile["Srgb"] = "Srgb"] = "Srgb";
        ColorProfile[ColorProfile["SrgbColorSpaceProfile"] = "SrgbColorSpaceProfile"] = "SrgbColorSpaceProfile";
        ColorProfile[ColorProfile["EuropeIsoCoatedFogra27"] = "EuropeIsoCoatedFogra27"] = "EuropeIsoCoatedFogra27";
        ColorProfile[ColorProfile["EuroscaleCoated"] = "EuroscaleCoated"] = "EuroscaleCoated";
        ColorProfile[ColorProfile["EuroscaleUncoated"] = "EuroscaleUncoated"] = "EuroscaleUncoated";
        ColorProfile[ColorProfile["IsoCoated"] = "IsoCoated"] = "IsoCoated";
        ColorProfile[ColorProfile["IsoCoatedEciV2"] = "IsoCoatedEciV2"] = "IsoCoatedEciV2";
        ColorProfile[ColorProfile["JapanColor2001Coated"] = "JapanColor2001Coated"] = "JapanColor2001Coated";
        ColorProfile[ColorProfile["JapanColor2001Uncoated"] = "JapanColor2001Uncoated"] = "JapanColor2001Uncoated";
        ColorProfile[ColorProfile["JapanColor2002Newspaper"] = "JapanColor2002Newspaper"] = "JapanColor2002Newspaper";
        ColorProfile[ColorProfile["JapanWebCoated"] = "JapanWebCoated"] = "JapanWebCoated";
        ColorProfile[ColorProfile["UsSheetfedCoated"] = "UsSheetfedCoated"] = "UsSheetfedCoated";
        ColorProfile[ColorProfile["UsSheetfedUncoated"] = "UsSheetfedUncoated"] = "UsSheetfedUncoated";
        ColorProfile[ColorProfile["UsWebCoatedSwop"] = "UsWebCoatedSwop"] = "UsWebCoatedSwop";
        ColorProfile[ColorProfile["UsWebUncoated"] = "UsWebUncoated"] = "UsWebUncoated";
        ColorProfile[ColorProfile["IsoCoatedV2Grey1cBas"] = "IsoCoatedV2Grey1cBas"] = "IsoCoatedV2Grey1cBas";
        ColorProfile[ColorProfile["IsoCoated300EciV2"] = "IsoCoated300EciV2"] = "IsoCoated300EciV2";
        ColorProfile[ColorProfile["CoatedFogra27"] = "CoatedFogra27"] = "CoatedFogra27";
        ColorProfile[ColorProfile["CoatedFogra39"] = "CoatedFogra39"] = "CoatedFogra39";
        ColorProfile[ColorProfile["UncoatedFogra29"] = "UncoatedFogra29"] = "UncoatedFogra29";
        ColorProfile[ColorProfile["WebCoatedFogra28"] = "WebCoatedFogra28"] = "WebCoatedFogra28";
        ColorProfile[ColorProfile["WebCoatedSwop2006Grade3"] = "WebCoatedSwop2006Grade3"] = "WebCoatedSwop2006Grade3";
        ColorProfile[ColorProfile["WebCoatedSwop2006Grade5"] = "WebCoatedSwop2006Grade5"] = "WebCoatedSwop2006Grade5";
        ColorProfile[ColorProfile["Isonewspaper26v4"] = "Isonewspaper26v4"] = "Isonewspaper26v4";
        ColorProfile[ColorProfile["Isonewspaper26v4Grey"] = "Isonewspaper26v4Grey"] = "Isonewspaper26v4Grey";
    })(exports.ColorProfile || (exports.ColorProfile = {}));
    /** http://www.colourphil.co.uk/rendering_intents.shtml */
    exports.ColorTransformationIntent = void 0;
    (function (ColorTransformationIntent) {
        ColorTransformationIntent[ColorTransformationIntent["RelativeColorimetricBpc"] = "RelativeColorimetricBpc"] = "RelativeColorimetricBpc";
        ColorTransformationIntent[ColorTransformationIntent["AbsoluteColorimetric"] = "AbsoluteColorimetric"] = "AbsoluteColorimetric";
        ColorTransformationIntent[ColorTransformationIntent["Perceptual"] = "Perceptual"] = "Perceptual";
        ColorTransformationIntent[ColorTransformationIntent["RelativeColorimetric"] = "RelativeColorimetric"] = "RelativeColorimetric";
        ColorTransformationIntent[ColorTransformationIntent["Saturation"] = "Saturation"] = "Saturation";
    })(exports.ColorTransformationIntent || (exports.ColorTransformationIntent = {}));
    /** Specifies how the dimensions of a ResizeAction are applied to the content */
    exports.ResizeMode = void 0;
    (function (ResizeMode) {
        ResizeMode[ResizeMode["Fit"] = "Fit"] = "Fit";
        ResizeMode[ResizeMode["Shrink"] = "Shrink"] = "Shrink";
        ResizeMode[ResizeMode["Resize"] = "Resize"] = "Resize";
    })(exports.ResizeMode || (exports.ResizeMode = {}));
    /** Specifies the kind of AlphaHandling to be applied to an image */
    exports.AlphaHandling = void 0;
    (function (AlphaHandling) {
        AlphaHandling[AlphaHandling["DiscardAlpha"] = "DiscardAlpha"] = "DiscardAlpha";
        AlphaHandling[AlphaHandling["ReplaceAlpha"] = "ReplaceAlpha"] = "ReplaceAlpha";
        AlphaHandling[AlphaHandling["ReplaceInvertedAlpha"] = "ReplaceInvertedAlpha"] = "ReplaceInvertedAlpha";
    })(exports.AlphaHandling || (exports.AlphaHandling = {}));
    exports.CropGravity = void 0;
    (function (CropGravity) {
        CropGravity[CropGravity["NorthWest"] = "NorthWest"] = "NorthWest";
        CropGravity[CropGravity["North"] = "North"] = "North";
        CropGravity[CropGravity["NorthEast"] = "NorthEast"] = "NorthEast";
        CropGravity[CropGravity["East"] = "East"] = "East";
        CropGravity[CropGravity["SouthEast"] = "SouthEast"] = "SouthEast";
        CropGravity[CropGravity["South"] = "South"] = "South";
        CropGravity[CropGravity["SouthWest"] = "SouthWest"] = "SouthWest";
        CropGravity[CropGravity["West"] = "West"] = "West";
    })(exports.CropGravity || (exports.CropGravity = {}));
    exports.RotateDirection = void 0;
    (function (RotateDirection) {
        RotateDirection[RotateDirection["Clockwise"] = "Clockwise"] = "Clockwise";
        RotateDirection[RotateDirection["CounterClockwise"] = "CounterClockwise"] = "CounterClockwise";
    })(exports.RotateDirection || (exports.RotateDirection = {}));
    /** Available compression types. */
    exports.CompressionType = void 0;
    (function (CompressionType) {
        CompressionType[CompressionType["None"] = "None"] = "None";
        CompressionType[CompressionType["Lzw"] = "Lzw"] = "Lzw";
        CompressionType[CompressionType["Rle"] = "Rle"] = "Rle";
        CompressionType[CompressionType["Zip"] = "Zip"] = "Zip";
    })(exports.CompressionType || (exports.CompressionType = {}));
    /** Video rendering preset, see http://dev.beandog.org/x264_preset_reference.html for more information. */
    exports.Preset = void 0;
    (function (Preset) {
        Preset[Preset["Ultrafast"] = "ultrafast"] = "Ultrafast";
        Preset[Preset["Superfast"] = "superfast"] = "Superfast";
        Preset[Preset["Veryfast"] = "veryfast"] = "Veryfast";
        Preset[Preset["Faster"] = "faster"] = "Faster";
        Preset[Preset["Fast"] = "fast"] = "Fast";
        Preset[Preset["Medium"] = "medium"] = "Medium";
        Preset[Preset["Slow"] = "slow"] = "Slow";
        Preset[Preset["Slower"] = "slower"] = "Slower";
    })(exports.Preset || (exports.Preset = {}));
    exports.Profile = void 0;
    (function (Profile) {
        Profile[Profile["Aac_low"] = "aac_low"] = "Aac_low";
        Profile[Profile["Mpeg2_aac_low"] = "mpeg2_aac_low"] = "Mpeg2_aac_low";
        Profile[Profile["Aac_ltp"] = "aac_ltp"] = "Aac_ltp";
        Profile[Profile["Aac_main"] = "aac_main"] = "Aac_main";
    })(exports.Profile || (exports.Profile = {}));
    /** Audio coders */
    exports.Coder = void 0;
    (function (Coder) {
        Coder[Coder["Twoloop"] = "twoloop"] = "Twoloop";
        Coder[Coder["Anmr"] = "anmr"] = "Anmr";
        Coder[Coder["Fast"] = "fast"] = "Fast";
    })(exports.Coder || (exports.Coder = {}));
    /** System user roles. */
    exports.SystemUserRole = void 0;
    (function (SystemUserRole) {
        SystemUserRole[SystemUserRole["Administrator"] = "Administrator"] = "Administrator";
    })(exports.SystemUserRole || (exports.SystemUserRole = {}));
    /** The template engine used for parsing the display patterns */
    exports.TemplateEngine = void 0;
    (function (TemplateEngine) {
        TemplateEngine[TemplateEngine["DotLiquid"] = "DotLiquid"] = "DotLiquid";
    })(exports.TemplateEngine || (exports.TemplateEngine = {}));
    /** Describes how a string value should be rendered */
    exports.StringRenderingType = void 0;
    (function (StringRenderingType) {
        StringRenderingType[StringRenderingType["Default"] = "Default"] = "Default";
        StringRenderingType[StringRenderingType["Markdown"] = "Markdown"] = "Markdown";
    })(exports.StringRenderingType || (exports.StringRenderingType = {}));
    /** Transfer states */
    exports.TransferState = void 0;
    (function (TransferState) {
        TransferState[TransferState["Draft"] = "Draft"] = "Draft";
        TransferState[TransferState["UploadInProgress"] = "UploadInProgress"] = "UploadInProgress";
        TransferState[TransferState["UploadCompleted"] = "UploadCompleted"] = "UploadCompleted";
        TransferState[TransferState["ImportInProgress"] = "ImportInProgress"] = "ImportInProgress";
        TransferState[TransferState["ImportCompleted"] = "ImportCompleted"] = "ImportCompleted";
        TransferState[TransferState["UploadCancelled"] = "UploadCancelled"] = "UploadCancelled";
        TransferState[TransferState["ImportCancelled"] = "ImportCancelled"] = "ImportCancelled";
        TransferState[TransferState["ImportFailed"] = "ImportFailed"] = "ImportFailed";
        TransferState[TransferState["Created"] = "Created"] = "Created";
        TransferState[TransferState["Deleted"] = "Deleted"] = "Deleted";
        TransferState[TransferState["TransferReady"] = "TransferReady"] = "TransferReady";
        TransferState[TransferState["FileDeleteInProgress"] = "FileDeleteInProgress"] = "FileDeleteInProgress";
        TransferState[TransferState["TransferCleanup"] = "TransferCleanup"] = "TransferCleanup";
        TransferState[TransferState["ImportCompletedWithErrors"] = "ImportCompletedWithErrors"] = "ImportCompletedWithErrors";
        TransferState[TransferState["UploadCompletedWithErrors"] = "UploadCompletedWithErrors"] = "UploadCompletedWithErrors";
        TransferState[TransferState["UploadCancellationInProgress"] = "UploadCancellationInProgress"] = "UploadCancellationInProgress";
        TransferState[TransferState["ImportDone"] = "ImportDone"] = "ImportDone";
    })(exports.TransferState || (exports.TransferState = {}));
    exports.OutputAccess = void 0;
    (function (OutputAccess) {
        OutputAccess[OutputAccess["Full"] = "Full"] = "Full";
        OutputAccess[OutputAccess["Preview"] = "Preview"] = "Preview";
        OutputAccess[OutputAccess["None"] = "None"] = "None";
    })(exports.OutputAccess || (exports.OutputAccess = {}));
    exports.ShareResolveBehavior = void 0;
    (function (ShareResolveBehavior) {
        ShareResolveBehavior[ShareResolveBehavior["Schemas"] = "Schemas"] = "Schemas";
    })(exports.ShareResolveBehavior || (exports.ShareResolveBehavior = {}));
    exports.TemplateType = void 0;
    (function (TemplateType) {
        TemplateType[TemplateType["ShareMail"] = "ShareMail"] = "ShareMail";
        TemplateType[TemplateType["SharePage"] = "SharePage"] = "SharePage";
        TemplateType[TemplateType["NewUserRegisteredMail"] = "NewUserRegisteredMail"] = "NewUserRegisteredMail";
        TemplateType[TemplateType["UserLockedMail"] = "UserLockedMail"] = "UserLockedMail";
        TemplateType[TemplateType["UserUnlockedMail"] = "UserUnlockedMail"] = "UserUnlockedMail";
        TemplateType[TemplateType["UserReviewedMail"] = "UserReviewedMail"] = "UserReviewedMail";
        TemplateType[TemplateType["UserInvitationMail"] = "UserInvitationMail"] = "UserInvitationMail";
        TemplateType[TemplateType["ShareNotFoundPage"] = "ShareNotFoundPage"] = "ShareNotFoundPage";
        TemplateType[TemplateType["UserTriggeredDeactivationRequestMail"] = "UserTriggeredDeactivationRequestMail"] = "UserTriggeredDeactivationRequestMail";
        TemplateType[TemplateType["UserEmailConflictSolvedMail"] = "UserEmailConflictSolvedMail"] = "UserEmailConflictSolvedMail";
        TemplateType[TemplateType["NotificationMail"] = "NotificationMail"] = "NotificationMail";
        TemplateType[TemplateType["NotificationMailItem"] = "NotificationMailItem"] = "NotificationMailItem";
    })(exports.TemplateType || (exports.TemplateType = {}));
    exports.OutputSource = void 0;
    (function (OutputSource) {
        OutputSource[OutputSource["Rendered"] = "Rendered"] = "Rendered";
        OutputSource[OutputSource["Embedded"] = "Embedded"] = "Embedded";
    })(exports.OutputSource || (exports.OutputSource = {}));
    exports.FileTransferState = void 0;
    (function (FileTransferState) {
        FileTransferState[FileTransferState["Draft"] = "Draft"] = "Draft";
        FileTransferState[FileTransferState["UploadInProgress"] = "UploadInProgress"] = "UploadInProgress";
        FileTransferState[FileTransferState["UploadCompleted"] = "UploadCompleted"] = "UploadCompleted";
        FileTransferState[FileTransferState["DataExtractionInProgress"] = "DataExtractionInProgress"] = "DataExtractionInProgress";
        FileTransferState[FileTransferState["DataExtractionDone"] = "DataExtractionDone"] = "DataExtractionDone";
        FileTransferState[FileTransferState["ImportInProgress"] = "ImportInProgress"] = "ImportInProgress";
        FileTransferState[FileTransferState["ImportCompleted"] = "ImportCompleted"] = "ImportCompleted";
        FileTransferState[FileTransferState["UploadCancelled"] = "UploadCancelled"] = "UploadCancelled";
        FileTransferState[FileTransferState["ImportCancelled"] = "ImportCancelled"] = "ImportCancelled";
        FileTransferState[FileTransferState["UploadFailed"] = "UploadFailed"] = "UploadFailed";
        FileTransferState[FileTransferState["ImportFailed"] = "ImportFailed"] = "ImportFailed";
        FileTransferState[FileTransferState["DeleteInProgress"] = "DeleteInProgress"] = "DeleteInProgress";
        FileTransferState[FileTransferState["Deleted"] = "Deleted"] = "Deleted";
        FileTransferState[FileTransferState["CleanupInProgress"] = "CleanupInProgress"] = "CleanupInProgress";
        FileTransferState[FileTransferState["CleanupCompleted"] = "CleanupCompleted"] = "CleanupCompleted";
    })(exports.FileTransferState || (exports.FileTransferState = {}));
    /** User role assignment operation type */
    exports.UserRoleAssignmentOperationType = void 0;
    (function (UserRoleAssignmentOperationType) {
        UserRoleAssignmentOperationType[UserRoleAssignmentOperationType["Add"] = "Add"] = "Add";
        UserRoleAssignmentOperationType[UserRoleAssignmentOperationType["Remove"] = "Remove"] = "Remove";
        UserRoleAssignmentOperationType[UserRoleAssignmentOperationType["Update"] = "Update"] = "Update";
    })(exports.UserRoleAssignmentOperationType || (exports.UserRoleAssignmentOperationType = {}));
    /** Data types of XMP fields */
    exports.XmpFieldDataType = void 0;
    (function (XmpFieldDataType) {
        XmpFieldDataType[XmpFieldDataType["Simple"] = "Simple"] = "Simple";
        XmpFieldDataType[XmpFieldDataType["LangAlt"] = "LangAlt"] = "LangAlt";
        XmpFieldDataType[XmpFieldDataType["List"] = "List"] = "List";
    })(exports.XmpFieldDataType || (exports.XmpFieldDataType = {}));
    /** Data types of metadata fields */
    exports.MetadataFieldDataType = void 0;
    (function (MetadataFieldDataType) {
        MetadataFieldDataType[MetadataFieldDataType["Simple"] = "Simple"] = "Simple";
        MetadataFieldDataType[MetadataFieldDataType["TranslatedString"] = "TranslatedString"] = "TranslatedString";
        MetadataFieldDataType[MetadataFieldDataType["Tagbox"] = "Tagbox"] = "Tagbox";
    })(exports.MetadataFieldDataType || (exports.MetadataFieldDataType = {}));
    /** Direction of mapping of XMP data */
    exports.MappingDirection = void 0;
    (function (MappingDirection) {
        MappingDirection[MappingDirection["XmpToMetadata"] = "XmpToMetadata"] = "XmpToMetadata";
        MappingDirection[MappingDirection["MetadataToXmp"] = "MetadataToXmp"] = "MetadataToXmp";
        MappingDirection[MappingDirection["Both"] = "Both"] = "Both";
    })(exports.MappingDirection || (exports.MappingDirection = {}));
    exports.IndexState = void 0;
    (function (IndexState) {
        IndexState[IndexState["Draft"] = "Draft"] = "Draft";
        IndexState[IndexState["Create"] = "Create"] = "Create";
        IndexState[IndexState["Inactive"] = "Inactive"] = "Inactive";
        IndexState[IndexState["Active"] = "Active"] = "Active";
        IndexState[IndexState["Closed"] = "Closed"] = "Closed";
        IndexState[IndexState["ReindexInProgress"] = "ReindexInProgress"] = "ReindexInProgress";
        IndexState[IndexState["Cancelled"] = "Cancelled"] = "Cancelled";
    })(exports.IndexState || (exports.IndexState = {}));
    exports.ContentDisposition = void 0;
    (function (ContentDisposition) {
        ContentDisposition[ContentDisposition["Attachment"] = "Attachment"] = "Attachment";
        ContentDisposition[ContentDisposition["Inline"] = "Inline"] = "Inline";
    })(exports.ContentDisposition || (exports.ContentDisposition = {}));
    exports.SearchIndexType = void 0;
    (function (SearchIndexType) {
        SearchIndexType[SearchIndexType["Content"] = "Content"] = "Content";
        SearchIndexType[SearchIndexType["ListItem"] = "ListItem"] = "ListItem";
    })(exports.SearchIndexType || (exports.SearchIndexType = {}));
    class SwaggerException extends Error {
        constructor(message, status, response, headers, result) {
            super();
            this.isSwaggerException = true;
            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }
        static isSwaggerException(obj) {
            return obj.isSwaggerException === true;
        }
    }
    function throwException(message, status, response, headers, result) {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, headers, null);
    }
    class OidcClientSettings {
        static create(settings) {
            return {
                client_id: settings.clientId,
                scope: settings.scope,
                authority: settings.stsServerUrl,
                response_type: "id_token token",
                filterProtocolClaims: true,
                loadUserInfo: true,
                redirect_uri: settings.redirectServerUrl ? settings.redirectServerUrl : settings.serverUrl + '/auth-callback',
                post_logout_redirect_uri: settings.logoutServerUrl ? settings.logoutServerUrl : settings.serverUrl,
                acr_values: 'tenant:{"id":"' +
                    settings.customerId + '","alias":"' +
                    settings.customerAlias + '"}'
            };
        }
    }
    class AccessTokenAuthClient extends AuthClient {
        constructor(pictureparkApiUrl, customerAlias, accessToken) {
            super(pictureparkApiUrl, customerAlias);
            this.accessToken = accessToken;
        }
        transformHttpRequestOptions(options) {
            if (options.headers && this.accessToken) {
                options.headers['Authorization'] = 'Bearer ' + this.accessToken;
            }
            return super.transformHttpRequestOptions(options);
        }
    }

    exports.AccessTokenAuthClient = AccessTokenAuthClient;
    exports.AuthClient = AuthClient;
    exports.BusinessProcessClient = BusinessProcessClient;
    exports.BusinessRuleClient = BusinessRuleClient;
    exports.ChannelClient = ChannelClient;
    exports.ContentClient = ContentClient;
    exports.ContentPermissionSetClient = ContentPermissionSetClient;
    exports.DisplayValueClient = DisplayValueClient;
    exports.DocumentHistoryClient = DocumentHistoryClient;
    exports.IdentityProviderClient = IdentityProviderClient;
    exports.InfoClient = InfoClient;
    exports.JsonSchemaClient = JsonSchemaClient;
    exports.ListItemClient = ListItemClient;
    exports.LiveStreamClient = LiveStreamClient;
    exports.MetadataClient = MetadataClient;
    exports.NotificationClient = NotificationClient;
    exports.OidcClientSettings = OidcClientSettings;
    exports.OutputClient = OutputClient;
    exports.OutputFormatClient = OutputFormatClient;
    exports.PictureparkClientBase = PictureparkClientBase;
    exports.ProfileClient = ProfileClient;
    exports.SchemaClient = SchemaClient;
    exports.SchemaPermissionSetClient = SchemaPermissionSetClient;
    exports.SchemaTransferClient = SchemaTransferClient;
    exports.ShareClient = ShareClient;
    exports.StatisticClient = StatisticClient;
    exports.SwaggerException = SwaggerException;
    exports.TemplateClient = TemplateClient;
    exports.TransferClient = TransferClient;
    exports.UserClient = UserClient;
    exports.UserRoleClient = UserRoleClient;
    exports.XmpMappingClient = XmpMappingClient;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
