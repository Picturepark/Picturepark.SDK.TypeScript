/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.3.0 (NJsonSchema v10.1.5.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthClient {
  constructor(private pictureparkApiUrl: string, private customerAlias?: string) {
  }

  getBaseUrl(defaultUrl: string, requestedUrl?: string) {
    return requestedUrl ? requestedUrl : this.pictureparkApiUrl;
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.customerAlias) {
      options.headers['Picturepark-CustomerAlias'] = this.customerAlias;
    }

    return Promise.resolve(options);
  }
}

export class PictureparkClientBase {
  constructor(private authClient: AuthClient) {

  }

  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return this.authClient ? this.authClient.getBaseUrl(defaultUrl) : baseUrl;
  }

  transformOptions(options: RequestInit): Promise<RequestInit> {
    return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options);
  }
}

export class BusinessProcessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get business process
     * @param id The business process id.
     * @return BusinessProcess
     */
    get(id: string | null): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Create business process
     * @param request The business process create request.
     * @return BusinessProcess
     */
    create(request: BusinessProcessCreateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Change business process state
     * @param id The business process id.
     * @param request The business process state change request.
     * @return BusinessProcess
     */
    changeState(id: string | null, request: BusinessProcessStateChangeRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/state";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeState(_response);
        });
    }

    protected processChangeState(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update business process notification
     * @param id The business process id.
     * @param request The business process notification update request.
     */
    updateNotification(id: string | null, request: BusinessProcessNotificationUpdateRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/notification";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateNotification(_response);
        });
    }

    protected processUpdateNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Cancel business process
     * @param id The business process id.
     */
    cancel(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Wait for states
     * @param id The business process id.
     * @param states (optional) Business process states to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(id: string | null, states?: string[] | null | undefined, timeout?: string | null | undefined): Promise<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitStates?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForStates(_response);
        });
    }

    protected processWaitForStates(response: Response): Promise<BusinessProcessWaitForStateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForStateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForStateResult>(<any>null);
    }

    /**
     * Wait for life cycles
     * @param id The business process id.
     * @param lifeCycles (optional) Business process life cycles to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(id: string | null, lifeCycles?: BusinessProcessLifeCycle[] | null | undefined, timeout?: string | null | undefined): Promise<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitLifeCycles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (lifeCycles !== undefined)
            lifeCycles && lifeCycles.forEach(item => { url_ += "lifeCycles=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForLifeCycles(_response);
        });
    }

    protected processWaitForLifeCycles(response: Response): Promise<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForLifeCycleResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Wait for completion
     * @param id The business process id.
     * @param timeout (optional) The timeout to wait for completion.
     * @param waitForContinuationCompletion (optional) Waits for the completion of the continuation business process (if existing, recursively). Default to true.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(id: string | null, timeout?: string | null | undefined, waitForContinuationCompletion?: boolean | undefined): Promise<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitCompletion?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitForContinuationCompletion === null)
            throw new Error("The parameter 'waitForContinuationCompletion' cannot be null.");
        else if (waitForContinuationCompletion !== undefined)
            url_ += "waitForContinuationCompletion=" + encodeURIComponent("" + waitForContinuationCompletion) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForCompletion(_response);
        });
    }

    protected processWaitForCompletion(response: Response): Promise<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitForLifeCycleResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitForLifeCycleResult>(<any>null);
    }

    /**
     * Get details
     * @param id The business process id.
     * @return BusinessProcessDetails
     */
    getDetails(id: string | null): Promise<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/details";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDetails(_response);
        });
    }

    protected processGetDetails(response: Response): Promise<BusinessProcessDetails> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessDetails>(<any>null);
    }

    /**
     * Search
     * @param request The business process request.
     * @return BusinessProcessSearchResult
     */
    search(request: BusinessProcessSearchRequest): Promise<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<BusinessProcessSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessSearchResult>(<any>null);
    }
}

export class BusinessRuleClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get the current business rule configuration
     * @return BusinessRuleConfiguration
     */
    getConfiguration(): Promise<BusinessRuleConfiguration> {
        let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<BusinessRuleConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessRuleConfiguration>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessRuleConfiguration>(<any>null);
    }

    /**
     * Updates the business rule configuration.
     * @param request Request containing the new configuration.
     * @return Business process
     */
    updateConfiguration(request: BusinessRuleConfigurationUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateConfiguration(_response);
        });
    }

    protected processUpdateConfiguration(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Searches for trace logs produces by business rule execution.
     * @param request Request
     * @return Holds results of trace log search.
     */
    searchTraces(request: BusinessRuleTraceLogSearchRequest): Promise<BusinessRuleTraceLogSearchResult> {
        let url_ = this.baseUrl + "/v1/BusinessRules/traceLog/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchTraces(_response);
        });
    }

    protected processSearchTraces(response: Response): Promise<BusinessRuleTraceLogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessRuleTraceLogSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessRuleTraceLogSearchResult>(<any>null);
    }
}

export class ChannelClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get all channels
     * @return List of channel
     */
    getAll(): Promise<Channel[]> {
        let url_ = this.baseUrl + "/v1/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Channel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel[]>(<any>null);
    }

    /**
     * Create channel
     * @param request The request containing information needed to create new channel.
     * @return Created channel
     */
    create(request: ChannelCreateRequest): Promise<Channel> {
        let url_ = this.baseUrl + "/v1/Channels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Channel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel>(<any>null);
    }

    /**
     * Get channel
     * @param id The channel ID.
     * @return Requested channel
     */
    get(id: string | null): Promise<Channel> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Channel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel>(<any>null);
    }

    /**
     * Update channel
     * @param id ID of channel to update
     * @param request The request containing information needed to update the channel.
     * @return Updated channel
     */
    update(id: string | null, request: ChannelUpdateRequest): Promise<Channel> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Channel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel>(<any>null);
    }

    /**
     * Delete channel
     * @param id ID of the channel that should be deleted.
     * @return OK
     */
    delete(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ContentPermissionSetClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get content permission set
     * @param id Content permission set ID.
     * @return Detail of a content permission set
     */
    get(id: string | null): Promise<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContentPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Update content permission set
     * @param id Content permission set ID.
     * @param permissionSet Permission set
     * @return Detail of a content permission set
     */
    update(id: string | null, permissionSet: ContentPermissionSetUpdateRequest): Promise<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ContentPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Delete content permission set
     * @param id Content permission set ID.
     */
    delete(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create content permission set
     * @param permissionSet Permission set
     * @return Detail of a content permission set
     */
    create(permissionSet: ContentPermissionSetCreateRequest): Promise<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ContentPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple content permission sets
     * @param ids (optional) Ids
     * @return Array of Detail of a content permission set
     */
    getMany(ids?: string[] | null | undefined): Promise<ContentPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ContentPermissionSetDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail[]>(<any>null);
    }

    /**
     * Transfer ownership of content permission set
     * @param id Content permission set ID.
     * @param request Request
     */
    transferOwnership(id: string | null, request: PermissionSetOwnershipTransferRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnership(_response);
        });
    }

    protected processTransferOwnership(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get permissions for content permission set
     * @param id Content permission set ID.
     * @return Array of Permission set rights
     */
    getPermissions(id: string | null): Promise<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<PermissionSetRight[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetRight[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple content permission sets
     * @param request Request
     * @return Response to a bulk operation
     */
    createMany(request: ContentPermissionSetCreateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Update multiple content permission sets
     * @param request Request to update multiple content permission sets.
     * @return Response to a bulk operation
     */
    updateMany(request: ContentPermissionSetUpdateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple content permission sets
     * @param request Request
     * @return Response to a bulk operation
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple content permission sets
     * @param request Request
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get permissions for multiple content permission sets
     * @param ids (optional) Ids
     * @return Array of
     */
    getPermissionsMany(ids?: string[] | null | undefined): Promise<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/permissions?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPermissionsMany(_response);
        });
    }

    protected processGetPermissionsMany(response: Response): Promise<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetUserPermissionRights[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search content permission set
     * @param request Request to search permission sets.
     * @return Result of a permission set search operation
     */
    search(request: PermissionSetSearchRequest): Promise<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PermissionSetSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult>(<any>null);
    }
}

export class ContentClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get content
     * @param id The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return Content detail
     */
    get(id: string | null, resolveBehaviors?: ContentResolveBehavior[] | null | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Content not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Delete content
     * @param id The ID of the content to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(id: string | null, forceReferenceRemoval?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (forceReferenceRemoval === null)
            throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
        else if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Download content
     * @param contentId The content ID.
     * @param outputFormatId The output format ID.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000).
     */
    download(contentId: string, outputFormatId: string, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download thumbnail
     * @param id The content ID.
     * @param size Thumbnail size. Either small, medium or large.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     */
    downloadThumbnail(id: string | null, size: ThumbnailSize, width?: number | null | undefined, height?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Contents/thumbnails/{id}/{size}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadThumbnail(_response);
        });
    }

    protected processDownloadThumbnail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Create content
     * @param request Content create request.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return The content details
     */
    create(request: ContentCreateRequest, resolveBehaviors?: ContentResolveBehavior[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <BusinessProcessLifeCycleNotHitException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("The specified wait timeout exceeded", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Get multiple contents
     * @param ids List of content IDs
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return List of Content detail
     */
    getMany(ids: string[] | null, resolveBehaviors?: ContentResolveBehavior[] | null | undefined): Promise<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/Contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ContentDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <RequestSizeLimitExceededException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("List of IDs exceeded maximum size", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("One or more contents not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail[]>(<any>null);
    }

    /**
     * Update content metadata
     * @param id The content ID.
     * @param request Content metadata update request.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows storing references to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Content detail
     */
    updateMetadata(id: string | null, request: ContentMetadataUpdateRequest, resolveBehaviors?: ContentResolveBehavior[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/metadata?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadata(_response);
        });
    }

    protected processUpdateMetadata(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <BusinessProcessLifeCycleNotHitException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("The specified wait timeout exceeded", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Update content permissions
     * @param id The content ID.
     * @param request Content permissions update request.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Content detail
     */
    updatePermissions(id: string | null, request: ContentPermissionsUpdateRequest, resolveBehaviors?: ContentResolveBehavior[] | null | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/permissions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissions(_response);
        });
    }

    protected processUpdatePermissions(response: Response): Promise<ContentDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <BusinessProcessLifeCycleNotHitException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("The specified wait timeout exceeded", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail>(<any>null);
    }

    /**
     * Restore content
     * @param id The content ID.
     * @param allowMissingDependencies (optional) Allows restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(id: string | null, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/restore?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Transfer content ownership
     * @param id The content ID.
     * @param request Content ownership transfer request.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    transferOwnership(id: string | null, request: ContentOwnershipTransferRequest, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/ownership?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnership(_response);
        });
    }

    protected processTransferOwnership(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update content file
     * @param id The ID of the content to replace.
     * @param request Content file update request
     * @return Business process
     */
    updateFile(id: string | null, request: ContentFileUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/file";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Get content references
     * @param id The content ID whose references to retrieve.
     * @param request Content references request.
     * @return ContentReferencesResult
     */
    getReferences(id: string | null, request: ContentReferencesRequest): Promise<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/references/search";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferences(_response);
        });
    }

    protected processGetReferences(response: Response): Promise<ContentReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentReferencesResult>(<any>null);
    }

    /**
     * Create download link
     * @param request Content download link request
     * @return Download link
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Promise<DownloadLink> {
        let url_ = this.baseUrl + "/v1/Contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDownloadLink(_response);
        });
    }

    protected processCreateDownloadLink(response: Response): Promise<DownloadLink> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DownloadLink>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DownloadLink>(<any>null);
    }

    /**
     * Create multiple contents
     * @param request Content create many request.
     * @return Business process
     */
    createMany(request: ContentCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple content metadata
     * @param request Content metadata update many request.
     * @return Business process
     */
    updateMetadataMany(request: ContentMetadataUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadataMany(_response);
        });
    }

    protected processUpdateMetadataMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("One or more contents not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple contents permissions
     * @param request Content permissions update many request.
     * @return Business process
     */
    updatePermissionsMany(request: ContentPermissionsUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissionsMany(_response);
        });
    }

    protected processUpdatePermissionsMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Transfer multiple contents ownerships
     * @param request Content ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: ContentOwnershipTransferManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents
     * @param request Delete many request.
     * @return Business process
     */
    deleteMany(request: ContentDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple contents - by filter
     * @param request Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(request: ContentDeleteManyFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteManyByFilter(_response);
        });
    }

    protected processDeleteManyByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Restore multiple contents
     * @param request Content restore many request.
     * @return Business process
     */
    restoreMany(request: ContentRestoreManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestoreMany(_response);
        });
    }

    protected processRestoreMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Get many content references
     * @param request Content many references request.
     * @return Content references result
     */
    getReferencesMany(request: ContentManyReferencesRequest): Promise<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/Contents/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferencesMany(_response);
        });
    }

    protected processGetReferencesMany(response: Response): Promise<ContentReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentReferencesResult>(<any>null);
    }

    /**
     * Batch update content fields - by IDs
     * @param request Content fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(request: ContentFieldsBatchUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByIds(_response);
        });
    }

    protected processBatchUpdateFieldsByIds(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param request Content fields batch update filter request. It contains the changes that need to be applied to the contents and the filter request to identify the contents.
     * @return Business process
     */
    batchUpdateFieldsByFilter(request: ContentFieldsBatchUpdateFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByFilter(_response);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Search contents
     * @param request Content search request.
     * @return Result for content search operation
     */
    search(request: ContentSearchRequest): Promise<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/Contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ContentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentSearchResult>(<any>null);
    }

    /**
     * Aggregate contents on channel
     * @param request Content aggregation on channel request.
     * @return Object aggregation result
     */
    aggregateOnChannel(request: ContentAggregationOnChannelRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Contents/aggregateOnChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregateOnChannel(_response);
        });
    }

    protected processAggregateOnChannel(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Aggregate contents
     * @param request Content aggregation request.
     * @return Object aggregation result
     */
    aggregate(request: ContentAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }
}

export class DisplayValueClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get status
     * @return VersionInfo
     */
    getStatus(): Promise<DisplayValueStatus> {
        let url_ = this.baseUrl + "/v1/DisplayValues/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<DisplayValueStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DisplayValueStatus>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DisplayValueStatus>(<any>null);
    }

    /**
     * Re-render the display values
     * @return VersionInfo
     */
    rerender(): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/DisplayValues/rerender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRerender(_response);
        });
    }

    protected processRerender(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

export class DocumentHistoryClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @return Document history item
     */
    getCurrent(documentType: string | null, documentId: string | null): Promise<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCurrent(_response);
        });
    }

    protected processGetCurrent(response: Response): Promise<DocumentHistory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory>(<any>null);
    }

    /**
     * Get version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document.
     * @return Document history item
     */
    getVersion(documentType: string | null, documentId: string | null, documentVersion: number): Promise<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<DocumentHistory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory>(<any>null);
    }

    /**
     * Compare with current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference.
     */
    compareWithCurrent(documentType: string | null, documentId: string | null, version?: number | undefined): Promise<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCompareWithCurrent(_response);
        });
    }

    protected processCompareWithCurrent(response: Response): Promise<DocumentHistoryDifference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Compare with version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document to use for the comparison.
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference
     */
    compareWithVersion(documentType: string | null, documentId: string | null, documentVersion: number, version?: number | undefined): Promise<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion)); 
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCompareWithVersion(_response);
        });
    }

    protected processCompareWithVersion(response: Response): Promise<DocumentHistoryDifference> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference>(<any>null);
    }

    /**
     * Search
     * @param request The document history search request.
     * @return Document history search result.
     */
    search(request: DocumentHistorySearchRequest): Promise<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<DocumentHistorySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistorySearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistorySearchResult>(<any>null);
    }
}

export class IdentityProviderClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get all identity providers
     * @return Array of identity providers
     */
    getAll(): Promise<IdentityProvider[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<IdentityProvider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdentityProvider[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProvider[]>(<any>null);
    }

    /**
     * Get basic info for all providers
     * @return Array of identity provider basic information
     */
    getAllBasicInfos(): Promise<IdentityProviderBasicInfo[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/basicInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllBasicInfos(_response);
        });
    }

    protected processGetAllBasicInfos(response: Response): Promise<IdentityProviderBasicInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdentityProviderBasicInfo[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProviderBasicInfo[]>(<any>null);
    }

    /**
     * Get identity provider
     * @param id Identity provider ID.
     * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
     */
    get(id: string | null): Promise<IdentityProvider> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityProvider> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdentityProvider>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProvider>(<any>null);
    }

    /**
     * Update identity provider
     * @param id Identity provider ID.
     * @param provider Update request
     * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
     */
    update(id: string | null, provider: IdentityProviderEditable): Promise<IdentityProvider> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(provider);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<IdentityProvider> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdentityProvider>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProvider>(<any>null);
    }

    /**
     * Get synchronizable attributes
     * @return Names of user attributes
     */
    getSynchronizableAttributes(): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/synchronizableAttributes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSynchronizableAttributes(_response);
        });
    }

    protected processGetSynchronizableAttributes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class InfoClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get version
     * @return VersionInfo
     */
    getVersion(): Promise<VersionInfo> {
        let url_ = this.baseUrl + "/v1/Info/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VersionInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionInfo>(<any>null);
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    getInfo(): Promise<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/Info/customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetInfo(_response);
        });
    }

    protected processGetInfo(response: Response): Promise<CustomerInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerInfo>(<any>null);
    }

    /**
     * Get status
     * @return SystemStatus
     */
    getStatus(): Promise<SystemStatus> {
        let url_ = this.baseUrl + "/v1/Info/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<SystemStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SystemStatus>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemStatus>(<any>null);
    }
}

export class JsonSchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get json schema
     * @param id The ID of the schema whose json schema to retrieve.
     */
    get(id: string | null): Promise<any> {
        let url_ = this.baseUrl + "/v1/JsonSchemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class ListItemClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get list item
     * @param id The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @return List item detail
     */
    get(id: string | null, resolveBehaviors?: ListItemResolveBehavior[] | null | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Update list item
     * @param id The list item ID.
     * @param request The list item update request.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return List item detail
     */
    update(id: string | null, request: ListItemUpdateRequest, resolveBehaviors?: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Delete list item
     * @param id The ID of the list item to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the list item should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(id: string | null, forceReferenceRemoval?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (forceReferenceRemoval === null)
            throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
        else if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Restore list item
     * @param id The list item ID.
     * @param allowMissingDependencies (optional) Allows restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(id: string | null, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}/restore?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get list item references
     * @param id The ID of the list item.
     * @param request Request options to specify how many references to fetch.
     * @return List item references
     */
    getReferences(id: string | null, request: ListItemReferencesRequest): Promise<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}/references/search";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferences(_response);
        });
    }

    protected processGetReferences(response: Response): Promise<ListItemReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemReferencesResult>(<any>null);
    }

    /**
     * Create list item
     * @param request List item create request.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return List item detail
     */
    create(request: ListItemCreateRequest, resolveBehaviors?: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies?: boolean | undefined, timeout?: string | null | undefined, waitSearchDocCreation?: boolean | undefined): Promise<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems?";
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ListItemDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail>(<any>null);
    }

    /**
     * Get multiple list items
     * @param ids (optional) List of list item IDs.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list items are resolved and returned.
     * @return List of list item details
     */
    getMany(ids?: string[] | null | undefined, resolveBehaviors?: ListItemResolveBehavior[] | null | undefined): Promise<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/ListItems?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ListItemDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail[]>(<any>null);
    }

    /**
     * Create multiple list items
     * @param request List item create many request.
     * @return Business process
     */
    createMany(request: ListItemCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple list items
     * @param request List item update many request.
     * @return Business process
     */
    updateMany(request: ListItemUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items
     * @param request List item delete many request.
     * @return Business process
     */
    deleteMany(request: ListItemDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple list items - by filter
     * @param request Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(request: ListItemDeleteManyFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteManyByFilter(_response);
        });
    }

    protected processDeleteManyByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Restore multiple list items
     * @param request List item restore many request.
     * @return Business process
     */
    restoreMany(request: ListItemRestoreManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestoreMany(_response);
        });
    }

    protected processRestoreMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Get multiple list items references
     * @param request ListItemManyReferencesRequest
     * @return A list of references per list item.
     */
    getReferencesMany(request: ListItemManyReferencesRequest): Promise<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/ListItems/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferencesMany(_response);
        });
    }

    protected processGetReferencesMany(response: Response): Promise<ListItemReferencesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemReferencesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemReferencesResult>(<any>null);
    }

    /**
     * Batch update fields - by IDs
     * @param request List item fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(request: ListItemFieldsBatchUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByIds(_response);
        });
    }

    protected processBatchUpdateFieldsByIds(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Batch update fields - by filter
     * @param request List item fields batch update by filter request.
     * @return Business process
     */
    batchUpdateFieldsByFilter(request: ListItemFieldsBatchUpdateFilterRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchUpdateFieldsByFilter(_response);
        });
    }

    protected processBatchUpdateFieldsByFilter(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Search list items
     * @param request The list item search request.
     * @return List item search result
     */
    search(request: ListItemSearchRequest): Promise<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/ListItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ListItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemSearchResult>(<any>null);
    }

    /**
     * Aggregate list items
     * @param request The list item aggregation request.
     * @return Object aggregation result
     */
    aggregate(request: ListItemAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/ListItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }
}

export class LiveStreamClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Search
     * @param request Parameters for the search
     * @return Resulting live stream events
     */
    search(request: LiveStreamSearchRequest): Promise<LiveStreamSearchResult> {
        let url_ = this.baseUrl + "/v1/LiveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<LiveStreamSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LiveStreamSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LiveStreamSearchResult>(<any>null);
    }
}

export class MetadataClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get status
     * @return The overall status of the contents and list items in comparison to the actual schemas' structure
     */
    getStatus(): Promise<MetadataStatus> {
        let url_ = this.baseUrl + "/v1/Metadata/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<MetadataStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MetadataStatus>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MetadataStatus>(<any>null);
    }

    /**
     * Update outdated
     * @return Business process
     */
    updateOutdated(): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Metadata/many/updateOutdated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateOutdated(_response);
        });
    }

    protected processUpdateOutdated(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

export class OutputFormatClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Sets the download file name patterns for an output format
     * @param id ID of the output format.
     * @param patterns Dictionary containing patterns per metadata language.
    If this is set, at least the customer's default language is required.
    Set any other language to an empty string and a fallback to the default language will occur.
    Set parameter to null to clear any already set patterns.
     * @return Business process
     */
    setDownloadFileNamePatterns(id: string | null, patterns: { [key: string]: string; }): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}/downloadFileNamePatterns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patterns);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetDownloadFileNamePatterns(_response);
        });
    }

    protected processSetDownloadFileNamePatterns(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Sets the download file name patterns for multiple output formats
     * @param request The request containing the patterns for each output format.
     * @return Business process
     */
    setDownloadFileNamePatternsMany(request: OutputFormatDownloadFileNamePatternUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/downloadFileNamePatterns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetDownloadFileNamePatternsMany(_response);
        });
    }

    protected processSetDownloadFileNamePatternsMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Render output format preview
     * @param request Information about the OutputFormat as well as which Content to use for the preview.
     * @return Rendered file
     */
    renderFormatPreview(request: OutputFormatRenderPreviewRequest): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/OutputFormats/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRenderFormatPreview(_response);
        });
    }

    protected processRenderFormatPreview(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Get multiple output formats
     * @param ids (optional) Output format IDs to get information about. If this is omitted, all output formats in the system will be returned.
     * @return Array of Represents an output format.
     */
    getMany(ids?: string[] | null | undefined): Promise<OutputFormatDetail[]> {
        let url_ = this.baseUrl + "/v1/OutputFormats?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<OutputFormatDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputFormatDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <RequestSizeLimitExceededException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("List of IDs exceeded maximum size", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputFormatDetail[]>(<any>null);
    }

    /**
     * Create output format
     * @param request Request containing information needed to create new output format.
     * @return Business process
     */
    create(request: OutputFormat): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Get output format
     * @param id Output format ID.
     * @return Represents an output format.
     */
    get(id: string | null): Promise<OutputFormatDetail> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OutputFormatDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputFormatDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputFormatDetail>(<any>null);
    }

    /**
     * Update output format
     * @param id Output format ID.
     * @param request Request containing information needed to update the output format.
     * @return Business process
     */
    update(id: string | null, request: OutputFormatEditable): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete output format
     * @param id Output format ID.
     * @return Business process
     */
    delete(id: string | null): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Create multiple output formats
     * @param request Request containing information needed to create new output format.
     * @return Business process
     */
    createMany(request: OutputFormatCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple output formats
     * @param request Request containing information needed to update the output format.
     * @return Business process
     */
    updateMany(request: OutputFormatUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple output formats
     * @param request The request with output format IDs to delete.
     * @return Business process
     */
    deleteMany(request: OutputFormatDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

export class OutputClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get output
     * @param id Output ID.
     * @return Output detail
     */
    get(id: string | null): Promise<OutputDetail> {
        let url_ = this.baseUrl + "/v1/Outputs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OutputDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputDetail>(<any>null);
    }

    /**
     * Search output documents
     * @param request The output search request.
     * @return Output result set
     */
    search(request: OutputSearchRequest): Promise<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/Outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<OutputSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputSearchResult>(<any>null);
    }

    /**
     * Resets retry attempt counters.
     * @param request Request containing options to filter which outputs should be reset.
     * @return Business process tracking the resetting
     */
    resetRetryAttempts(request: OutputResetRetryAttemptsRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Outputs/resetRetryAttempts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetRetryAttempts(_response);
        });
    }

    protected processResetRetryAttempts(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

export class ProfileClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get
     * @return User profile
     */
    get(): Promise<UserProfile> {
        let url_ = this.baseUrl + "/v1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(<any>null);
    }

    /**
     * Update
     * @param request Request to update a user profile..
     * @return Updated user profile
     */
    update(request: UserProfileUpdateRequest): Promise<UserProfile> {
        let url_ = this.baseUrl + "/v1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(<any>null);
    }

    /**
     * Request deletion
     * @return OK
     */
    requestDeletion(): Promise<void> {
        let url_ = this.baseUrl + "/v1/Profile/requestDeletion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRequestDeletion(_response);
        });
    }

    protected processRequestDeletion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SchemaPermissionSetClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get schema permission set
     * @param id Schema permission set ID.
     * @return Detail of a schema permission set
     */
    get(id: string | null): Promise<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SchemaPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Update schema permission set
     * @param id Schema permission set ID.
     * @param permissionSet Permission set
     * @return Detail of a schema permission set
     */
    update(id: string | null, permissionSet: SchemaPermissionSetUpdateRequest): Promise<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SchemaPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Delete schema permission set
     * @param id Schema permission set ID.
     */
    delete(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create schema permission set
     * @param permissionSet Permission set
     * @return Detail of a schema permission set
     */
    create(permissionSet: SchemaPermissionSetCreateRequest): Promise<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<SchemaPermissionSetDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail>(<any>null);
    }

    /**
     * Get multiple schema permission sets
     * @param ids (optional) Ids
     * @return Array of Detail of a schema permission set
     */
    getMany(ids?: string[] | null | undefined): Promise<SchemaPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<SchemaPermissionSetDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail[]>(<any>null);
    }

    /**
     * Transfer ownership of schema permission set
     * @param id Schema permission set ID.
     * @param request Request
     */
    transferOwnership(id: string | null, request: PermissionSetOwnershipTransferRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnership(_response);
        });
    }

    protected processTransferOwnership(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get permissions for schema permission set
     * @param id Schema permission set ID.
     * @return Array of Permission set rights
     */
    getPermissions(id: string | null): Promise<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<PermissionSetRight[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetRight[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetRight[]>(<any>null);
    }

    /**
     * Create multiple schema permission sets
     * @param request Request
     * @return Response to a bulk operation
     */
    createMany(request: SchemaPermissionSetCreateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Update multiple schema permission sets
     * @param request Request to update multiple schema permissions sets.
     * @return Response to a bulk operation
     */
    updateMany(request: SchemaPermissionSetUpdateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple schema permission sets
     * @param request Request
     * @return Response to a bulk operation
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Transfer ownership of multiple schema permission sets
     * @param request Request
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get permissions for multiple schema permission sets
     * @param ids (optional) Ids
     * @return Array of
     */
    getPermissionsMany(ids?: string[] | null | undefined): Promise<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/permissions?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPermissionsMany(_response);
        });
    }

    protected processGetPermissionsMany(response: Response): Promise<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetUserPermissionRights[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetUserPermissionRights[]>(<any>null);
    }

    /**
     * Search schema permission set
     * @param request Request to search permission sets.
     * @return Result of a permission set search operation
     */
    search(request: PermissionSetSearchRequest): Promise<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PermissionSetSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult>(<any>null);
    }
}

export class SchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get schema
     * @param id The schema ID.
     * @return Schema detail
     */
    get(id: string | null): Promise<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SchemaDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <SchemaNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Requested schema could not be found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail>(<any>null);
    }

    /**
     * Update schema
     * @param id The schema ID.
     * @param request The schema update request.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema update result, containing the updated schema
     */
    update(id: string | null, request: SchemaUpdateRequest, timeout?: string | null | undefined): Promise<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SchemaUpdateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaUpdateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <SchemaValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("The validation exception of schema update", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <SchemaNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Schema with this ID could not be found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaUpdateResult>(<any>null);
    }

    /**
     * Delete schema
     * @param id The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema delete result
     */
    delete(id: string | null, timeout?: string | null | undefined): Promise<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<SchemaDeleteResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDeleteResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <SchemaInUseException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Schema is used in other entities and cannot be deleted", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <SchemaNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Schema with this ID could not be found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDeleteResult>(<any>null);
    }

    /**
     * Exists schema
     * @param id The schema ID.
     * @return Schema Exists response
     */
    exists(id: string | null): Promise<SchemaExistsResponse> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/exists";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<SchemaExistsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaExistsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaExistsResponse>(<any>null);
    }

    /**
     * Exists field in schema
     * @param schemaId The schema ID.
     * @param fieldId The field ID.
     * @return Field Exists response
     */
    fieldExists(schemaId: string | null, fieldId: string | null): Promise<FieldExistsResponse> {
        let url_ = this.baseUrl + "/v1/Schemas/{schemaId}/{fieldId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFieldExists(_response);
        });
    }

    protected processFieldExists(response: Response): Promise<FieldExistsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FieldExistsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldExistsResponse>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schema specified in
     * @param id The schema ID.
     * @return Referenced schema details
     */
    getReferenced(id: string | null): Promise<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/referenced";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReferenced(_response);
        });
    }

    protected processGetReferenced(response: Response): Promise<SchemaDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <RequestSizeLimitExceededException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("List of IDs exceeded maximum size", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail[]>(<any>null);
    }

    /**
     * Transfer ownership
     * @param id The schema ID.
     * @param request Request detailing which user to transfer to.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return OK
     */
    transferOwnership(id: string | null, request: SchemaOwnershipTransferRequest, timeout?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/ownership?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnership(_response);
        });
    }

    protected processTransferOwnership(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create schema
     * @param request The schema create request.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema create result, containing the created schema
     */
    create(request: SchemaCreateRequest, timeout?: string | null | undefined): Promise<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/Schemas?";
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<SchemaCreateResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaCreateResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <SchemaValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("The validation exception of schema creation", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaCreateResult>(<any>null);
    }

    /**
     * Get multiple schemas
     * @param ids (optional) Comma separated list of schema IDs.
     * @return List of schema details
     */
    getMany(ids?: string[] | null | undefined): Promise<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<SchemaDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <RequestSizeLimitExceededException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("List of IDs exceeded maximum size", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail[]>(<any>null);
    }

    /**
     * Create multiple schemas
     * @param request The schema create many request.
     * @return BusinessProcess which can be awaited
     */
    createMany(request: SchemaCreateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <SchemaValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("One or more schemas failed to validate", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Update multiple schema
     * @param request Request to update multiple schemas.
     * @return BusinessProcess which can be awaited
     */
    updateMany(request: SchemaUpdateManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkArgumentNullException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Argument must not be null", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Gets all schemas referenced by the schemas specified in
     * @param ids (optional) The schema IDs.
     * @return Referenced schema details
     */
    getManyReferenced(ids?: string[] | null | undefined): Promise<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas/many/referenced?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetManyReferenced(_response);
        });
    }

    protected processGetManyReferenced(response: Response): Promise<SchemaDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail[]>(<any>null);
    }

    /**
     * Transfer ownership of multiple schemas
     * @param request Schema ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: SchemaOwnershipTransferManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Search schemas
     * @param request The schema search request.
     * @return Schema search result
     */
    search(request: SchemaSearchRequest): Promise<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/Schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SchemaSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaSearchResult>(<any>null);
    }

    /**
     * Search index fields
     * @param request The search request.
     * @return Indexed fields
     */
    getIndexFields(request: IndexFieldsSearchBySchemaIdsRequest): Promise<IndexField[]> {
        let url_ = this.baseUrl + "/v1/Schemas/indexFields/searchBySchemaIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetIndexFields(_response);
        });
    }

    protected processGetIndexFields(response: Response): Promise<IndexField[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexField[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexField[]>(<any>null);
    }
}

export class SchemaTransferClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Import schemas
     * @param request The schema import request.
     * @return Transfer
     */
    import(request: SchemaImportRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/SchemaTransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkArgumentNullException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Argument must not be null", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }
}

export class ShareClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get share json
     * @param token Share token
     * @param lang (optional) Language code
     * @return ShareDetail
     */
    getShareJson(token: string | null, lang?: string | null | undefined): Promise<ShareDetail> {
        let url_ = this.baseUrl + "/v1/Shares/json/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (lang !== undefined)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShareJson(_response);
        });
    }

    protected processGetShareJson(response: Response): Promise<ShareDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareDetail>(<any>null);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     */
    download(token: string | null, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download shared output
     * @param token Share token
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     */
    downloadSingleContent(token: string | null, contentId: string | null, outputFormatId: string | null, width?: number | null | undefined, height?: number | null | undefined, range?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token)); 
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&"; 
        if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadSingleContent(_response);
        });
    }

    protected processDownloadSingleContent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Get
     * @param id Share Id (not token, use [GetShareJson](#operation/Share_GetShareJson) to get share by token)
     * @return Share detail
     */
    get(id: string | null): Promise<ShareDetail> {
        let url_ = this.baseUrl + "/v1/Shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ShareDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ShareNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Share could not be found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareDetail>(<any>null);
    }

    /**
     * Update
     * @param id The share id.
     * @param request The share update request.
     * @return BusinessProcess
     */
    update(id: string | null, request: ShareBaseUpdateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <BusinessProcessLifeCycleNotHitException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Create
     * @param request Polymorphic create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return BusinessProcess
     */
    create(request: ShareBaseCreateRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Content could not be found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : <PermissionValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("No permission to share", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete multiple shares
     * @param request A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(request: ShareDeleteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Revokes multiple shares
     * @param request A revoke many request containing the ids of the shares to revoke.
     * @return BusinessProcess
     */
    revoke(request: ShareRevokeManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/many/revoke";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevoke(_response);
        });
    }

    protected processRevoke(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return Share aggregation result
     */
    aggregate(request: ShareAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest): Promise<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/Shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ShareSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareSearchResult>(<any>null);
    }
}

export class TransferClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <MaximumTransferSizeException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Get transfer details
     * @param id ID of transfer.
     * @return TransferDetail
     */
    get(id: string | null): Promise<TransferDetail> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TransferDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferDetail>(<any>null);
    }

    /**
     * Delete transfer
     * @param id ID of transfer.
     * @return OK
     */
    delete(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Import transfer
     * @param id ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    import(id: string | null, request: ImportTransferRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/import";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Import transfer partially
     * @param id ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(id: string | null, request: ImportTransferPartialRequest): Promise<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/partialImport";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPartialImport(_response);
        });
    }

    protected processPartialImport(response: Response): Promise<Transfer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer>(<any>null);
    }

    /**
     * Cancel transfer
     * @param id ID of transfer.
     * @return OK
     */
    cancel(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Promise<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/Transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<TransferSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferSearchResult>(<any>null);
    }

    /**
     * Get file
     * @param id ID of file transfer.
     * @return FileTransferDetail
     */
    getFile(id: string | null): Promise<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/Transfers/files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<FileTransferDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferDetail>(<any>null);
    }

    /**
     * Search for files
     * @param request The file transfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Promise<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/Transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchFiles(_response);
        });
    }

    protected processSearchFiles(response: Response): Promise<FileTransferSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferSearchResult>(<any>null);
    }

    /**
     * Delete files
     * @param request The file transfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/Transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFiles(_response);
        });
    }

    protected processDeleteFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Promise<Blacklist> {
        let url_ = this.baseUrl + "/v1/Transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBlacklist(_response);
        });
    }

    protected processGetBlacklist(response: Response): Promise<Blacklist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Blacklist>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Blacklist>(<any>null);
    }

    /**
     * Upload file
     * @param formFile Information about chunk.
     * @param chunkNumber Information about chunk.
     * @param currentChunkSize Information about chunk.
     * @param totalSize Information about chunk.
     * @param totalChunks Information about chunk.
     * @param transferId ID of transfer.
     * @param requestId Identifier of file.
     * @return OK
     */
    uploadFile(formFile: FileParameter | null, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string | null, requestId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{transferId}/files/{requestId}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId)); 
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId)); 
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "ChunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "CurrentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "TotalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "TotalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserRoleClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Search user roles
     * @param request User role search request.
     * @return Result of the user role search
     */
    search(request: UserRoleSearchRequest): Promise<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/UserRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<UserRoleSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleSearchResult>(<any>null);
    }

    /**
     * Get multiple user roles
     * @param ids (optional) User role IDs to get information about.
     * @return Array of Represents a user role, which associates users with user rights.
     */
    getMany(ids?: string[] | null | undefined): Promise<UserRoleDetail[]> {
        let url_ = this.baseUrl + "/v1/UserRoles?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<UserRoleDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <RequestSizeLimitExceededException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("List of IDs exceeded maximum size", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDetail[]>(<any>null);
    }

    /**
     * Create user role
     * @param request Request containing information needed to create new user role.
     * @return Represents a user role, which associates users with user rights.
     */
    create(request: UserRoleCreateRequest): Promise<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<UserRoleDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDetail>(<any>null);
    }

    /**
     * Create multiple user roles
     * @param request Request containing information needed to create new user role.
     * @return Response to a bulk operation
     */
    createMany(request: UserRoleCreateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Update multiple user roles
     * @param request Request containing information needed to update the user role.
     * @return Response to a bulk operation
     */
    updateMany(request: UserRoleUpdateManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Delete multiple user roles
     * @param request The request with user role IDs to delete.
     * @return Response to a bulk operation
     */
    deleteMany(request: UserRoleDeleteManyRequest): Promise<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BulkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BulkResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkResponse>(<any>null);
    }

    /**
     * Get user role
     * @param id User role ID.
     * @return Represents a user role, which associates users with user rights.
     */
    get(id: string | null): Promise<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserRoleDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDetail>(<any>null);
    }

    /**
     * Update user role
     * @param id User role ID.
     * @param request Request containing information needed to update the user role.
     * @return Represents a user role, which associates users with user rights.
     */
    update(id: string | null, request: UserRoleEditable): Promise<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserRoleDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDetail>(<any>null);
    }

    /**
     * Delete user role
     * @param id User role ID.
     */
    delete(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get user
     * @param id User ID to search for.
     * @return Requested user details
     */
    get(id: string | null): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Update user
     * @param id User ID to action on.
     * @param request New user information.
     * @return User details after the update of the user
     */
    update(id: string | null, request: UserUpdateRequest): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Lock / unlock user
     * @param id User ID to action on.
     * @param request Request detailing if the user should be locked or unlocked.
     * @return OK
     */
    lock(id: string | null, request: UserLockRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLock(_response);
        });
    }

    protected processLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Change lock state of multiple users
     * @param request Information about users to update and the desired lock state
     * @return Business process
     */
    lockMany(request: UserLockManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLockMany(_response);
        });
    }

    protected processLockMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Change user's review state
     * @param id User ID to action on.
     * @param request Request detailing if the user should be set as _reviewed_ or _to be reviewed_.
     * @return OK
     */
    review(id: string | null, request: UserReviewRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/review";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReview(_response);
        });
    }

    protected processReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Change Review state of multiple users
     * @param request Information about users to update and the desired review state
     * @return Business process
     */
    reviewMany(request: UserReviewManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReviewMany(_response);
        });
    }

    protected processReviewMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Invite user
     * @param id User ID to action on.
     * @return OK
     */
    invite(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/invite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Invite multiple users
     * @param request Information about users to invite
     * @return Business process
     */
    inviteMany(request: UserInviteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processInviteMany(_response);
        });
    }

    protected processInviteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Reinvite user
     * @param id User ID to action on.
     * @return OK
     */
    reinvite(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/reinvite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReinvite(_response);
        });
    }

    protected processReinvite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Reinvite users
     * @param request Information about users to reinvite
     * @return Business process
     */
    reInviteMany(request: UserReinviteManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/reinvite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReInviteMany(_response);
        });
    }

    protected processReInviteMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Assign or unassign userRoles
     * @param request Information about users to modify and kind of operation
     * @return Business process
     */
    assignUserRoles(request: UserRoleAssignManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/assignUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssignUserRoles(_response);
        });
    }

    protected processAssignUserRoles(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }

    /**
     * Delete user
     * @param id User ID
     * @param request Request with details about deletion
     * @return OK
     */
    delete(id: string | null, request: UserDeleteRequest): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Restore user
     * @param id User ID to action on.
     * @return OK
     */
    restore(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Cancels a user triggered deletion request and returns user to _Reviewed_ state.
     * @param id User ID to action on.
     * @return OK
     */
    cancelDeletionRequest(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/cancelDeletionRequest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelDeletionRequest(_response);
        });
    }

    protected processCancelDeletionRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get user by owner token
     * @param tokenId ID of the owner token.
     * @return User details of the user referenced by the owner token
     */
    getByOwnerToken(tokenId: string | null): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByOwnerToken(_response);
        });
    }

    protected processGetByOwnerToken(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Create user
     * @param request Requested user information.
     * @return Newly created user
     */
    create(request: UserCreateRequest): Promise<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * Get multiple users
     * @param ids (optional) User IDs.
     * @return Details of all the users who were found
     */
    getMany(ids?: string[] | null | undefined): Promise<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/Users/many?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<UserDetail[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail[]>(<any>null);
    }

    /**
     * Search users
     * @param request User search request.
     * @return Result of the user search
     */
    search(request: UserSearchRequest): Promise<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/Users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<UserSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSearchResult>(<any>null);
    }

    /**
     * Aggregate users
     * @param request User aggregation request.
     * @return Aggregation based on the request
     */
    aggregate(request: UserAggregationRequest): Promise<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult>(<any>null);
    }

    /**
     * Update identity provider on multiple users
     * @param request User update identity provider request.
     * @return Business process
     */
    updateIdentityProviderMany(request: UserUpdateIdentityProviderManyRequest): Promise<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/updateIdentityProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateIdentityProviderMany(_response);
        });
    }

    protected processUpdateIdentityProviderMany(response: Response): Promise<BusinessProcess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <PictureparkValidationException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <PictureparkNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : <PictureparkConflictException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Too many requests", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess>(<any>null);
    }
}

/** Business process */
export interface BusinessProcess {
    /** ID of the business process. */
    id: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation: boolean;
    /** Scope of the business process. */
    businessProcessScope: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate: Date;
    /** When the business process finished. */
    endDate: Date;
    /** Is the business process finished. */
    finished: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: BusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
    /** Id of the business process that will be automatically started after the completion of the current one, if any. */
    continuationBusinessProcessId?: string | undefined;
}

/** Scope of the business process */
export enum BusinessProcessScope {
    System = <any>"System",
    User = <any>"User",
}

/** Life cycle of the business process */
export enum BusinessProcessLifeCycle {
    Draft = <any>"Draft",
    InProgress = <any>"InProgress",
    Succeeded = <any>"Succeeded",
    Cancelled = <any>"Cancelled",
    CancellationInProgress = <any>"CancellationInProgress",
    Failed = <any>"Failed",
    SucceededWithErrors = <any>"SucceededWithErrors",
}

/** State transition information of a business process */
export interface BusinessProcessState {
    /** State of the business process */
    state: string;
    /** Date and time of when the state transition was performed. */
    timestamp: Date;
    /** Eventual error associated to the state transition. */
    error?: ErrorResponse | undefined;
}

/** Error information with serialized exception */
export interface ErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;
}

export interface Exception {
}

export interface PictureparkException extends Exception {
    traceLevel?: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode?: number;
    exceptionMessage?: string | undefined;
}

export interface PictureparkBusinessException extends PictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export interface PictureparkValidationException extends PictureparkBusinessException {
}

export enum TraceLevel {
    Critical = <any>"Critical",
    Error = <any>"Error",
    Warning = <any>"Warning",
    Information = <any>"Information",
    Verbose = <any>"Verbose",
}

export interface PictureparkConflictException extends PictureparkBusinessException {
    reference?: string | undefined;
}

export interface PictureparkTimeoutException extends PictureparkValidationException {
}

export interface PictureparkForbiddenException extends PictureparkBusinessException {
}

export interface UserEmailAlreadyExistsException extends PictureparkValidationException {
    email?: string | undefined;
}

export interface UnableToDeleteUserRoleException extends PictureparkValidationException {
    userRoleId?: string | undefined;
}

export interface UserRoleAssignedException extends UnableToDeleteUserRoleException {
}

export interface UserNotFoundException extends PictureparkBusinessException {
    missingUserId?: string | undefined;
}

export interface UserInactiveOrDeletedException extends PictureparkValidationException {
    /** The ID of the inactive or deleted user in question. */
    affectedUserId?: string | undefined;
}

export interface InactiveOrDeletedUserRefusedAccessException extends PictureparkForbiddenException {
}

export interface TermsOfServiceNotNewestException extends PictureparkBusinessException {
}

export interface IllegalAuthorizationStateTransitionException extends PictureparkValidationException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;
    transition?: string | undefined;
}

/** User authorization state */
export enum AuthorizationState {
    Reviewed = <any>"Reviewed",
    ToBeReviewed = <any>"ToBeReviewed",
    Invited = <any>"Invited",
    UserTriggeredDeactivation = <any>"UserTriggeredDeactivation",
}

export interface TermsOfServiceConsentRequiredException extends PictureparkForbiddenException {
}

export interface PictureparkNotFoundException extends PictureparkBusinessException {
    reference?: string | undefined;
}

export interface UserRolesNotFoundException extends PictureparkNotFoundException {
    userRoleIds?: string[] | undefined;
}

export interface UnauthorizedException extends PictureparkBusinessException {
}

export interface UserUnlockDisallowedException extends PictureparkValidationException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;
}

export interface UserAlreadyInRequestedLockStateException extends PictureparkBusinessException {
    affectedUserId?: string | undefined;
    userIsLocked?: boolean;
}

export interface LoginUsingIncorrectIdentityProviderException extends PictureparkForbiddenException {
    affectedUserId?: string | undefined;
}

export interface IdentityProviderNotFoundException extends PictureparkValidationException {
    missingIdentityProviderId?: string | undefined;
    external?: boolean;
}

export interface UserDoesNotSupportLocalLoginException extends PictureparkValidationException {
    affectedUserId?: string | undefined;
}

export interface UserAttributeNotSynchronizableException extends PictureparkValidationException {
    attributePath?: string | undefined;
}

export interface UnableToMapMultipleClaimTypesIntoSameAttributeException extends PictureparkValidationException {
    attributePath?: string | undefined;
}

export interface UnableToChangeUserRolesForFederatedUser extends PictureparkValidationException {
    affectedUserId?: string | undefined;
}

export interface UnableToDeleteDefaultUserRoleException extends UnableToDeleteUserRoleException {
}

export interface UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException extends UnableToDeleteUserRoleException {
    identityProviderIds?: string[] | undefined;
}

export interface RenderingException extends PictureparkBusinessException {
}

export interface FormatNotApplicableForRenderingException extends RenderingException {
    contentRenderingType?: RenderingCategory;
    outputFormatId?: string | undefined;
}

export enum RenderingCategory {
    Unknown = <any>"Unknown",
    Image = <any>"Image",
    Document = <any>"Document",
    Video = <any>"Video",
    Audio = <any>"Audio",
    Vector = <any>"Vector",
}

export interface ServiceProviderDeleteException extends PictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export interface ServiceProviderCreateException extends PictureparkException {
    externalId?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export interface ServiceProviderNotFoundException extends PictureparkException {
    missingServiceProviderId?: string | undefined;
}

export interface DocumentVersionNotFoundException extends PictureparkNotFoundException {
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export interface DefaultChannelDeleteException extends PictureparkValidationException {
}

export interface ChannelsNotFoundException extends PictureparkNotFoundException {
}

export interface SuperAdminRolesNotAssignableToChannelException extends PictureparkValidationException {
}

export interface ElasticVersionUpdateException extends PictureparkException {
    expectedVersion?: string | undefined;
    actualVersion?: string | undefined;
}

export interface InvalidVersionException extends PictureparkException {
    component?: string | undefined;
    version?: string | undefined;
    expectedVersion?: string | undefined;
}

export interface EnvironmentNotDeactivatedException extends PictureparkException {
}

export interface EnvironmentNotFoundException extends PictureparkException {
}

export interface EnvironmentDeactivationException extends PictureparkException {
    deactivationMessage?: string | undefined;
}

export interface CustomerClonesNotAcceptedException extends PictureparkValidationException {
}

export interface ShareNotFoundException extends PictureparkNotFoundException {
    shareId?: string | undefined;
}

export interface ShareByTokenNotFoundException extends PictureparkNotFoundException {
    token?: string | undefined;
}

export interface TokenGenerationException extends PictureparkBusinessException {
    retries?: number;
}

export interface ShareExpiredException extends PictureparkBusinessException {
    token?: string | undefined;
}

export interface ShareSizeLimitExceededException extends PictureparkValidationException {
    shareId?: string | undefined;
    limit?: number;
}

export interface OutputIdNotFoundException extends PictureparkNotFoundException {
    outputId?: string | undefined;
}

export interface OutputNotFoundException extends PictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export interface UnableToCreateOrModifyStaticOutputFormatException extends PictureparkValidationException {
}

export interface NotSupportedFileMappingException extends PictureparkValidationException {
    inputExtension?: string | undefined;
    targetFormatKind?: string | undefined;
}

export interface NotSupportedFileMappingForDynamicFormatException extends NotSupportedFileMappingException {
    formatId?: string | undefined;
}

export interface NotSupportedFileExtensionException extends PictureparkValidationException {
    extension?: string | undefined;
}

export interface DuplicateOutputFormatIdException extends PictureparkValidationException {
}

export interface OutputFormatResizingNotSupportedException extends PictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export interface OutputBackupNotRequestedException extends PictureparkValidationException {
}

export interface LeaseNotAcquiredException extends PictureparkBusinessException {
    resourceId?: string | undefined;
}

export interface OperationInProgressException extends PictureparkBusinessException {
    leaseResourceType?: LeaseResourceType;
}

export enum LeaseResourceType {
    SchemaEditing = <any>"SchemaEditing",
}

export interface RetryException extends PictureparkBusinessException {
    retries?: number;
    innerExceptionDetail?: string | undefined;
}

export interface OwnerTokenNotFoundException extends PictureparkNotFoundException {
    ownerTokenUserIds?: string[] | undefined;
}

export interface InvalidStateException extends PictureparkValidationException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export interface PictureparkArgumentNullException extends PictureparkValidationException {
    argumentName?: string | undefined;
}

export interface ObjectTypeMismatchException extends PictureparkBusinessException {
    type?: string | undefined;
}

export interface InvalidStateTransitionException extends InvalidStateException {
    transition?: string | undefined;
}

export interface FailedToLockException extends PictureparkBusinessException {
    resourceId?: string | undefined;
}

export interface PictureparkOperationCanceledException extends PictureparkBusinessException {
}

export interface PictureparkApplicationException extends PictureparkBusinessException {
}

export interface MissingCustomerDefaultLanguageException extends PictureparkValidationException {
    customerDefaultLanguage?: string | undefined;
}

export interface PartialOperationNotSupportedException extends PictureparkValidationException {
}

export interface ContractMismatchException extends PictureparkValidationException {
}

export interface InvalidArgumentException extends PictureparkValidationException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export interface ArgumentRangeException extends InvalidArgumentException {
    minAcceptableValue?: string | undefined;
    maxAcceptableValue?: string | undefined;
}

export interface UnknownException extends PictureparkBusinessException {
}

export interface OwnerTokenInUseException extends PictureparkValidationException {
    ownerTokenUserId?: string | undefined;
}

export interface InvalidValueFormatException extends PictureparkValidationException {
}

export interface ItemIdDuplicatedException extends PictureparkValidationException {
    id?: string | undefined;
}

export interface RequestSizeLimitExceededException extends PictureparkValidationException {
    argumentName?: string | undefined;
    limit?: number;
    requestedAmount?: number;
}

export interface CustomerViolationException extends PictureparkException {
    expectedCustomerId?: string | undefined;
    currentCustomerId?: string | undefined;
}

export interface CustomerAliasNotFoundException extends PictureparkException {
    customerAlias?: string | undefined;
}

export interface CustomerAliasInUseException extends PictureparkBusinessException {
    existingCustomerId?: string | undefined;
    alias?: string | undefined;
}

export interface CustomerNotDeactivatedException extends PictureparkException {
    customerId?: string | undefined;
}

export interface CustomerDeactivationException extends PictureparkException {
    customerId?: string | undefined;
    deactivationMessage?: string | undefined;
}

export interface CustomerHostNotFoundException extends PictureparkException {
    hostName?: string | undefined;
}

export interface CustomerNotFoundException extends PictureparkException {
    customerId?: string | undefined;
}

export interface CustomerNotActiveException extends PictureparkException {
    customerId?: string | undefined;
}

export interface CustomerBoostValuesInvalidException extends PictureparkValidationException {
}

export interface SnapshotRetentionTimeTooShortException extends PictureparkValidationException {
    snapshotRetentionTime?: string;
    minimumRetentionTime?: string;
}

export interface ConfigurationIndexNotFoundException extends PictureparkException {
    configurationIndex?: string | undefined;
}

export interface DuplicateSearchIndexDocException extends PictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export interface SearchIndexDocNotFoundException extends PictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export interface IndexDocumentNotFoundException extends PictureparkBusinessException {
    indexId?: string | undefined;
}

export interface DuplicateAliasException extends PictureparkException {
    indexAlias?: string | undefined;
}

export interface SearchIndexNotFoundException extends PictureparkBusinessException {
    searchIndexId?: string | undefined;
}

export interface DefaultSearchIndexDeleteException extends PictureparkBusinessException {
}

export interface SearchIndexInUseException extends PictureparkBusinessException {
    searchIndex?: string | undefined;
}

export interface IndexException extends PictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export interface IndexMappingException extends PictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export interface DuplicatedSearchBehaviorException extends PictureparkValidationException {
    duplicatedSearchBehaviors?: string | undefined;
}

export interface SearchStringLeadingWildcardException extends PictureparkValidationException {
}

export interface DuplicateAggregatorException extends PictureparkValidationException {
    aggregatorName?: string | undefined;
}

export interface InvalidDateTimeFormatException extends PictureparkValidationException {
    value?: string | undefined;
    expectedFormat?: string | undefined;
}

export interface InvalidSortFieldException extends PictureparkValidationException {
    fieldName?: string | undefined;
}

export interface DocumentVersionConflictException extends PictureparkConflictException {
    documentId?: string | undefined;
    documentType?: string | undefined;
    documentVersion?: number;
}

export interface RedisDatabaseExceededException extends PictureparkException {
    customerId?: string | undefined;
    customerCount?: number;
    maxCount?: number;
    startIndex?: number;
    redisDatabaseCount?: number;
}

export interface DuplicateDocumentException extends PictureparkValidationException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export interface ObjectStoreResponseException extends PictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export interface ObjectStoreException extends PictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
}

export interface QueryException extends PictureparkBusinessException {
    debugInformation?: string | undefined;
}

export interface PermissionOwnershipTransferException extends PictureparkValidationException {
    transferUserId?: string | undefined;
    missingUserRight?: UserRight;
}

export enum UserRight {
    ManageContent = <any>"ManageContent",
    ManageSharings = <any>"ManageSharings",
    ManageTransfer = <any>"ManageTransfer",
    ManageChannels = <any>"ManageChannels",
    ManageSchemas = <any>"ManageSchemas",
    ManageUsers = <any>"ManageUsers",
    ManageUserRoles = <any>"ManageUserRoles",
    ManagePermissions = <any>"ManagePermissions",
    ManageSearchIndexes = <any>"ManageSearchIndexes",
    ManageCollections = <any>"ManageCollections",
    ManageListItems = <any>"ManageListItems",
    ManageServiceProviders = <any>"ManageServiceProviders",
    ManageEmbeds = <any>"ManageEmbeds",
    ManageTemplates = <any>"ManageTemplates",
    ManageTermsOfService = <any>"ManageTermsOfService",
    ManageLiveStream = <any>"ManageLiveStream",
    ManageDocumentHistory = <any>"ManageDocumentHistory",
    ManageAllShares = <any>"ManageAllShares",
    ManageOutputFormats = <any>"ManageOutputFormats",
    ManageBusinessProcesses = <any>"ManageBusinessProcesses",
    ManageIdentityProviders = <any>"ManageIdentityProviders",
}

export interface PermissionSetNotFoundException extends PictureparkNotFoundException {
    permissionSetIds?: string[] | undefined;
}

export interface PermissionSetAggregateException extends PictureparkValidationException {
    exceptions?: PictureparkException[] | undefined;
}

export interface DuplicateRightException extends PictureparkValidationException {
    permissionSetId?: string | undefined;
}

export interface PermissionValidationException extends PictureparkValidationException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export interface PermissionSetInUseException extends PictureparkValidationException {
    reference?: string | undefined;
    referenceCount?: number;
}

export interface ContentPermissionException extends PictureparkValidationException {
    contentId?: string | undefined;
    contentRights?: ContentRight[] | undefined;
}

/** Content rights */
export enum ContentRight {
    View = <any>"View",
    AccessOriginal = <any>"AccessOriginal",
    EditMetadata = <any>"EditMetadata",
    EditContent = <any>"EditContent",
    ManagePermissions = <any>"ManagePermissions",
    Delete = <any>"Delete",
}

export interface ListItemPermissionException extends PictureparkValidationException {
    listItemId?: string | undefined;
    metadataRight?: MetadataRight;
}

/** Metadata rights */
export enum MetadataRight {
    View = <any>"View",
    ManageItems = <any>"ManageItems",
    ManageSchema = <any>"ManageSchema",
}

export interface SchemaPermissionException extends PictureparkValidationException {
    schemaId?: string | undefined;
    metadataRight?: MetadataRight;
}

/** This exception is an abstract base for permission set validation. */
export interface PermissionSetValidationException extends PictureparkValidationException {
    permissionSetId?: string | undefined;
}

export interface PermissionSetInvalidRightCombinationException extends PermissionSetValidationException {
}

export interface AmbiguousUserRoleRightsException extends PermissionSetValidationException {
}

export interface UnsupportedListItemChangeCommandException extends PictureparkValidationException {
    commandType?: string | undefined;
}

export interface ListItemLayerException extends PictureparkValidationException {
    listItemId?: string | undefined;
}

export interface ListItemNotFoundException extends PictureparkNotFoundException {
    listItemIds?: string[] | undefined;
}

export interface ListItemCyclicDependencyException extends PictureparkBusinessException {
    listItemIds?: string[] | undefined;
}

export interface DeleteListItemsWithReferencesException extends PictureparkValidationException {
    numberOfReferences?: number;
}

export interface ListItemUpdateManyException extends PictureparkBusinessException {
    failedItemsCount?: number;
    totalItemsCount?: number;
}

export interface ListItemSchemaMismatchException extends PictureparkValidationException {
    listItemId?: string | undefined;
    listItemSchemaId?: string | undefined;
    fieldSchemaId?: string | undefined;
}

export interface TransferInfoNotFoundException extends PictureparkNotFoundException {
    transferInfoId?: string | undefined;
}

export interface FileTransferNotFoundException extends PictureparkNotFoundException {
    fileTransferId?: string | undefined;
}

export interface InvalidTransferTypeException extends PictureparkBusinessException {
    transferType?: TransferType;
}

/** Type of the transfer */
export enum TransferType {
    FileUpload = <any>"FileUpload",
    FileUploadAutoImport = <any>"FileUploadAutoImport",
    WebDownload = <any>"WebDownload",
    SchemaImport = <any>"SchemaImport",
}

export interface TransferNotFoundException extends PictureparkNotFoundException {
    transferId?: string | undefined;
}

export interface WrongChunkSizeException extends PictureparkValidationException {
    actual?: number;
    expected?: number;
}

export interface ChunkSizeOutOfRangeException extends PictureparkValidationException {
    actual?: number;
    minimum?: number;
    maximum?: number;
}

export interface MaximumTransferSizeException extends PictureparkException {
    transferSize?: number;
    maximumTransferSize?: number;
    transferId?: string | undefined;
}

export interface FileIdDuplicatedException extends PictureparkValidationException {
    fileId?: string | undefined;
}

export interface MissingDependenciesException extends PictureparkValidationException {
    itemIds?: string | undefined;
}

export interface RelationSelfReferencingException extends PictureparkValidationException {
    itemId?: string | undefined;
    itemType?: string | undefined;
}

export interface InvalidChangeCommandFieldTypeInvalidException extends PictureparkValidationException {
    commandType?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldActualType?: string | undefined;
    fieldExpectedType?: string | undefined;
}

export interface InvalidChangeCommandFieldNotFoundException extends PictureparkValidationException {
    commandTypeName?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export interface InvalidChangeCommandSchemaChangeInvalidException extends PictureparkValidationException {
    commandTypeName?: string | undefined;
    schemaId?: string | undefined;
}

export interface InvalidMetadataException extends PictureparkValidationException {
    metadataErrors?: MetadataError[] | undefined;
    validationErrors?: PictureparkBusinessException[] | undefined;
}

export interface MetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export interface RelationNotFoundException extends PictureparkBusinessException {
    relationId?: string | undefined;
}

export interface RelationTypeNotFoundException extends PictureparkBusinessException {
    relationType?: string | undefined;
}

export interface RelationTypeTargetDocTypeMismatchException extends PictureparkBusinessException {
    relationType?: string | undefined;
    targetDocType?: string | undefined;
    expectedTargetDocType?: string | undefined;
}

export interface AggregationNameInvalidException extends PictureparkValidationException {
    aggregationName?: string | undefined;
    aggregationPrefix?: string | undefined;
}

/** Size of the aggregation is invalid. */
export interface AggregationSizeInvalidException extends PictureparkValidationException {
    /** The name identifying the aggregation. */
    aggregationName?: string | undefined;
    /** The invalid size of the aggregation: size must be equal or greater than 1. */
    aggregationSize?: number;
}

export interface AggregationFilterNotSupportedException extends PictureparkValidationException {
    aggregationName?: string | undefined;
    notSupportedFilterType?: string | undefined;
    supportedFilterTypes?: string[] | undefined;
}

export interface RelationTypeMissingException extends PictureparkBusinessException {
}

export interface ReferencesUpdateException extends PictureparkBusinessException {
    exceptions?: ReferenceUpdateException[] | undefined;
}

export interface ReferenceUpdateException extends PictureparkBusinessException {
    /** This is the source of the reference. */
    referenceItemId?: string | undefined;
    /** This is the DocType of the source of the reference. */
    referenceType?: string | undefined;
    /** These exceptions describe why the source metadata item could not be updated. */
    exceptions?: PictureparkException[] | undefined;
}

export interface DuplicatedItemAssignedException extends PictureparkValidationException {
    itemId?: string | undefined;
    itemPath?: string | undefined;
}

export interface InvalidDataTypeException extends PictureparkValidationException {
    value?: any | undefined;
}

export interface LayerAssignmentInvalidException extends PictureparkValidationException {
    layerId?: string | undefined;
    value?: any | undefined;
}

export interface OutdatedMetadataUpdateInProgressException extends PictureparkValidationException {
}

export interface SchemaFieldOverwriteTypeMismatchException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    fieldOverwriteType?: string | undefined;
    fieldType?: string | undefined;
}

export interface SchemaFieldOverwriteIdException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldIdDuplicatedException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldIdPreviouslyUsedException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    usedInSchemaId?: string | undefined;
}

export interface SchemaFieldIdAlreadyExistsInSchemaHierarchyException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    existingInSchemaId?: string | undefined;
}

export interface SchemaFieldSchemaIndexInfoSimpleSearchNestingException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export interface SchemaFieldSchemaIndexInfoNestingException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export interface SchemaFieldIdUppercaseException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaIdLowercaseException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaInfoNotFoundException extends PictureparkNotFoundException {
    schemaId?: string | undefined;
}

export interface IndexedFieldThresholdExceededException extends PictureparkValidationException {
    schemaIds?: string[] | undefined;
    indexedFieldCount?: number;
    indexedFieldThreshold?: number;
}

export interface SortableFieldThresholdExceededException extends PictureparkValidationException {
    schemaIds?: string[] | undefined;
    sortableFieldCount?: number;
    sortableFieldThreshold?: number;
}

export interface DuplicateSchemaInfoException extends PictureparkBusinessException {
    schemaId?: string | undefined;
}

export interface SchemaFieldNumberRangeException extends PictureparkValidationException {
    fieldId?: string | undefined;
    propertyName?: string | undefined;
    minValue?: number;
    maxValue?: number;
}

export interface SchemaInUseContentSchemaException extends PictureparkValidationException {
    schemaId?: string | undefined;
    contentSchemaIds?: string[] | undefined;
}

export interface LayerAssignmentInUseWithContentsException extends PictureparkValidationException {
    schemaId?: string | undefined;
    usedAssignmentSchemaIds?: string[] | undefined;
}

export interface SchemaInUseListItemException extends PictureparkValidationException {
    schemaId?: string | undefined;
    listItemCount?: number;
}

export interface SchemaInUseContentException extends PictureparkValidationException {
    schemaId?: string | undefined;
    contentCount?: number;
}

export interface SchemaInUseFieldException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldNamespaces?: string[] | undefined;
}

export interface DuplicateMetadataDisplayPatternException extends PictureparkValidationException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;
}

export interface DuplicateSchemaException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaImportEmptyException extends PictureparkValidationException {
}

export interface SchemaImportVersionMismatchException extends PictureparkValidationException {
    providedVersion?: string | undefined;
    expectedVersion?: string | undefined;
}

export interface SchemaInheritanceFieldIndexDeviationException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaInheritanceTypeDeviationException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaValidationException extends PictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export interface SchemaSortFieldException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldIdException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldTypeChangeException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldTypeName?: string | undefined;
    newTypeName?: string | undefined;
}

export interface SchemaFieldIndexException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldNotSortableException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export interface SchemaFieldNotSearchableException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export interface SchemaFieldInvalidBoostException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    boost?: number;
    allowedBoostValues?: number[] | undefined;
}

export interface SchemaNoContentException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaParentChangeException extends PictureparkValidationException {
    schemaId?: string | undefined;
    oldSchemaParentId?: string | undefined;
    newSchemaParentId?: string | undefined;
}

export interface SchemaMissingTypeException extends PictureparkValidationException {
    schemaId?: string | undefined;
    expectedSchemaTypes?: SchemaType[] | undefined;
}

/** Type of the schema */
export enum SchemaType {
    Content = <any>"Content",
    Layer = <any>"Layer",
    List = <any>"List",
    Struct = <any>"Struct",
}

export interface SchemaPermissionConfigurationException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaNoLayerException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaIdException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaInUseException extends PictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export interface SchemaNotFoundException extends PictureparkNotFoundException {
    schemaId?: string | undefined;
}

export interface SchemaCountLimitReachedException extends PictureparkBusinessException {
}

export interface SystemSchemaInvalidModificationException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaFieldRelationSchemaSystemSchemaException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export interface SchemaFieldRelationSchemaTypeUnsupportedException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export interface SchemaMultipleTypesException extends PictureparkValidationException {
    schemaId?: string | undefined;
    schemaTypes?: string[] | undefined;
}

export interface MissingDisplayPatternForCustomerDefaultLanguageException extends PictureparkValidationException {
    schemaId?: string | undefined;
    missingTypes?: DisplayPatternType[] | undefined;
}

/** The display pattern type */
export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail",
    List = <any>"List",
    Detail = <any>"Detail",
    Name = <any>"Name",
    DownloadFileName = <any>"DownloadFileName",
}

export interface SchemaViewForAllException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SystemLayerReferenceInvalidModificationException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface SchemaFieldAnalyzerInvalidException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    analyzers?: Analyzer[] | undefined;
    allowedAnalyzers?: Analyzer[] | undefined;
}

export enum Analyzer {
    None = <any>"None",
    Simple = <any>"Simple",
    Language = <any>"Language",
    PathHierarchy = <any>"PathHierarchy",
    EdgeNGram = <any>"EdgeNGram",
    NGram = <any>"NGram",
}

export interface SchemaFieldRelationMultipleTypesException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export interface SchemaFieldNotRequirableException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export interface DisplayPatternTypeNotSupportedException extends PictureparkValidationException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;
}

export interface DeleteContentsWithReferencesException extends PictureparkValidationException {
    numberOfReferences?: number;
    numberOfShares?: number;
}

export interface ContentMetadataUpdateManyException extends PictureparkBusinessException {
    failedItemsCount?: number;
    totalItemsCount?: number;
}

export interface ContentNotFoundException extends PictureparkNotFoundException {
    contentIds?: string[] | undefined;
}

export interface ContentLayerInvalidException extends PictureparkValidationException {
    contentId?: string | undefined;
    layerIds?: string | undefined;
}

export interface ContentFileReplaceTypeMismatchException extends PictureparkValidationException {
    contentId?: string | undefined;
    originalContentType?: ContentType;
    newContentType?: ContentType;
}

/** Content types */
export enum ContentType {
    Unknown = <any>"Unknown",
    Bitmap = <any>"Bitmap",
    VectorGraphic = <any>"VectorGraphic",
    RawImage = <any>"RawImage",
    InterchangeDocument = <any>"InterchangeDocument",
    WordProcessingDocument = <any>"WordProcessingDocument",
    TextDocument = <any>"TextDocument",
    DesktopPublishingDocument = <any>"DesktopPublishingDocument",
    Presentation = <any>"Presentation",
    Spreadsheet = <any>"Spreadsheet",
    Archive = <any>"Archive",
    Audio = <any>"Audio",
    Video = <any>"Video",
    Font = <any>"Font",
    Multimedia = <any>"Multimedia",
    Application = <any>"Application",
    SourceCode = <any>"SourceCode",
    Database = <any>"Database",
    Cad = <any>"Cad",
    Model3d = <any>"Model3d",
    Virtual = <any>"Virtual",
}

export interface ContentBackupFailedException extends PictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    outputId?: string | undefined;
}

export interface ContentLayerSameRootException extends PictureparkValidationException {
    contentId?: string | undefined;
    layerIdsByRootSchema?: LayerIdsByRootSchema[] | undefined;
}

export interface LayerIdsByRootSchema {
    rootSchemaId?: string | undefined;
    layerSchemaIds?: string[] | undefined;
}

export interface BusinessProcessEngineRequestException extends PictureparkBusinessException {
    businessProcessId?: string | undefined;
    engineError?: string | undefined;
}

export interface BusinessProcessNotFoundException extends PictureparkNotFoundException {
    businessProcessId?: string | undefined;
}

export interface BusinessProcessDefinitionNotFoundException extends PictureparkNotFoundException {
    processDefinitionId?: string | undefined;
}

export interface BusinessProcessDefinitionCreateException extends PictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export interface BusinessProcessNotExternalException extends PictureparkForbiddenException {
    businessProcessId?: string | undefined;
}

export interface BusinessProcessCancellationNotSupportedException extends PictureparkValidationException {
    businessProcessId?: string | undefined;
}

export interface BusinessProcessContinuationException extends PictureparkBusinessException {
    continuationBusinessProcessId?: string | undefined;
    precedingBusinessProcessId?: string | undefined;
    precedingBusinessProcessException?: PictureparkException | undefined;
}

export interface SchemaFieldImportMismatchException extends PictureparkValidationException {
    schemaId?: string | undefined;
    importingFieldIds?: string | undefined;
    existingFieldIds?: string | undefined;
}

export interface SchemaFieldImportRelatedSchemaMismatchException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingRelatedSchemaId?: string | undefined;
    existingRelatedSchemaId?: string | undefined;
}

export interface SchemaFieldImportTypeMismatchException extends PictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingFieldType?: string | undefined;
    existingFieldType?: string | undefined;
}

export interface SchemaFieldNotSupportedException extends PictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldType?: string | undefined;
}

export interface SchemaFieldDisplayPatternTypeNotSupportedException extends PictureparkValidationException {
    fieldId?: string | undefined;
    displayPatternType?: DisplayPatternType;
    supportedDisplayPatternTypes?: DisplayPatternType[] | undefined;
}

export interface SnapshotTimeoutException extends PictureparkTimeoutException {
}

export interface SnapshotFailedException extends PictureparkBusinessException {
}

export interface SnapshotSkippedException extends PictureparkBusinessException {
}

export interface AddMetadataLanguageTimeoutException extends PictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export interface EnvironmentProcessAlreadyRunningException extends PictureparkValidationException {
    environmentProcessType?: EnvironmentProcessType;
}

export enum EnvironmentProcessType {
    AddMetadataLanguage = <any>"AddMetadataLanguage",
    CustomerUpdate = <any>"CustomerUpdate",
    EnvironmentUpdate = <any>"EnvironmentUpdate",
    CustomerBoostValuesUpdate = <any>"CustomerBoostValuesUpdate",
}

export interface EnvironmentProcessNotFoundException extends PictureparkNotFoundException {
    environmentProcessId?: string | undefined;
}

export interface EnvironmentProcessWaitTimeoutException extends PictureparkTimeoutException {
    environmentProcessId?: string | undefined;
    waitedLifecycles?: string | undefined;
}

export interface CustomerBoostValuesUpdateTimeoutException extends PictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export interface NoTermsOfServiceDefinedException extends PictureparkBusinessException {
}

export interface AtLeastOneActiveTermsOfServiceMustExistException extends PictureparkValidationException {
}

export interface ForbiddenHtmlElementsUsedException extends PictureparkValidationException {
}

export interface BusinessProcessStateNotHitException extends PictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: string[] | undefined;
    actual?: string | undefined;
}

export interface BusinessProcessLifeCycleNotHitException extends PictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: BusinessProcessLifeCycle[] | undefined;
    actual?: BusinessProcessLifeCycle;
}

export interface OnlyAccessibleToRecipientException extends PictureparkValidationException {
}

export interface EnvironmentNotAvailableException extends PictureparkException {
}

export interface CustomerNotAvailableException extends PictureparkException {
    customerId?: string | undefined;
}

export interface CustomerAliasHeaderMissingException extends PictureparkValidationException {
}

export interface BusinessRuleActionInvalidDocumentTypeException extends PictureparkValidationException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;
}

export enum BusinessRuleTriggerDocType {
    Content = <any>"Content",
}

export interface BusinessRuleActionInvalidExecutionScopeException extends PictureparkValidationException {
    allowedScopes?: BusinessRuleExecutionScope[] | undefined;
}

export enum BusinessRuleExecutionScope {
    MainDoc = <any>"MainDoc",
    SearchDoc = <any>"SearchDoc",
}

export interface BusinessRuleActionsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleConditionMissingException extends PictureparkValidationException {
}

export interface BusinessRuleConditionsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleConfigurationValidationException extends PictureparkValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export interface BusinessRuleSchemaIdInvalidException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface BusinessRulePermissionSetIdInvalidException extends PictureparkValidationException {
    permissionSetId?: string | undefined;
}

export interface BusinessRuleRuleIdDuplicationException extends PictureparkValidationException {
}

export interface BusinessRuleRuleIdMissingException extends PictureparkValidationException {
}

export interface BusinessRuleTriggerPointMissingException extends PictureparkValidationException {
}

export interface BusinessRuleValidationException extends PictureparkValidationException {
    ruleId?: string | undefined;
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export interface BusinessRuleConditionInvalidTriggerPointDocumentTypeException extends PictureparkValidationException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;
}

export interface BusinessRuleRegularExpressionInvalidException extends PictureparkValidationException {
    regex?: string | undefined;
}

export interface BusinessRuleConditionInvalidTriggerPointActionException extends PictureparkValidationException {
    allowedActions?: BusinessRuleTriggerAction[] | undefined;
}

export enum BusinessRuleTriggerAction {
    Create = <any>"Create",
    Update = <any>"Update",
    FileReplacement = <any>"FileReplacement",
}

export interface BusinessRuleRefIdsMissingException extends PictureparkValidationException {
}

export interface BusinessRulePathInvalidException extends PictureparkValidationException {
    path?: string | undefined;
}

export interface BusinessRuleFieldIdInvalidException extends PictureparkValidationException {
    fieldId?: string | undefined;
}

export interface BusinessRuleContentPermissionSetIdsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleFieldPathInvalidException extends PictureparkValidationException {
    fieldPath?: string | undefined;
}

export interface BusinessRulePolygonInvalidException extends PictureparkValidationException {
}

export interface BusinessRuleArrayIndexInvalidException extends PictureparkValidationException {
    index?: string | undefined;
}

export interface BusinessRuleDictionaryKeyInvalidException extends PictureparkValidationException {
    key?: string | undefined;
}

export interface BusinessRuleProjectionTransformationsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleInvalidVariableNameException extends PictureparkValidationException {
    name?: string | undefined;
}

export interface BusinessRuleTransformationGroupTransformationsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleTransformationGroupInputsMissingException extends PictureparkValidationException {
}

export interface BusinessRuleNamedCacheNameInvalidException extends PictureparkValidationException {
    cacheName?: string | undefined;
}

export interface BusinessRuleNGramTransformationSizeInvalidException extends PictureparkValidationException {
    size?: number;
    minSize?: number;
    maxSize?: number;
}

export interface BusinessRuleNGramTransformationMinWordLengthInvalidException extends PictureparkValidationException {
    minWordLength?: number;
}

export interface BusinessRuleNGramTransformationMaxWordLengthInvalidException extends PictureparkValidationException {
    maxWordLength?: number;
}

export interface NamedCacheConfigurationException extends PictureparkValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export interface NamedCacheNameMissingException extends PictureparkValidationException {
}

export interface NamedCacheNameDuplicationException extends PictureparkValidationException {
    name?: string | undefined;
}

export interface ListItemNamedCacheSchemaIdInvalidException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface ListItemNamedCacheKeyFieldsInvalidException extends PictureparkValidationException {
}

export interface SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException extends PictureparkValidationException {
    schemaId?: string | undefined;
}

export interface NoTagsFoundException extends PictureparkBusinessException {
}

export interface OutputNotAvailableException extends PictureparkBusinessException {
}

export interface ModelNotFoundException extends PictureparkNotFoundException {
}

export interface DisplayValueRerenderingInProgressException extends PictureparkValidationException {
}

export interface OutputFormatNotFoundException extends PictureparkNotFoundException {
    outputFormatId?: string | undefined;
}

export interface OutputFormatSourceNotDefinedException extends PictureparkValidationException {
    outputFormatId?: string | undefined;
}

export interface OutputFormatRetentionTimeOutOfRangeException extends ArgumentRangeException {
    outputFormatId?: string | undefined;
}

export interface NotSupportedFileExtensionForFormatException extends NotSupportedFileExtensionException {
    formatKind?: string | undefined;
    outputFormatId?: string | undefined;
}

export interface CollectionSizeLimitExceededException extends PictureparkValidationException {
    collectionId?: string | undefined;
    limit?: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

/** Create request to create a BusinessProcess. */
export interface BusinessProcessCreateRequest {
    /** Indicates if the system starting the business process supports cancellation. */
    supportsCancellation: boolean;
    /** Notification data to send to the user when creating the business process.
Set to null to not create a notification. */
    notification?: BusinessProcessNotificationUpdate | undefined;
    /** Initial state of the business process. */
    initialState: string;
}

/** Notification update for a business process. */
export interface BusinessProcessNotificationUpdate {
    /** The title the message that is shown to the user should have. */
    title: TranslatedStringDictionary;
    /** The message shown to the user. */
    message: TranslatedStringDictionary;
    /** An optional navigation link that allows the user to jump to a page giving more information
about the process. */
    navigationLink?: string | undefined;
    /** The event type of the notification. */
    eventType: NotificationEventType;
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface TranslatedStringDictionary {

    [key: string]: string | any; 
}

export enum NotificationEventType {
    Pending = <any>"Pending",
    InProgress = <any>"InProgress",
    Success = <any>"Success",
    Error = <any>"Error",
    Warning = <any>"Warning",
    Information = <any>"Information",
}

/** Transitions the business process to a new state and/or life cycle. */
export interface BusinessProcessStateChangeRequest {
    /** The new state of the business process. */
    state: string;
    /** The new life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** An optional notification update to be posted together with the transition. */
    notification?: BusinessProcessNotificationUpdate | undefined;
}

/** Updates the notification of a business process without changing the state or the life cycle. */
export interface BusinessProcessNotificationUpdateRequest extends BusinessProcessNotificationUpdate {
}

/** Result from waiting for state(s) on a business process */
export interface BusinessProcessWaitForStateResult {
    /** The state that was hit. */
    stateHit?: string | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Result from waiting for life cycle(s) on a business process */
export interface BusinessProcessWaitForLifeCycleResult {
    /** The life cycle that was hit. */
    lifeCycleHit?: BusinessProcessLifeCycle | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Detailed representation of a business process */
export interface BusinessProcessDetails extends BusinessProcess {
    /** Details for the business process. */
    details?: BusinessProcessDetailsDataBase | undefined;
}

/** Base class for the details of a business process */
export interface BusinessProcessDetailsDataBase {
}

/** Business process detailed information regarding a batch operation */
export interface BusinessProcessDetailsDataBatchResponse extends BusinessProcessDetailsDataBase {
    /** The DocType on which the operation was performed. */
    docType: string;
    /** The response of the batch operation. */
    response: BatchResponse;
}

/** Response from a batch operation */
export interface BatchResponse {
    /** Rows in the response. */
    rows: BatchResponseRow[];
}

/** Row in a batch operation response */
export interface BatchResponseRow {
    /** Id of the item. */
    id: string;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** Status code of the operation. */
    status: number;
    /** New version of the item. */
    version: number;
    /** If the operation did not succeed, this contains error information. */
    error?: ErrorResponse | undefined;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

/** Business process detailed information regarding Schema / ListItems import operation */
export interface BusinessProcessDetailsDataSchemaImport extends BusinessProcessDetailsDataBase {
    /** Result information of a schema import operation */
    schemaImportResult?: SchemaImportResult | undefined;
    /** Result information of a list item import operation */
    listItemImportResult?: ListItemImportResult | undefined;
}

/** Result information of a schema import operation */
export interface SchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[] | undefined;
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[] | undefined;
}

/** Result information of a list item import operation */
export interface ListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system */
    skippedListItemIds?: string[] | undefined;
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[] | undefined;
}

/** Business process detailed information regarding a CDN purge operation */
export interface BusinessProcessDetailsDataCdnPurge extends BusinessProcessDetailsDataBase {
    /** Serialized CDN configuration. */
    serializedCdnConfiguration: string;
    /** Jobs that were processed in the operation. */
    jobs: CdnPurgeJobBase[];
}

/** Base class for a CDN purge job */
export interface CdnPurgeJobBase {
    /** Indicates if the operation was performed successfully. */
    success: boolean;
    /** Number of retries left until the operation is considered as failed. */
    retriesLeft: number;
}

/** Represents a CDN purge by tag (e.g. share ID) */
export interface CdnPurgeJobByTag extends CdnPurgeJobBase {
    /** The tag that should be purged. */
    tag: string;
}

export interface CdnPurgeJobByUri extends CdnPurgeJobBase {
    uri?: string | undefined;
}

/** Business process detailed information regarding Content import */
export interface BusinessProcessDetailsDataContentImport extends BusinessProcessDetailsDataBase {
    /** Items that were imported. */
    items?: ContentImportResult[] | undefined;
}

/** Represents an item imported during a content import */
export interface ContentImportResult {
    /** ID of the file transfer. */
    fileTransferId: string;
    /** ID of the resulting content. */
    contentId?: string | undefined;
    /** State of the item. */
    state?: string | undefined;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** If the operation did not succeeded, this contains error related information. */
    error?: ErrorResponse | undefined;
}

/** Base class for search results */
export interface BaseResultOfBusinessProcess {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: BusinessProcess[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Search result from a search for business processes */
export interface BusinessProcessSearchResult extends SearchBehaviorBaseResultOfBusinessProcess {
}

export interface QueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;
}

/** Search request to search for business processes */
export interface BusinessProcessSearchRequest {
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

/** The filters' base class */
export interface FilterBase {
}

/** Used to put filters in "and" */
export interface AndFilter extends FilterBase {
    /** The filters to put in "and". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Put filters in "or" */
export interface OrFilter extends FilterBase {
    /** The filters to put in "or". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Negates the specified filter */
export interface NotFilter extends FilterBase {
    /** The filter to be negated. */
    filter: FilterBase;
}

/** Filters over a range of date time values */
export interface DateRangeFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The date time range. */
    range: DateRange;
}

/** The date time range class used in filters */
export interface DateRange {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** Filters over the existence of a field's value */
export interface ExistsFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
}

/** Filters geo point values based on a bounding box */
export interface GeoBoundingBoxFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The top left corner of the bounding box's geo location (latitude and longitude). */
    topLeft: GeoLocation;
    /** The bottom right corner of the bounding box's geo location (latitude and longitude). */
    bottomRight: GeoLocation;
}

/** It stores geo location information (latitude and longitude) */
export interface GeoLocation {
    /** The latitude */
    lat?: number;
    /** The longitude */
    lon?: number;
}

/** Filters within the radius of the distance from a location */
export interface GeoDistanceFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: GeoLocation;
    /** The distance in meters from the point of origin. */
    distance?: number;
}

/** Filters on nested documents */
export interface NestedFilter extends FilterBase {
    /** The path pointing to the nested document (i.e. personLayer.nestedAddress). */
    path: string;
    /** The filter to be applied on the nested documents. */
    filter: FilterBase;
}

/** Filters over a range of numeric values */
export interface NumericRangeFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The numeric range on which filtering. */
    range: NumericRange;
}

/** The numeric range class */
export interface NumericRange {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** Filters field's values based on a prefix */
export interface PrefixFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to be used as prefix. */
    prefix: string;
}

/** Filters values exactly containing a term */
export interface TermFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to use to filter on. */
    term: string;
}

/** Filters values containing at least one of the terms */
export interface TermsFilter extends FilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The list of values to be filtered on. At least one must match to return results. */
    terms: string[];
}

/** Filters aggregations */
export interface AggregationFilter extends FilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The filter to be applied. */
    filter?: FilterBase | undefined;
    /** Autogenerated Guid at request time, for precise aggregation result mapping. */
    temporaryAggregatorRequestId?: string | undefined;
}

/** Filters on child documents */
export interface ChildFilter extends FilterBase {
    /** The type of the child document. */
    childType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

/** Filters on parent documents */
export interface ParentFilter extends FilterBase {
    /** The type of the parent document. */
    parentType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

/** Search behaviors */
export enum SearchBehavior {
    DropInvalidCharactersOnFailure = <any>"DropInvalidCharactersOnFailure",
    WildcardOnSingleTerm = <any>"WildcardOnSingleTerm",
    SimplifiedSearch = <any>"SimplifiedSearch",
    WildcardOnEveryTerm = <any>"WildcardOnEveryTerm",
    SimplifiedSearchOr = <any>"SimplifiedSearchOr",
}

/** Represents the business rule configuration. */
export interface BusinessRuleConfiguration {
    /** Disables the rule completely. */
    disableRuleEngine: boolean;
    /** Rules */
    rules?: BusinessRule[] | undefined;
    /** Named caches. */
    caches?: NamedCacheConfigurationBase[] | undefined;
}

/** A business rule */
export interface BusinessRule {
    /** User defined ID of the rule. */
    id?: string | undefined;
    /** Trigger point. */
    triggerPoint?: BusinessRuleTriggerPoint | undefined;
    /** Enable. */
    isEnabled: boolean;
    /** Language specific rule names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific rule description. */
    description?: TranslatedStringDictionary | undefined;
    /** Enable trace logs for this rule. */
    enableTracing: boolean;
}

/** Represents a trigger point for a business rule */
export interface BusinessRuleTriggerPoint {
    /** Execution scope. */
    executionScope: BusinessRuleExecutionScope;
    /** Document type. */
    documentType: BusinessRuleTriggerDocType;
    /** Action performed. */
    action: BusinessRuleTriggerAction;
}

/** A business rule configurable by specific actions and conditions */
export interface BusinessRuleConfigurable extends BusinessRule {
    /** The condition that makes this rule trigger. */
    condition?: BusinessRuleCondition | undefined;
    /** Optional transformations to apply. */
    transformationGroups?: BusinessRuleTransformationGroup[] | undefined;
    /** The actions that are performed when this rule triggers. */
    actions?: BusinessRuleAction[] | undefined;
}

/** Conditions on which a business rule is executed */
export interface BusinessRuleCondition {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
}

/** Links multiple conditions with a boolean operator */
export interface BooleanCondition extends BusinessRuleCondition {
    /** The conditions. */
    conditions?: BusinessRuleCondition[] | undefined;
}

/** Links conditions with AND */
export interface AndCondition extends BooleanCondition {
}

/** Links conditions with OR */
export interface OrCondition extends BooleanCondition {
}

/** Matches when a layer was assigned */
export interface LayerAssignedCondition extends BusinessRuleCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;
}

/** Matches when a layer was unassigned */
export interface LayerUnassignedCondition extends BusinessRuleCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;
}

/** Matches when a permission set was assigned */
export interface ContentPermissionSetAssignedCondition extends BusinessRuleCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;
}

/** Matches when a permission set was unassigned */
export interface ContentPermissionSetUnassignedCondition extends BusinessRuleCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;
}

/** Matches when a field matching the field path string (JSON path) changes to the expected value. */
export interface FieldValueChangedCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Expected value for the field to have to satisfy the condition */
    expectedValue?: any | undefined;
}

/** Matches when a field matching the field path string (JSON Path) changes and matches the given regular expression. */
export interface MatchRegexCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Regular expression */
    regex?: string | undefined;
    /** Optional variable name to store the matched regex groups in */
    storeIn?: string | undefined;
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is newly assigned. */
export interface TagboxItemAssignedCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was assigned in the tagbox */
    refId?: string | undefined;
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is removed. */
export interface TagboxItemUnassignedCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was unassigned from the tagbox */
    refId?: string | undefined;
}

/** Matches when the content schema of a metadata item equals the one set in the condition. */
export interface ContentSchemaCondition extends BusinessRuleCondition {
    /** Content schema id to match on. */
    schemaId?: string | undefined;
}

export interface NumberCompareCondition extends BusinessRuleCondition {
    /** JSON path to the field. */
    fieldPath?: string | undefined;
    /** Mode to use for comparison. */
    mode?: BusinessRuleNumberCompareConditionMode;
    /** Value to compare to. */
    value?: number;
}

export enum BusinessRuleNumberCompareConditionMode {
    LessThan = <any>"LessThan",
    LessThanEqual = <any>"LessThanEqual",
    Equal = <any>"Equal",
    GreaterThanEqual = <any>"GreaterThanEqual",
    GreaterThan = <any>"GreaterThan",
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is newly assigned. */
export interface ContentRelationItemAssignedCondition extends BusinessRuleCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is removed. */
export interface ContentRelationItemUnassignedCondition extends BusinessRuleCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when the geo point from the field specified by the field path is inside the specified polygon. */
export interface GeoPointWithinPolygonCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** List of points that form the polygon for the geo fence.
Must include at least 3 points. */
    polygon?: LatLon[] | undefined;
}

/** Stores a coordinate */
export interface LatLon {
    /** Latitude */
    lat: number;
    /** Longitude */
    lon: number;
}

/** Matches whenever the assigned content permission sets changed. */
export interface ContentPermissionSetsChangedCondition extends BusinessRuleCondition {
}

/** Matches whenever the assigned content(s) in a relationship field changed. */
export interface ContentRelationItemsChangedCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches whenever the assigned layers of a content changed. */
export interface LayersChangedCondition extends BusinessRuleCondition {
}

/** Matches whenever the assigned item(s) in a tagbox changed. */
export interface TagboxItemsChangedCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when a field matching the field path string (JSON path) is empty. */
export interface FieldEmptyCondition extends BusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when the inner condition is not matching. */
export interface NotCondition extends BusinessRuleCondition {
    /** Inner condition. */
    condition?: BusinessRuleCondition | undefined;
}

/** Business rule transformation group: A group of transformations to run for the specified inputs */
export interface BusinessRuleTransformationGroup {
    /** The inputs of the transformation group. */
    inputs?: string[] | undefined;
    /** A list of transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;
    /** Variable name where the final result should be stored in. */
    storeIn?: string | undefined;
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
}

/** Business rule transformation */
export interface BusinessRuleTransformation {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
}

/** Takes an item from a dictionary by its key. */
export interface TakeDictionaryValueTransformation extends BusinessRuleTransformation {
    /** Key of the item. */
    key?: string | undefined;
}

/** Takes an item from an array by its index. */
export interface TakeArrayValueTransformation extends BusinessRuleTransformation {
    /** Index of the item. */
    index?: string | undefined;
}

/** Joins the input by a configurable separator */
export interface JoinByTransformation extends BusinessRuleTransformation {
    /** Separator to use. */
    separator?: string | undefined;
}

/** Uses a named cache to lookup a value. */
export interface LookupCacheTransformation extends BusinessRuleTransformation {
    /** Name of the cache to use. */
    namedCache?: string | undefined;
}

/** Produces N-grams based on splitting a text on whitespace characters. Removes punctuation as well. */
export interface NGramTransformation extends BusinessRuleTransformation {
    /** Maximum size of n-grams to produce.
Settings this to 3 will produce unigrams, bigrams, trigrams. */
    size?: number;
    /** Minimum length of a word to be considered. */
    minWordLength?: number;
    /** Maximum length of a word to be considered. */
    maxWordLength?: number | undefined;
}

/** Transforms a list by applying a set of transformation for each item in the list. */
export interface ProjectionTransformation extends BusinessRuleTransformation {
    /** Transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;
}

/** Action to be performed by a business rule */
export interface BusinessRuleAction {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
}

/** Assigns a layer, adding the default values to the data dictionary */
export interface AssignLayerAction extends BusinessRuleAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
    /** An object containing default values (used for example to populate required fields). */
    defaultValues?: any | undefined;
}

/** Removes a layer */
export interface UnassignLayerAction extends BusinessRuleAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
}

/** Assign a value to all fields matching the FieldPath (JSON path). */
export interface AssignValueAction extends BusinessRuleAction {
    /** Path to the object the value should be inserted in. */
    path?: string | undefined;
    /** ID of the field, the value should be inserted in. */
    fieldId?: string | undefined;
    /** Value to assign. */
    value?: any | undefined;
    /** Indicates whether existing values should be replaced.
Note: for multi fieldsets and relations, this setting controls, if the value is added
to the already existing values or if the existing values shall be overwritten. */
    replace?: boolean;
}

/** Assigns one or multiple tag box items to the multi tagbox identified by the path (JSON path). */
export interface AssignTagboxItemsAction extends BusinessRuleAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates whether all the already assigned tags get replaced by the set specified in the action.
If false, the not already assigned tags get added, the rest is left as is. */
    replace?: boolean;
}

/** Removes one or multiple tag box items from the multi tagbox identified by the path (JSON path). */
export interface UnassignTagboxItemsAction extends BusinessRuleAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be removed. */
    refIds?: any | undefined;
}

/** Assigns one or more permission sets to a content. */
export interface AssignContentPermissionSetsAction extends BusinessRuleAction {
    /** IDs of the permission sets to assign. */
    permissionSetIds?: any | undefined;
    /** Indicates whether the already assigned permissions should be replaced or merged. */
    replace?: boolean;
}

/** Removes one or more permission sets from a content. */
export interface UnassignContentPermissionSetsAction extends BusinessRuleAction {
    /** IDs of the permission sets to unassign. */
    permissionSetIds?: any | undefined;
}

export interface ProduceMessageAction extends BusinessRuleAction {
}

/** Assigns a set of list item ids to all multi tag boxes in a layer where the filter defined on the tagbox does allow assignment of the ID. */
export interface AssignTagboxItemsInLayerAction extends BusinessRuleAction {
    /** Named cache to use for lookup, should be of type SchemaTagboxFilterLookupNamedCacheConfiguration */
    namedCache?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates where the assignment should be additive to the already assigned tags
or if existing tags should be replaced. */
    replace?: boolean;
}

/** Enqueue content for tagging */
export interface EnqueueTaggingAction extends BusinessRuleAction {
    /** Options to use while tagging. */
    options?: TaggingOptionsBase | undefined;
}

/** Options for tagging */
export interface TaggingOptionsBase {
    /** Override for the output format ID to tag. */
    tagOutputFormatId?: string | undefined;
    /** Override for the cache to use. */
    keywordLookupCacheName?: string | undefined;
    /** Override for the layer to assign. */
    taggingLayerId?: string | undefined;
    /** Override for the field id where found tags are stored. */
    foundTagsFieldId?: string | undefined;
    /** Override for the field id where not found tags are stored. */
    missingKeywordsFieldId?: string | undefined;
}

/** Options for clarifai tagging */
export interface ClarifaiTaggingOptions extends TaggingOptionsBase {
    /** Override for the model to use */
    model?: string | undefined;
    /** Override for the language to use */
    language?: string | undefined;
    /** Minimum value a concept must have to be considered */
    minimumValue?: string | undefined;
}

export interface SimulatedTaggingOptions extends TaggingOptionsBase {
    /** Number of keywords to assign. */
    numberOfKeywords?: string | undefined;
}

/** A business rule expressed as a script */
export interface BusinessRuleScript extends BusinessRule {
    /** Script */
    script?: string | undefined;
}

/** Named cache configuration */
export interface NamedCacheConfigurationBase {
    /** Name of named cache. */
    name?: string | undefined;
    /** Indicates if the lookup should be cache sensitive. */
    caseSensitive: boolean;
}

/** List item named cache */
export interface ListItemNamedCacheConfiguration extends NamedCacheConfigurationBase {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** List of IDs of fields to use as a composite key */
    keyFields?: string[] | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;
}

/** Creates a cache for all multi tag boxes in a schema Lookup key is then in the format [ fieldId, refId ], returns the refId if matched by the filter */
export interface SchemaTagboxFilterLookupNamedCacheConfiguration extends NamedCacheConfigurationBase {
    /** The layer id. */
    schemaId?: string | undefined;
}

export interface InverseListItemNamedCacheConfiguration extends NamedCacheConfigurationBase {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** ID of the field that yields the value */
    valueField?: string | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;
}

/** Update request for changing business rule configuration */
export interface BusinessRuleConfigurationUpdateRequest {
    /** Disables the rule engine completely. */
    disableRuleEngine: boolean;
    /** Rules. */
    rules?: BusinessRule[] | undefined;
    /** Named caches. */
    caches?: NamedCacheConfigurationBase[] | undefined;
}

/** Base class for search results */
export interface BaseResultOfBusinessRuleTraceLog {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: BusinessRuleTraceLog[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfBusinessRuleTraceLog extends BaseResultOfBusinessRuleTraceLog {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog extends SearchBehaviorBaseResultOfBusinessRuleTraceLog {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Holds results of trace log search. */
export interface BusinessRuleTraceLogSearchResult extends SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog {
}

/** Result of an aggregation */
export interface AggregationResult {
    /** Name of the aggregation. */
    name: string;
    /** When there are lots of unique terms, Elastic Search only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response. */
    sumOtherDocCount?: number | undefined;
    /** Items returned for the aggregation. Each item consists of a bucket with the matched value and the number of matches.
Optionally inner aggregations for further drill down can be available. */
    aggregationResultItems?: AggregationResultItem[] | undefined;
}

/** Aggregation result item */
export interface AggregationResultItem {
    /** Value matched. */
    name: string;
    /** Number of items matched. */
    count: number;
    /** Ready to use filter to filter the data based on the aggregation result values.
It can be passed as one of the aggregation filters of an aggregation query: it returns documents meeting the aggregation condition. */
    filter?: AggregationFilter | undefined;
    /** True if the current result item matches on of the aggregation filters sent in the query. */
    active: boolean;
    /** Inner aggregation results, if inner aggregations were provided in the query. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Contains a trace for a single document affected by potentially multiple business rules being evaluated and executed. */
export interface BusinessRuleTraceLog {
    /** ID of the trace. */
    id?: string | undefined;
    /** ID of the document. */
    documentId?: string | undefined;
    /** Type of the document. */
    documentType: BusinessRuleTriggerDocType;
    /** IDs of rules that were traced for this document. */
    ruleIds?: string[] | undefined;
    /** Detailed information about rules traced. */
    rules?: BusinessRuleTracedRule[] | undefined;
    /** Validation errors occuring after all rules have ran. */
    validationErrors?: ErrorResponse[] | undefined;
    /** General errors occuring when saving the document. */
    generalErrors?: ErrorResponse[] | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;
}

/** Traced Business rule */
export interface BusinessRuleTracedRule {
    /** Configuration of the rule as it was running. Enriched with trace ref IDs. */
    configuration?: BusinessRule | undefined;
    /** Evaluations performed for this rule. */
    evaluations?: BusinessRuleTracedEvaluation[] | undefined;
}

/** Evaluation trace of a business rule */
export interface BusinessRuleTracedEvaluation {
    /** Indicates if the rule was found to be executable. */
    conditionSatisfied: boolean;
    /** Detailed evaluation results for each condition. */
    conditions?: BusinessRuleTracedEvaluationCondition[] | undefined;
    /** Detailed results for transformation groups. */
    transformationGroups?: BusinessRuleTracedTransformationGroup[] | undefined;
    /** Detailed steps performed by actions. */
    actions?: BusinessRuleTracedAction[] | undefined;
    /** State of variables after all transformation groups were ran. */
    variables?: { [key: string]: string; } | undefined;
}

/** Detail trace for business rule condition */
export interface BusinessRuleTracedEvaluationCondition {
    /** Trace reference ID of condition. */
    traceRefId?: string | undefined;
    /** Indicates if this condition evaluated to true. */
    satisfied: boolean;
    /** Additional reason why condition evaluated to given result. */
    reason?: string | undefined;
}

/** Trace of transformation group */
export interface BusinessRuleTracedTransformationGroup {
    /** Trace reference ID of transformation group. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input for group */
    input?: string | undefined;
    /** Serialized JSON of output for group */
    output?: string | undefined;
    /** Detailed traces for each step performed by transformations in group. */
    transformations?: BusinessRuleTracedTransformation[] | undefined;
}

/** Trace of single transformation step */
export interface BusinessRuleTracedTransformation {
    /** Trace reference ID of transformation. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input of transformation */
    input?: string | undefined;
    /** Serialized JSON of output of transformation */
    output?: string | undefined;
}

/** Detailed trace for business rule action */
export interface BusinessRuleTracedAction {
    /** Trace reference ID of action */
    traceRefId?: string | undefined;
    /** Indicates if the action modified the document */
    documentModified: boolean;
    /** Additional information provided by the trace */
    text?: string | undefined;
}

/** Audit information */
export interface UserAudit {
    /** The date on which the document was created. */
    creationDate: Date;
    /** The last date on which the document was modified. */
    modificationDate: Date;
    /** ID of the user who created the document. */
    createdByUser?: string | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: string | undefined;
}

export interface BusinessRuleTraceLogSearchRequest {
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
}

/** It is the base class for all aggregators. */
export interface AggregatorBase {
    /** The slug name of the aggregation. It must be unique per aggregation request. */
    name: string;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional filter to limit the data set the aggregation is operation on. */
    filter?: FilterBase | undefined;
}

/** A multi-bucket range aggregator dedicated for date values. */
export interface DateRangeAggregator extends AggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** A list of date time ranges. */
    ranges: DateRangeForAggregator[];
}

/** The date range class used in aggregators. */
export interface DateRangeForAggregator {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A multi-bucket range aggregator that works on geo_point fields */
export interface GeoDistanceAggregator extends AggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: GeoLocation;
    /** A list of distance ranges. */
    ranges: GeoDistance[];
}

/** Stores geo distance information for gei distance aggregation */
export interface GeoDistance {
    /** Language specific geo distance names. */
    names?: TranslatedStringDictionary | undefined;
    /** The distance in meters. */
    distance: number;
}

/** A special single bucket aggregation that enables aggregating on nested documents */
export interface NestedAggregator extends AggregatorBase {
    /** The path pointing to the nested object. */
    path: string;
}

/** A multi-bucket range aggregator. */
export interface NumericRangeAggregator extends AggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges on which aggregate. */
    ranges: NumericRangeForAggregator[];
}

/** The numeric range for aggregator class */
export interface NumericRangeForAggregator {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** A multi-bucket value aggregator */
export interface TermsAggregator extends AggregatorBase {
    /** The field's ID to execute the aggregation on. Only not analyzed fields are supported. */
    field: string;
    /** It defines how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
    /** Limits the possible returned aggregation values by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used. */
    searchFields?: string[] | undefined;
}

/** A multi-bucket value aggregator used for aggregations on relation item ids. */
export interface TermsRelationAggregator extends TermsAggregator {
    /** Type of the item target of the relation. It is used to resolve the target ID. */
    documentType?: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content",
    ListItem = <any>"ListItem",
    Schema = <any>"Schema",
    User = <any>"User",
    ContentPermissionSet = <any>"ContentPermissionSet",
    Owner = <any>"Owner",
    UserRole = <any>"UserRole",
}

/** A multi-bucket value aggregator used for aggregations on indexed enum values. */
export interface TermsEnumAggregator extends TermsAggregator {
    /** Type of the enum target of the relation. It is used to resolve the enum translation. */
    enumType: string;
}

/** Sorting information */
export interface SortInfo {
    /** The field's ID to sort on. */
    field?: string | undefined;
    /** The sort direction (ascending/descending). */
    direction: SortDirection;
}

/** The sort direction */
export enum SortDirection {
    Asc = <any>"Asc",
    Desc = <any>"Desc",
}

export interface Channel {
    /** ID of channel. */
    id: string;
    /** Numeric sort order of the channel. Channels are returned ordered by this field. */
    sortOrder: number;
    /** The search index ID where the channel requests the content from. Only RootContentSearchIndex is supported. */
    searchIndexId: string;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names: TranslatedStringDictionary;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort: SortInfo[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns: TranslatedStringDictionary;
    /** Audit information. */
    audit: UserAudit;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export interface ChannelCreateRequest {
    id?: string | undefined;
    sort?: SortInfo[] | undefined;
    sortOrder: number;
    names: TranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export interface ChannelUpdateRequest {
    sort?: SortInfo[] | undefined;
    sortOrder: number;
    names: TranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

/** Base class for detail of permission sets */
export interface PermissionSetDetailOfContentRight {
    /** The permission set ID. */
    id: string;
    /** Language specific permission set names. */
    names: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on content documents or list items. */
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on content documents or list items. */
    exclusive: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId: string;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

/** Detail of a content permission set */
export interface ContentPermissionSetDetail extends PermissionSetDetailOfContentRight {
}

/** Rights assigned to a user role. */
export interface PermissionUserRoleRightsOfContentRight {
    /** The user role ID. */
    userRoleId?: string | undefined;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: ContentRight[] | undefined;
}

/** Rights assigned to a user role. */
export interface PermissionUserRoleRightsOfPermissionSetRight {
    /** The user role ID. */
    userRoleId?: string | undefined;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: PermissionSetRight[] | undefined;
}

/** Permission set rights */
export enum PermissionSetRight {
    Apply = <any>"Apply",
    Manage = <any>"Manage",
}

/** Audit information */
export interface UserAuditDetail {
    /** The date on which the document was created. */
    creationDate: Date;
    /** The last date on which the document was modified. */
    modificationDate: Date;
    /** ID of the user who created the document. */
    createdByUser?: User | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: User | undefined;
}

export interface User {
    /** User's Picturepark ID. */
    id?: string | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Marks a user that was deleted from the system. */
    isDeleted: boolean;
}

export interface PermissionSetCreateRequestOfContentRight {
    names: TranslatedStringDictionary;
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    requestId?: string | undefined;
}

export interface ContentPermissionSetCreateRequest extends PermissionSetCreateRequestOfContentRight {
}

export interface UserRoleRightsOfContentRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: ContentRight[] | undefined;
}

export interface UserRoleRightsOfPermissionSetRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: PermissionSetRight[] | undefined;
}

/** Base class for permission set update requests */
export interface PermissionSetUpdateRequestOfContentRight {
    /** Language specific permission set names. */
    names: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on content documents or list items. */
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a content permission set */
export interface ContentPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfContentRight {
}

export interface PermissionSetOwnershipTransferRequest {
    /** The ID of the user to whom the permission set ownership should be transferred to. */
    transferUserId: string;
}

/** Response to a bulk operation */
export interface BulkResponse {
    /** Rows of the bulk response. */
    rows?: BulkResponseRow[] | undefined;
}

/** Row information of a bulk response */
export interface BulkResponseRow {
    /** ID of the document. */
    id: string;
    /** Version of the document. */
    version: number;
    /** Eventual error. */
    error?: string | undefined;
    /** True if item successfully saved. False otherwise. */
    succeeded: boolean;
    /** Returned status code. */
    status: number;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

export interface ContentPermissionSetCreateManyRequest {
    items?: ContentPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple content permission sets */
export interface ContentPermissionSetUpdateManyRequest {
    /** Content permission sets update requests. */
    items?: ContentPermissionSetUpdateRequestItem[] | undefined;
}

/** Base class for permission set update requests */
export interface PermissionSetUpdateRequestItemOfContentRight extends PermissionSetUpdateRequestOfContentRight {
    /** The permission set ID. */
    id: string;
}

/** Request to update a content permission set */
export interface ContentPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfContentRight {
}

export interface PermissionSetDeleteManyRequest {
    permissionSetIds?: string[] | undefined;
}

export interface PermissionSetOwnershipTransferManyRequest {
    items?: PermissionSetOwnershipTransferItem[] | undefined;
}

export interface PermissionSetOwnershipTransferItem extends PermissionSetOwnershipTransferRequest {
    /** The permission set ID. */
    permissionSetId?: string | undefined;
}

export interface PermissionSetUserPermissionRights {
    permissionSetId?: string | undefined;
    permissionSetRights?: PermissionSetRight[] | undefined;
}

/** Base class for search results */
export interface BaseResultOfPermissionSet {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: PermissionSet[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfPermissionSet extends BaseResultOfPermissionSet {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Result of a permission set search operation */
export interface PermissionSetSearchResult extends SearchBehaviorBaseResultOfPermissionSet {
}

/** Permission set */
export interface PermissionSet {
    /** The permission set ID. */
    id: string;
    /** When true this permission set will derogate all other configured permission sets.
Cannot be changed after creation. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names: TranslatedStringDictionary;
}

/** Request to search permission sets */
export interface PermissionSetSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    filter?: FilterBase | undefined;
    /** Filters based on the PermissionSetRight of the user. */
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the result.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
}

/** Content detail */
export interface ContentDetail {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified.
by the ContentSchemaId property. */
    content?: any | undefined;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** The content ID. */
    id: string;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** The Outputs generated from the content. They identifies the rendered files generated by the system.
They are available only for file base contents, and they depends on the output formats configured in the system. */
    outputs?: Output[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** The owner token ID. Defines the content owner. */
    ownerTokenId: string;
    /** The resolved owner. */
    owner?: User | undefined;
    /** Content type. */
    contentType: ContentType;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The actual lifecycle value of the content. Becomes Inactive when the content is deleted. */
    lifeCycle: LifeCycle;
    /** List of content rights the user has on this content */
    contentRights?: ContentRight[] | undefined;
}

/** Output */
export interface Output {
    /** The ID of the output. Can be null for dynamic outputs which are not rendered yet. */
    id?: string | undefined;
    /** The ID of the output format this output represents. */
    outputFormatId: string;
    /** The ID of the content for which this output has been created. */
    contentId: string;
    /** The rendering state of the output file. */
    renderingState: OutputRenderingState;
    /** Detail of the output that are format dependent. */
    detail?: OutputDataBase | undefined;
    /** Date and time of the backup of the output file. */
    backupTimestamp?: Date | undefined;
    /** Number of rendering retry attempts left. */
    attemptsLeft: number;
    /** Version counter incremented every time this output is rendered (or in case of Original when new original is uploaded). */
    fileVersion: number;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering: boolean;
}

export enum OutputRenderingState {
    InProgress = <any>"InProgress",
    Completed = <any>"Completed",
    Failed = <any>"Failed",
    Skipped = <any>"Skipped",
    NoLicense = <any>"NoLicense",
    RerenderRequested = <any>"RerenderRequested",
}

/** Base class for the output detail dependent on the file format. */
export interface OutputDataBase {
    /** The extension of the file. */
    fileExtension?: string | undefined;
    /** The path where the file is stored. */
    filePath?: string | undefined;
    /** The size of the file in bytes. */
    fileSizeInBytes?: number | undefined;
    /** The SHA-1 hash of the file. */
    sha1Hash?: string | undefined;
    /** The original filename of the file. */
    originalFileName?: string | undefined;
}

/** Output information for an image file. */
export interface OutputDataImage extends OutputDataBase {
    /** The width of the image. */
    width?: number;
    /** The height of the image. */
    height?: number;
}

/** Output information for an audio file. */
export interface OutputDataAudio extends OutputDataBase {
    /** Duration of the audio stream in seconds. */
    durationInSeconds?: number | undefined;
}

/** Output information for a video file. */
export interface OutputDataVideo extends OutputDataBase {
    /** Duration of the video in seconds. */
    durationInSeconds?: number;
    /** With of the video. */
    width?: number;
    /** Height of the video. */
    height?: number;
    /** The sprites making up the key frames of the video. */
    sprites?: Sprite[] | undefined;
}

/** The sprite of a video sprite */
export interface Sprite {
    /** The width of the sprite. */
    width: number;
    /** The height of the sprite. */
    height: number;
    /** Y coordinate of the sprite in the saved file. */
    y: number;
    /** X coordinate of the sprite in the saved file. */
    x: number;
    /** The starting point in time of the sprite in the video. */
    start: string;
    /** The ending point in time of the sprite in the video. */
    end: string;
}

/** Output information for a document file. */
export interface OutputDataDocument extends OutputDataBase {
    /** Number of document's pages. */
    pageCount?: number;
}

/** Output information for a vector file. */
export interface OutputDataVector extends OutputDataBase {
}

/** Default output information */
export interface OutputDataDefault extends OutputDataBase {
}

/** Output detail */
export interface OutputDetail extends Output {
}

export interface DisplayValueDictionary {

    [key: string]: string | any; 
}

/** Lifecycle */
export enum LifeCycle {
    Draft = <any>"Draft",
    Active = <any>"Active",
    Inactive = <any>"Inactive",
    Deleted = <any>"Deleted",
}

export enum ContentResolveBehavior {
    Content = <any>"Content",
    LinkedListItems = <any>"LinkedListItems",
    Metadata = <any>"Metadata",
    Outputs = <any>"Outputs",
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail",
    InnerDisplayValueList = <any>"InnerDisplayValueList",
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail",
    InnerDisplayValueName = <any>"InnerDisplayValueName",
    Owner = <any>"Owner",
    Permissions = <any>"Permissions",
    OuterDisplayValueThumbnail = <any>"OuterDisplayValueThumbnail",
    OuterDisplayValueList = <any>"OuterDisplayValueList",
    OuterDisplayValueDetail = <any>"OuterDisplayValueDetail",
    OuterDisplayValueName = <any>"OuterDisplayValueName",
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = <any>"Small",
    Medium = <any>"Medium",
    Large = <any>"Large",
}

/** Request to create a content */
export interface ContentCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by the ContentSchemaId property. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to update content metadata */
export interface ContentMetadataUpdateRequest {
    /** An optional list of IDs of the schemas that should be updated/replaced based on the options below and Metadata provided.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by
the ContentSchemaId property. Updating the Content property is only possible for virtual items (contents
whose ContentType is Virtual).
Update of content data will be done only if this attribute has any data, i.e. if it's not null or empty. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property.
If there are no data for a specified LayerSchemaId, it is treated as empty. */
    metadata?: { [key: string]: any; } | undefined;
    /** Options to modify the behavior for updating the layers.
Merge: the content is updated so that the assigned layers to the content will be a merge of the ones specified in the LayerSchemaIds property
and the ones already existing; existing assigned layers not specified in the property are kept and missing layers are assigned.
Replace: the content is updated so that only the layers specified in the LayerSchemaIds property are assigned to the content;
existing assigned layers not specified in the property are removed and missing layers are assigned.
Defaults to Merge. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Obsolete attribute, please use LayerFieldsUpdateOption and ContentFieldsUpdateOption for finer control over metadata and/or content update. */
    schemaFieldsUpdateOptions?: UpdateOption | undefined;
    /** Options to modify the behavior for updating the values of schemas.
Merge: the values specified in the Metadata dictionary are merged to the existing values of the corresponding schema on the content.
Replace: the values specified in the Metadata dictionary entirely replace any existing value of the corresponding schema on the content.
Defaults to Merge. */
    layerFieldsUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace the content.
Defaults to Merge. */
    contentFieldsUpdateOptions: UpdateOption;
}

/** Controls the update of metadata */
export enum UpdateOption {
    Merge = <any>"Merge",
    Replace = <any>"Replace",
}

/** Request to update the permissions of a content */
export interface ContentPermissionsUpdateRequest {
    /** A list of content permission set IDs which control content permissions that will be updated on the content.
These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Request to transfer the content ownership */
export interface ContentOwnershipTransferRequest {
    /** The ID of the user to whom the content ownership has to be transferred to. */
    transferUserId: string;
}

/** Request to update a content file */
export interface ContentFileUpdateRequest {
    /** ID of the file transfer to use to replace the content file. */
    fileTransferId: string;
}

/** Result to a get content references operation */
export interface ContentReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;
    /** List of share references */
    shareReferences?: ContentShareReferenceResult | undefined;
}

/** Base class for search results */
export interface BaseResultOfMetadataReference {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: MetadataReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Result for getting references. */
export interface MetadataReferenceResult extends BaseResultOfMetadataReference {
    /** Indicates if any reference is originating from an item that the current user does not have access to. */
    isReferencedByRestrictedItem?: boolean | undefined;
}

/** Reference to a metadata item */
export interface MetadataReference {
    /** Target ID of reference. */
    targetMetadataItemId: string;
    /** Indicates if the source of the reference is restricted because of permissions.
If this is true and the SourceMetadataItemId property is filled, the user does not have the
edit permission on the source metadata item. If the SourceMetadataItemId is null, the user also
does not have the view permission on that item. */
    isRestricted: boolean;
    /** ID of the source of the reference. */
    sourceMetadataItemId?: string | undefined;
    /** DocType of the source of the reference. */
    sourceDocType?: string | undefined;
}

/** Base class for search results */
export interface BaseResultOfContentShareReference {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ContentShareReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Result class for share reference search */
export interface ContentShareReferenceResult extends BaseResultOfContentShareReference {
}

/** Share information for a share referencing a content */
export interface ContentShareReference {
    /** ID of the share. */
    id?: string | undefined;
    /** Name of the share. */
    name?: string | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** Type of the share. */
    shareType: ShareType;
    /** The email address of the user who created the share. */
    emailAddress?: string | undefined;
}

export enum ShareType {
    Basic = <any>"Basic",
    Embed = <any>"Embed",
}

/** Request to get the references to a content */
export interface ContentReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;
}

/** Request to page data */
export interface PagingRequest {
    /** Limits the number of the returned schemas. Defaults to 0. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
}

/** Request to get paginated metadata references */
export interface MetadataReferencesPagingRequest extends PagingRequest {
    /** Set to true to check if any incoming references are originating from an item the current user does not have full access to. */
    fetchReferencedByRestrictedItem?: boolean;
}

/** Download link information */
export interface DownloadLink {
    /** Token of the download, used to generate the url. */
    downloadToken: string;
    /** Url of the download link. */
    downloadUrl: string;
}

/** Request to create a content download link */
export interface ContentDownloadLinkCreateRequest {
    /** List of content information to generate the download link */
    contents: ContentDownloadRequestItem[];
}

/** Information needed to generate a content download link */
export interface ContentDownloadRequestItem {
    /** ID of the content that is going to be downloaded. */
    contentId: string;
    /** ID of the output format that is going to be downloaded. */
    outputFormatId: string;
}

/** Request to create multiple contents */
export interface ContentCreateManyRequest {
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be created. */
    items: ContentCreateRequest[];
}

/** Request to update many contents metadata */
export interface ContentMetadataUpdateManyRequest {
    /** Allows storing references to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Update items */
    items: ContentMetadataUpdateItem[];
}

/** Item to update content metadata */
export interface ContentMetadataUpdateItem extends ContentMetadataUpdateRequest {
    /** The ID of the content. */
    id: string;
}

/** Request to update multiple contents permissions */
export interface ContentPermissionsUpdateManyRequest {
    /** Content permissions update items */
    items: ContentPermissionsUpdateItem[];
}

/** Content permissions update item */
export interface ContentPermissionsUpdateItem extends ContentPermissionsUpdateRequest {
    /** ID of the content. */
    contentId: string;
}

/** Request to transfer multiple contents ownerships */
export interface ContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer items. */
    items: ContentOwnershipTransferItem[];
}

/** Content ownership transfer item */
export interface ContentOwnershipTransferItem extends ContentOwnershipTransferRequest {
    /** The content ID. */
    contentId: string;
}

/** Request to delete multiple contents. */
export interface ContentDeleteManyRequest {
    /** IDs of the contents to delete. */
    contentIds: string[];
    /** A value indicating whether references to the contents should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple contents based on a provided filter */
export interface ContentDeleteManyFilterRequest {
    /** Filters the contents that need to be deleted. */
    filterRequest: ContentFilterRequest;
    /** A value indicating whether references to the content items should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

export interface ContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
}

export enum ContentSearchType {
    Metadata = <any>"Metadata",
    FullText = <any>"FullText",
    MetadataAndFullText = <any>"MetadataAndFullText",
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly",
    All = <any>"All",
    InactiveOnly = <any>"InactiveOnly",
    ActiveInactiveOnly = <any>"ActiveInactiveOnly",
}

/** Filter items with broken or not broken dependencies */
export enum BrokenDependenciesFilter {
    All = <any>"All",
    NotBrokenOnly = <any>"NotBrokenOnly",
    BrokenOnly = <any>"BrokenOnly",
}

/** Request to restore multiple contents */
export interface ContentRestoreManyRequest {
    /** IDs of the contents to restore. */
    contentIds: string[];
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to get multiple contents' references */
export interface ContentManyReferencesRequest {
    /** The IDs of the contents whose references need to be retrieved. */
    contentIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;
}

/** Base class for the content metadata batch requests. */
export interface MetadataValuesChangeRequestBase {
    /** Changes that need to be applied to the existing content metadata. The same set of changes is applied to all contents. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating contents with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update contents' fields based on content IDs */
export interface ContentFieldsBatchUpdateRequest extends MetadataValuesChangeRequestBase {
    /** The IDs of the contents whose fields need to be updated. */
    contentIds: string[];
}

/** The base class for metadata value change commands. */
export interface MetadataValuesChangeCommandBase {
    /** The ID of the schema to which the operation scope is addressed. */
    schemaId: string;
}

/** Updates schema values */
export interface MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase {
    /** An object containing the metadata values to add / update. */
    value: any;
}

/** Adds or updates schema values */
export interface MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase {
    /** An object containing the metadata values to add / update. */
    value: any;
}

/** Removes schema and all its values */
export interface MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase {
}

/** Replaces schema values */
export interface MetadataValuesSchemaReplaceCommand extends MetadataValuesChangeCommandBase {
    /** An object containing the metadata values for the schema. The existing dictionary will be entirely overwritten. */
    value: any;
}

/** Removes a field and its value from the values of the specified schema */
export interface MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field to be removed within the specified schema (i.e. remove the street from the address of a person: fieldPath = "address.streetName", schemaId = "PersonLayer") */
    fieldPath: string;
}

/** Adds a list item to a FieldMultiTagbox field */
export interface MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace */
    fieldNamespace: string;
    /** The ID of the list item to be added. */
    referenceId: string;
}

/** Removes a list item from a FieldMultiTagbox field */
export interface MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace. */
    fieldNamespace: string;
    /** The ID of the list item to be removed. */
    referenceId: string;
}

/** Request to batch update contents' fields based on a filter */
export interface ContentFieldsBatchUpdateFilterRequest extends MetadataValuesChangeRequestBase {
    /** Filters the contents on which the change commands must be applied. */
    filterRequest: ContentFilterRequest;
}

/** Base class for search results */
export interface BaseResultOfContent {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Content[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfContent extends BaseResultOfContent {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorWithAggregationBaseResultOfContent extends SearchBehaviorBaseResultOfContent {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Result for content search operation */
export interface ContentSearchResult extends SearchBehaviorWithAggregationBaseResultOfContent {
    /** Result of rights aggregation count requested in rightsAggregations in the ContentSearchRequest. */
    rightsAggregationsCounts?: ContentRightAggregationCount[] | undefined;
}

/** Combination of ContentRight and found document count */
export interface ContentRightAggregationCount {
    /** ContentRight. */
    contentRight: ContentRight;
    /** Found document count. */
    count: number;
}

export interface Content {
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId: string;
    /** The content type of this content. All except Virtual are binary files. */
    contentType: ContentType;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues: { [key: string]: string; };
    id: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** Life cycle of content */
    lifeCycle: LifeCycle;
}

/** Request to aggregate contents based on the aggregators defined on a channel */
export interface ContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. Defaults to RootChannel.
For the ContentAggregationOnChannelRequest only, the existing aggregation saved on the channel are retrieved and used to perform the aggregation. */
    channelId?: string | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limit the search to the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** Limits the aggregation to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the aggregation to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType: ContentSearchType;
}

/** Request to search contents */
export interface ContentSearchRequest extends ContentAggregationOnChannelRequest {
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the contents to the ones the user has the specified ContentRights. */
    rightsFilter?: ContentRight[] | undefined;
    /** Returns the aggregated document counts to the ones the user has the specified ContentRights.
Produces the rightsAggregationCounts on the ContentSearchResult. View will be ignored as the totalResults already gives this information. */
    rightsAggregations?: ContentRight[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ContentSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Result for an aggregation operation */
export interface ObjectAggregationResult {
    /** How long did the search and aggregation took. */
    elapsedMilliseconds: number;
    /** Results of the aggregation. */
    aggregationResults: AggregationResult[];
    /** Search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Request to aggregate contents based on the specified aggregators */
export interface ContentAggregationRequest extends ContentAggregationOnChannelRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

export interface DisplayValueStatus {
    /** The schema ids (of type Content or Layer) for which the re-rendering of the display values is needed. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the re-rendering of the display values is needed. */
    listSchemaIds?: string[] | undefined;
    /** The state of the display values compared to the schema structure (UpToDate = ok, Outdated = re-rendering needed). */
    state: DisplayValuesState;
}

export enum DisplayValuesState {
    UpToDate = <any>"UpToDate",
    Outdated = <any>"Outdated",
    RerenderingInProgress = <any>"RerenderingInProgress",
}

export interface DocumentHistory {
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: UserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;
}

export interface UserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;
}

export enum DocumentChangeAction {
    Create = <any>"Create",
    Update = <any>"Update",
    Delete = <any>"Delete",
    Activate = <any>"Activate",
    Deactivate = <any>"Deactivate",
}

export interface DocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    /** Contains an RFC 6902 compatible patch that can be applied on the old document to get the new document.
Use a library like jsondiffpatch.net (https://github.com/wbish/jsondiffpatch.net)
or jsondiffpatch (https://github.com/benjamine/jsondiffpatch) to process this. */
    patch?: any | undefined;
}

/** Base class for search results */
export interface BaseResultOfDocumentHistory {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: DocumentHistory[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export interface DocumentHistorySearchResult extends BaseResultOfDocumentHistory {
}

export interface DocumentHistorySearchRequest {
    /** Limits the start date of the search request. By default no limitation set. */
    from: Date;
    /** Limits the end date of the search request. By default no limitation set. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document ID. E.g. contentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specific document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
}

export interface IdentityProviderEditable {
    /** Mapping of identity provider claims to user attributes */
    claimMapping?: { [key: string]: string; } | undefined;
    /** Name of the identity provider claim that holds group membership information */
    groupClaimType?: string | undefined;
    /** IdP (AD) group to user role ID mapping */
    groupMapping?: IdpGroupToUserRoleMapping[] | undefined;
    /** Optional user role ID that will be assigned to a user is none of the group mappings produce a match */
    fallbackUserRoleId?: string | undefined;
}

/** Represents an identity provider defined in IdentityServer and its Picturepark configuration */
export interface IdentityProvider extends IdentityProviderEditable {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id?: string | undefined;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;
}

export interface IdpGroupToUserRoleMapping {
    /** Name of the group on external identity provider */
    group?: string | undefined;
    /** User role ID as defined in CP */
    userRoleId?: string | undefined;
}

/** Basic information about an identity provider */
export interface IdentityProviderBasicInfo {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id?: string | undefined;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;
}

/** The version view item for the environment. */
export interface VersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The bamboo release version. Only provided on bamboo deployments. */
    release?: string | undefined;
}

/** Customer configuration information */
export interface CustomerInfo {
    /** The customer ID. */
    customerId: string;
    /** The name of the customer instance. */
    name: string;
    /** Alias of the customer instance. */
    customerAlias: string;
    /** The base URL of identity server to authenticate the user using OpenID Connect. */
    identityServerUrl: string;
    /** The base API URL. */
    apiUrl: string;
    /** Information if the query details can be enabled when searching. For debug purposes only. */
    enableQueryDetails: boolean;
    /** Configured languages of customer instance (system, metadata, default). */
    languageConfiguration: LanguageConfiguration;
    /** Languages including translations for the configured system and metadata languages. */
    languages: Language[];
    /** Configured rendering outputs including translations for the customer instance. */
    outputFormats: OutputFormatInfo[];
    /** Boost levels that can be applied to a metadata field to boost the the significance of the field in a search operation. */
    boostValues: number[];
    /** Apps registered for this customer */
    apps?: CustomerApp[] | undefined;
    modificationDate: Date;
    /** Url to access Frontend service */
    baseUrl: string;
    /** Base bath to access logos of customer (including trailing slash), available images: name, full, small, background */
    logosUrl: string;
}

export interface LanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages?: string[] | undefined;
    /** A list of languages serving as metadata languages. */
    metadataLanguages?: string[] | undefined;
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage?: string | undefined;
}

export interface Language {
    /** Language translations. */
    name: TranslatedStringDictionary;
    /** IETF language tag. E.g en, en-US, de. */
    ietf: string;
    /** Two letter ISO language code. E.g. en, de. */
    twoLetterISOLanguageName?: string | undefined;
    /** Three letter ISO language code. E.g. eng, deu. */
    threeLetterISOLanguageName?: string | undefined;
    /** Region code of the language. E.g. US, DE, CH. */
    regionCode?: string | undefined;
}

export interface OutputFormatInfo {
    /** Output ID. */
    id: string;
    /** Output translations. */
    names: TranslatedStringDictionary;
}

export interface CustomerApp {
    appId?: string | undefined;
    name?: TranslatedStringDictionary | undefined;
    description?: TranslatedStringDictionary | undefined;
    icon?: string | undefined;
}

export interface SystemStatus {
    /** The status of the search indices. */
    searchIndicesStatus?: StatusOfSearchIndexState[] | undefined;
    /** The status of the display values. */
    displayValuesStatus?: StatusOfDisplayValuesState[] | undefined;
    /** The status of the contents and list items. */
    metadataStatus?: StatusOfMetadataState[] | undefined;
}

export interface StatusOfSearchIndexState {
    id?: string | undefined;
    state: SearchIndexState;
}

export enum SearchIndexState {
    Green = <any>"Green",
    Yellow = <any>"Yellow",
    Red = <any>"Red",
}

export interface StatusOfDisplayValuesState {
    id?: string | undefined;
    state: DisplayValuesState;
}

export interface StatusOfMetadataState {
    id?: string | undefined;
    state: MetadataState;
}

/** The state of the contents and list items */
export enum MetadataState {
    UpToDate = <any>"UpToDate",
    Outdated = <any>"Outdated",
    UpdateInProgress = <any>"UpdateInProgress",
}

/** List item detail */
export interface ListItemDetail {
    /** The list item ID. */
    id: string;
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content?: any | undefined;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: DisplayValueDictionary | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

export enum ListItemResolveBehavior {
    Content = <any>"Content",
    LinkedListItems = <any>"LinkedListItems",
    InnerDisplayValueThumbnail = <any>"InnerDisplayValueThumbnail",
    InnerDisplayValueList = <any>"InnerDisplayValueList",
    InnerDisplayValueDetail = <any>"InnerDisplayValueDetail",
    InnerDisplayValueName = <any>"InnerDisplayValueName",
    OuterDisplayValueThumbnail = <any>"OuterDisplayValueThumbnail",
    OuterDisplayValueList = <any>"OuterDisplayValueList",
    OuterDisplayValueDetail = <any>"OuterDisplayValueDetail",
    OuterDisplayValueName = <any>"OuterDisplayValueName",
}

/** Request to update an existing list item */
export interface ListItemUpdateRequest {
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema of the list item. */
    content?: any | undefined;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace any existing content.
Defaults to Merge. */
    contentFieldsUpdateOptions: UpdateOption;
}

/** Result from getting references to list items. */
export interface ListItemReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;
}

/** Request to get the references to a list item */
export interface ListItemReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
}

/** Request to create a list item */
export interface ListItemCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema. */
    content?: any | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to create multiple list items */
export interface ListItemCreateManyRequest {
    /** Allows creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be created. */
    items: ListItemCreateRequest[];
}

/** Request to update multiple list items */
export interface ListItemUpdateManyRequest {
    /** Allows updating list items with references to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be updated. */
    items: ListItemUpdateItem[];
}

export interface ListItemUpdateItem extends ListItemUpdateRequest {
    /** The list item id. */
    id: string;
}

/** Request to delete multiple list items */
export interface ListItemDeleteManyRequest {
    /** IDs of the list items to delete. */
    listItemIds: string[];
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple list items based on a provided filter */
export interface ListItemDeleteManyFilterRequest {
    /** Filters the list items that need to be deleted. */
    filterRequest: ListItemFilterRequest;
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to filter list items */
export interface ListItemFilterRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
}

/** Request to restore multiple deleted list items */
export interface ListItemRestoreManyRequest {
    /** The IDs of the list items to restore. */
    listItemIds: string[];
    /** Allows restoring list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to get the references to multiple list items */
export interface ListItemManyReferencesRequest {
    /** The IDs of the list items whose references need to be retrieved. */
    listItemIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
}

/** Request to batch update list items' fields based on list item IDs */
export interface ListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated. */
    listItemIds: string[];
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update list items' fields based on a filter */
export interface ListItemFieldsBatchUpdateFilterRequest {
    /** Filters the list items on which the change commands must be applied. */
    filterRequest: ListItemFilterRequest;
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allow updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Base class for search results */
export interface BaseResultOfListItem {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ListItem[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfListItem extends BaseResultOfListItem {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorWithAggregationBaseResultOfListItem extends SearchBehaviorBaseResultOfListItem {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Result for list item search operation */
export interface ListItemSearchResult extends SearchBehaviorWithAggregationBaseResultOfListItem {
}

export interface ListItem {
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The list item id. */
    id: string;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content data of the list item. */
    content?: any | undefined;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** LifeCycle of list item */
    lifeCycle: LifeCycle;
}

/** Request to aggregate list items */
export interface ListItemSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the aggregation to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** Request to search list items */
export interface ListItemSearchRequest extends ListItemSearchAndAggregationBaseRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ListItemSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of enums that control which parts of the list item are resolved and returned. */
    resolveBehaviors?: ListItemResolveBehavior[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Request to aggregate list items */
export interface ListItemAggregationRequest extends ListItemSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Base class for search results */
export interface BaseResultOfLiveStream {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: LiveStream[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Results of live stream search. */
export interface LiveStreamSearchResult extends BaseResultOfLiveStream {
}

export interface LiveStream {
    id: string;
    document?: string | undefined;
    scopeType?: string | undefined;
    timestamp: Date;
    traceJob?: LiveStreamTraceJob | undefined;
    audit?: UserAudit | undefined;
}

export interface LiveStreamTraceJob {
    traceJobId?: string | undefined;
    ipAddress?: string | undefined;
    userId?: string | undefined;
    apiClientId?: string | undefined;
}

export interface LiveStreamSearchRequest {
    /** Sets the start date and time for results based on Timestamp attribute. */
    from: Date;
    /** Sets the end date and time for results based on Timestamp attribute. */
    to: Date;
    /** Optionally limits the result to only the specified scope type. */
    scopeType?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
}

/** The overall status of the contents and list items in comparison to the actual schemas' structure */
export interface MetadataStatus {
    /** The schema ids (of type Content or Layer) for which the contents are outdated and need to be updated. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the the list items are outdated and need to be updated. */
    listSchemaIds?: string[] | undefined;
    /** The global state of the Contents and ListItems compared to the schema structure (Green = ok, Red = update needed). */
    state: MetadataState;
    /** The field ids that that cannot be used and needs to be cleaned up after updating the outdated contents and list items. */
    fieldIdsToCleanup?: { [key: string]: string[]; } | undefined;
}

/** Used to change the download file name pattern for multiple formats at once. */
export interface OutputFormatDownloadFileNamePatternUpdateManyRequest {
    /** Download file name update requests to be processed. */
    items: OutputFormatDownloadFileNamePatternUpdateRequestItem[];
}

/** Represents a change to the download file name pattern to one output format. */
export interface OutputFormatDownloadFileNamePatternUpdateRequestItem {
    /** ID of the output format to set pattern for. */
    id: string;
    /** The patterns to use per metadata language.
The customer's default language is required. */
    patterns?: TranslatedStringDictionary | undefined;
}

/** Specifies for which content a given format should be rendered */
export interface OutputFormatRenderPreviewRequest {
    /** The content for which the format should be rendered */
    contentId?: string | undefined;
    /** The format which should be rendered. */
    outputFormat?: OutputFormatRenderingSpecification | undefined;
}

/** Used to specify how to render derived outputs */
export interface OutputFormatRenderingSpecification {
    /** Which output format should be used as a source of data. */
    sourceOutputFormats?: SourceOutputFormats | undefined;
    /** Information about the technical format of the data, e.g. JPEG, AAC or video still. */
    format?: FormatBase | undefined;
}

/** Defines the source used for rendering an OutputFormat depending on the type of content */
export interface SourceOutputFormats {
    /** The source to be used for content of type Image */
    image?: string | undefined;
    /** The source to be used for content of type Video */
    video?: string | undefined;
    /** The source to be used for content of type Document */
    document?: string | undefined;
    /** The source to be used for content of type Audio */
    audio?: string | undefined;
    /** The source to be used for content of type Vector */
    vector?: string | undefined;
}

export interface FormatBase {
}

/** Base class for ImageFormats such as JPEG, PNG, TIFF, ... */
export interface ImageFormatBase extends FormatBase {
    /** Color profile to use. Colorspace is derived from the chosen profile. */
    colorProfile?: ColorProfile | undefined;
    /** The method of conversion for color spaces (e.g. CMYK to RGB). Further information can be found here: http://www.colourphil.co.uk/rendering_intents.shtml */
    colorTransformationIntent?: ColorTransformationIntent;
    /** Horizontal resolution in dpi (dots per inch) */
    horizontalResolution?: number | undefined;
    /** Vertical resolution in dpi (dots per inch) */
    verticalResolution?: number | undefined;
    /** Copy clipping paths from input. */
    keepClippingPath?: boolean;
    /** Copy Exif metadata from input. */
    cloneExif?: boolean;
    /** Copy Iptc metadata from input. */
    cloneIptc?: boolean;
    /** Copy AdobeResources from input. */
    cloneAdobeResources?: boolean;
    /** Copy Xmp metadata from input. */
    cloneXmp?: boolean;
    /** Allows resizing of the image. */
    resizeAction?: ResizeAction | undefined;
    /** A collection of actions to be applied during rendering. */
    actions?: ImageActionBase[] | undefined;
}

/** Available color profiles */
export enum ColorProfile {
    AdobeRgb1998 = <any>"AdobeRgb1998",
    AppleRgb = <any>"AppleRgb",
    ColorMatchRgb = <any>"ColorMatchRgb",
    EciRgbV1 = <any>"EciRgbV1",
    EciRgbV2 = <any>"EciRgbV2",
    Srgb = <any>"Srgb",
    SrgbColorSpaceProfile = <any>"SrgbColorSpaceProfile",
    EuropeIsoCoatedFogra27 = <any>"EuropeIsoCoatedFogra27",
    EuroscaleCoated = <any>"EuroscaleCoated",
    EuroscaleUncoated = <any>"EuroscaleUncoated",
    IsoCoated = <any>"IsoCoated",
    IsoCoatedEciV2 = <any>"IsoCoatedEciV2",
    JapanColor2001Coated = <any>"JapanColor2001Coated",
    JapanColor2001Uncoated = <any>"JapanColor2001Uncoated",
    JapanColor2002Newspaper = <any>"JapanColor2002Newspaper",
    JapanWebCoated = <any>"JapanWebCoated",
    UsSheetfedCoated = <any>"UsSheetfedCoated",
    UsSheetfedUncoated = <any>"UsSheetfedUncoated",
    UsWebCoatedSwop = <any>"UsWebCoatedSwop",
    UsWebUncoated = <any>"UsWebUncoated",
    IsoCoatedV2Grey1cBas = <any>"IsoCoatedV2Grey1cBas",
    IsoCoated300EciV2 = <any>"IsoCoated300EciV2",
    CoatedFogra27 = <any>"CoatedFogra27",
    CoatedFogra39 = <any>"CoatedFogra39",
    UncoatedFogra29 = <any>"UncoatedFogra29",
    WebCoatedFogra28 = <any>"WebCoatedFogra28",
    WebCoatedSwop2006Grade3 = <any>"WebCoatedSwop2006Grade3",
    WebCoatedSwop2006Grade5 = <any>"WebCoatedSwop2006Grade5",
    Isonewspaper26v4 = <any>"Isonewspaper26v4",
    Isonewspaper26v4Grey = <any>"Isonewspaper26v4Grey",
}

/** http://www.colourphil.co.uk/rendering_intents.shtml */
export enum ColorTransformationIntent {
    RelativeColorimetricBpc = <any>"RelativeColorimetricBpc",
    AbsoluteColorimetric = <any>"AbsoluteColorimetric",
    Perceptual = <any>"Perceptual",
    RelativeColorimetric = <any>"RelativeColorimetric",
    Saturation = <any>"Saturation",
}

/** Specifies image resize parameters. */
export interface ResizeAction {
    /** Target width for the output. */
    width: number;
    /** Target height for the output. */
    height: number;
    /** Specifies additional resize behaviour. */
    resizeMode: ResizeMode;
}

/** Specifies how the dimensions of a ResizeAction are applied to the content */
export enum ResizeMode {
    Fit = <any>"Fit",
    Shrink = <any>"Shrink",
    Resize = <any>"Resize",
}

export interface ImageActionBase {
}

/** An ImageAction that allows different forms of modifying alpha information in an image. */
export interface AlphaHandlingAction extends ImageActionBase {
    /** Specifies the kind of alpha handling to be applied. */
    alphaHandling?: AlphaHandling;
    /** Specifies potentially needed color information for alpha handling. Must be given in RGB hex format (8 bit per channel). */
    replacementRgbColorHexCode?: string | undefined;
}

/** Specifies the kind of AlphaHandling to be applied to an image */
export enum AlphaHandling {
    DiscardAlpha = <any>"DiscardAlpha",
    ReplaceAlpha = <any>"ReplaceAlpha",
    ReplaceInvertedAlpha = <any>"ReplaceInvertedAlpha",
}

/** An ImageAction that allows cropping an image. */
export interface CropAction extends ImageActionBase {
    /** X-Coordinate of top left point of the cropping rectangle. */
    x?: number;
    /** Y-Coordinate of top left point of the cropping rectangle. */
    y?: number;
    /** Width of the cropping rectangle. */
    width?: number;
    /** Height of the cropping rectangle. */
    height?: number;
}

/** Increases sharpness of an image by using the unsharp mask technique. */
export interface UnsharpenMaskAction extends ImageActionBase {
    /** Unsharp mask amount (the difference between blurred and original image). */
    amount?: number;
    /** Blur radius used to produce unfocused version of the image. */
    radius?: number;
    /** The threshold value for the unsharp mask in range [0, 1] */
    threshold?: number;
}

/** An ImageAction that allows rendering a watermark to an image */
export interface WatermarkAction extends ImageActionBase {
    /** Identifies the image to be used as watermark */
    watermarkFilePath?: string | undefined;
    /** Margin to the left border of the image, in pixels */
    marginLeft?: number | undefined;
    /** Margin to the top of the image, in pixels */
    marginTop?: number | undefined;
    /** Margin to the right border of the image, in pixels */
    marginRight?: number | undefined;
    /** Margin to the bottom of the image, in pixels */
    marginBottom?: number | undefined;
    /** Scales the opacity of the watermark */
    opacity?: number;
    /** Scales the watermark width according to the size of the final image. */
    widthRatio?: number;
    /** Scales the watermark height according to the size of the final image. */
    heightRatio?: number;
}

/** Special format that represents the original. */
export interface OriginalFormat extends FormatBase {
    extension?: string | undefined;
}

/** Renders a JPEG image. */
export interface JpegFormat extends ImageFormatBase {
    /** Compression quality. Must be in range [0,100] and defaults to 80. */
    quality?: number;
    /** Whether to use progressive encoding or not. */
    isProgressive?: boolean;
    /** Whether to use chroma subsampling or not. */
    chromaSubsamplingEnabled?: boolean;
    extension?: string | undefined;
}

/** Renders a PNG image. */
export interface PngFormat extends ImageFormatBase {
    /** Whether the image is interlaced or not. */
    interlaced?: boolean;
    extension?: string | undefined;
}

/** Renders a TIFF image */
export interface TiffFormat extends ImageFormatBase {
    /** Specifies whether color channels should be premultiplied with alpha (associated alpha) or not (unassociated alpha). */
    alphaPremultiplied?: boolean;
    /** Specifies the compression type to use. */
    compressionType?: CompressionType;
    /** Preserve (including size affecting changes) unspecified extraChannels. */
    includeUnspecifiedTiffExtraChannels?: boolean;
    extension?: string | undefined;
}

/** Available compression types. */
export enum CompressionType {
    None = <any>"None",
    Lzw = <any>"Lzw",
    Rle = <any>"Rle",
    Zip = <any>"Zip",
}

/** Base class for rendering video. */
export interface VideoFormatBase extends FormatBase {
}

/** Renders H.264 in mp4 container. */
export interface Mp4VideoFormat extends VideoFormatBase {
    /** Allows resizing of the video. */
    resizeAction?: ResizeAction | undefined;
    /** Gets or sets the encoding audio codec. */
    audioCodec?: AudioFormatBase | undefined;
    /** Gets or sets the encoding codec preset. */
    preset?: Preset;
    extension?: string | undefined;
}

/** Base class for rendering audio. */
export interface AudioFormatBase extends FormatBase {
}

/** Video rendering preset, see http://dev.beandog.org/x264_preset_reference.html for more information. */
export enum Preset {
    Ultrafast = <any>"ultrafast",
    Superfast = <any>"superfast",
    Veryfast = <any>"veryfast",
    Faster = <any>"faster",
    Fast = <any>"fast",
    Medium = <any>"medium",
    Slow = <any>"slow",
    Slower = <any>"slower",
}

/** Generates a sprite image of the input video. */
export interface VideoSpriteFormat extends VideoFormatBase {
    /** Specifies the dimensions of a single frame in the sprite. */
    spriteResizeAction?: ResizeAction | undefined;
    /** Limit for the number of frames to generate. */
    maxNumberOfSprites?: number;
    /** JPEG-quality to use for the sprite. */
    quality?: number;
    extension?: string | undefined;
}

export interface VideoStillFormat extends VideoFormatBase {
    extension?: string | undefined;
    /** Specifies the position from which to produce the image. */
    positionInSeconds?: number;
}

/** Specifies Aac encoding for the output and additional settings for the encoder. */
export interface AacAudioFormat extends AudioFormatBase {
    extension?: string | undefined;
    /** Gets or sets the encoding profile. */
    profile?: Profile;
    /** Gets or sets the encoding coder. */
    coder?: Coder;
    /** Gets or sets the bitrate of the encoding in kbps. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding variable bit rate (VBR) - 1 is lowest quality and 5 is highest quality. */
    variableBitRate?: number | undefined;
}

export enum Profile {
    Aac_low = <any>"aac_low",
    Mpeg2_aac_low = <any>"mpeg2_aac_low",
    Aac_ltp = <any>"aac_ltp",
    Aac_main = <any>"aac_main",
}

/** Audio coders */
export enum Coder {
    Twoloop = <any>"twoloop",
    Anmr = <any>"anmr",
    Fast = <any>"fast",
}

/** Generates a waveform image from an Audio source. */
export interface AudioStillFormat extends AudioFormatBase {
    extension?: string | undefined;
}

/** Renders an MP3 audio file. */
export interface Mp3AudioFormat extends AudioFormatBase {
    extension?: string | undefined;
    /** Gets or sets the encoding bitrate. This setting and Quality are mutually exclusive. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding quality. This setting and Bitrate are mutually exclusive.
Values can be set it range of 0 to 9, where a lower value is a higher quality. */
    quality?: number | undefined;
}

/** Base class for rendering documents. */
export interface DocumentFormatBase extends FormatBase {
}

/** Render a document to a raster image */
export interface DocumentStillFormat extends DocumentFormatBase {
    extension?: string | undefined;
    /** Allows resizing of the image. */
    resizeAction?: ResizeAction | undefined;
}

export interface PdfFormat extends DocumentFormatBase {
    /** Specifies compression quality used for ReduceFileSize. */
    jpegQuality?: number;
    /** Whether to linearize the output for fast web viewing. */
    fastWebView?: boolean;
    /** Whether to apply measures to decrease output size or not. */
    reduceFileSize?: boolean;
    extension?: string | undefined;
    /** Whether to extract document full text from this output. */
    extractFullText?: boolean;
}

/** Base class for rendering vector graphics. */
export interface VectorFormatBase extends FormatBase {
}

/** Render a PDF to SVG */
export interface SvgFormat extends VectorFormatBase {
    extension?: string | undefined;
}

/** Render a vector graphic to a raster image */
export interface VectorStillFormat extends VectorFormatBase {
    extension?: string | undefined;
    /** Specifies output dimensions for raster operation */
    resizeAction?: ResizeAction | undefined;
}

/** Represents the editable part of the output format. */
export interface OutputFormatEditable extends OutputFormatRenderingSpecification {
    /** Language specific names. */
    names: TranslatedStringDictionary;
    /** How long should the dynamic outputs created from this format be kept. */
    retentionTime?: string;
    /** Optional patterns (liquid syntax) that produce the filename for item of this output format.
If set, the customer's default language is required. */
    downloadFileNamePatterns?: TranslatedStringDictionary | undefined;
    /** Indicates if outputs derived from original output format should be accessible also for users not having AccessOriginal permission on the content. */
    viewForAll?: boolean;
}

/** Represents an output format. */
export interface OutputFormat extends OutputFormatEditable {
    /** Output format ID. */
    id?: string | undefined;
    /** Marks if this is a system output format. */
    system?: boolean;
    /** A dynamic output format is not rendered automatically, but only on demand. */
    dynamic?: boolean;
    /** Specifies if output format should be taken into account during data extraction. */
    dataExtraction?: boolean;
    /** Temporary outputs will not be backed up. */
    temporary?: boolean;
}

/** Represents an output format. */
export interface OutputFormatDetail extends OutputFormat {
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

/** Used to create multiple new output formats at once. */
export interface OutputFormatCreateManyRequest {
    /** Output format items to be created. */
    items?: OutputFormat[] | undefined;
}

/** Used to modify multiple output formats at once. */
export interface OutputFormatUpdateManyRequest {
    /** Output format items to be modified. */
    items?: OutputFormatUpdateManyRequestItem[] | undefined;
}

/** Represents one item to be modified in a bulk update operation on output formats. */
export interface OutputFormatUpdateManyRequestItem extends OutputFormatEditable {
    /** ID of the output format to modify. */
    id?: string | undefined;
}

/** Used to remove multiple output formats at once. */
export interface OutputFormatDeleteManyRequest {
    /** List of IDs of output formats to remove. */
    ids?: string[] | undefined;
}

/** Base class for search results */
export interface BaseResultOfOutput {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Output[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

export interface OutputSearchResult extends BaseResultOfOutput {
}

export interface OutputSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[] | undefined;
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[] | undefined;
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[] | undefined;
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[] | undefined;
}

export interface OutputResetRetryAttemptsRequest {
    /** List of output IDs you want to filter on. If this field is not empty, the other will be ignored. */
    outputIds?: string[] | undefined;
    /** List of Content IDs you want to filter on. */
    contentIds?: string[] | undefined;
    /** The file extension of the outputs you want to filter on. */
    fileExtensions?: string[] | undefined;
    /** The IDs of the output formats you want to filter on. */
    outputFormatIds?: string[] | undefined;
    /** Should the successful filter results also be reset (and subsequently re-rendered)? */
    includeCompleted: boolean;
}

/** User profile. */
export interface UserProfile {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;
    /** Authorization state. */
    authorizationState: AuthorizationState;
    /** Indicates if the user is locked. */
    isLocked: boolean;
    /** A list of user rights assigned to the user. */
    userRights?: UserRight[] | undefined;
    /** A list of user role IDs assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Indicates if the user has not accepted the latest terms of consent. */
    termsConsentExpired: boolean;
    /** A list of system user roles assigned to the user. */
    systemUserRoles?: SystemUserRole[] | undefined;
    /** Indicates if the user has the developer flag set. */
    isDeveloper: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated: boolean;
}

/** User's address */
export interface UserAddress {
    /** Company address line */
    company?: string | undefined;
    /** Company department. */
    department?: string | undefined;
    /** Street and house number. */
    address?: string | undefined;
    /** Additional address line. */
    alternativeAddress?: string | undefined;
    /** ZIP code. */
    zip?: string | undefined;
    /** City or town. */
    city?: string | undefined;
    /** Phone number. */
    phone?: string | undefined;
    /** Country code. */
    countryCode?: string | undefined;
}

/** System user roles. */
export enum SystemUserRole {
    Administrator = <any>"Administrator",
}

/** Request to update a user profile. */
export interface UserProfileUpdateRequest {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;
}

/** Base class for detail of permission sets */
export interface PermissionSetDetailOfMetadataRight {
    /** The permission set ID. */
    id: string;
    /** Language specific permission set names. */
    names: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on content documents or list items. */
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on content documents or list items. */
    exclusive: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId: string;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

/** Detail of a schema permission set */
export interface SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight {
}

/** Rights assigned to a user role. */
export interface PermissionUserRoleRightsOfMetadataRight {
    /** The user role ID. */
    userRoleId?: string | undefined;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: MetadataRight[] | undefined;
}

export interface PermissionSetCreateRequestOfMetadataRight {
    names: TranslatedStringDictionary;
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
    requestId?: string | undefined;
}

export interface SchemaPermissionSetCreateRequest extends PermissionSetCreateRequestOfMetadataRight {
}

export interface UserRoleRightsOfMetadataRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: MetadataRight[] | undefined;
}

/** Base class for permission set update requests */
export interface PermissionSetUpdateRequestOfMetadataRight {
    /** Language specific permission set names. */
    names: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on content documents or list items. */
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a schema permission set */
export interface SchemaPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfMetadataRight {
}

export interface SchemaPermissionSetCreateManyRequest {
    items?: SchemaPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple schema permissions sets */
export interface SchemaPermissionSetUpdateManyRequest {
    /** Schema permission sets update requests. */
    items?: SchemaPermissionSetUpdateRequestItem[] | undefined;
}

/** Base class for permission set update requests */
export interface PermissionSetUpdateRequestItemOfMetadataRight extends PermissionSetUpdateRequestOfMetadataRight {
    /** The permission set ID. */
    id: string;
}

/** Request to update a schema permission set */
export interface SchemaPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfMetadataRight {
}

/** The details of a schema */
export interface SchemaDetail {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id: string;
    /** System generated schema namespace. It contains the full schema hierarchy up to the root schema (i.e. [RootSchemaId].[ParentSchemaId].[SchemaId]). */
    schemaNamespace: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
    /** The owner token ID. Defines the schema owner. */
    ownerTokenId: string;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** The complete list of all descendant schema IDs. */
    descendantSchemaIds?: string[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** The number of fields generated by the schema in the search index for filtering, searching and sorting. */
    searchFieldCount?: SearchFieldCount | undefined;
}

/** Represent the template whose value will be resolved based on the actual content. */
export interface DisplayPattern {
    /** The template engine used for parsing the display patterns. */
    templateEngine: TemplateEngine;
    /** The display pattern type. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;
}

/** The template engine used for parsing the display patterns */
export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid",
}

/** The field base class */
export interface FieldBase {
    /** The field ID. It can be a slug; it must be unique within the schema hierarchy (ancestors / descendants); it must be begin with lower case. */
    id: string;
    /** The index ID is auto generated by the system. */
    indexId?: string | undefined;
    /** The field namespace is auto generated by the system: it carries the hierarchy information. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Defines if the field can be edited or not. */
    fixed: boolean;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
}

/** The field used to store a boolean */
export interface FieldBoolean extends FieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a date */
export interface FieldDate extends FieldBase {
    /** The date format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a date time */
export interface FieldDateTime extends FieldBase {
    /** The date time format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store multiple date time values */
export interface FieldDateTimeArray extends FieldDateTime {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a decimal value */
export interface FieldDecimal extends FieldBase {
    /** The decimal pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a dictionary of values */
export interface FieldDictionary extends FieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store multiple dictionaries' values */
export interface FieldDictionaryArray extends FieldDictionary {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a geo point */
export interface FieldGeoPoint extends FieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** A field that can be triggered, and store in such occasion the id of the user and the time that triggered it. The last user who triggered it and the last time in which it was triggered can be used for filtering or for simple search (if enabled on the field). Such information are stored in two inner fields: "triggeredBy" and "triggeredOn". In order to be triggered in a Content or ListItem metadata dictionary, the special '"_trigger": true' should be sent in the data of the field itself. */
export interface FieldTrigger extends FieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a long value */
export interface FieldLong extends FieldBase {
    /** The long pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store multiple long values */
export interface FieldLongArray extends FieldLong {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single fieldset */
export interface FieldSingleFieldset extends FieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
}

/** Indexing information for a schema */
export interface SchemaIndexingInfo {
    /** A collection of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[] | undefined;
}

/** Indexing information for a field of a schema */
export interface FieldIndexingInfo {
    /** The field ID. */
    id: string;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
    /** Indexing information of schema's fields related to this field (if existing). */
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;
}

/** The field used to store multiple fieldsets */
export interface FieldMultiFieldset extends FieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single tagbox */
export interface FieldSingleTagbox extends FieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;
}

/** The field used to store multiple tagboxes */
export interface FieldMultiTagbox extends FieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** An optional filter to limit the returned list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;
}

/** The field used to store a string value */
export interface FieldString extends FieldBase {
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template. */
    template?: string | undefined;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** If values are stored in this list, field values are limited to these ones. */
    grantedValues?: string[] | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The analyzer base class */
export interface AnalyzerBase {
}

/** An analyzer using the ElasticSearch's EdgeNGram tokenizer */
export interface EdgeNGramAnalyzer extends AnalyzerBase {
    /** The analyzer type: EdgeNGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: edgengram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using an ElasticSearch's language tokenizer */
export interface LanguageAnalyzer extends AnalyzerBase {
    /** The analyzer type: Language */
    type?: Analyzer;
    /** The suffix for the analyzed field: language. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's NGram tokenizer */
export interface NGramAnalyzer extends AnalyzerBase {
    /** The analyzer type: NGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: ngram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's path hierarchy tokenizer */
export interface PathHierarchyAnalyzer extends AnalyzerBase {
    /** The analyzer type: PathHierarchy */
    type?: Analyzer;
    /** The suffix for the analyzed field: pathhierarchy. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer */
export interface SimpleAnalyzer extends AnalyzerBase {
    /** The analyzer type: Simple */
    type?: Analyzer;
    /** The suffix for the analyzed field: simple. */
    fieldSuffix?: string | undefined;
}

/** The field used to store multiple string values */
export interface FieldStringArray extends FieldString {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a translated string values */
export interface FieldTranslatedString extends FieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's lenght. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory. */
    requiredMetadataLanguages?: string[] | undefined;
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template.
             */
    template?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a single relation */
export interface FieldSingleRelation extends FieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Defines the allowed elation types. */
    relationTypes: RelationType[];
}

/** Defines a relation */
export interface RelationType {
    /** The ID of the relation type. */
    id: string;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the type of the document target of the relation. Currently supported: Content, ListItem. */
    targetDocType: string;
    /** An optional filter to limit the documents of type TargetDocType. */
    filter?: FilterBase | undefined;
}

/** The field used to store multiple relations */
export interface FieldMultiRelation extends FieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The relation types supported by the field. */
    relationTypes: RelationType[];
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** Base class to overwrite field's information */
export interface FieldOverwriteBase {
    /** The field's ID whose information need to be overwritten. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not: this value will overwrite the existing Required value specified in the parent schema  if
OverwriteRequired is set to true. */
    required: boolean;
    /** Enable the overwriting of the Required property of the field specified by the Id property. */
    overwriteRequired: boolean;
}

/** Overwritten information for FieldSingleTagbox */
export interface FieldOverwriteSingleTagbox extends FieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema  if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema  if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;
}

/** Overwritten information for FieldMultiTagbox */
export interface FieldOverwriteMultiTagbox extends FieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;
    /** The maximum number of items that can be stored: this value will overwrite the existing MaximumItems value specified in the parent schema if
OverwriteMaximumItems is set to true. */
    maximumItems?: number | undefined;
    /** Enable the overwriting of the MaximumItems property of the field specified by the Id property. */
    overwriteMaximumItems?: boolean;
    /** The minimum number of items that must be stored: this value will overwrite the existing MinimumItems value specified in the parent schema if
OverwriteMinimumItems is set to true. */
    minimumItems?: number | undefined;
    /** Enable the overwriting of the MinimumItems property of the field specified by the Id property. */
    overwriteMinimumItems?: boolean;
}

/** Count information of fields in the search index for filtering, searching and sorting */
export interface SearchFieldCount {
    /** The number of fields created in the search index to store filter information for a schema. */
    indexedField: number;
    /** The number of fields created in the search index to store search information for a schema. */
    simpleSearchField: number;
    /** The number of fields created in the search index to store sorting information for a schema. */
    sortableField: number;
}

/** Exists response */
export interface SchemaExistsResponse {
    /** It indicates if it exists. */
    exists: boolean;
}

/** Response for a query if a field exists */
export interface FieldExistsResponse {
    /** Indicates if a field with the specified ID currently exists. */
    exists: boolean;
    /** Indicates if a field with the specified ID was previously used.
A field ID that was previously in use cannot be used again. */
    previouslyUsed: boolean;
    /** If the field does already exist or has already existed, this will contain the ID
of the schema containing it. It case of parent-child schemas, a field ID
has to be unique across the schema hierarchy. */
    schemaId?: string | undefined;
}

/** Result of a schema update operation */
export interface SchemaUpdateResult {
    /** The details of the updated schema. */
    schema?: SchemaDetail | undefined;
}

/** Request to update an existing schema */
export interface SchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

/** Result of a schema delete operation */
export interface SchemaDeleteResult {
}

export interface SchemaOwnershipTransferRequest {
    /** The id of the user to whom the schema has to be transferred to. */
    transferUserId?: string | undefined;
}

/** Result of a schema create operation */
export interface SchemaCreateResult {
    /** The details of the created schema. */
    schema?: SchemaDetail | undefined;
}

/** Request to create a schema */
export interface SchemaCreateRequest {
    /** The schema ID. It can be a slug, but must be unique throughout the whole customer setup. */
    id: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

/** Request to create multiple schemas */
export interface SchemaCreateManyRequest {
    /** The schemas to create. Cyclic dependencies between schemas are supported, if they
are all in the same request. */
    schemas: SchemaCreateRequest[];
}

/** Request to update multiple schemas */
export interface SchemaUpdateManyRequest {
    /** The schemas to update. */
    schemas: SchemaUpdateItem[];
}

/** Item to update a schema */
export interface SchemaUpdateItem extends SchemaUpdateRequest {
    /** Id of the schema to update */
    id: string;
}

export interface SchemaOwnershipTransferManyRequest {
    /** The schema ids. */
    schemaIds?: string[] | undefined;
    /** The id of user to whom the schemas have to be transferred to. */
    transferUserId?: string | undefined;
}

/** Base class for search results */
export interface BaseResultOfSchema {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Schema[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfSchema extends BaseResultOfSchema {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Result for schema search operation */
export interface SchemaSearchResult extends SearchBehaviorBaseResultOfSchema {
}

/** A schema */
export interface Schema {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with an immediate inheritance. */
    childCount: number;
    /** The descendant depth of the schema. */
    level: number;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
}

/** Request to search schemas */
export interface SchemaSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Currently only sorting on the Names property is allowed. */
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the schemas. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the SchemaSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the schemas to the ones the user has the specified MetadataRights. */
    rightsFilter?: MetadataRight[] | undefined;
}

/** Contains compiled field information. */
export interface IndexField {
    id?: string | undefined;
    /** The field id. */
    fieldId?: string | undefined;
    /** The field's type name. */
    type?: string | undefined;
    /** Contains all index field name variants of the field. */
    indexFields?: { [key: string]: string; } | undefined;
    /** Contains all simple search field name variants of the field.
The amount of simple search fields can be equal or less to the amount of IndexFields, but never more. */
    simpleSearchFields?: { [key: string]: string; } | undefined;
    /** Contains the fields boost value. */
    boost: number;
    /** Not to be returned for search query, but only used for mapping purposes */
    ignoreForSearch: boolean;
    /** The path of the Nested document this property belongs to. If set to null, it means that there is no Nested document */
    nestedPath?: string | undefined;
    /** Path to the sorting information in the DataSortValuesField sort index. */
    sortField?: string | undefined;
}

/** Request to search indexed fields of specific schemas */
export interface IndexFieldsSearchBySchemaIdsRequest {
    /** The IDs of the schemas for which the indexed fields should be returned. */
    schemaIds?: string[] | undefined;
    /** Controls how the search works which schemas should be considered in the search.
AllDescendantsFieldsOnRootSchema: All indexed fields from descendant schemas of root ones will be returned. Schemas that are not root schemas will be ignored.
SchemaAndParentFieldsOnly: Indexed fields of the requested schema and its parents will be returned. */
    searchMode: IndexFieldsSearchMode;
}

/** How the index field search works */
export enum IndexFieldsSearchMode {
    AllDescendantsFieldsOnRootSchema = <any>"AllDescendantsFieldsOnRootSchema",
    SchemaAndParentFieldsOnly = <any>"SchemaAndParentFieldsOnly",
}

/** Represents a transfer. */
export interface Transfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string | undefined;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string | undefined;
}

/** Transfer states */
export enum TransferState {
    Draft = <any>"Draft",
    UploadInProgress = <any>"UploadInProgress",
    UploadCompleted = <any>"UploadCompleted",
    ImportInProgress = <any>"ImportInProgress",
    ImportCompleted = <any>"ImportCompleted",
    UploadCancelled = <any>"UploadCancelled",
    ImportCancelled = <any>"ImportCancelled",
    ImportFailed = <any>"ImportFailed",
    Created = <any>"Created",
    Deleted = <any>"Deleted",
    TransferReady = <any>"TransferReady",
    FileDeleteInProgress = <any>"FileDeleteInProgress",
    TransferCleanup = <any>"TransferCleanup",
    ImportCompletedWithErrors = <any>"ImportCompletedWithErrors",
    UploadCompletedWithErrors = <any>"UploadCompletedWithErrors",
    UploadCancellationInProgress = <any>"UploadCancellationInProgress",
    ImportDone = <any>"ImportDone",
}

/** Request to import schemas and list items */
export interface SchemaImportRequest {
    /** ID of the file transfer identifying the file previously uploaded. */
    fileTransferId: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items belonging to the schema. */
    importListItems: boolean;
}

/** Share detail */
export interface ShareDetail {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name: string;
    /** Description of share entered by user. */
    description?: string | undefined;
    /** Creator of share. */
    creator: ShareUser;
    /** Audit information. */
    audit: UserAudit;
    /** Detailed information about contents in the share. */
    contentSelections: ShareContentDetail[];
    /** List of shared layers. */
    layerSchemaIds?: string[] | undefined;
    /** Detail of share. */
    data?: ShareDataBase | undefined;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Info if share is already expired. */
    expired: boolean;
    /** Defined access for contents in share. */
    outputAccess: OutputAccess;
    /** Type of share. */
    shareType: ShareType;
}

/** Reduced set of user information used for shares */
export interface ShareUser {
    /** Name of user */
    displayName: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash: string;
}

/** Detail of shared content */
export interface ShareContentDetail {
    /** The id of the schema with schema type content. */
    contentSchemaId: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content: any;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** Content ID. */
    id: string;
    /** List of shared outputs for this content. */
    outputs: ShareOutputBase[];
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues: DisplayValueDictionary;
    /** Contains an URL that can be used to retrieve the icon corresponding to the file type. */
    iconUrl?: string | undefined;
}

/** Base of shared output */
export interface ShareOutputBase {
    /** Content ID. */
    contentId: string;
    /** Output format ID. */
    outputFormatId: string;
    /** Url to directly view output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    viewUrl?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    downloadUrl?: string | undefined;
    /** Output details. */
    detail?: OutputDataBase | undefined;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering: boolean;
}

/** Shared output for basic share */
export interface ShareOutputBasic extends ShareOutputBase {
}

/** Shared output for embed share */
export interface ShareOutputEmbed extends ShareOutputBase {
    /** Share token for the shared output. */
    token?: string | undefined;
}

/** Base of share data */
export interface ShareDataBase {
    /** The URL to access the share. */
    url: string;
}

/** Embed share data */
export interface ShareDataEmbed extends ShareDataBase {
    /** Token for the embed share. */
    token: string;
}

/** Basic share data */
export interface ShareDataBasic extends ShareDataBase {
    /** List of recipients added using email address */
    mailRecipients: MailRecipient[];
    /** List of recipients that exist in Picturepark. */
    internalRecipients: InternalRecipient[];
    /** Language of share. */
    languageCode?: string | undefined;
}

/** Share mail recipient */
export interface MailRecipient {
    /** User information including email. */
    userEmail: UserEmail;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export interface UserEmail {
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Email address */
    emailAddress: string;
}

/** Internal share recipient */
export interface InternalRecipient {
    /** User information of recipient. */
    recipient: User;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export enum OutputAccess {
    Full = <any>"Full",
    Preview = <any>"Preview",
    None = <any>"None",
}

/** Base of update request for share */
export interface ShareBaseUpdateRequest {
    /** Name of share. */
    name: string;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Optional description of share. */
    description?: string | undefined;
    /** List of contents including outputs. Existing items needs to be sent again, otherwise they will be removed. */
    contents: ShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

export interface ShareContent {
    /** Content ID to share. */
    contentId: string;
    /** List of output formats for this content to share. If not specified outer OutputAccess is used. */
    outputFormatIds?: string[] | undefined;
}

/** Update request for basic share */
export interface ShareBasicUpdateRequest extends ShareBaseUpdateRequest {
}

/** Update request for embed share */
export interface ShareEmbedUpdateRequest extends ShareBaseUpdateRequest {
}

/** Base create request for share */
export interface ShareBaseCreateRequest {
    /** Name of share. */
    name: string;
    /** Optional description of share. */
    description?: string | undefined;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** List of contents including outputs to share. */
    contents: ShareContent[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

export interface ShareBasicCreateRequest extends ShareBaseCreateRequest {
    /** List of external mail recipients which are no Picturepark users. */
    recipientEmails?: UserEmail[] | undefined;
    /** System language used for share (mail and detail page). en or de. */
    languageCode: string;
    /** Set to true to disable the creation of notifications and emails to recipients. */
    suppressNotifications?: boolean;
}

/** Create request for embed share */
export interface ShareEmbedCreateRequest extends ShareBaseCreateRequest {
}

export interface ShareDeleteManyRequest {
    /** IDs of shares to delete. */
    ids: string[];
}

export interface ShareRevokeManyRequest {
    ids?: string[] | undefined;
}

/** Request to aggregate shares based on the specified aggregators */
export interface ShareSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
}

/** Request to aggregate shares based on the specified aggregators */
export interface ShareAggregationRequest extends ShareSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Base class for search results */
export interface BaseResultOfShare {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Share[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfShare extends BaseResultOfShare {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorWithAggregationBaseResultOfShare extends SearchBehaviorBaseResultOfShare {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Result for share search operation */
export interface ShareSearchResult extends SearchBehaviorWithAggregationBaseResultOfShare {
}

/** Share */
export interface Share {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name?: string | undefined;
    /** List of shared content IDs. */
    contentIds: string[];
    /** Audit information. */
    audit: UserAudit;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Type of share. */
    shareType: ShareType;
    /** Share is readonly if the current user is not the creator but only the recipient. */
    isReadOnly: boolean;
}

/** Request to search shares */
export interface ShareSearchRequest extends ShareSearchAndAggregationBaseRequest {
    /** Limits the document count of the result set. */
    limit?: number;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Creates a transfer. */
export interface CreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer.
The client is responsible for uploading files to backend.
Required when TransferType is FileUpload or FileUploadAutoImport. */
    files?: TransferUploadFile[] | undefined;
    /** Weblinks downloaded in transfer.
The backend will download files using HTTP, therefore public access to files is needed.
Required when TransferType is WebDownload. */
    webLinks?: TransferWebLink[] | undefined;
    /** Name of collection created after transfer. */
    collectionName?: string | undefined;
    /** A value indicating whether to create a collection after importing the transfer. */
    createCollection: boolean;
}

/** Represents the base class for transfer items. */
export interface TransferFile {
    /** Replaced in favor of RequestId. Client generated identifier of the item. */
    identifier?: string | undefined;
    /** Client generated identifier of the item. */
    requestId?: string | undefined;
}

/** Represents a file being uploaded in a transfer. */
export interface TransferUploadFile extends TransferFile {
    /** Target filename of file. */
    fileName: string;
}

/** Represents an item being downloaded by URL in a transfer. */
export interface TransferWebLink extends TransferFile {
    /** URL of the item. */
    url: string;
    /** Optional target filename of the file. */
    fileName?: string | undefined;
}

/** Represents a transfer and includes detailed information. */
export interface TransferDetail extends Transfer {
    /** Audit information. */
    audit: UserAudit;
    /** Number of items processed. */
    itemProgress?: number;
    /** Total number of items. */
    itemCount?: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount?: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount?: number;
    /** Number of items failed. */
    itemsFailed?: number;
    /** Number of items cancelled. */
    itemsCancelled?: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressTimeStamp?: Date | undefined;
    /** Time stamp of last progress update from upload. */
    lastFileUploadProgressTimeStamp?: Date | undefined;
}

export interface ImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export interface ImportTransferPartialRequest {
    items?: FileTransferCreateItem[] | undefined;
}

export interface FileTransferCreateItem {
    fileId: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Base class for search results */
export interface BaseResultOfTransfer {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Transfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfTransfer extends BaseResultOfTransfer {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Result from a search for transfers. */
export interface TransferSearchResult extends SearchBehaviorBaseResultOfTransfer {
}

/** Request to search for transfers. */
export interface TransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the TransferSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

/** Representation of a file transfer. */
export interface FileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Replaced in favor of RequestId. Client provided identifier. */
    identifier?: string | undefined;
    /** Client provided identifier. */
    requestId: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string | undefined;
}

/** Detailed representation of file transfer. */
export interface FileTransferDetail extends FileTransfer {
    /** Audit information. */
    audit: UserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata | undefined;
    /** Outputs rendered during data extraction phase. */
    outputItems?: FileTransferOutput[] | undefined;
}

export interface FileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: any | undefined;
    exifMetadata?: any | undefined;
    language?: string | undefined;
}

export interface AudioMetadata extends FileMetadata {
    audioStreams?: AudioStream[] | undefined;
}

export interface AudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export interface DocumentMetadata extends FileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount?: number;
    characterCountWithSpaces?: number;
    lineCount?: number;
    pageCount?: number;
    slideCount?: number;
    paragraphCount?: number;
    revisionNumber?: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
}

export interface EpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export interface ImageMetadata extends FileMetadata {
    width?: number;
    height?: number;
    widthInInch?: number;
    heightInInch?: number;
    widthInCm?: number;
    heightInCm?: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel?: number;
    bitsPerChannel?: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha?: boolean;
    isIndexed?: boolean;
    isExtended?: boolean;
    horizontalResolution?: number;
    verticalResolution?: number;
    totalFrames?: number;
    totalUnspecifiedTiffExtraChannels?: number;
    hasExifData?: boolean;
    hasIptcData?: boolean;
    hasAdobeResourceData?: boolean;
    hasXmpData?: boolean;
    uncompressedSizeInBytes?: number;
}

export interface VideoMetadata extends FileMetadata {
    width?: number;
    height?: number;
    durationInSeconds?: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;
}

export interface VideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export interface VectorMetadata extends FileMetadata {
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    title?: string | undefined;
    pageCount?: number;
    epsInfo?: EpsMetadata | undefined;
}

export interface FileTransferOutput {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered",
    Embedded = <any>"Embedded",
}

export enum FileTransferState {
    Draft = <any>"Draft",
    UploadInProgress = <any>"UploadInProgress",
    UploadCompleted = <any>"UploadCompleted",
    DataExtractionInProgress = <any>"DataExtractionInProgress",
    DataExtractionDone = <any>"DataExtractionDone",
    ImportInProgress = <any>"ImportInProgress",
    ImportCompleted = <any>"ImportCompleted",
    UploadCancelled = <any>"UploadCancelled",
    ImportCancelled = <any>"ImportCancelled",
    UploadFailed = <any>"UploadFailed",
    ImportFailed = <any>"ImportFailed",
    DeleteInProgress = <any>"DeleteInProgress",
    Deleted = <any>"Deleted",
    CleanupInProgress = <any>"CleanupInProgress",
    CleanupCompleted = <any>"CleanupCompleted",
}

/** Base class for search results */
export interface BaseResultOfFileTransfer {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: FileTransfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfFileTransfer extends BaseResultOfFileTransfer {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Result from a search for file transfers. */
export interface FileTransferSearchResult extends SearchBehaviorBaseResultOfFileTransfer {
}

/** Request to search for file transfers. */
export interface FileTransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
}

/** Deletes files from transfer. */
export interface FileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];
}

/** Blacklist containing file name patterns skipped when uploading. */
export interface Blacklist {
    /** Blacklist entries. */
    items: BlacklistItem[];
}

/** Entry in the Blacklist. */
export interface BlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;
}

/** Base class for search results */
export interface BaseResultOfUserRole {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: UserRole[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfUserRole extends BaseResultOfUserRole {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Holds results of the user role search. */
export interface UserRoleSearchResult extends SearchBehaviorBaseResultOfUserRole {
}

/** Represents a user role, which associates users with user rights. */
export interface UserRoleEditable {
    /** Language specific user role names. */
    names: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights: UserRight[];
}

/** Represents a user role, which associates users with user rights. */
export interface UserRole extends UserRoleEditable {
    /** User role ID. */
    id: string;
}

export interface UserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to user roles. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Which languages to search against when using the search string. */
    searchLanguages?: string[] | undefined;
    /** Defines if the user roles with system user role Administrator is returned. */
    includeAdministratorSystemUserRole: boolean;
}

/** Represents a user role, which associates users with user rights. */
export interface UserRoleDetail extends UserRole {
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

/** Holds information needed to create multiple user roles. */
export interface UserRoleCreateManyRequest {
    /** Multiple user creation requests. */
    items: UserRoleCreateRequest[];
}

/** Holds information needed for user role creation. */
export interface UserRoleCreateRequest extends UserRoleEditable {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Holds information about which user roles and how are requested to be updated. */
export interface UserRoleUpdateManyRequest {
    /** New value for user roles with specified IDs. */
    items: UserRole[];
}

/** Holds information about which user roles are requested to be deleted. */
export interface UserRoleDeleteManyRequest {
    /** IDs of the user roles to delete. */
    ids: string[];
}

/** Represents the updateable fields of the user. */
export interface UserUpdateRequest extends User {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRole[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** User's address. */
    address?: UserAddress | undefined;
    /** Identity provider that governs this user or null for Picturepark's own IdentityServer. */
    identityProviderId?: string | undefined;
}

/** Detail information about a user. */
export interface UserDetail extends UserUpdateRequest {
    /** Owner tokens referencing the user. */
    ownerTokens?: OwnerToken[] | undefined;
    /** Authorization state the user is currently in. */
    authorizationState?: AuthorizationState;
    /** Locked users are unable to log in and use the system. */
    isLocked?: boolean;
    /** Life cycle state the user is currently in. */
    lifeCycle?: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser?: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly?: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated?: boolean;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
}

export interface OwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

export interface UserLockRequest {
    /** Indicates the requested lock state of the user.
If _true_ was specified, the user will be _locked_. _False_ will unlock the previously _locked_ user.
If User is already in desired state, this will be returned as error. */
    lock: boolean;
}

/** Base class for requests affecting multiple users */
export interface UserManyRequestBase {
    /** User IDs. */
    userIds: string[];
}

/** Request update of lock state of multiple users */
export interface UserLockManyRequest extends UserManyRequestBase {
    /** Indicates the requested lock state of the users.
If _true_ was specified, the users will be _locked_. _False_ will unlock the previously _locked_ users.
Users which are already in desired state will be returned as errors. */
    lock: boolean;
}

/** Holds additional information for user review. */
export interface UserReviewRequest {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed: boolean;
}

/** Review many request */
export interface UserReviewManyRequest extends UserManyRequestBase {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed: boolean;
}

/** Request for inviting users (applies to users in states ToBeReviewed + Reviewed) */
export interface UserInviteManyRequest extends UserManyRequestBase {
}

/** Request for re-inviting users (applies to users in states Invited) */
export interface UserReinviteManyRequest extends UserManyRequestBase {
}

/** Request to update role assignment of users. */
export interface UserRoleAssignManyRequest extends UserManyRequestBase {
    /** Users roles to modify. */
    userRoleIds: string[];
    /** Defines how to apply specified UserRoleIds to UserIds
If an operation results in no change for a user, that user will be returned as succeeded. */
    operation: UserRoleAssignmentOperationType;
}

/** User role assignment operation type */
export enum UserRoleAssignmentOperationType {
    Add = <any>"Add",
    Remove = <any>"Remove",
    Update = <any>"Update",
}

/** Details of the user deletion. */
export interface UserDeleteRequest {
    /** User ID of user who will take over the ownership of the content currently owned by the deleted user. */
    ownerTokenTransferUserId?: string | undefined;
}

/** Holds information needed for user creation. */
export interface UserCreateRequest {
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** IDs of user roles the user is assigned to. */
    userRoleIds?: string[] | undefined;
    /** User address. */
    address?: UserAddress | undefined;
}

/** Base class for search results */
export interface BaseResultOfUserWithRoles {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: UserWithRoles[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorBaseResultOfUserWithRoles extends BaseResultOfUserWithRoles {
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export interface SearchBehaviorWithAggregationBaseResultOfUserWithRoles extends SearchBehaviorBaseResultOfUserWithRoles {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;
}

/** Holds results of the user search. */
export interface UserSearchResult extends SearchBehaviorWithAggregationBaseResultOfUserWithRoles {
}

/** User information retrieved via search */
export interface UserWithRoles {
    /** IDs of user roles user is assigned to */
    userRoleIds?: string[] | undefined;
    /** User's Picturepark ID. */
    id: string;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Authorization state the user is currently in. */
    authorizationState: AuthorizationState;
    /** Life cycle state the user is currently in. */
    lifeCycle: LifeCycle;
    /** A locked user is not allowed to log in. */
    isLocked: boolean;
    /** A support user is a user created for Picturepark support personnel. */
    isSupportUser: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated: boolean;
}

/** Represents an aggregation request over users. */
export interface UserSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Return only users in certain life cycle state(s). */
    lifeCycleFilter: LifeCycleFilter;
    /** Return only users with certain user rights. */
    userRightsFilter?: UserRight[] | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    includeServiceUser: boolean;
}

/** Represents user search request. */
export interface UserSearchRequest extends UserSearchAndAggregationBaseRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Represents an aggregation request over users. */
export interface UserAggregationRequest extends UserSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Request to update identity provider assignment of users. */
export interface UserUpdateIdentityProviderManyRequest extends UserManyRequestBase {
    /** Identity provider to assign to users. */
    identityProviderId: string;
}

export interface DataDictionary {

    [key: string]: any; 
}

export interface Message {
    id?: string | undefined;
    retries: number;
    priority: number;
    deduplicate: boolean;
}

export interface LiveStreamMessage extends Message {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    timestamp?: Date;
    scope?: string | undefined;
    documentChange?: DocumentChange | undefined;
    applicationEvent?: ApplicationEvent | undefined;
}

export interface DocumentChange {
    documentName?: string | undefined;
    documentId?: string | undefined;
    version: number;
    action?: string | undefined;
    timeStamp: Date;
}

export interface ApplicationEvent {
    timestamp: Date;
}

export interface TransferEvent extends ApplicationEvent {
    transferId?: string | undefined;
    state?: TransferState;
}

export interface ReindexEvent extends ApplicationEvent {
    indexId?: string | undefined;
    state?: IndexState;
}

export enum IndexState {
    Draft = <any>"Draft",
    Create = <any>"Create",
    Inactive = <any>"Inactive",
    Active = <any>"Active",
    Closed = <any>"Closed",
    ReindexInProgress = <any>"ReindexInProgress",
    Cancelled = <any>"Cancelled",
}

export interface ContentDetailViewEvent extends ApplicationEvent {
    contentIds?: string[] | undefined;
}

export interface ContentDownloadEvent extends ApplicationEvent {
    downloadInfos?: DownloadTrackingInfo[] | undefined;
    fileSize?: number;
    shareToken?: string | undefined;
    range?: string | undefined;
}

export interface DownloadTrackingInfo {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    contentDisposition: ContentDisposition;
}

export enum ContentDisposition {
    Attachment = <any>"Attachment",
    Inline = <any>"Inline",
}

export interface SessionRenewalEvent extends ApplicationEvent {
    authorizationState?: AuthorizationState;
}

export interface SharePageViewEvent extends ApplicationEvent {
    shareToken?: string | undefined;
}

export interface ApiStatisticsEvent extends ApplicationEvent {
    requestsPerClient?: { [key: string]: number; } | undefined;
}

export interface BusinessProcessEvent extends ApplicationEvent {
    businessProcessId?: string | undefined;
    lifeCycle?: BusinessProcessLifeCycle | undefined;
    state?: string | undefined;
}

export interface OutputRenderedEvent extends ApplicationEvent {
    outputId?: string | undefined;
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    renderingState?: OutputRenderingState;
}

export interface ConfigurationChangeEvent extends ApplicationEvent {
    documentType?: string | undefined;
}

export interface CustomerChangeEvent extends ConfigurationChangeEvent {
    lifeCycle?: LifeCycle;
}

export interface SearchReindexCompletedEvent extends ApplicationEvent {
    searchIndex?: SearchIndexType;
    items?: number;
    duration?: string;
}

export enum SearchIndexType {
    Content = <any>"Content",
    ListItem = <any>"ListItem",
}

export interface BusinessRuleFiredEvent extends ApplicationEvent {
    details?: BusinessRuleFiredEventDetail[] | undefined;
}

export interface BusinessRuleFiredEventDetail {
    documentId?: string | undefined;
    documentType?: string | undefined;
    ruleIds?: string[] | undefined;
}

export interface BusinessProcessCancellationRequestedEvent extends ApplicationEvent {
    businessProcessId?: string | undefined;
}

export interface ConsoleMessage extends Message {
    command?: string | undefined;
    arguments?: TupleOfStringAndString[] | undefined;
    targetQueue?: string | undefined;
}

export interface TupleOfStringAndString {
    item1: string;
    item2: string;
}

export interface NodeInfoMessage extends Message {
    nodeId?: string | undefined;
    hostName?: string | undefined;
    lastResponseTime?: Date;
    serviceName?: string | undefined;
    fileVersion?: string | undefined;
    productVersion?: string | undefined;
    release?: string | undefined;
    logLevel?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

export class OidcClientSettings {
  static create(settings: { serverUrl: string, stsServerUrl: string, clientId: string, customerAlias: string, 
    customerId: string, scope: string, redirectServerUrl?: string, logoutServerUrl?: string }) {
    
    return {
      client_id: settings.clientId,
      scope: settings.scope,
      authority: settings.stsServerUrl,
      response_type: "id_token token",
      filterProtocolClaims: true,
      loadUserInfo: true,
      redirect_uri: settings.redirectServerUrl ? settings.redirectServerUrl : settings.serverUrl + '/auth-callback',
      post_logout_redirect_uri: settings.logoutServerUrl ? settings.logoutServerUrl : settings.serverUrl,
      acr_values: 'tenant:{"id":"' +
        settings.customerId + '","alias":"' +
        settings.customerAlias + '"}'
    }
  }
}

export class AccessTokenAuthClient extends AuthClient {
  constructor(pictureparkApiUrl: string, customerAlias: string, private accessToken: string) {
    super(pictureparkApiUrl, customerAlias);
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.accessToken) {
      options.headers['Authorization'] = 'Bearer ' + this.accessToken;
    }

    return super.transformHttpRequestOptions(options);
  }
}