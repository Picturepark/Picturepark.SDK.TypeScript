/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.9.3.0 (NJsonSchema v9.7.7.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { AuthClient, TokenAuthClient } from './auth';

export class PictureparkClientBase {
    constructor(private authClient: AuthClient) {

    }

    getBaseUrl(defaultUrl: string) {
        return this.authClient ? this.authClient.getBaseUrl(defaultUrl) : defaultUrl;        
    }

    transformOptions(options: RequestInit): Promise<RequestInit> {
        return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options);
    }
}

export class ContentClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Update Single - OwnershipTransfer
     * @contentId The content id.
     * @updateRequest The content ownership transfer request update request.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return ContentDetail
     */
    updateTransferOwnership(contentId: string, updateRequest: ContentOwnershipTransferRequest | null, timeout: number | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Ownership/Transfer?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTransferOwnership(_response);
        });
    }

    protected processUpdateTransferOwnership(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Get Many
     * @ids Comma-separated list of contentIds
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return List of ContentDetail
     */
    getMany(ids: string[] | null, resolve: boolean, patterns: string[] | null): Promise<ContentDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<ContentDetail[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail[] | null>(<any>null);
    }

    /**
     * Process many ownership trasnfer request
     * @contentsOwnershipTransferRequest The content ownership transfer request request.
     * @return BusinessProcess
     */
    transferOwnershipMany(contentsOwnershipTransferRequest: ContentsOwnershipTransferRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Ownership/Transfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsOwnershipTransferRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTransferOwnershipMany(_response);
        });
    }

    protected processTransferOwnershipMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregate
     * @contentAggregationRequest The aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(contentAggregationRequest: ContentAggregationRequest | null): Promise<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Aggregate by Channel
     * @channelId The channel id
     * @contentAggregationRequest The content aggregation request.
     * @return ObjectAggregationResult
     */
    aggregateByChannel(channelId: string, contentAggregationRequest: ContentAggregationRequest | null): Promise<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ChannelId}/Aggregate";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregateByChannel(_response);
        });
    }

    protected processAggregateByChannel(response: Response): Promise<ObjectAggregationResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Creates a content batch download
     * @request The content batch download request
     * @return ContentBatchDonloadItem
     */
    createDownloadLink(request: ContentBatchDownloadRequest | null): Promise<ContentBatchDownloadItem | null> {
        let url_ = this.baseUrl + "/V1/Contents/CreateBatchContentDownload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDownloadLink(_response);
        });
    }

    protected processCreateDownloadLink(response: Response): Promise<ContentBatchDownloadItem | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentBatchDownloadItem>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentBatchDownloadItem | null>(<any>null);
    }

    /**
     * Create Single
     * @createRequest The content create request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    createContent(createRequest: CreateContentRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateContent(_response);
        });
    }

    protected processCreateContent(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Downloads content in a specific outputformat
     * @contentId The content id
     * @outputFormatId The output format id
     * @range the range
     * @return HttpResponseMessage
     */
    download(contentId: string, outputFormatId: string, range: string | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Downloads/{ContentId}/{OutputFormatId}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Range": range !== undefined && range !== null ? "" + range : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Get Thumbnail
     * @contentId The Content id
     * @size Thumbnail size. Either small, medium or large
     * @return HttpResponseMessage
     */
    downloadThumbnail(contentId: string, size: ThumbnailSize): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Thumbnails/{ContentId}/{Size}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{Size}", encodeURIComponent("" + size)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadThumbnail(_response);
        });
    }

    protected processDownloadThumbnail(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Download resized content
     * @contentId The Content id
     * @outputFormatId The output format id
     * @width The content width
     * @height The content height
     * @return HttpResponseMessage
     */
    downloadResized(contentId: string, outputFormatId: string, width: number, height: number): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/V1/Contents/Downloads/{ContentId}/{OutputFormatId}/{Width}/{Height}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{OutputFormatId}", encodeURIComponent("" + outputFormatId)); 
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined.");
        url_ = url_.replace("{Width}", encodeURIComponent("" + width)); 
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined.");
        url_ = url_.replace("{Height}", encodeURIComponent("" + height)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDownloadResized(_response);
        });
    }

    protected processDownloadResized(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*)"?;/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Get Single
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    get(contentId: string, resolve: boolean, patterns: string[] | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Metadata
     * @contentId The content id.
     * @updateRequest The metadata update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updateMetadata(contentId: string, updateRequest: UpdateContentMetadataRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadata(_response);
        });
    }

    protected processUpdateMetadata(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Update Single - Permissions
     * @contentId The content id.
     * @updateRequest The content permission update request.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    updatePermissions(contentId: string, updateRequest: UpdateContentPermissionsRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Permissions?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissions(_response);
        });
    }

    protected processUpdatePermissions(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Search
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    search(contentSearchRequest: ContentSearchRequest | null): Promise<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ContentSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentSearchResult | null>(<any>null);
    }

    /**
     * Search By Channel
     * @channelId The channel id.
     * @contentSearchRequest The content search request.
     * @return ContentSearchResult
     */
    searchByChannel(channelId: string, contentSearchRequest: ContentSearchRequest | null): Promise<ContentSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ChannelId}/Search";
        if (channelId === undefined || channelId === null)
            throw new Error("The parameter 'channelId' must be defined.");
        url_ = url_.replace("{ChannelId}", encodeURIComponent("" + channelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchByChannel(_response);
        });
    }

    protected processSearchByChannel(response: Response): Promise<ContentSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentSearchResult | null>(<any>null);
    }

    /**
     * Deactivates a content
     * @contentId the id of the content to deactivate
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     */
    deactivate(contentId: string, timeout: number): Promise<void> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Deactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update Single - File
     * @contentId The id of the content to replace
     * @updateRequest Update request
     */
    updateFile(contentId: string, updateRequest: ContentFileUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/File";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFile(_response);
        });
    }

    protected processUpdateFile(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Reactivate - Content
     * @contentId The content id.
     * @resolve Resolves the data of referenced list items into the contents's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ContentDetail
     */
    reactivate(contentId: string, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ContentDetail | null> {
        let url_ = this.baseUrl + "/V1/Contents/{ContentId}/Reactivate?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{ContentId}", encodeURIComponent("" + contentId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReactivate(_response);
        });
    }

    protected processReactivate(response: Response): Promise<ContentDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentDetail | null>(<any>null);
    }

    /**
     * Dactivate Many - Content
     * @deactivationRequest The deactivation request
     * @return BusinessProcess
     */
    deactivateMany(deactivationRequest: ContentDeactivationRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeactivateMany(_response);
        });
    }

    protected processDeactivateMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Reactivate Many - Content
     * @reactivationRequest The content reactivation request.
     * @return BusinessProcess
     */
    reactivateMany(reactivationRequest: ContentReactivationRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Reactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reactivationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReactivateMany(_response);
        });
    }

    protected processReactivateMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many - Metadata
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    updateMetadataMany(updateRequest: ContentsMetadataUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadataMany(_response);
        });
    }

    protected processUpdateMetadataMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Update by filter - Metadata
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    updateMetadataByFilter(updateRequest: FilterContentsMetadataUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Metadata/Filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMetadataByFilter(_response);
        });
    }

    protected processUpdateMetadataByFilter(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many - Permissions
     * @updateRequest The permissions update request.
     * @return BusinessProcess
     */
    updatePermissionsMany(updateRequest: UpdateContentPermissionsRequest[] | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Contents/Many/Permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermissionsMany(_response);
        });
    }

    protected processUpdatePermissionsMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }
}

export class BusinessProcessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @businessProcessSearchRequest The business process request
     * @return BusinessProcessSearchResult
     */
    search(businessProcessSearchRequest: BusinessProcessSearchRequest | null): Promise<BusinessProcessSearchResult | null> {
        let url_ = this.baseUrl + "/v1/businessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(businessProcessSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<BusinessProcessSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessSearchResult | null>(<any>null);
    }

    /**
     * Start
     * @processDefinitionId The process definition id
     * @request The start process request
     * @return BusinessProcess
     */
    start(processDefinitionId: string, request: StartProcessRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/v1/businessProcesses/processDefinitions/{processDefinitionId}/start";
        if (processDefinitionId === undefined || processDefinitionId === null)
            throw new Error("The parameter 'processDefinitionId' must be defined.");
        url_ = url_.replace("{processDefinitionId}", encodeURIComponent("" + processDefinitionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Mark as ended
     * @processId The process id
     */
    markAsEnded(processId: string): Promise<void> {
        let url_ = this.baseUrl + "/v1/businessProcesses/processes/{processId}/markAsEnded";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkAsEnded(_response);
        });
    }

    protected processMarkAsEnded(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send message
     * @processId The process id
     * @request The send message request
     */
    sendMessage(processId: string, request: SendMessageRequest | null): Promise<void> {
        let url_ = this.baseUrl + "/v1/businessProcesses/processes/{processId}/message";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Wait for states
     * @processId The process id
     * @states The states to wait for
     * @timeout The timeout in ms
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string | null, timeout: number): Promise<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/v1/businessProcesses/{processId}/wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId)); 
        if (states === undefined)
            throw new Error("The parameter 'states' must be defined.");
        else
            url_ += "states=" + encodeURIComponent("" + states) + "&"; 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForStates(_response);
        });
    }

    protected processWaitForStates(response: Response): Promise<BusinessProcessWaitResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitResult | null>(<any>null);
    }
}

export class DocumentHistoryClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search for document history
     * @documentHistorySearchRequest The document history search request
     * @return DocumentHistorySearchResult
     */
    search(documentHistorySearchRequest: DocumentHistorySearchRequest | null): Promise<DocumentHistorySearchResult | null> {
        let url_ = this.baseUrl + "/V1/History/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentHistorySearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<DocumentHistorySearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistorySearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistorySearchResult | null>(<any>null);
    }

    /**
     * Gets a document history
     * @id The id
     * @return DocumentHistory
     */
    get(id: string): Promise<DocumentHistory | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DocumentHistory | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory | null>(<any>null);
    }

    /**
     * Get document history version
     * @id The id
     * @version The version
     * @return DocumentHistory
     */
    getVersion(id: string, version: string): Promise<DocumentHistory | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/{Version}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{Version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<DocumentHistory | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistory>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistory | null>(<any>null);
    }

    /**
     * Get latest difference of document history
     * @id The id
     * @oldVersion The old version
     * @return DocumentHistoryDifference
     */
    getDifferenceLatest(id: string, oldVersion: number): Promise<DocumentHistoryDifference | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/Difference/{OldVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDifferenceLatest(_response);
        });
    }

    protected processGetDifferenceLatest(response: Response): Promise<DocumentHistoryDifference | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference | null>(<any>null);
    }

    /**
     * Get the difference between tho document history
     * @id The id
     * @oldVersion The old version
     * @newVersion The new version
     * @return DocumentHistoryDifference
     */
    getDifference(id: string, oldVersion: number, newVersion: number): Promise<DocumentHistoryDifference | null> {
        let url_ = this.baseUrl + "/V1/History/{Id}/Difference/{OldVersion}/{NewVersion}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (oldVersion === undefined || oldVersion === null)
            throw new Error("The parameter 'oldVersion' must be defined.");
        url_ = url_.replace("{OldVersion}", encodeURIComponent("" + oldVersion)); 
        if (newVersion === undefined || newVersion === null)
            throw new Error("The parameter 'newVersion' must be defined.");
        url_ = url_.replace("{NewVersion}", encodeURIComponent("" + newVersion)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDifference(_response);
        });
    }

    protected processGetDifference(response: Response): Promise<DocumentHistoryDifference | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentHistoryDifference>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DocumentHistoryDifference | null>(<any>null);
    }
}

export class JsonSchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Json Schema
     * @schemaId Schema Id
     * @return JsonSchemaViewItem
     */
    get(schemaId: string): Promise<any | null> {
        let url_ = this.baseUrl + "/V1/JsonSchemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<any | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any | null>(<any>null);
    }
}

export class ListItemClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create Single
     * @listItem List item create request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    create(listItem: ListItemCreateRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems?";
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItem);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ListItemDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail | null>(<any>null);
    }

    /**
     * Create Many
     * @objects A list of ListItemCreateRequests.
     * @return BusinessProcess
     */
    createMany(objects: ListItemCreateRequest[] | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMany(_response);
        });
    }

    protected processCreateMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Delete Many
     * @ids The list item id list.
     * @return BusinessProcess
     */
    deleteMany(ids: string[] | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Update Many
     * @objects A list of ListItemUpdateRequests.
     * @return BusinessProcess
     */
    updateMany(objects: ListItemUpdateRequest[] | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(objects);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMany(_response);
        });
    }

    protected processUpdateMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregate
     * @listItemAggregationRequest The list item aggregation request.
     * @return ObjectAggregationResult
     */
    aggregate(listItemAggregationRequest: ListItemAggregationRequest | null): Promise<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemAggregationRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Search
     * @listItemSearchRequest The list item search request.
     * @return List item result set.
     */
    search(listItemSearchRequest: ListItemSearchRequest | null): Promise<ListItemSearchResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ListItemSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemSearchResult | null>(<any>null);
    }

    /**
     * Delete Single
     * @objectId The list item id.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     */
    delete(objectId: string, timeout: number): Promise<void> {
        let url_ = this.baseUrl + "/V1/ListItems/{ObjectId}?";
        if (objectId === undefined || objectId === null)
            throw new Error("The parameter 'objectId' must be defined.");
        url_ = url_.replace("{ObjectId}", encodeURIComponent("" + objectId)); 
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Single
     * @listItemId The list item id.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     */
    get(listItemId: string, resolve: boolean, patterns: string[] | null): Promise<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ListItemDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail | null>(<any>null);
    }

    /**
     * Update Single
     * @listItemId The list item id.
     * @updateRequest The list item update request.
     * @resolve Resolves the data of referenced list items into the list item's content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @patterns Comma-separated list of display pattern ids. Resolves display values of referenced list items where the display pattern id matches.
     * @return ListItemDetail
     */
    update(listItemId: string, updateRequest: ListItemUpdateRequest | null, resolve: boolean, timeout: number | null, patterns: string[] | null): Promise<ListItemDetail | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ListItemId}?";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{ListItemId}", encodeURIComponent("" + listItemId)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        if (patterns !== undefined)
            patterns && patterns.forEach(item => { url_ += "patterns=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ListItemDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListItemDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemDetail | null>(<any>null);
    }

    /**
     * Update by filter - Fields
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    updateFieldsByFilter(updateRequest: ListItemFieldsFilterUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many/Fields/Filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFieldsByFilter(_response);
        });
    }

    protected processUpdateFieldsByFilter(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Update - Fields
     * @updateRequest The metadata update request.
     * @return BusinessProcess
     */
    updateFields(updateRequest: ListItemFieldsUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/ListItems/Many/Fields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFields(_response);
        });
    }

    protected processUpdateFields(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Wait For States
     * @processId The business process id.
     * @states Comma-separated list of business process states to wait for.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return BusinessProcessWaitResult
     */
    waitForStates(processId: string, states: string[] | null, timeout: number): Promise<BusinessProcessWaitResult | null> {
        let url_ = this.baseUrl + "/V1/ListItems/{ProcessId}/Wait?";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{ProcessId}", encodeURIComponent("" + processId)); 
        if (states !== undefined)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (timeout === undefined || timeout === null)
            throw new Error("The parameter 'timeout' must be defined and cannot be null.");
        else
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWaitForStates(_response);
        });
    }

    protected processWaitForStates(response: Response): Promise<BusinessProcessWaitResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcessWaitResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcessWaitResult | null>(<any>null);
    }
}

export class LiveStreamClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search LiveStream
     * @liveStreamSearchRequest The livestream search request
     * @return ObjectSearchResult
     */
    search(liveStreamSearchRequest: LiveStreamSearchRequest | null): Promise<ObjectSearchResult | null> {
        let url_ = this.baseUrl + "/V1/LiveStream/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(liveStreamSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ObjectSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSearchResult | null>(<any>null);
    }
}

export class SchemaClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Many
     * @ids Comma separated list of schema ids
     * @return SchemaDetail
     */
    getMany(ids: string[] | null): Promise<SchemaDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Schemas?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMany(_response);
        });
    }

    protected processGetMany(response: Response): Promise<SchemaDetail[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail[] | null>(<any>null);
    }

    /**
     * Create Single
     * @schema The schema create request.
     * @return BusinessProcess
     */
    create(schema: SchemaCreateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Get Single
     * @schemaId The schema id.
     * @return SchemaDetail
     */
    get(schemaId: string): Promise<SchemaDetail | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SchemaDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaDetail | null>(<any>null);
    }

    /**
     * Update Single
     * @schemaId The schema id.
     * @schema The schema update request.
     * @return BusinessProcess
     */
    update(schemaId: string, schema: SchemaUpdateRequest | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schema);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Delete Single
     * @schemaId The schema id.
     * @return BusinessProcess
     */
    delete(schemaId: string): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Exists
     * @schemaId The schema id.
     * @fieldId The optional field id.
     * @return ExistsResponse
     */
    exists(schemaId: string, fieldId: string | null): Promise<ExistsResponse | null> {
        let url_ = this.baseUrl + "/V1/Schemas/{SchemaId}/Exists?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{SchemaId}", encodeURIComponent("" + schemaId)); 
        if (fieldId === undefined)
            throw new Error("The parameter 'fieldId' must be defined.");
        else
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<ExistsResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExistsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExistsResponse | null>(<any>null);
    }

    /**
     * Search
     * @schemaSearchRequest The schema search request.
     * @return Schema result set.
     */
    search(schemaSearchRequest: SchemaSearchRequest | null): Promise<SchemaSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Schemas/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schemaSearchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SchemaSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaSearchResult | null>(<any>null);
    }
}

export class PermissionClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get UserRight validation result
     * @permission The UserRight to validate
     * @return Boolean - user has permission
     */
    getUserPermissions(permission: UserRight): Promise<boolean> {
        let url_ = this.baseUrl + "/V1/Permission/UserPermissions/{Permission}";
        if (permission === undefined || permission === null)
            throw new Error("The parameter 'permission' must be defined.");
        url_ = url_.replace("{Permission}", encodeURIComponent("" + permission)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * Search Content Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchContentPermissions(request: PermissionSetSearchRequest | null): Promise<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Permission/ContentPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchContentPermissions(_response);
        });
    }

    protected processSearchContentPermissions(response: Response): Promise<PermissionSetSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Content Permission Single
     * @permissionSetId The content permission set id.
     * @return ContentPermissionSetDetail
     */
    getContentPermissions(permissionSetId: string): Promise<ContentPermissionSetDetail | null> {
        let url_ = this.baseUrl + "/V1/Permission/ContentPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetContentPermissions(_response);
        });
    }

    protected processGetContentPermissions(response: Response): Promise<ContentPermissionSetDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContentPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentPermissionSetDetail | null>(<any>null);
    }

    /**
     * Search Schema Permissions
     * @request The permission search request.
     * @return PermissionSetSearchResult
     */
    searchSchemaPermissions(request: PermissionSetSearchRequest | null): Promise<PermissionSetSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Permission/SchemaPermissionSets/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchSchemaPermissions(_response);
        });
    }

    protected processSearchSchemaPermissions(response: Response): Promise<PermissionSetSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionSetSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSetSearchResult | null>(<any>null);
    }

    /**
     * Get Schema Permission Single
     * @permissionSetId The schema permission set id.
     * @return SchemaPermissionSetDetail
     */
    getSchemaPermissions(permissionSetId: string): Promise<SchemaPermissionSetDetail | null> {
        let url_ = this.baseUrl + "/V1/Permission/SchemaPermissionSets/{PermissionSetId}";
        if (permissionSetId === undefined || permissionSetId === null)
            throw new Error("The parameter 'permissionSetId' must be defined.");
        url_ = url_.replace("{PermissionSetId}", encodeURIComponent("" + permissionSetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSchemaPermissions(_response);
        });
    }

    protected processGetSchemaPermissions(response: Response): Promise<SchemaPermissionSetDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SchemaPermissionSetDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SchemaPermissionSetDetail | null>(<any>null);
    }
}

export class PublicAccessClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get Version
     * @return VersionInfo
     */
    getVersion(): Promise<VersionInfo | null> {
        let url_ = this.baseUrl + "/V1/PublicAccess/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionInfo | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VersionInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionInfo | null>(<any>null);
    }

    /**
     * Get Share
     * @token The token
     * @return ShareBaseDetail
     */
    getShare(token: string | null): Promise<ShareBaseDetail | null> {
        let url_ = this.baseUrl + "/V1/PublicAccess/GetShare?";
        if (token === undefined)
            throw new Error("The parameter 'token' must be defined.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShare(_response);
        });
    }

    protected processGetShare(response: Response): Promise<ShareBaseDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareBaseDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareBaseDetail | null>(<any>null);
    }
}

export class ShareClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Update single
     * @id The share id.
     * @updateRequest The share update request.
     * @resolve Resolves the data of referenced list items into the shares content.
     * @timeout Maximum time in milliseconds to wait for the business process completed state.
     * @return Share
     */
    update(id: string, updateRequest: ShareBaseUpdateRequest | null, resolve: boolean, timeout: number | null): Promise<BaseResultOfShareBase | null> {
        let url_ = this.baseUrl + "/V1/Shares/{Id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        if (resolve === undefined || resolve === null)
            throw new Error("The parameter 'resolve' must be defined and cannot be null.");
        else
            url_ += "resolve=" + encodeURIComponent("" + resolve) + "&"; 
        if (timeout !== undefined)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<BaseResultOfShareBase | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BaseResultOfShareBase>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseResultOfShareBase | null>(<any>null);
    }

    /**
     * Get single
     * @id Share Id (not token, use PublicAccess to get share by token)
     * @return Polymorph share
     */
    get(id: string): Promise<ShareBaseDetail | null> {
        let url_ = this.baseUrl + "/V1/Shares/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ShareBaseDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareBaseDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareBaseDetail | null>(<any>null);
    }

    /**
     * Delete many
     * @shareIds A list of ListItemCreateRequests.
     * @return BusinessProcess
     */
    deleteMany(shareIds: string[] | null): Promise<BusinessProcess | null> {
        let url_ = this.baseUrl + "/V1/Shares/DeleteMany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(shareIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<BusinessProcess | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BusinessProcess>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BusinessProcess | null>(<any>null);
    }

    /**
     * Aggregate
     * @request Aggregation request
     * @return AggregationResult
     */
    aggregate(request: ShareAggregationRequest | null): Promise<ObjectAggregationResult | null> {
        let url_ = this.baseUrl + "/V1/Shares/Aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAggregate(_response);
        });
    }

    protected processAggregate(response: Response): Promise<ObjectAggregationResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ObjectAggregationResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectAggregationResult | null>(<any>null);
    }

    /**
     * Create single
     * @request Polymorph create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return Create result
     */
    create(request: ShareBaseCreateRequest | null): Promise<CreateShareResult | null> {
        let url_ = this.baseUrl + "/V1/Shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CreateShareResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ContentNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CreateShareResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateShareResult | null>(<any>null);
    }

    /**
     * Search
     * @request Search request
     * @return Share search result
     */
    search(request: ShareSearchRequest | null): Promise<ShareSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Shares/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ShareSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShareSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShareSearchResult | null>(<any>null);
    }
}

export class TransferClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Delete Files
     * @request The filetransfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest | null): Promise<void> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFiles(_response);
        });
    }

    protected processDeleteFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Blacklist
     * @return Blacklist
     */
    getBlacklist(): Promise<Blacklist | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBlacklist(_response);
        });
    }

    protected processGetBlacklist(response: Response): Promise<Blacklist | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Blacklist>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Blacklist | null>(<any>null);
    }

    /**
     * Cancels an active transfer. Valid states: TODO
     */
    cancelTransfer(transferId: string): Promise<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Cancel";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelTransfer(_response);
        });
    }

    protected processCancelTransfer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create Transfer
     * @request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest | null): Promise<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Transfer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer | null>(<any>null);
    }

    /**
     * Delete Transfer
     * @transferId The tranfer id
     * @return Transfer
     */
    delete(transferId: string): Promise<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Transferdetail
     * @transferId The tranfer id
     * @return TransferDetail
     */
    get(transferId: string): Promise<TransferDetail | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TransferDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferDetail | null>(<any>null);
    }

    /**
     * Get File
     * @fileTransferId The filetransfer id
     * @return FileTransferDetail
     */
    getFile(fileTransferId: string): Promise<FileTransferDetail | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/{FileTransferId}";
        if (fileTransferId === undefined || fileTransferId === null)
            throw new Error("The parameter 'fileTransferId' must be defined.");
        url_ = url_.replace("{FileTransferId}", encodeURIComponent("" + fileTransferId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<FileTransferDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferDetail | null>(<any>null);
    }

    /**
     * Delete Transfer
     * @transferId The tranfer id
     * @request The filetransfer to content create request
     * @return Transfer
     */
    importTransfer(transferId: string, request: FileTransfer2ContentCreateRequest | null): Promise<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Import";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportTransfer(_response);
        });
    }

    protected processImportTransfer(response: Response): Promise<Transfer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer | null>(<any>null);
    }

    /**
     * Create a partial import
     * @transferId The transfer id
     * @request The filetransfer partial to content create request
     */
    partialImport(transferId: string, request: FileTransferPartial2ContentCreateRequest | null): Promise<Transfer | null> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/PartialImport";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPartialImport(_response);
        });
    }

    protected processPartialImport(response: Response): Promise<Transfer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Transfer>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Transfer | null>(<any>null);
    }

    /**
     * Search
     * @request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest | null): Promise<TransferSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<TransferSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransferSearchResult | null>(<any>null);
    }

    /**
     * Search for files
     * @request The file transfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest | null): Promise<FileTransferSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Transfers/Files/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchFiles(_response);
        });
    }

    protected processSearchFiles(response: Response): Promise<FileTransferSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FileTransferSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileTransferSearchResult | null>(<any>null);
    }

    /**
     * Upload file
     * @formFile Gets or sets the form file.
     * @relativePath Relative path of the uploading file
     * @chunkNumber Current chunk number. starts with 1
     * @currentChunkSize Size in bytes of the current chunk
     * @totalSize Total size in bytes of the uploading file
     * @totalChunks Total chunks of the uploading file
     */
    uploadFile(formFile: FileParameter | null, relativePath: string | null, chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string, identifier: string): Promise<void> {
        let url_ = this.baseUrl + "/V1/Transfers/{TransferId}/Files/{Identifier}/Upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{TransferId}", encodeURIComponent("" + transferId)); 
        if (identifier === undefined || identifier === null)
            throw new Error("The parameter 'identifier' must be defined.");
        url_ = url_.replace("{Identifier}", encodeURIComponent("" + identifier)); 
        if (relativePath !== undefined)
            url_ += "relativePath=" + encodeURIComponent("" + relativePath) + "&"; 
        if (chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' cannot be null.");
        else if (chunkNumber !== undefined)
            url_ += "chunkNumber=" + encodeURIComponent("" + chunkNumber) + "&"; 
        if (currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' cannot be null.");
        else if (currentChunkSize !== undefined)
            url_ += "currentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&"; 
        if (totalSize === null)
            throw new Error("The parameter 'totalSize' cannot be null.");
        else if (totalSize !== undefined)
            url_ += "totalSize=" + encodeURIComponent("" + totalSize) + "&"; 
        if (totalChunks === null)
            throw new Error("The parameter 'totalChunks' cannot be null.");
        else if (totalChunks !== undefined)
            url_ += "totalChunks=" + encodeURIComponent("" + totalChunks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search for users
     * @searchRequest The user search request
     * @return UserSearchResult
     */
    search(searchRequest: UserSearchRequest | null): Promise<UserSearchResult | null> {
        let url_ = this.baseUrl + "/V1/Users/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<UserSearchResult | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSearchResult | null>(<any>null);
    }

    /**
     * Get Userdetail by id
     * @userId The user id
     * @return UserDetail
     */
    getUser(userId: string): Promise<UserDetail | null> {
        let url_ = this.baseUrl + "/V1/Users/GetUser/{UserId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{UserId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail | null>(<any>null);
    }

    /**
     * Get userdetail by owner token
     * @tokenId The token id
     * @return UserDetail
     */
    getByOwnerToken(tokenId: string): Promise<UserDetail | null> {
        let url_ = this.baseUrl + "/V1/Users/Owner/{TokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{TokenId}", encodeURIComponent("" + tokenId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByOwnerToken(_response);
        });
    }

    protected processGetByOwnerToken(response: Response): Promise<UserDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail | null>(<any>null);
    }

    /**
     * Get List of Channels
     */
    getChannels(): Promise<Channel[] | null> {
        let url_ = this.baseUrl + "/V1/Users/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetChannels(_response);
        });
    }

    protected processGetChannels(response: Response): Promise<Channel[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Channel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Channel[] | null>(<any>null);
    }
}

export class OutputClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get outputs by contentIds
     * @contentsByIdsRequest Contains the list of contentIds for which the outputs are requested
     * @return The Result containing a list of OutputDetail's
     */
    getByContentIds(contentsByIdsRequest: ContentsByIdsRequest | null): Promise<OutputDetail[] | null> {
        let url_ = this.baseUrl + "/V1/Outputs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contentsByIdsRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByContentIds(_response);
        });
    }

    protected processGetByContentIds(response: Response): Promise<OutputDetail[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputDetail[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputDetail[] | null>(<any>null);
    }

    /**
     * Get Single
     * @outputId The output id.
     * @return OutputDetail
     */
    get(outputId: string): Promise<OutputDetail | null> {
        let url_ = this.baseUrl + "/V1/Outputs/{OutputId}";
        if (outputId === undefined || outputId === null)
            throw new Error("The parameter 'outputId' must be defined.");
        url_ = url_.replace("{OutputId}", encodeURIComponent("" + outputId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OutputDetail | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <OutputNotFoundException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OutputDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutputDetail | null>(<any>null);
    }
}

export class ProfileClient extends PictureparkClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return UserProfile
     */
    get(): Promise<UserProfile | null> {
        let url_ = this.baseUrl + "/V1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserProfile | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile | null>(<any>null);
    }

    /**
     * Update
     * @return UserProfile
     */
    update(profile: UserProfile | null): Promise<UserProfile | null> {
        let url_ = this.baseUrl + "/V1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profile);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<UserProfile | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserProfile>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <PictureparkException>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile | null>(<any>null);
    }
}

export interface ContentOwnershipTransferRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** The id of the user to whom the content document has to be transfered to. */
    transferUserId?: string | undefined;
}

/** A content detail. */
export interface ContentDetail {
    /** Audit data with information regarding document creation and modification. */
    audit?: UserAudit | undefined;
    /** The content data */
    content?: any | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    /** The id of the content schema */
    contentSchemaId?: string | undefined;
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's
             display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type */
    entityType: EntityType;
    /** The content id. */
    id?: string | undefined;
    /** An optional list of layer schemas ids */
    layerSchemaIds?: string[] | undefined;
    /** The metadata dictionary */
    metadata?: DataDictionary | undefined;
    /** A list of rendering ouputs for underlying digital file. */
    outputs?: Output[] | undefined;
    /** The id of a owner token. Defines the content owner. */
    ownerTokenId?: string | undefined;
    /** The trashed flag. */
    trashed: boolean;
}

export interface UserAudit {
    creationDate: Date;
    modificationDate: Date;
    createdByUser?: string | undefined;
    modifiedByUser?: string | undefined;
}

export enum ContentType {
    Unknown = <any>"Unknown", 
    Bitmap = <any>"Bitmap", 
    VectorGraphic = <any>"VectorGraphic", 
    RawImage = <any>"RawImage", 
    InterchangeDocument = <any>"InterchangeDocument", 
    WordProcessingDocument = <any>"WordProcessingDocument", 
    TextDocument = <any>"TextDocument", 
    DesktopPublishingDocument = <any>"DesktopPublishingDocument", 
    Presentation = <any>"Presentation", 
    Spreadsheet = <any>"Spreadsheet", 
    Archive = <any>"Archive", 
    Audio = <any>"Audio", 
    Video = <any>"Video", 
    Font = <any>"Font", 
    Multimedia = <any>"Multimedia", 
    Application = <any>"Application", 
    SourceCode = <any>"SourceCode", 
    Database = <any>"Database", 
    Cad = <any>"Cad", 
    Model3d = <any>"Model3d", 
}

export interface DisplayValueDictionary {

    [key: string]: string | any; 
}

export enum EntityType {
    Content = <any>"Content", 
    BasicShare = <any>"BasicShare", 
    EmbedShare = <any>"EmbedShare", 
    Metadata = <any>"Metadata", 
    FileTransfer = <any>"FileTransfer", 
}

export interface DataDictionary {

    [key: string]: any; 
}

export interface Output {
    id?: string | undefined;
    outputFormatId?: string | undefined;
    contentId?: string | undefined;
    detail?: OutputDetailBase | undefined;
}

export interface OutputDetailBase {
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
}

export interface OutputDetailImage extends OutputDetailBase {
    width: number;
    height: number;
}

export interface OutputDetailAudio extends OutputDetailBase {
    durationInSeconds?: number | undefined;
}

export interface OutputDetailVideo extends OutputDetailBase {
    durationInSeconds: number;
    width: number;
    height: number;
    sprites?: Sprite[] | undefined;
}

export interface Sprite {
    width: number;
    height: number;
    y: number;
    x: number;
    start: string;
    end: string;
}

export interface OutputDetailDocument extends OutputDetailBase {
    pageCount: number;
}

export interface OutputDetailDefault extends OutputDetailBase {
}

export interface OutputDetail extends Output {
}

export interface Exception {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export interface PictureparkException extends Exception {
    traceLevel: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode: number;
}

export enum TraceLevel {
    Critical = <any>"Critical", 
    Error = <any>"Error", 
    Warning = <any>"Warning", 
    Information = <any>"Information", 
    Verbose = <any>"Verbose", 
}

export interface PictureparkBusinessException extends PictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export interface PictureparkApplicationException extends PictureparkBusinessException {
}

export interface PictureparkArgumentNullException extends PictureparkBusinessException {
    argumentName?: string | undefined;
}

export interface ContentNotFoundException extends PictureparkBusinessException {
    contentId?: string | undefined;
}

export interface BusinessProcessDefinitionCreateException extends PictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export interface BusinessProcessDefinitionNotFoundException extends PictureparkBusinessException {
    processDefinitionId?: string | undefined;
}

export interface BusinessProcessNotFoundException extends PictureparkBusinessException {
    businessProcessId?: string | undefined;
}

export interface CustomerHostNotFoundException extends PictureparkException {
    hostName?: string | undefined;
}

export interface CustomerNotFoundException extends PictureparkException {
    customerId?: string | undefined;
}

export interface DocumentNotFoundException extends PictureparkBusinessException {
    documentId?: string | undefined;
}

export interface DocumentVersionNotFoundException extends PictureparkBusinessException {
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export interface DriveRequestException extends PictureparkBusinessException {
}

export interface DuplicateRightException extends PictureparkBusinessException {
    permissionSetId?: string | undefined;
}

export interface DuplicateDocumentException extends PictureparkBusinessException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export interface DuplicateAggregatorException extends PictureparkBusinessException {
    aggregatorName?: string | undefined;
}

export interface FailedToLockException extends PictureparkBusinessException {
    resourceId?: string | undefined;
}

export interface IndexException extends PictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export interface InvalidArgumentException extends PictureparkBusinessException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export interface InvalidCustomerException extends PictureparkException {
    customerId?: string | undefined;
}

export interface PictureparkInvalidMetadataException extends PictureparkBusinessException {
    metadataErrors?: MetadataError[] | undefined;
}

export interface MetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export interface InvalidStateException extends PictureparkBusinessException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export interface InvalidStateTransitionException extends InvalidStateException {
    transition?: string | undefined;
}

export interface InvalidUserOrPasswordException extends PictureparkException {
    customerId?: string | undefined;
}

export interface PictureparkMappingException extends PictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export interface MessagePerformerTaskCanceledException extends PictureparkException {
    messageId?: string | undefined;
    customerId?: string | undefined;
}

export interface NotFoundException extends PictureparkBusinessException {
    reference?: string | undefined;
}

export interface ObjectStoreException extends PictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
}

export interface ObjectStoreResponseException extends PictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export interface PictureparkOperationCanceledException extends PictureparkBusinessException {
}

export interface OperationTimeoutException extends PictureparkBusinessException {
}

export interface OutputNotFoundException extends PictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export interface PermissionException extends PictureparkBusinessException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export interface QueryException extends PictureparkBusinessException {
    debugInformation?: string | undefined;
    serverError?: StorageServerError | undefined;
}

export interface StorageServerError {
    error?: StorageError | undefined;
    status: number;
}

export interface StorageError {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
    rootCause?: StorageRootCause[] | undefined;
    causedBy?: StorageCausedBy | undefined;
}

export interface StorageRootCause {
    index?: string | undefined;
    reason?: string | undefined;
    resourceId?: string | undefined;
    resourceType?: string | undefined;
    type?: string | undefined;
}

export interface StorageCausedBy {
    reason?: string | undefined;
    type?: string | undefined;
    innerCausedBy?: StorageCausedBy | undefined;
}

export interface RenderingException extends PictureparkBusinessException {
}

export interface RenderingJobItemNotSetException extends PictureparkBusinessException {
}

export interface ServiceProviderCreateException extends PictureparkException {
    userId?: string | undefined;
    externalId?: string | undefined;
    virtualHost?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export interface ServiceProviderDeleteException extends PictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export interface ServiceProviderNotFoundException extends PictureparkException {
    missingServiceProviderId?: string | undefined;
}

export interface TokenValidationException extends PictureparkBusinessException {
}

export interface UnknownException extends PictureparkBusinessException {
    exceptionDetail?: string | undefined;
}

export interface UserNotFoundException extends PictureparkBusinessException {
    missingUserId?: string | undefined;
}

export interface UserPermanentlyRemovedException extends PictureparkBusinessException {
    removedUserId?: string | undefined;
}

export interface UserRoleAssignedException extends PictureparkBusinessException {
    userRoleId?: string | undefined;
}

export interface UserRolesRightsAssignedException extends PictureparkBusinessException {
    contentPermissionSetId?: string | undefined;
}

export interface ContentsOwnershipTransferRequest {
    /** The content ids. */
    contentIds?: string[] | undefined;
    /** The id of user to whom the content documents have to be transfered to. */
    transferUserId?: string | undefined;
}

export interface BusinessProcess {
    id?: string | undefined;
    processDefinitionId?: string | undefined;
    referenceId?: string | undefined;
    referenceDocType?: string | undefined;
    notificationId?: string | undefined;
    businessProcessScope: BusinessProcessScope;
    lifeCycle: BusinessProcessLifeCylce;
    startDate: Date;
    endDate: Date;
    stateHistory?: BusinessProcessStateItem[] | undefined;
    processDefinitionName?: string | undefined;
    currentState?: string | undefined;
}

export enum BusinessProcessScope {
    System = <any>"System", 
    User = <any>"User", 
}

export enum BusinessProcessLifeCylce {
    Draft = <any>"Draft", 
    Started = <any>"Started", 
    Ended = <any>"Ended", 
    Cancelled = <any>"Cancelled", 
}

export interface BusinessProcessStateItem {
    state?: string | undefined;
    timestamp: Date;
    error?: ErrorResponse | undefined;
}

export interface ErrorResponse {
    exception?: string | undefined;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
}

export interface BusinessProcessBulkResponse extends BusinessProcess {
    response?: BulkResponse | undefined;
}

export interface BulkResponse {
    rows?: BulkResponseRow[] | undefined;
}

export interface BulkResponseRow {
    id?: string | undefined;
    version: number;
    error?: string | undefined;
    reason?: string | undefined;
    succeeded: boolean;
}

export interface ContentAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages in configured within the customer's language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
}

/** The FilterBase is the base class for all filters. */
export interface FilterBase {
}

/** The AndFilter> is a compound filter and returns documents that match all of the specified filters. */
export interface AndFilter extends FilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The OrFilter is a compound filter and returns documents that match any of the specified filters. */
export interface OrFilter extends FilterBase {
    /** Accepts all filters. */
    filters?: FilterBase[] | undefined;
}

/** The NotFilter is a compound filter and returns documents that do not match the specified filter. */
export interface NotFilter extends FilterBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The DateRangeFilter returns documents with fields that have date values within a certain range. */
export interface DateRangeFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The date range. Supported pattern: now(+-)(int)(YMDHm). */
    range?: DateRange | undefined;
}

/** The date range class used in aggregators and filters. */
export interface DateRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

export interface TranslatedStringDictionary {

    [key: string]: string | any; 
}

/** The ExistsFilter returns documents that have at least one non-null value in the original field. */
export interface ExistsFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
}

/** The GeoBoundingBoxFilter returns documents that are found based on a point location using a bounding box. */
export interface GeoBoundingBoxFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The top left longitude/latitude configuration. */
    topLeft?: GeoLocation | undefined;
    /** The bottom right longitude/latitude configuration. */
    bottomRight?: GeoLocation | undefined;
}

export interface GeoLocation {
    lat: number;
    lon: number;
}

/** The GeoDistanceRangeFilter returns documents that include only hits that exists within a specific distance from a geo point. */
export interface GeoDistanceFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The range distance in meters. */
    distance: number;
}

/** The GeoDistanceRangeFilter returns documents that exists within a range from a specific point. */
export interface GeoDistanceRangeFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The longitude/latitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** The numeric range. */
    range?: NumericRange | undefined;
}

export interface NumericRange {
    /** Tranlsated range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** The NestedFilter is a joining filter and returns documents whose nested objects / documents (see nested mapping) match the specified filter. */
export interface NestedFilter extends FilterBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The NumericRangeFilter returns documents with fields that have numeric values within a certain range. */
export interface NumericRangeFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The numeric range with from and to properties. */
    range?: NumericRange | undefined;
}

/** The PrefixFilter returns documents that have fields containing terms with a specified prefix (not analyzed). */
export interface PrefixFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The prefix term to filter on. */
    prefix?: string | undefined;
}

/** The TermFilter returns documents that contain the exact term specified in the inverted index. */
export interface TermFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** The term to filter on. */
    term?: string | undefined;
}

/** The TermsFilter returns documents that have fields that match any of the provided terms (not analyzed). */
export interface TermsFilter extends FilterBase {
    /** The elastic search index field to execute the filter on. */
    field?: string | undefined;
    /** A list of OR combined terms. */
    terms?: string[] | undefined;
}

/** An AggregationFilter is provided with each aggregated value. When selecting the aggregated value the aggregation filter is added to the search query and returns doucments meeting the aggregation condition. */
export interface AggregationFilter extends FilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The aggregation filter property. Available filters are TermFilter, DateRangeFilter, NumericRangeFilter and GeoDistanceRangeFilter. */
    filter?: FilterBase | undefined;
    temporaryAggregatorRequestId?: string | undefined;
}

/** The ChildFilter allows to apply filters on child documents and returns documents that match the specified filter on the child document. */
export interface ChildFilter extends FilterBase {
    /** The elastic search index type to filter as a child. */
    childType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The ParentFilter allows to apply filters on parent documents and returns documents that match the specified filter on the parent document. */
export interface ParentFilter extends FilterBase {
    /** The elastic search index type to filter as a parent. */
    parentType?: string | undefined;
    /** The filter to apply on the child entity. It accepts all filters. */
    filter?: FilterBase | undefined;
}

/** The AggregatorBase is the base class for all aggregators. */
export interface AggregatorBase {
    /** The slug name of the aggregation. Must be unique per aggregation request. */
    name?: string | undefined;
    /** The translated names of the aggregation. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
}

/** The DateRangeAggregator is a multi-bucket range aggregation dedicated for date values. Each bucket represents a range. */
export interface DateRangeAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of date ranges. Supported pattern: now(+-)(int)(YMDHm). */
    ranges?: DateRange[] | undefined;
}

/** The FilterAggregator is a single bucket aggregation of documents that match a specified filter. */
export interface FilterAggregator extends AggregatorBase {
    /** Limits the result set. */
    filter?: FilterBase | undefined;
}

/** The GeoDistanceAggregator is a multi-bucket range aggregation that works on geo_point fields. Each bucket represents a range. */
export interface GeoDistanceAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** The latitude/logitude configuration for the point of origin. */
    location?: GeoLocation | undefined;
    /** A list of numeric ranges in meter. */
    ranges?: NumericRange[] | undefined;
}

/** The NestedAggregator is a special single bucket aggregation that enables aggregating nested documents. */
export interface NestedAggregator extends AggregatorBase {
    /** The path pointing to the nested object. */
    path?: string | undefined;
}

/** The NumericRangeAggregator is a multi-bucket range aggregation. Each bucket represents a range. */
export interface NumericRangeAggregator extends AggregatorBase {
    /** The elastic search index field to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges. */
    ranges?: NumericRange[] | undefined;
}

/** The TermsAggregator is a multi-bucket value aggregation where buckets are dynamically built - one per unique value. */
export interface TermsAggregator extends AggregatorBase {
    /** The elastic search index field (not analyzed) to execute the aggregation on. */
    field?: string | undefined;
    /** The size parameter can be set to define how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
}

/** The TermsRelationAggregator is derived from TermsAggregator and used for aggregations on relation item ids. */
export interface TermsRelationAggregator extends TermsAggregator {
    /** When aggregating on relations ids the DocumentType is needed to resolve the target item translation. */
    documentType: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    Schema = <any>"Schema", 
    User = <any>"User", 
    ContentPermissionSet = <any>"ContentPermissionSet", 
    Owner = <any>"Owner", 
}

/** The TermsRelationAggregator is derived from the TermsAggregator and used for aggregations on indexed enum values. */
export interface TermsEnumAggregator extends TermsAggregator {
    /** When aggregating on enum fields EnumType is needed to resolve the enum translation. */
    enumType?: string | undefined;
}

export enum LifeCycleFilter {
    ActiveOnly = <any>"ActiveOnly", 
    All = <any>"All", 
    InactiveOnly = <any>"InactiveOnly", 
}

export enum ContentSearchType {
    Metadata = <any>"Metadata", 
    FullText = <any>"FullText", 
    MetadataAndFullText = <any>"MetadataAndFullText", 
}

export interface ObjectAggregationResult {
    elapsedMilliseconds: number;
    aggregationResults?: AggregationResult[] | undefined;
    /** The search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one */
    isSearchStringRewritten: boolean;
}

export interface AggregationResult {
    name?: string | undefined;
    sumOtherDocCount?: number | undefined;
    temporaryRequestId?: string | undefined;
    aggregationResultItems?: AggregationResultItem[] | undefined;
}

export interface AggregationResultItem {
    name?: string | undefined;
    count: number;
    filter?: AggregationFilter | undefined;
    active: boolean;
    aggregationResults?: AggregationResult[] | undefined;
}

export interface ContentBatchDownloadRequest {
    contents?: ContentBatchDownloadRequestItem[] | undefined;
}

export interface ContentBatchDownloadRequestItem {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export interface DownloadItem {
}

export interface ContentBatchDownloadItem extends DownloadItem {
    downloadToken?: string | undefined;
    downloadUrl?: string | undefined;
}

/** A request structure for creating a content document. */
export interface CreateContentRequest {
    /** The id of a schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content document. */
    content?: any | undefined;
    /** The layer metadata of the content document. */
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets.  */
    contentPermissionSetIds?: string[] | undefined;
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = <any>"Small", 
    Medium = <any>"Medium", 
    Large = <any>"Large", 
}

export interface UpdateContentPermissionsRequest {
    /** The content id. */
    contentId?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export interface ContentSearchRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** The collection id. */
    collectionId?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
}

export interface SortInfo {
    field?: string | undefined;
    direction: SortDirection;
}

export enum SortDirection {
    Asc = <any>"Asc", 
    Desc = <any>"Desc", 
}

export enum ContentRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Update = <any>"Update", 
    Manage = <any>"Manage", 
    Trash = <any>"Trash", 
}

export interface BaseResultOfContent {
    totalResults: number;
    results?: Content[] | undefined;
    pageToken?: string | undefined;
}

export interface ContentSearchResult extends BaseResultOfContent {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export interface Content {
    audit?: UserAudit | undefined;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues?: { [key: string] : string; } | undefined;
    id?: string | undefined;
}

export interface ContentFileUpdateRequest {
    contentId?: string | undefined;
    fileTransferId?: string | undefined;
}

export interface UpdateContentMetadataRequest {
    /** The content id. */
    id?: string | undefined;
    /** An id list of schemas with schema type content or layer. */
    schemaIds?: string[] | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with schema type content or layer. */
    metadata?: DataDictionary | undefined;
}

export interface ContentDeactivationRequest {
    contentIds?: string[] | undefined;
}

export interface ContentReactivationRequest {
    contentIds?: string[] | undefined;
}

export interface MetadataValuesChangeRequestBase {
    /** A container for all change commads. */
    changeCommands?: MetadataValuesChangeCommandBase[] | undefined;
}

export interface ContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase {
    /** The ids of the content documents. */
    contentIds?: string[] | undefined;
}

/** The base class for metadata value change commands. */
export interface MetadataValuesChangeCommandBase {
}

/** Updates schema values. */
export interface MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Adds or updates schema values. */
export interface MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase {
    /** The id of the schema with type content or layer to be updated. */
    schemaId?: string | undefined;
    /** The metadata values containing a set of changes. Update is additive and will not remove values. To remove complete fields use the MetadataValuesFieldRemoveCommand instead. */
    value?: DataDictionary | undefined;
}

/** Removes schema values. */
export interface MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The id of the schema with type layer to be removed. */
    schemaId?: string | undefined;
}

/** Removes a field and its value from the schema values. */
export interface MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The fully qualified field name of the field to be removed, e.g. "Data.SchemaId.FieldId". */
    fieldNamespace?: string | undefined;
}

/** Adds a list item id reference to a multi tagbox. */
export interface MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be added. */
    referenceId?: string | undefined;
}

/** Removes a list item id reference from a multi tagbox. */
export interface MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase {
    /** The fully qualified field name of the multi tagbox field. */
    fieldNamespace?: string | undefined;
    /** The id of the list item to be removed. */
    referenceId?: string | undefined;
}

export interface FilterContentsMetadataUpdateRequest extends MetadataValuesChangeRequestBase {
    contentSearchRequest?: ContentSearchRequest | undefined;
    totalItemsCount: number;
}

export interface BusinessProcessSearchRequest {
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
}

export interface BaseResultOfBusinessProcess {
    totalResults: number;
    results?: BusinessProcess[] | undefined;
    pageToken?: string | undefined;
}

export interface BusinessProcessSearchResult extends BaseResultOfBusinessProcess {
    elapsedMilliseconds: number;
}

export interface StartProcessRequest {
    variables?: any | undefined;
}

export interface SendMessageRequest {
    messageName?: string | undefined;
    variables?: any | undefined;
}

export interface BusinessProcessWaitResult {
    hasStateHit: boolean;
    processEnded: boolean;
    stateHit?: string | undefined;
    businessProcess?: BusinessProcess | undefined;
}

export interface DocumentHistorySearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
}

export interface DocumentHistorySearchResult {
    totalResults: number;
    results?: DocumentHistory[] | undefined;
    pageToken?: string | undefined;
    elapsedMilliseconds: number;
}

export interface DocumentHistory {
    id?: string | undefined;
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentTypeContract?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: UserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;
}

export interface UserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;
}

export enum DocumentChangeAction {
    Create = <any>"Create", 
    Update = <any>"Update", 
    Delete = <any>"Delete", 
    Activate = <any>"Activate", 
    Deactivate = <any>"Deactivate", 
}

export interface DocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    oldValues?: any | undefined;
    newValues?: any | undefined;
}

/** A request structure for creating a list item document. */
export interface ListItemCreateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** The list item id. When not provided a Guid is generated. */
    listItemId?: string | undefined;
}

/** The detail view item for the list item. */
export interface ListItemDetail {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;
}

export interface ListItemAggregationRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down on a specific aggregated value. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Defines the aggregation resultset. */
    aggregators?: AggregatorBase[] | undefined;
    /** Broadens the aggregation and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
}

export interface ListItemSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the list item result set. */
    filter?: FilterBase | undefined;
    /** Broadens the search and include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search to list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** Defines the return language of translation values. Defaults to x-default. */
    displayLanguage?: string | undefined;
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Define the display values included in the search response for the referenced fields. Defaults to no display value. */
    referencedFieldsDisplayPatternIds?: string[] | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** When set to true the content data is included in the result items. */
    includeMetadata: boolean;
}

export interface BaseResultOfListItem {
    totalResults: number;
    results?: ListItem[] | undefined;
    pageToken?: string | undefined;
}

/** Encapsulates the result of a list item search. */
export interface ListItemSearchResult extends BaseResultOfListItem {
}

/** A document stored in the elastic search metadata index, with fields corresponding to the the schemantics of its underlying list schema. */
export interface ListItem {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The id of the schema with schema type list. */
    contentSchemaId?: string | undefined;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The entity type of the list item is metadata. */
    entityType: EntityType;
    /** The list item id. */
    id?: string | undefined;
}

/** A request structure for updating a list item. */
export interface ListItemUpdateRequest {
    /** The content data of the list item. */
    content?: any | undefined;
    /** The list item id. */
    id?: string | undefined;
}

/** ListItemFieldsFilterUpdateRequest class */
export interface ListItemFieldsFilterUpdateRequest {
    /** The search request used to filter the list items on which the change commands must be applied */
    searchRequest?: ListItemSearchRequest | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesSchemaUpdateCommand[] | undefined;
}

export interface ListItemFieldsUpdateRequest {
    /** The ids of the list items whose fields need to be updated */
    listItemIds?: string[] | undefined;
    /** The change commads to be applied to the list items */
    changeCommands?: MetadataValuesSchemaUpdateCommand[] | undefined;
}

export interface LiveStreamSearchRequest {
    from: Date;
    to: Date;
    start: number;
    limit: number;
    pageToken?: string | undefined;
}

export interface BaseResultOfObject {
    totalResults: number;
    results?: any[] | undefined;
    pageToken?: string | undefined;
}

export interface RewritableBaseResultOfObject extends BaseResultOfObject {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export interface ObjectSearchResult extends RewritableBaseResultOfObject {
    elapsedMilliseconds: number;
}

export interface SchemaDetail {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Is true when schema is system provided. */
    system: boolean;
    /** The owner token id. Defines the schema owner. */
    ownerTokenId?: string | undefined;
    /** Opens list item document accessibility. If true the SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** A complete id list of all descendant schemas. */
    descendantSchemaIds?: string[] | undefined;
    audit?: UserAudit | undefined;
    /** The number of fields generated by the schema for the Search operations. */
    searchFieldCount?: SearchFieldCount | undefined;
}

export enum SchemaType {
    Content = <any>"Content", 
    Layer = <any>"Layer", 
    List = <any>"List", 
    Struct = <any>"Struct", 
}

export interface DisplayPattern {
    id?: string | undefined;
    templateEngine: TemplateEngine;
    displayPatternType: DisplayPatternType;
    templates?: TranslatedStringDictionary | undefined;
}

export enum TemplateEngine {
    DotLiquid = <any>"DotLiquid", 
}

export enum DisplayPatternType {
    Thumbnail = <any>"Thumbnail", 
    List = <any>"List", 
    Detail = <any>"Detail", 
    Custom = <any>"Custom", 
    Name = <any>"Name", 
}

export interface FieldBase {
    id?: string | undefined;
    indexId?: string | undefined;
    fieldNamespace?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    required: boolean;
    fixed: boolean;
    index: boolean;
    simpleSearch: boolean;
    boost: number;
}

export interface FieldBoolean extends FieldBase {
}

export interface FieldDate extends FieldBase {
    format?: string | undefined;
}

export interface FieldDateTime extends FieldBase {
    format?: string | undefined;
}

export interface FieldDateTimeArray extends FieldDateTime {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export interface FieldDecimal extends FieldBase {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export interface FieldDictionary extends FieldBase {
}

export interface FieldDictionaryArray extends FieldDictionary {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export interface FieldGeoPoint extends FieldBase {
}

export interface FieldLong extends FieldBase {
    pattern?: string | undefined;
    minimum?: number | undefined;
    maximum?: number | undefined;
}

export interface FieldLongArray extends FieldLong {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export interface FieldSingleFieldset extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
}

export interface SchemaIndexingInfo {
    fields?: FieldIndexingInfo[] | undefined;
}

export interface FieldIndexingInfo {
    id?: string | undefined;
    index: boolean;
    simpleSearch: boolean;
    boost: number;
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;
}

export interface FieldMultiFieldset extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export interface FieldSingleTagbox extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;
}

export interface FieldMultiTagbox extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
    filter?: FilterBase | undefined;
    listItemCreateTemplate?: string | undefined;
}

export interface FieldString extends FieldBase {
    template?: string | undefined;
    keepFieldValue: boolean;
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    grantedValues?: string[] | undefined;
}

/** The analyzer base class. */
export interface AnalyzerBase {
    /** Includes the analyzed field in the simple search. */
    simpleSearch: boolean;
}

/** An analyzer using the EdgeNGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-edgengram-tokenizer.html */
export interface EdgeNGramAnalyzer extends AnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a language analyzer. Restricted to the languages supported by elastic search. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html */
export interface LanguageAnalyzer extends AnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the NGram tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html */
export interface NGramAnalyzer extends AnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using the path hierarchy tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pathhierarchy-tokenizer.html */
export interface PathHierarchyAnalyzer extends AnalyzerBase {
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer. https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html */
export interface SimpleAnalyzer extends AnalyzerBase {
    fieldSuffix?: string | undefined;
}

export interface FieldStringArray extends FieldString {
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

export interface FieldTranslatedString extends FieldBase {
    pattern?: string | undefined;
    minimumLength?: number | undefined;
    maximumLength?: number | undefined;
    analyzers?: AnalyzerBase[] | undefined;
    multiLine: boolean;
    requiredMetadataLanguages?: string[] | undefined;
    template?: string | undefined;
    keepFieldValue: boolean;
}

export interface FieldSingleRelation extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;
}

export interface RelationType {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    targetContext: TargetContext;
    schemaId?: string | undefined;
    filter?: FilterBase | undefined;
}

export enum TargetContext {
    Content = <any>"Content", 
    ListItem = <any>"ListItem", 
    User = <any>"User", 
    Custom = <any>"Custom", 
}

export interface FieldMultiRelation extends FieldBase {
    schemaId?: string | undefined;
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    relationTypes?: RelationType[] | undefined;
    maxRecursion: number;
    uniqueItems: boolean;
    maximumItems?: number | undefined;
    minimumItems?: number | undefined;
}

/** Count info of fields for search operations */
export interface SearchFieldCount {
    /** The number of fields generated by the schema in the Search index. */
    dataField: number;
    /** The number of indexed fields generated by the schema in the Search index. */
    indexedField: number;
    /** The number of fields to be queried in the simple search for the schema. */
    simpleSearchField: number;
}

/** Response that tells if exists */
export interface ExistsResponse {
    /** Gets or sets a value indicating whether it exists */
    exists: boolean;
}

export interface SchemaCreateRequest {
    /** The schema id. Can be a slug, but must be unique throughout the whole customer setup. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. Can be empty. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and/or list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens list item document accessibility. If true SchemaPermissionSetIds must be empty. */
    public: boolean;
    /** An optional id list of schema permission sets. Control list item document permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
}

export interface SchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** An optional list of aggregations to group content documents and list items. */
    aggregations?: AggregatorBase[] | undefined;
    /** A simple ordering property for schemas. */
    sortOrder: number;
    /** Sorts content documents and/or list items. */
    sort?: SortInfo[] | undefined;
    /** Opens schema accessibility. */
    public: boolean;
    /** An optional id list of schema permission sets which control list item permissions. When not empty Public must be false. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** An optional id list of schemas with type content for a schema with type layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Types control schema usage. Schema types can only be added, but not removed. */
    types?: SchemaType[] | undefined;
}

export interface SchemaSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to *. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the schema result set. */
    filter?: FilterBase | undefined;
}

export interface BaseResultOfSchema {
    totalResults: number;
    results?: Schema[] | undefined;
    pageToken?: string | undefined;
}

export interface RewritableBaseResultOfSchema extends BaseResultOfSchema {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export interface SchemaSearchResult extends RewritableBaseResultOfSchema {
}

export interface Schema {
    /** The schema id. */
    id?: string | undefined;
    /** The parent schema id. */
    parentSchemaId?: string | undefined;
    /** Types control schema usage. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with a immediate inheritance. */
    childCount: number;
    /** The descendancy depth of the schema. */
    level: number;
    /** Is true when schema is system provided. */
    system: boolean;
}

export enum UserRight {
    ManageContent = <any>"ManageContent", 
    ManageSharings = <any>"ManageSharings", 
    ManageDrives = <any>"ManageDrives", 
    ManageTransfer = <any>"ManageTransfer", 
    ManageChannels = <any>"ManageChannels", 
    ManageSchemas = <any>"ManageSchemas", 
    ManageUsers = <any>"ManageUsers", 
    ManageUserRoles = <any>"ManageUserRoles", 
    ManagePermissions = <any>"ManagePermissions", 
    ManageSearchIndexes = <any>"ManageSearchIndexes", 
    ManageRecipients = <any>"ManageRecipients", 
    ManageCollections = <any>"ManageCollections", 
    ManageListItems = <any>"ManageListItems", 
    ManageServiceProviders = <any>"ManageServiceProviders", 
    ManageEmbeds = <any>"ManageEmbeds", 
    ManageTemplates = <any>"ManageTemplates", 
}

export interface PermissionSetSearchRequest {
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    rightFilter?: PermissionSetRight | undefined;
}

export enum PermissionSetRight {
    Apply = <any>"Apply", 
}

export interface BaseResultOfPermissionSet {
    totalResults: number;
    results?: PermissionSet[] | undefined;
    pageToken?: string | undefined;
}

export interface RewritableBaseResultOfPermissionSet extends BaseResultOfPermissionSet {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export interface PermissionSetSearchResult extends RewritableBaseResultOfPermissionSet {
    aggregationResults?: AggregationResult[] | undefined;
    elapsedMilliseconds: number;
}

export interface PermissionSet {
    /** The permission set id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific permission set names. */
    names?: TranslatedStringDictionary | undefined;
}

export interface PermissionSetDetailOfContentRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export interface ContentPermissionSetDetail extends PermissionSetDetailOfContentRight {
}

export interface PermissionUserRoleRightsOfContentRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: ContentRight[] | undefined;
}

export interface PermissionUserRoleRightsOfPermissionSetRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: PermissionSetRight[] | undefined;
}

export interface PermissionSetDetailOfMetadataRight {
    id?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    trashed: boolean;
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    exclusive: boolean;
}

export interface SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight {
}

export interface PermissionUserRoleRightsOfMetadataRight {
    userRoleId?: string | undefined;
    names?: TranslatedStringDictionary | undefined;
    rights?: MetadataRight[] | undefined;
}

export enum MetadataRight {
    View = <any>"View", 
    Edit = <any>"Edit", 
    Manage = <any>"Manage", 
}

export interface VersionInfo {
    comments?: string | undefined;
    event?: Event | undefined;
    modifier?: string | undefined;
    modifyDate?: Date | undefined;
    version?: string | undefined;
}

export interface Event {
    action?: EventAction | undefined;
    changed?: string | undefined;
    instanceID?: string | undefined;
    parameters?: string | undefined;
    softwareAgent?: string | undefined;
    when?: Date | undefined;
}

/** Corresponds to stEvt.ActionChoice */
export enum EventAction {
    Converted = <any>"Converted", 
    Copied = <any>"Copied", 
    Created = <any>"Created", 
    Cropped = <any>"Cropped", 
    Edited = <any>"Edited", 
    Filtered = <any>"Filtered", 
    Formatted = <any>"Formatted", 
    VersionUpdated = <any>"VersionUpdated", 
    Printed = <any>"Printed", 
    Published = <any>"Published", 
    Managed = <any>"Managed", 
    Produced = <any>"Produced", 
    Resized = <any>"Resized", 
    Saved = <any>"Saved", 
    Derived = <any>"Derived", 
}

export interface ShareBaseDetail {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    audit?: UserAudit | undefined;
    entityType: EntityType;
    contentSelections?: ContentDetail2[] | undefined;
    layerSchemaIds?: string[] | undefined;
    mailTemplateId?: string | undefined;
    expirationDate?: Date | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export interface ContentDetail2 {
    trashed: boolean;
    /** The entity type of a content document is content. */
    entityType: EntityType;
    /** The id of the schema with schema type content. */
    contentSchemaId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    content?: DataDictionary | undefined;
    metadata?: DataDictionary | undefined;
    id?: string | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
    outputs?: Output[] | undefined;
    audit?: UserAudit | undefined;
    ownerTokenId?: string | undefined;
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
}

export interface TemplateBase {
    width?: number | undefined;
    height?: number | undefined;
}

export interface CardTemplate extends TemplateBase {
    showNavigation: boolean;
    showOverlay: boolean;
    showLogo: boolean;
    showFooter: boolean;
}

export interface ListTemplate extends TemplateBase {
}

export interface BasicTemplate extends TemplateBase {
}

export enum OutputAccess {
    Full = <any>"Full", 
    Preview = <any>"Preview", 
    None = <any>"None", 
}

export interface ShareBasicDetail extends ShareBaseDetail {
    url?: string | undefined;
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    languageCode?: string | undefined;
}

export interface MailRecipient {
    userEmail?: UserEmail | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export interface UserEmail {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export interface InternalRecipient {
    recipient?: UserItem | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export interface UserItem {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
}

export interface ShareEmbedDetail extends ShareBaseDetail {
    embedContentItems?: EmbedContentDetail[] | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export interface EmbedContentDetail {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    token?: string | undefined;
    url?: string | undefined;
}

export interface ShareBaseUpdateRequest {
    id?: string | undefined;
    name?: string | undefined;
    expirationDate?: Date | undefined;
    description?: string | undefined;
    shareContentItems?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export interface ShareContent {
    contentId?: string | undefined;
    outputFormatIds?: string[] | undefined;
}

export interface ShareBasicUpdateRequest extends ShareBaseUpdateRequest {
}

export interface ShareEmbedUpdateRequest extends ShareBaseUpdateRequest {
}

export interface BaseResultOfShareBase {
    totalResults: number;
    results?: ShareBase[] | undefined;
    pageToken?: string | undefined;
}

export interface ShareBase {
    name?: string | undefined;
    contentIds?: string[] | undefined;
    id?: string | undefined;
    audit?: UserAudit | undefined;
    entityType: EntityType;
    expirationDate?: Date | undefined;
}

export interface ShareBasic extends ShareBase {
    mailRecipients?: MailRecipient[] | undefined;
    internalRecipients?: InternalRecipient[] | undefined;
    description?: string | undefined;
}

export interface ShareEmbed extends ShareBase {
}

export interface ShareAggregationRequest {
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    sort?: SortInfo[] | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    aggregationFilters?: AggregationFilter[] | undefined;
    aggregators?: AggregatorBase[] | undefined;
    displayLanguage?: string | undefined;
}

export interface ShareBaseCreateRequest {
    name?: string | undefined;
    description?: string | undefined;
    expirationDate?: Date | undefined;
    contents?: ShareContent[] | undefined;
    layerSchemaIds?: string[] | undefined;
    template?: TemplateBase | undefined;
    outputAccess: OutputAccess;
}

export interface ShareBasicCreateRequest extends ShareBaseCreateRequest {
    recipientsEmail?: UserEmail[] | undefined;
    recipientsUser?: UserItem[] | undefined;
    recipientsGroup?: UserRole[] | undefined;
    languageCode?: string | undefined;
    mailTemplateId?: string | undefined;
}

export interface UserRole {
    /** The user role id. */
    id?: string | undefined;
    trashed: boolean;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** All user rights for this user role. */
    userRights?: UserRight[] | undefined;
}

export interface ShareEmbedCreateRequest extends ShareBaseCreateRequest {
}

export interface CreateShareResult {
    shareId?: string | undefined;
}

export interface ShareSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. Defaults to empty. */
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Defines the offset from the first result you want to fetch. Defaults to 0. */
    start: number;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** An optional search filter. Limits the share document result set. */
    filter?: FilterBase | undefined;
}

export interface RewritableBaseResultOfShareBase extends BaseResultOfShareBase {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export interface ShareSearchResult extends RewritableBaseResultOfShareBase {
    elapsedMilliseconds: number;
}

export interface FileTransferDeleteRequest {
    transferId?: string | undefined;
    fileTransferIds?: string[] | undefined;
}

export interface Blacklist {
    items?: BlacklistItem[] | undefined;
}

export interface BlacklistItem {
    name?: string | undefined;
    match?: string | undefined;
}

export interface CreateTransferRequest {
    name?: string | undefined;
    transferType: TransferType;
    files?: TransferUploadFile[] | undefined;
    driveFiles?: TransferDriveFile[] | undefined;
    webLinks?: TransferWebLink[] | undefined;
    collectionName?: string | undefined;
    createCollection: boolean;
}

export enum TransferType {
    FileUpload = <any>"FileUpload", 
    DriveImport = <any>"DriveImport", 
    DriveExport = <any>"DriveExport", 
    WebDownload = <any>"WebDownload", 
    SchemaImport = <any>"SchemaImport", 
}

export interface TransferFile {
    identifier?: string | undefined;
}

export interface TransferUploadFile extends TransferFile {
    fileName?: string | undefined;
}

export interface TransferDriveFile extends TransferFile {
    driveId?: string | undefined;
    fileId?: string | undefined;
    name?: string | undefined;
    externalOutputFolderId?: string | undefined;
}

export interface TransferWebLink extends TransferFile {
    url?: string | undefined;
}

export interface Transfer {
    id?: string | undefined;
    name?: string | undefined;
    state: TransferState;
    transferType: TransferType;
    businessProcessId?: string | undefined;
    fileTransferCount: number;
}

export enum TransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    ImportFailed = <any>"ImportFailed", 
    Created = <any>"Created", 
    UploadFailed = <any>"UploadFailed", 
    Deleted = <any>"Deleted", 
    TransferReady = <any>"TransferReady", 
    FileDeleteInProgress = <any>"FileDeleteInProgress", 
    TransferCleanup = <any>"TransferCleanup", 
}

export interface TransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    audit?: UserAudit | undefined;
    name?: string | undefined;
    state: TransferState;
    businessProcessId?: string | undefined;
    transferType: TransferType;
    itemProgress: number;
    itemCount: number;
    itemsFailed: number;
    itemsCancelled: number;
    lastProgressStamp: number;
    fileTransferCount: number;
}

export interface FileTransferDetail {
    id?: string | undefined;
    rev?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    audit?: UserAudit | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    fileMetadata?: FileMetadata | undefined;
    driveMetadata?: DriveMetadata | undefined;
    outputItems?: OutputItem[] | undefined;
    contentId?: string | undefined;
}

export enum FileTransferState {
    Draft = <any>"Draft", 
    UploadInProgress = <any>"UploadInProgress", 
    UploadCompleted = <any>"UploadCompleted", 
    DataExtractionInProgress = <any>"DataExtractionInProgress", 
    DataExtractionDone = <any>"DataExtractionDone", 
    ImportInProgress = <any>"ImportInProgress", 
    ImportCompleted = <any>"ImportCompleted", 
    UploadCancelled = <any>"UploadCancelled", 
    ImportCancelled = <any>"ImportCancelled", 
    UploadFailed = <any>"UploadFailed", 
    ImportFailed = <any>"ImportFailed", 
    DeleteInProgress = <any>"DeleteInProgress", 
    Deleted = <any>"Deleted", 
    CleanupInProgress = <any>"CleanupInProgress", 
    CleanupCompleted = <any>"CleanupCompleted", 
}

export interface FileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: XmpMetadata | undefined;
    exifMetadata?: ExifMetadata | undefined;
    language?: string | undefined;
}

export interface XmpMetadata {
    dc?: Dc | undefined;
    crs?: Crs | undefined;
    iptcCore?: IptcCore | undefined;
    iptcExt?: IptcExt | undefined;
    iptcIIM?: IptcIIM | undefined;
    lr?: Lr | undefined;
    pdf?: Pdf | undefined;
    photoshop?: Photoshop | undefined;
    plus?: Plus | undefined;
    tiff?: Tiff | undefined;
    xmp?: Xmp | undefined;
    xmpBJ?: XmpBJ | undefined;
    xmpDM?: XmpDM | undefined;
    xmpG?: XmpG | undefined;
    xmpGImg?: XmpGImg | undefined;
    xmpidq?: Xmpidq | undefined;
    xmpMM?: XmpMM | undefined;
    xmpNote?: XmpNote | undefined;
    xmpRights?: XmpRights | undefined;
    xmpTPg?: XmpTPg | undefined;
}

export interface Dc {
    contributor?: string[] | undefined;
    coverage?: string | undefined;
    creator?: string[] | undefined;
    date?: Date[] | undefined;
    description?: { [key: string] : string; } | undefined;
    format?: string | undefined;
    identifier?: string | undefined;
    language?: string[] | undefined;
    publisher?: string[] | undefined;
    relation?: string[] | undefined;
    rights?: { [key: string] : string; } | undefined;
    source?: string | undefined;
    subject?: string[] | undefined;
    title?: { [key: string] : string; } | undefined;
    type?: string | undefined;
}

export interface Crs {
    autoBrightness?: boolean | undefined;
    autoContrast?: boolean | undefined;
    autoExposure?: boolean | undefined;
    autoShadows?: boolean | undefined;
    blueHue?: number | undefined;
    blueSaturation?: number | undefined;
    brightness?: number | undefined;
    cameraProfile?: string | undefined;
    chromaticAberrationB?: number | undefined;
    chromaticAberrationR?: number | undefined;
    colorNoiseReduction?: number | undefined;
    contrast?: number | undefined;
    cropTop?: number | undefined;
    cropLeft?: number | undefined;
    cropBottom?: number | undefined;
    cropRight?: number | undefined;
    cropAngle?: number | undefined;
    cropWidth?: number | undefined;
    cropHeight?: number | undefined;
    cropUnits?: CropUnit | undefined;
    exposure?: number | undefined;
    greenHue?: number | undefined;
    greenSaturation?: number | undefined;
    hasCrop?: boolean | undefined;
    hasSettings?: boolean | undefined;
    luminanceSmoothing?: number | undefined;
    rawFileName?: string | undefined;
    redHue?: number | undefined;
    redSaturation?: number | undefined;
    saturation?: number | undefined;
    shadows?: number | undefined;
    shadowTint?: number | undefined;
    sharpness?: number | undefined;
    temperature?: number | undefined;
    tint?: number | undefined;
    toneCurve?: string[] | undefined;
    toneCurveName?: ToneCurve | undefined;
    version?: string | undefined;
    vignetteAmount?: number | undefined;
    vignetteMidpoint?: number | undefined;
    whiteBalance?: WhiteBalance | undefined;
}

/** Corresponds to crs.CropUnitsChoice */
export enum CropUnit {
    Pixels = <any>"Pixels", 
    Inches = <any>"Inches", 
    Centimeters = <any>"Centimeters", 
}

/** Corresponds to crs.ToneCurveNameChoice */
export enum ToneCurve {
    Linear = <any>"Linear", 
    MediumContrast = <any>"MediumContrast", 
    StrongContrast = <any>"StrongContrast", 
    Custom = <any>"Custom", 
}

/** Corresponds to crs.WhiteBalanceChoice */
export enum WhiteBalance {
    AsShot = <any>"AsShot", 
    Auto = <any>"Auto", 
    Daylight = <any>"Daylight", 
    Cloudy = <any>"Cloudy", 
    Shade = <any>"Shade", 
    Tungsten = <any>"Tungsten", 
    Fluorescent = <any>"Fluorescent", 
    Flash = <any>"Flash", 
    Custom = <any>"Custom", 
}

export interface IptcCore {
    countryCode?: string | undefined;
    intellectualGenre?: string | undefined;
    scene?: string[] | undefined;
    subjectCode?: string[] | undefined;
    location?: string | undefined;
    creatorContactInfo?: CreatorContactInfo | undefined;
}

export interface CreatorContactInfo {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
    url?: string | undefined;
}

export interface IptcExt {
    additionalModelInformation?: string | undefined;
    artworkOrObject?: ArtworkOrObjectInfo[] | undefined;
    organisationInImageCode?: string[] | undefined;
    controlledVocabularyTerm?: string[] | undefined;
    locationShown?: LocationInfo[] | undefined;
    modelAge?: number[] | undefined;
    organisationInImageName?: string[] | undefined;
    personInImage?: string[] | undefined;
    digitalImageGUID?: string | undefined;
    digitalSourceType?: string | undefined;
    event?: { [key: string] : string; } | undefined;
    imageRegistryEntry?: RegistryEntryInfo[] | undefined;
    metadataLastEdited?: Date | undefined;
    locationCreated?: LocationInfo[] | undefined;
    maxAvailHeight?: number | undefined;
    maxAvailWidth?: number | undefined;
}

export interface ArtworkOrObjectInfo {
    copyrightNotice?: string | undefined;
    creator?: string[] | undefined;
    dateCreated?: Date | undefined;
    source?: string | undefined;
    sourceInventoryNumber?: string | undefined;
    title?: { [key: string] : string; } | undefined;
}

export interface LocationInfo {
    city?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    provinceState?: string | undefined;
    sublocation?: string | undefined;
    worldRegion?: string | undefined;
}

export interface RegistryEntryInfo {
    registryItemIdentifier?: string | undefined;
    registryOrganisationIdentifier?: string | undefined;
}

export interface IptcIIM {
    modelVersion?: number | undefined;
    destination?: string[] | undefined;
    fileFormat?: number | undefined;
    fileFormatVersion?: number | undefined;
    serviceIdentifier?: string | undefined;
    envelopeNumber?: string | undefined;
    productID?: string[] | undefined;
    envelopePriority?: number | undefined;
    dateSent?: Date | undefined;
    timeSent?: Date | undefined;
    uno?: string | undefined;
    recordVersion?: number | undefined;
    objectTypeReference?: string | undefined;
    objectAttributeReference?: string | undefined;
    objectName?: { [key: string] : string; } | undefined;
    editStatus?: string | undefined;
    urgency?: number | undefined;
    subjectReference?: string[] | undefined;
    category?: string | undefined;
    supplementalCategory?: string[] | undefined;
    fixtureIdentifier?: string | undefined;
    keywords?: string[] | undefined;
    contentLocationCode?: string[] | undefined;
    contentLocationName?: string[] | undefined;
    releaseDate?: Date | undefined;
    releaseTime?: Date | undefined;
    expirationDate?: Date | undefined;
    expirationTime?: Date | undefined;
    specialInstruction?: string | undefined;
    actionAdvised?: string | undefined;
    referenceService?: string | undefined;
    referenceDate?: Date | undefined;
    referenceNumber?: string | undefined;
    dateCreated?: Date | undefined;
    timeCreated?: Date | undefined;
    digitalCreationDate?: Date | undefined;
    digitalCreationTime?: Date | undefined;
    originatingProgram?: string | undefined;
    programVersion?: string | undefined;
    byline?: string[] | undefined;
    bylineTitle?: string | undefined;
    city?: string | undefined;
    sublocation?: string | undefined;
    provinceState?: string | undefined;
    countryPrimaryLocationCode?: string | undefined;
    countryPrimaryLocationName?: string | undefined;
    originalTransmissionReference?: string | undefined;
    headline?: string | undefined;
    credit?: string | undefined;
    source?: string | undefined;
    copyrightNotice?: { [key: string] : string; } | undefined;
    captionAbstract?: { [key: string] : string; } | undefined;
    writerEditor?: string | undefined;
    imageType?: string | undefined;
    imageOrientation?: string | undefined;
    languageIdentifier?: string | undefined;
}

export interface Lr {
    hierarchicalSubject?: string[] | undefined;
}

export interface Pdf {
    keywords?: string | undefined;
    pdfVersion?: string | undefined;
    producer?: string | undefined;
    trapped?: boolean | undefined;
}

export interface Photoshop {
    authorsPosition?: string | undefined;
    captionWriter?: string | undefined;
    category?: string | undefined;
    city?: string | undefined;
    colorMode?: ColorMode | undefined;
    country?: string | undefined;
    credit?: string | undefined;
    dateCreated?: Date | undefined;
    documentAncestors?: string[] | undefined;
    headline?: string | undefined;
    history?: string | undefined;
    iccProfile?: string | undefined;
    instructions?: string | undefined;
    source?: string | undefined;
    state?: string | undefined;
    supplementalCategories?: string[] | undefined;
    textLayers?: PhotoshopLayer[] | undefined;
    transmissionReference?: string | undefined;
    urgency?: number | undefined;
    legacyIPTCDigest?: string | undefined;
}

/** Corresponds to photoshop.ColorModeChoice */
export enum ColorMode {
    Bitmap = <any>"Bitmap", 
    Grayscale = <any>"Grayscale", 
    Indexed = <any>"Indexed", 
    RGB = <any>"RGB", 
    CMYK = <any>"CMYK", 
    Multichannel = <any>"Multichannel", 
    Duotone = <any>"Duotone", 
    LAB = <any>"LAB", 
}

export interface PhotoshopLayer {
    layerName?: string | undefined;
    layerText?: string | undefined;
}

export interface Plus {
    version?: string | undefined;
    licensee?: LicenseeInfo[] | undefined;
    licenseeID?: string | undefined;
    licenseeName?: string | undefined;
    endUser?: EndUserInfo[] | undefined;
    endUserID?: string | undefined;
    endUserName?: string | undefined;
    licensor?: LicensorInfo[] | undefined;
    licensorNotes?: { [key: string] : string; } | undefined;
    mediaSummaryCode?: string | undefined;
    licenseStartDate?: Date | undefined;
    licenseEndDate?: Date | undefined;
    mediaConstraints?: { [key: string] : string; } | undefined;
    regionConstraints?: { [key: string] : string; } | undefined;
    productOrServiceConstraints?: { [key: string] : string; } | undefined;
    imageFileConstraints?: string[] | undefined;
    imageAlterationConstraints?: string[] | undefined;
    imageDuplicationConstraints?: string | undefined;
    modelReleaseStatus?: string | undefined;
    modelReleaseID?: string[] | undefined;
    minorModelAgeDisclosure?: string | undefined;
    propertyReleaseStatus?: string | undefined;
    propertyReleaseID?: string[] | undefined;
    otherConstraints?: { [key: string] : string; } | undefined;
    creditLineRequired?: string | undefined;
    adultContentWarning?: string | undefined;
    otherLicenseRequirements?: { [key: string] : string; } | undefined;
    termsAndConditionsText?: { [key: string] : string; } | undefined;
    termsAndConditionsURL?: string | undefined;
    otherConditions?: { [key: string] : string; } | undefined;
    imageType?: string | undefined;
    licensorImageID?: string | undefined;
    fileNameAsDelivered?: string | undefined;
    imageFileFormatAsDelivered?: string | undefined;
    imageFileSizeAsDelivered?: string | undefined;
    copyrightStatus?: string | undefined;
    copyrightRegistrationNumber?: string | undefined;
    firstPublicationDate?: Date | undefined;
    copyrightOwner?: CopyrightOwnerInfo[] | undefined;
    copyrightOwnerImageID?: string | undefined;
    imageCreator?: ImageCreatorInfo[] | undefined;
    imageCreatorImageID?: string | undefined;
    imageSupplier?: ImageSupplierInfo[] | undefined;
    imageSupplierImageID?: string | undefined;
    licenseeImageID?: string | undefined;
    licenseeImageNotes?: { [key: string] : string; } | undefined;
    otherImageInfo?: { [key: string] : string; } | undefined;
    licenseID?: string | undefined;
    licensorTransactionID?: string[] | undefined;
    licenseeTransactionID?: string[] | undefined;
    licenseeProjectReference?: string[] | undefined;
    licenseTransactionDate?: Date | undefined;
    reuse?: string | undefined;
    otherLicenseDocuments?: string[] | undefined;
    otherLicenseInfo?: { [key: string] : string; } | undefined;
    custom1?: { [key: string] : string; }[] | undefined;
    custom2?: { [key: string] : string; }[] | undefined;
    custom3?: { [key: string] : string; }[] | undefined;
    custom4?: { [key: string] : string; }[] | undefined;
    custom5?: { [key: string] : string; }[] | undefined;
    custom6?: { [key: string] : string; }[] | undefined;
    custom7?: { [key: string] : string; }[] | undefined;
    custom8?: { [key: string] : string; }[] | undefined;
    custom9?: { [key: string] : string; }[] | undefined;
    custom10?: { [key: string] : string; }[] | undefined;
}

export interface LicenseeInfo {
    licenseeName?: string | undefined;
    licenseeID?: string | undefined;
}

export interface EndUserInfo {
    endUserName?: string | undefined;
    endUserID?: string | undefined;
}

export interface LicensorInfo {
    licensorName?: string | undefined;
    licensorID?: string | undefined;
    licensorStreetAddress?: string | undefined;
    licensorExtendedAddress?: string | undefined;
    licensorCity?: string | undefined;
    licensorRegion?: string | undefined;
    licensorPostalCode?: string | undefined;
    licensorCountry?: string | undefined;
    licensorTelephoneType1?: string | undefined;
    licensorTelephone1?: string | undefined;
    licensorTelephoneType2?: string | undefined;
    licensorTelephone2?: string | undefined;
    licensorEmail?: string | undefined;
    licensorURL?: string | undefined;
}

export interface CopyrightOwnerInfo {
    copyrightOwnerName?: string | undefined;
    copyrightOwnerID?: string | undefined;
}

export interface ImageCreatorInfo {
    imageCreatorName?: string | undefined;
    imageCreatorID?: string | undefined;
}

export interface ImageSupplierInfo {
    imageSupplierName?: string | undefined;
    imageSupplierID?: string | undefined;
}

export interface Tiff {
    artist?: string | undefined;
    bitsPerSample?: number[] | undefined;
    compression?: Compression | undefined;
    copyright?: { [key: string] : string; } | undefined;
    dateTime?: Date | undefined;
    imageDescription?: { [key: string] : string; } | undefined;
    imageLength?: number | undefined;
    imageWidth?: number | undefined;
    make?: string | undefined;
    model?: string | undefined;
    orientation?: Orientation | undefined;
    photometricInterpretation?: PhotometricInterpretation | undefined;
    planarConfiguration?: PlanarConfiguration | undefined;
    primaryChromaticities?: string[] | undefined;
    referenceBlackWhite?: string[] | undefined;
    resolutionUnit?: ResolutionUnit | undefined;
    samplesPerPixel?: number | undefined;
    software?: string | undefined;
    transferFunction?: number[] | undefined;
    whitePoint?: string[] | undefined;
    xResolution?: string | undefined;
    yResolution?: string | undefined;
    yCbCrCoefficients?: string[] | undefined;
    yCbCrPositioning?: YCbCrPositioning | undefined;
    yCbCrSubSampling?: YCbCrSubSampling | undefined;
    nativeDigest?: string | undefined;
}

/** Corresponds to tiff.CompressionChoice */
export enum Compression {
    Uncompressed = <any>"Uncompressed", 
    CCITT = <any>"CCITT", 
    T4 = <any>"T4", 
    T6 = <any>"T6", 
    LZW = <any>"LZW", 
    OJPEG = <any>"OJPEG", 
    JPEG = <any>"JPEG", 
    Deflate = <any>"Deflate", 
    T82 = <any>"T82", 
    T43 = <any>"T43", 
    NeXT = <any>"NeXT", 
    ARW = <any>"ARW", 
    RAW = <any>"RAW", 
    SRW = <any>"SRW", 
    Group3_1D = <any>"Group3_1D", 
    PackBits = <any>"PackBits", 
    ThunderScan = <any>"ThunderScan", 
    KDC = <any>"KDC", 
    RasterPadding = <any>"RasterPadding", 
    LineWork = <any>"LineWork", 
    HighContinuous = <any>"HighContinuous", 
    BinaryLineWork = <any>"BinaryLineWork", 
    PixarFilm = <any>"PixarFilm", 
    PixarLog = <any>"PixarLog", 
    DCS = <any>"DCS", 
    JBIG = <any>"JBIG", 
    JPEG2000 = <any>"JPEG2000", 
    NEF = <any>"NEF", 
    JBIG2 = <any>"JBIG2", 
    DCR = <any>"DCR", 
    PEF = <any>"PEF", 
}

/** Corresponds to tiff.OrientationChoice */
export enum Orientation {
    None = <any>"None", 
    TopRowLeftColumn = <any>"TopRowLeftColumn", 
    TopRowRightColumn = <any>"TopRowRightColumn", 
    BottomRowLeftColumn = <any>"BottomRowLeftColumn", 
    BottomRowRightColumn = <any>"BottomRowRightColumn", 
    LeftRowTopColumn = <any>"LeftRowTopColumn", 
    RightRowTopColumn = <any>"RightRowTopColumn", 
    RightRowBottomColumn = <any>"RightRowBottomColumn", 
    LeftRowBottomColumn = <any>"LeftRowBottomColumn", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to tiff.PhotometricInterpretationChoice */
export enum PhotometricInterpretation {
    WhiteIsZero = <any>"WhiteIsZero", 
    BlackIsZero = <any>"BlackIsZero", 
    RGB = <any>"RGB", 
    Palette = <any>"Palette", 
    TransparencyMask = <any>"TransparencyMask", 
    CMYK = <any>"CMYK", 
    YCbCr = <any>"YCbCr", 
    CIELab = <any>"CIELab", 
    ICCLab = <any>"ICCLab", 
    ITULab = <any>"ITULab", 
    ColorFilterArray = <any>"ColorFilterArray", 
    LogL = <any>"LogL", 
    LogLUV = <any>"LogLUV", 
    LinearRaw = <any>"LinearRaw", 
}

/** Corresponds to tiff.PlanarConfigurationChoice */
export enum PlanarConfiguration {
    Chunky = <any>"Chunky", 
    Planar = <any>"Planar", 
    Line = <any>"Line", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum ResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Centimeter = <any>"Centimeter", 
}

/** Corresponds to tiff.YCbCrPositioningChoice */
export enum YCbCrPositioning {
    Centered = <any>"Centered", 
    Cosited = <any>"Cosited", 
}

/** Corresponds to tiff.YCbCrSubSamplingChoice */
export enum YCbCrSubSampling {
    YCbCr111 = <any>"YCbCr111", 
    YCbCr422 = <any>"YCbCr422", 
    YCbCr420 = <any>"YCbCr420", 
}

export interface Xmp {
    baseURL?: string | undefined;
    createDate?: Date | undefined;
    creatorTool?: string | undefined;
    identifier?: string[] | undefined;
    label?: string | undefined;
    metadataDate?: Date | undefined;
    modifyDate?: Date | undefined;
    nickname?: string | undefined;
    rating?: Rating | undefined;
    thumbnails?: XmpGImg[] | undefined;
    pageInfo?: XmpGImg[] | undefined;
}

/** Corresponds to xmp.RatingChoice */
export enum Rating {
    Rejected = <any>"Rejected", 
    Unrated = <any>"Unrated", 
    One = <any>"One", 
    Two = <any>"Two", 
    Three = <any>"Three", 
    Four = <any>"Four", 
    Five = <any>"Five", 
}

export interface XmpGImg {
    format?: ImgFormat | undefined;
    width?: number | undefined;
    height?: number | undefined;
    image?: string | undefined;
}

/** Corresponds to xmpGImg.FormatChoice */
export enum ImgFormat {
    JPEG = <any>"JPEG", 
}

export interface XmpBJ {
    jobRef?: Job[] | undefined;
}

export interface Job {
    id?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export interface XmpDM {
    absPeakAudioFilePath?: string | undefined;
    artist?: string | undefined;
    album?: string | undefined;
    altTapeName?: string | undefined;
    altTimecode?: TimeCode | undefined;
    audioChannelType?: AudioChannelType | undefined;
    audioCompressor?: string | undefined;
    audioSampleRate?: number | undefined;
    audioSampleType?: AudioSampleType | undefined;
    beatSpliceParams?: BeatSpliceStretch | undefined;
    cameraAngle?: CameraAngle | undefined;
    cameraLabel?: string | undefined;
    cameraModel?: string | undefined;
    cameraMove?: CameraMove | undefined;
    client?: string | undefined;
    comment?: string | undefined;
    composer?: string | undefined;
    contributedMedia?: Media[] | undefined;
    director?: string | undefined;
    directorPhotography?: string | undefined;
    duration?: Time | undefined;
    engineer?: string | undefined;
    fileDataRate?: string | undefined;
    genre?: string | undefined;
    good?: boolean | undefined;
    instrument?: string | undefined;
    introTime?: Time | undefined;
    key?: AudioMusicalKey | undefined;
    logComment?: string | undefined;
    loop?: boolean | undefined;
    numberOfBeats?: number | undefined;
    markers?: Marker[] | undefined;
    outCue?: Time | undefined;
    projectName?: string | undefined;
    projectRef?: ProjectLink | undefined;
    pullDown?: VideoPullDown | undefined;
    relativePeakAudioFilePath?: string | undefined;
    relativeTimestamp?: Time | undefined;
    releaseDate?: Date | undefined;
    resampleParams?: ResampleStretch | undefined;
    scaleType?: AudioMusicalScaleType | undefined;
    scene?: string | undefined;
    shotDate?: Date | undefined;
    shotDay?: string | undefined;
    shotLocation?: string | undefined;
    shotName?: string | undefined;
    shotNumber?: string | undefined;
    shotSize?: ShotSize | undefined;
    speakerPlacement?: string | undefined;
    startTimecode?: TimeCode | undefined;
    stretchMode?: AudioStretchMode | undefined;
    takeNumber?: number | undefined;
    tapeName?: string | undefined;
    tempo?: number | undefined;
    timeScaleParams?: TimeScaleStretch | undefined;
    timeSignature?: TimeSignature | undefined;
    trackNumber?: number | undefined;
    tracks?: Track[] | undefined;
    videoAlphaMode?: VideoAlphaMode | undefined;
    videoAlphaPremultipleColor?: XmpG | undefined;
    videoAlphaUnityIsTransparent?: boolean | undefined;
    videoColorSpace?: VideoColorSpace | undefined;
    videoCompressor?: string | undefined;
    videoFieldOrder?: VideoFieldOrder | undefined;
    videoFrameRate?: VideoFrameRate | undefined;
    videoFrameSize?: Dimension | undefined;
    videoPixelDepth?: VideoPixelDepth | undefined;
    videoPixelAspectRatio?: string | undefined;
}

export interface TimeCode {
    timeFormat?: TimeFormat | undefined;
    timeValue?: string | undefined;
}

/** Corresponds to Timecode.TimeFormatChoice */
export enum TimeFormat {
    Timecode24 = <any>"Timecode24", 
    Timecode25 = <any>"Timecode25", 
    Timecode2997Drop = <any>"Timecode2997Drop", 
    Timecode2997NonDrop = <any>"Timecode2997NonDrop", 
    Timecode30 = <any>"Timecode30", 
    Timecode50 = <any>"Timecode50", 
    Timecode5994Drop = <any>"Timecode5994Drop", 
    Timecode5994NonDrop = <any>"Timecode5994NonDrop", 
    Timecode60 = <any>"Timecode60", 
    Timecode23976 = <any>"Timecode23976", 
}

/** Corresponds to xmpDM.AudioChannelTypeChoice */
export enum AudioChannelType {
    CHANNEL_MONO = <any>"CHANNEL_MONO", 
    CHANNEL_STEREO = <any>"CHANNEL_STEREO", 
    CHANNEL_5_1 = <any>"CHANNEL_5_1", 
    CHANNEL_7_1 = <any>"CHANNEL_7_1", 
    CHANNEL_16 = <any>"CHANNEL_16", 
    CHANNEL_OTHER = <any>"CHANNEL_OTHER", 
}

/** Corresponds to xmpDM.AudioSampleTypeChoice */
export enum AudioSampleType {
    SAMPLE_8_INT = <any>"SAMPLE_8_INT", 
    SAMPLE_16_INT = <any>"SAMPLE_16_INT", 
    SAMPLE_24_INT = <any>"SAMPLE_24_INT", 
    SAMPLE_32_INT = <any>"SAMPLE_32_INT", 
    SAMPLE_32_FLOAT = <any>"SAMPLE_32_FLOAT", 
    SAMPLE_COMPRESSED = <any>"SAMPLE_COMPRESSED", 
    SAMPLE_PACKED = <any>"SAMPLE_PACKED", 
    SAMPLE_OTHER = <any>"SAMPLE_OTHER", 
}

export interface BeatSpliceStretch {
    riseInDecibel?: number | undefined;
    riseInTimeDuration?: Time | undefined;
    useFileBeatsMarker?: boolean | undefined;
}

export interface Time {
    scale?: string | undefined;
    value?: number | undefined;
}

/** Corresponds to xmpDM.CameraAngleChoice */
export enum CameraAngle {
    ANGLE_LOW = <any>"ANGLE_LOW", 
    ANGLE_EYE_LEVEL = <any>"ANGLE_EYE_LEVEL", 
    ANGLE_HIGH = <any>"ANGLE_HIGH", 
    ANGLE_OVERHEAD_SHOT = <any>"ANGLE_OVERHEAD_SHOT", 
    ANGLE_BIRDS_EYE_SHOT = <any>"ANGLE_BIRDS_EYE_SHOT", 
    ANGLE_DUTCH = <any>"ANGLE_DUTCH", 
    ANGLE_POV = <any>"ANGLE_POV", 
    ANGLE_OVER_THE_SHOULDER = <any>"ANGLE_OVER_THE_SHOULDER", 
    ANGLE_REACTION_SHOT = <any>"ANGLE_REACTION_SHOT", 
}

/** Corresponds to xmpDM.CameraMoveChoice */
export enum CameraMove {
    MOVE_AERIAL = <any>"MOVE_AERIAL", 
    MOVE_BOOM_UP = <any>"MOVE_BOOM_UP", 
    MOVE_BOOM_DOWN = <any>"MOVE_BOOM_DOWN", 
    MOVE_CRANE_UP = <any>"MOVE_CRANE_UP", 
    MOVE_CRANE_DOWN = <any>"MOVE_CRANE_DOWN", 
    MOVE_DOLLY_IN = <any>"MOVE_DOLLY_IN", 
    MOVE_DOLLY_OUT = <any>"MOVE_DOLLY_OUT", 
    MOVE_PAN_LEFT = <any>"MOVE_PAN_LEFT", 
    MOVE_PAN_RIGHT = <any>"MOVE_PAN_RIGHT", 
    MOVE_PEDESTAL_UP = <any>"MOVE_PEDESTAL_UP", 
    MOVE_PEDESTAL_DOWN = <any>"MOVE_PEDESTAL_DOWN", 
    MOVE_TILT_UP = <any>"MOVE_TILT_UP", 
    MOVE_TILT_DOWN = <any>"MOVE_TILT_DOWN", 
    MOVE_TRACKING = <any>"MOVE_TRACKING", 
    MOVE_TRUCK_LEFT = <any>"MOVE_TRUCK_LEFT", 
    MOVE_TRUCK_RIGHT = <any>"MOVE_TRUCK_RIGHT", 
    MOVE_ZOOM_IN = <any>"MOVE_ZOOM_IN", 
    MOVE_ZOOM_OUT = <any>"MOVE_ZOOM_OUT", 
}

export interface Media {
    duration?: Time | undefined;
    managed?: boolean | undefined;
    path?: string | undefined;
    startTime?: Time | undefined;
    track?: string | undefined;
    webStatement?: string | undefined;
}

/** Corresponds to xmpDM.AudioMusicalKeyChoice */
export enum AudioMusicalKey {
    KEY_C = <any>"KEY_C", 
    KEY_C_SHARP = <any>"KEY_C_SHARP", 
    KEY_D = <any>"KEY_D", 
    KEY_D_SHARP = <any>"KEY_D_SHARP", 
    KEY_E = <any>"KEY_E", 
    KEY_F = <any>"KEY_F", 
    KEY_F_SHARP = <any>"KEY_F_SHARP", 
    KEY_G = <any>"KEY_G", 
    KEY_G_SHARP = <any>"KEY_G_SHARP", 
    KEY_A = <any>"KEY_A", 
    KEY_A_SHARP = <any>"KEY_A_SHARP", 
    KEY_B = <any>"KEY_B", 
}

export interface Marker {
    comment?: string | undefined;
    cuePointParams?: { [key: string] : string; } | undefined;
    cuePointType?: string | undefined;
    duration?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
    probability?: number | undefined;
    speaker?: string | undefined;
    startTime?: string | undefined;
    target?: string | undefined;
    type?: MarkerType | undefined;
}

/** Corresponds to Xmp.Media.Marker.TypeChoice */
export enum MarkerType {
    Chapter = <any>"Chapter", 
    Cue = <any>"Cue", 
    Index = <any>"Index", 
    Speech = <any>"Speech", 
    Track = <any>"Track", 
}

export interface ProjectLink {
    path?: string | undefined;
    type?: ProjectLinkType | undefined;
}

/** Corresponds to Xmp.Media.ProjectLink.TypeChoice */
export enum ProjectLinkType {
    Movie = <any>"Movie", 
    Still = <any>"Still", 
    Audio = <any>"Audio", 
    Custom = <any>"Custom", 
}

/** Corresponds to xmpDM.VideoPullDownChoice */
export enum VideoPullDown {
    PULLDOWN_WSSWW = <any>"PULLDOWN_WSSWW", 
    PULLDOWN_SSWWW = <any>"PULLDOWN_SSWWW", 
    PULLDOWN_SWWWS = <any>"PULLDOWN_SWWWS", 
    PULLDOWN_WWWSS = <any>"PULLDOWN_WWWSS", 
    PULLDOWN_WWSSW = <any>"PULLDOWN_WWSSW", 
    PULLDOWN_WWWSW = <any>"PULLDOWN_WWWSW", 
    PULLDOWN_WWSWW = <any>"PULLDOWN_WWSWW", 
    PULLDOWN_WSWWW = <any>"PULLDOWN_WSWWW", 
    PULLDOWN_SWWWW = <any>"PULLDOWN_SWWWW", 
    PULLDOWN_WWWWS = <any>"PULLDOWN_WWWWS", 
}

export interface ResampleStretch {
    quality?: Quality | undefined;
}

/** Corresponds to Xmp.Media.resampleStretch.QualityChoice and Xmp.Media.timeScaleStretch.QualityChoice */
export enum Quality {
    High = <any>"High", 
    Medium = <any>"Medium", 
    Low = <any>"Low", 
}

/** Corresponds to xmpDM.AudioMusicalScaleTypeChoice */
export enum AudioMusicalScaleType {
    SCALE_MAJOR = <any>"SCALE_MAJOR", 
    SCALE_MINOR = <any>"SCALE_MINOR", 
    SCALE_BOTH = <any>"SCALE_BOTH", 
    SCALE_NEITHER = <any>"SCALE_NEITHER", 
}

/** Corresponds to xmpDM.ShotSizeChoice */
export enum ShotSize {
    SHOT_ECU = <any>"SHOT_ECU", 
    SHOT_MCU = <any>"SHOT_MCU", 
    SHOT_CU = <any>"SHOT_CU", 
    SHOT_MS = <any>"SHOT_MS", 
    SHOT_WS = <any>"SHOT_WS", 
    SHOT_MWS = <any>"SHOT_MWS", 
    SHOT_EWS = <any>"SHOT_EWS", 
}

/** Corresponds to xmpDM.AudioStretchModeChoice */
export enum AudioStretchMode {
    STRETCH_FIXED_LENGTH = <any>"STRETCH_FIXED_LENGTH", 
    STRETCH_TIME_SCALE = <any>"STRETCH_TIME_SCALE", 
    STRETCH_RESAMPLE = <any>"STRETCH_RESAMPLE", 
    STRETCH_BEAT_SPLICE = <any>"STRETCH_BEAT_SPLICE", 
    STRETCH_HYBRID = <any>"STRETCH_HYBRID", 
}

export interface TimeScaleStretch {
    frameOverlappingPercentage?: number | undefined;
    frameSize?: number | undefined;
    quality?: Quality | undefined;
}

/** Corresponds to xmpDM.TimeSignatureChoice */
export enum TimeSignature {
    TIME_2_4 = <any>"TIME_2_4", 
    TIME_3_4 = <any>"TIME_3_4", 
    TIME_4_4 = <any>"TIME_4_4", 
    TIME_5_4 = <any>"TIME_5_4", 
    TIME_7_4 = <any>"TIME_7_4", 
    TIME_6_8 = <any>"TIME_6_8", 
    TIME_9_8 = <any>"TIME_9_8", 
    TIME_12_8 = <any>"TIME_12_8", 
    TIME_OTHER = <any>"TIME_OTHER", 
}

export interface Track {
    frameRate?: string | undefined;
    markers?: Marker[] | undefined;
    trackName?: string | undefined;
    trackType?: MarkerType | undefined;
}

/** Corresponds to xmpDM.VideoAlphaModeChoice */
export enum VideoAlphaMode {
    ALPHA_MODE_STRAIGHT = <any>"ALPHA_MODE_STRAIGHT", 
    ALPHA_MODE_PREMULTIPLIED = <any>"ALPHA_MODE_PREMULTIPLIED", 
    ALPHA_MODE_NONE = <any>"ALPHA_MODE_NONE", 
}

export interface XmpG {
    a?: number | undefined;
    b?: number | undefined;
    l?: number | undefined;
    black?: number | undefined;
    cyan?: number | undefined;
    magenta?: number | undefined;
    yellow?: number | undefined;
    blue?: number | undefined;
    green?: number | undefined;
    red?: number | undefined;
    mode?: ColorantMode | undefined;
    swatchName?: string | undefined;
    type?: ColorantType | undefined;
}

/** Corresponds to xmpG.ModeChoice */
export enum ColorantMode {
    CMYK = <any>"CMYK", 
    RGB = <any>"RGB", 
    LAB = <any>"LAB", 
}

/** Corresponds to xmpG.TypeChoice */
export enum ColorantType {
    Process = <any>"Process", 
    Spot = <any>"Spot", 
}

/** Corresponds to xmpDM.VideoColorSpaceChoice */
export enum VideoColorSpace {
    COLOR_SPACE_SRGB = <any>"COLOR_SPACE_SRGB", 
    COLOR_SPACE_CCIR_601 = <any>"COLOR_SPACE_CCIR_601", 
    COLOR_SPACE_CCIR_709 = <any>"COLOR_SPACE_CCIR_709", 
}

/** Corresponds to xmpDM.VideoFieldOrderChoice */
export enum VideoFieldOrder {
    FIELD_ORDER_UPPER = <any>"FIELD_ORDER_UPPER", 
    FIELD_ORDER_LOWER = <any>"FIELD_ORDER_LOWER", 
    FIELD_ORDER_PROGRESSIVE = <any>"FIELD_ORDER_PROGRESSIVE", 
}

/** Corresponds to xmpDM.VideoFrameRateChoice */
export enum VideoFrameRate {
    FRAME_RATE_24 = <any>"FRAME_RATE_24", 
    FRAME_RATE_NTSC = <any>"FRAME_RATE_NTSC", 
    FRAME_RATE_PAL = <any>"FRAME_RATE_PAL", 
}

export interface Dimension {
    height?: number | undefined;
    width?: number | undefined;
    unit?: Unit | undefined;
}

/** Corresponds to stDim.UnitChoice */
export enum Unit {
    Inch = <any>"Inch", 
    Millimeter = <any>"Millimeter", 
    Centimeter = <any>"Centimeter", 
    Pixel = <any>"Pixel", 
    Pica = <any>"Pica", 
    Point = <any>"Point", 
}

/** Corresponds to xmpDM.VideoPixelDepthChoice */
export enum VideoPixelDepth {
    PIXEL_DEPTH_8_INT = <any>"PIXEL_DEPTH_8_INT", 
    PIXEL_DEPTH_16_INT = <any>"PIXEL_DEPTH_16_INT", 
    PIXEL_DEPTH_24_INT = <any>"PIXEL_DEPTH_24_INT", 
    PIXEL_DEPTH_32_INT = <any>"PIXEL_DEPTH_32_INT", 
    PIXEL_DEPTH_32_FLOAT = <any>"PIXEL_DEPTH_32_FLOAT", 
    PIXEL_DEPTH_OTHER = <any>"PIXEL_DEPTH_OTHER", 
}

export interface Xmpidq {
    scheme?: string | undefined;
}

export interface XmpMM {
    derivedFrom?: Reference | undefined;
    documentID?: string | undefined;
    history?: Event[] | undefined;
    ingredients?: Reference[] | undefined;
    instanceID?: string | undefined;
    managedFrom?: Reference | undefined;
    manager?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    managerVariant?: string | undefined;
    originalDocumentID?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    versionID?: string | undefined;
    versions?: VersionInfo[] | undefined;
}

export interface Reference {
    alternatePaths?: string[] | undefined;
    documentID?: string | undefined;
    filePath?: string | undefined;
    fromPart?: string | undefined;
    instanceID?: string | undefined;
    lastModifyDate?: Date | undefined;
    manager?: string | undefined;
    managerVariant?: string | undefined;
    manageTo?: string | undefined;
    manageUI?: string | undefined;
    maskMarkers?: MaskMarkers | undefined;
    originalDocumentID?: string | undefined;
    partMapping?: string | undefined;
    renditionClass?: string | undefined;
    renditionParams?: string | undefined;
    toPart?: string | undefined;
    versionID?: string | undefined;
}

/** Corresponds to stRef.MaskMarkersChoice */
export enum MaskMarkers {
    All = <any>"All", 
    None = <any>"None", 
}

export interface XmpNote {
    hasExtendedXMP?: string | undefined;
}

export interface XmpRights {
    certificate?: string | undefined;
    marked?: boolean | undefined;
    owner?: string[] | undefined;
    usageTerms?: { [key: string] : string; } | undefined;
    webStatement?: string | undefined;
}

export interface XmpTPg {
    colorants?: XmpG[] | undefined;
    fonts?: Font[] | undefined;
    maxPageSize?: Dimension | undefined;
    nPages?: number | undefined;
    plateNames?: string[] | undefined;
}

export interface Font {
    childFontFiles?: string[] | undefined;
    composite?: boolean | undefined;
    fontFace?: string | undefined;
    fontFamily?: string | undefined;
    fontFileName?: string | undefined;
    fontName?: string | undefined;
    fontType?: FontType | undefined;
    versionString?: string | undefined;
}

/** Corresponds to stFnt.FontTypeChoice */
export enum FontType {
    TrueType = <any>"TrueType", 
    Type1 = <any>"Type1", 
    OpenType = <any>"OpenType", 
    OpenTypeCFF = <any>"OpenTypeCFF", 
}

export interface ExifMetadata {
    exif?: Exif | undefined;
    exifAux?: ExifAux | undefined;
}

export interface Exif {
    apertureValue?: string | undefined;
    brightnessValue?: string | undefined;
    cfaPattern?: CFAPattern | undefined;
    colorSpace?: ColorSpace | undefined;
    componentsConfiguration?: number[] | undefined;
    compressedBitsPerPixel?: string | undefined;
    contrast?: Contrast | undefined;
    customRendered?: CustomRendered | undefined;
    dateTimeOriginal?: Date | undefined;
    dateTimeDigitized?: Date | undefined;
    deviceSettingDescription?: DeviceSettings | undefined;
    digitalZoomRatio?: string | undefined;
    exifVersion?: ExifVersion | undefined;
    exposureBiasValue?: string | undefined;
    exposureIndex?: string | undefined;
    exposureMode?: ExposureMode | undefined;
    exposureProgram?: ExposureProgram | undefined;
    exposureTime?: string | undefined;
    fileSource?: FileSource | undefined;
    flash?: Flash | undefined;
    flashEnergy?: string | undefined;
    flashpixVersion?: FlashpixVersion | undefined;
    fNumber?: string | undefined;
    focalLength?: string | undefined;
    focalLengthIn35mmFilm?: number | undefined;
    focalPlaneResolutionUnit?: FocalPlaneResolutionUnit | undefined;
    focalPlaneXResolution?: string | undefined;
    focalPlaneYResolution?: string | undefined;
    gainControl?: GainControl | undefined;
    gpsAltitude?: string | undefined;
    gpsAltitudeRef?: GPSAltitudeRef | undefined;
    gpsAreaInformation?: string | undefined;
    gpsDestBearing?: string | undefined;
    gpsDestBearingRef?: GPSDestBearingRef | undefined;
    gpsDestDistance?: string | undefined;
    gpsDestDistanceRef?: GPSDestDistanceRef | undefined;
    gpsDestLatitude?: string | undefined;
    gpsDestLongitude?: string | undefined;
    gpsDifferential?: GPSDifferential | undefined;
    gpsdop?: string | undefined;
    gpsImgDirection?: string | undefined;
    gpsImgDirectionRef?: GPSImgDirectionRef | undefined;
    gpsCoordinate?: GPSCoordinate | undefined;
    gpsLatitude?: string | undefined;
    gpsLongitude?: string | undefined;
    gpsMapDatum?: string | undefined;
    gpsMeasureMode?: string | undefined;
    gpsProcessingMethod?: string | undefined;
    gpsSatellites?: string | undefined;
    gpsSpeed?: string | undefined;
    gpsSpeedRef?: GPSSpeedRef | undefined;
    gpsStatus?: GPSStatus | undefined;
    gpsTimeStamp?: Date | undefined;
    gpsTrack?: string | undefined;
    gpsTrackRef?: string | undefined;
    gpsVersionID?: string | undefined;
    imageUniqueID?: string | undefined;
    isoSpeedRatings?: number[] | undefined;
    lightSource?: LightSource | undefined;
    maxApertureValue?: string | undefined;
    meteringMode?: MeteringMode | undefined;
    oecf?: OECF | undefined;
    pixelXDimension?: number | undefined;
    pixelYDimension?: number | undefined;
    relatedSoundFile?: string | undefined;
    saturation?: Saturation | undefined;
    sceneCaptureType?: SceneCaptureType | undefined;
    sceneType?: SceneType | undefined;
    sensingMethod?: SensingMethod | undefined;
    sharpness?: Sharpness | undefined;
    shutterSpeedValue?: string | undefined;
    spatialFrequencyResponse?: SFR | undefined;
    spectralSensitivity?: string | undefined;
    subjectArea?: number[] | undefined;
    subjectDistance?: string | undefined;
    subjectDistanceRange?: SubjectDistanceRange | undefined;
    subjectLocation?: number[] | undefined;
    userComment?: { [key: string] : string; } | undefined;
    whiteBalance?: WhiteBalanceExif | undefined;
    nativeDigest?: string | undefined;
}

export interface CFAPattern {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: number[] | undefined;
}

/** Corresponds to exif.ColorSpaceChoice */
export enum ColorSpace {
    None = <any>"None", 
    SRGB = <any>"sRGB", 
    AdobeRGB = <any>"AdobeRGB", 
    Uncalibrated = <any>"Uncalibrated", 
}

/** Corresponds to exif.ContrastChoice */
export enum Contrast {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.CustomRenderedChoice */
export enum CustomRendered {
    NormalProcess = <any>"NormalProcess", 
    CustomProcess = <any>"CustomProcess", 
}

export interface DeviceSettings {
    columns?: number | undefined;
    rows?: number | undefined;
    settings?: string[] | undefined;
}

/** Corresponds to exif.ExifVersionChoice */
export enum ExifVersion {
    V210 = <any>"V210", 
    V220 = <any>"V220", 
    V221 = <any>"V221", 
    V222 = <any>"V222", 
    V230 = <any>"V230", 
}

/** Corresponds to exif.ExposureModeChoice */
export enum ExposureMode {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    AutoBracket = <any>"AutoBracket", 
}

/** Corresponds to exif.ExposureProgramChoice */
export enum ExposureProgram {
    Undefined = <any>"Undefined", 
    Manual = <any>"Manual", 
    NormalProgram = <any>"NormalProgram", 
    AperturePriority = <any>"AperturePriority", 
    ShutterPriority = <any>"ShutterPriority", 
    CreativeProgram = <any>"CreativeProgram", 
    ActionProgram = <any>"ActionProgram", 
    PortraitMode = <any>"PortraitMode", 
    LandscapeMode = <any>"LandscapeMode", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.FileSourceChoice */
export enum FileSource {
    Other = <any>"Other", 
    TransparentScanner = <any>"TransparentScanner", 
    ReflexScanner = <any>"ReflexScanner", 
    DSC = <any>"DSC", 
}

export interface Flash {
    fired?: boolean | undefined;
    return?: FlashReturn | undefined;
    mode?: FlashMode | undefined;
    function?: boolean | undefined;
    redEyeMode?: boolean | undefined;
}

/** Corresponds to Xmp.Structure.Flash.ReturnChoice */
export enum FlashReturn {
    NoStrobeReturnDetection = <any>"NoStrobeReturnDetection", 
    StrobeReturnLightNotDetected = <any>"StrobeReturnLightNotDetected", 
    StrobeReturnLightDetected = <any>"StrobeReturnLightDetected", 
}

/** Corresponds to Xmp.Structure.Flash.ModeChoice */
export enum FlashMode {
    Unknown = <any>"Unknown", 
    CompulsoryFlashFiring = <any>"CompulsoryFlashFiring", 
    CompulsoryFlashSuppression = <any>"CompulsoryFlashSuppression", 
    AutoMode = <any>"AutoMode", 
}

/** Corresponds to exif.FlashpixVersionChoice */
export enum FlashpixVersion {
    V100 = <any>"V100", 
    V101 = <any>"V101", 
    V110 = <any>"V110", 
}

/** Corresponds to exif.FocalPlaneResolutionUnitChoice */
export enum FocalPlaneResolutionUnit {
    None = <any>"None", 
    Inch = <any>"Inch", 
    Meter = <any>"Meter", 
    Centimeter = <any>"Centimeter", 
    Millimeter = <any>"Millimeter", 
    Micrometer = <any>"Micrometer", 
}

/** Corresponds to exif.GainControlChoice */
export enum GainControl {
    None = <any>"None", 
    LowGainUp = <any>"LowGainUp", 
    HighGainUp = <any>"HighGainUp", 
    LowGainDown = <any>"LowGainDown", 
    HighGainDown = <any>"HighGainDown", 
}

/** Corresponds to exif.GPSAltitudeRefChoice */
export enum GPSAltitudeRef {
    AboveSeaLevel = <any>"AboveSeaLevel", 
    BelowSeaLevel = <any>"BelowSeaLevel", 
}

/** Corresponds to exif.GPSDestBearingRefChoice */
export enum GPSDestBearingRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

/** Corresponds to exif.GPSDestDistanceRefChoice */
export enum GPSDestDistanceRef {
    Kilometers = <any>"Kilometers", 
    Miles = <any>"Miles", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSDifferentialChoice */
export enum GPSDifferential {
    WithoutCorrection = <any>"WithoutCorrection", 
    WithCorrection = <any>"WithCorrection", 
}

/** Corresponds to exif.GPSImgDirectionRefChoice */
export enum GPSImgDirectionRef {
    TrueDirection = <any>"TrueDirection", 
    MagneticDirection = <any>"MagneticDirection", 
}

export interface GPSCoordinate {
    lon?: number | undefined;
    lat?: number | undefined;
}

/** Corresponds to exif.GPSSpeedRefChoice */
export enum GPSSpeedRef {
    KilometersPerHour = <any>"KilometersPerHour", 
    MilesPerHour = <any>"MilesPerHour", 
    Knots = <any>"Knots", 
}

/** Corresponds to exif.GPSStatusChoice */
export enum GPSStatus {
    MeasurementInProgress = <any>"MeasurementInProgress", 
    MeasurementIsInteroperability = <any>"MeasurementIsInteroperability", 
}

/** Corresponds to exif.LightSourceChoice */
export enum LightSource {
    Unidentified = <any>"Unidentified", 
    Daylight = <any>"Daylight", 
    Fluorescent = <any>"Fluorescent", 
    Tungsten = <any>"Tungsten", 
    Flash = <any>"Flash", 
    FineWeather = <any>"FineWeather", 
    CloudyWeather = <any>"CloudyWeather", 
    Shade = <any>"Shade", 
    DaylightFluorescent = <any>"DaylightFluorescent", 
    DayWhiteFluorescent = <any>"DayWhiteFluorescent", 
    CoolWhiteFluorescent = <any>"CoolWhiteFluorescent", 
    WhiteFluorescent = <any>"WhiteFluorescent", 
    StandardIlluminantA = <any>"StandardIlluminantA", 
    StandardIlluminantB = <any>"StandardIlluminantB", 
    StandardIlluminantC = <any>"StandardIlluminantC", 
    D55Illuminant = <any>"D55Illuminant", 
    D65Illuminant = <any>"D65Illuminant", 
    D75Illuminant = <any>"D75Illuminant", 
    D50Illuminant = <any>"D50Illuminant", 
    ISOStudioTungsten = <any>"ISOStudioTungsten", 
    Other = <any>"Other", 
}

/** Corresponds to exif.MeteringModeChoice */
export enum MeteringMode {
    Unidentified = <any>"Unidentified", 
    Average = <any>"Average", 
    CenterWeightedAverage = <any>"CenterWeightedAverage", 
    Spot = <any>"Spot", 
    MultiSpot = <any>"MultiSpot", 
    Pattern = <any>"Pattern", 
    Partial = <any>"Partial", 
    Reserved = <any>"Reserved", 
    Other = <any>"Other", 
}

export interface OECF {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SaturationChoice */
export enum Saturation {
    Normal = <any>"Normal", 
    Low = <any>"Low", 
    High = <any>"High", 
    Unknown = <any>"Unknown", 
}

/** Corresponds to exif.SceneCaptureTypeChoice */
export enum SceneCaptureType {
    Standard = <any>"Standard", 
    Landscape = <any>"Landscape", 
    Portrait = <any>"Portrait", 
    NightScene = <any>"NightScene", 
}

/** Corresponds to exif.SceneTypeChoice */
export enum SceneType {
    DirectlyPhotographedImage = <any>"DirectlyPhotographedImage", 
}

/** Corresponds to exif.SensingMethodChoice */
export enum SensingMethod {
    Undefined = <any>"Undefined", 
    MonochromeArea = <any>"MonochromeArea", 
    OneChipColourAreaSensor = <any>"OneChipColourAreaSensor", 
    TwoChipColourAreaSensor = <any>"TwoChipColourAreaSensor", 
    ThreeChipColourAreaSensor = <any>"ThreeChipColourAreaSensor", 
    ColourSequentialAreaSensor = <any>"ColourSequentialAreaSensor", 
    MonochromeLinearArea = <any>"MonochromeLinearArea", 
    TrilinearSensor = <any>"TrilinearSensor", 
    ColourSequentialLinearSensor = <any>"ColourSequentialLinearSensor", 
}

/** Corresponds to exif.SharpnessChoice */
export enum Sharpness {
    Normal = <any>"Normal", 
    Soft = <any>"Soft", 
    Hard = <any>"Hard", 
    Unknown = <any>"Unknown", 
}

export interface SFR {
    columns?: number | undefined;
    rows?: number | undefined;
    values?: string[] | undefined;
    names?: string[] | undefined;
}

/** Corresponds to exif.SubjectDistanceRangeChoice */
export enum SubjectDistanceRange {
    Unknown = <any>"Unknown", 
    Macro = <any>"Macro", 
    CloseView = <any>"CloseView", 
    DistantView = <any>"DistantView", 
}

/** Corresponds to exif.WhiteBalanceChoice */
export enum WhiteBalanceExif {
    Auto = <any>"Auto", 
    Manual = <any>"Manual", 
    Unknown = <any>"Unknown", 
}

export interface ExifAux {
    lens?: string | undefined;
    serialNumber?: string | undefined;
}

export interface AudioMetadata extends FileMetadata {
    audioStreams?: AudioStream[] | undefined;
}

export interface AudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export interface DocumentMetadata extends FileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount: number;
    characterCountWithSpaces: number;
    lineCount: number;
    pageCount: number;
    slideCount: number;
    paragraphCount: number;
    revisionNumber: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;
    embeddedFiles?: FileMetadata[] | undefined;
}

export interface EpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export interface ImageMetadata extends FileMetadata {
    width: number;
    height: number;
    widthInInch: number;
    heightInInch: number;
    widthInCm: number;
    heightInCm: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel: number;
    bitsPerChannel: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha: boolean;
    isIndexed: boolean;
    isExtended: boolean;
    horizontalResolution: number;
    verticalResolution: number;
    totalFrames: number;
    totalUnspecifiedTiffExtraChannels: number;
    hasExifData: boolean;
    hasIptcData: boolean;
    hasAdobeResourceData: boolean;
    hasXmpData: boolean;
    uncompressedSizeInBytes: number;
}

export interface VideoMetadata extends FileMetadata {
    width: number;
    height: number;
    durationInSeconds: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;
}

export interface VideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export interface DriveMetadata {
    location?: string | undefined;
    fileType?: string | undefined;
    audit?: DriveMetadataAudit | undefined;
    description?: string | undefined;
}

export interface DriveMetadataAudit {
    owner?: string | undefined;
    modified?: string | undefined;
    opened?: string | undefined;
    created?: string | undefined;
}

export interface OutputItem {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = <any>"Rendered", 
    Embedded = <any>"Embedded", 
}

export interface FileTransfer2ContentCreateRequest {
    transferId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export interface FileTransferPartial2ContentCreateRequest {
    transferId?: string | undefined;
    items?: FileTransferCreateItem[] | undefined;
}

export interface FileTransferCreateItem {
    fileId?: string | undefined;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    metadata?: DataDictionary | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export interface TransferSearchRequest {
    channel?: string | undefined;
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export interface BaseResultOfTransfer {
    totalResults: number;
    results?: Transfer[] | undefined;
    pageToken?: string | undefined;
}

export interface TransferSearchResult extends BaseResultOfTransfer {
    elapsedMilliseconds: number;
}

export interface FileTransferSearchRequest {
    searchString?: string | undefined;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
}

export interface BaseResultOfFileTransfer {
    totalResults: number;
    results?: FileTransfer[] | undefined;
    pageToken?: string | undefined;
}

export interface FileTransferSearchResult extends BaseResultOfFileTransfer {
    elapsedMilliseconds: number;
}

export interface FileTransfer {
    id?: string | undefined;
    name?: string | undefined;
    identifier?: string | undefined;
    transferId?: string | undefined;
    state: FileTransferState;
    entityType: EntityType;
    contentId?: string | undefined;
}

export interface UserSearchRequest {
    searchString?: string | undefined;
    /** Allow the backend to modify the search string if it generates a non valid query */
    allowSearchStringRewrite: boolean;
    sort?: SortInfo[] | undefined;
    start: number;
    limit: number;
    filter?: FilterBase | undefined;
    lifeCycleFilter: LifeCycleFilter;
}

export interface BaseResultOfUser {
    totalResults: number;
    results?: User[] | undefined;
    pageToken?: string | undefined;
}

export interface RewritableBaseResultOfUser extends BaseResultOfUser {
    searchString?: string | undefined;
    isSearchStringRewritten: boolean;
}

export interface UserSearchResult extends RewritableBaseResultOfUser {
    elapsedMilliseconds: number;
}

export interface User extends UserItem {
    userRoleIds?: string[] | undefined;
}

export interface UserDetail extends UserItem {
    password?: string | undefined;
    userRoles?: UserRole[] | undefined;
    comment?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    drives?: Drive[] | undefined;
    ownerTokens?: OwnerToken[] | undefined;
    authorizationState: AuthorizationState;
}

export interface UserAddress {
    company?: string | undefined;
    address?: string | undefined;
    alternativeAddress?: string | undefined;
    department?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    phone?: string | undefined;
    countryCode?: string | undefined;
}

export interface Drive {
    id?: string | undefined;
    name?: string | undefined;
}

export interface OwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

export enum AuthorizationState {
    Active = <any>"Active", 
    Review = <any>"Review", 
    Locked = <any>"Locked", 
}

export interface Channel {
    id?: string | undefined;
    sortOrder: number;
    /** The search index id. */
    searchIndexId?: string | undefined;
    entityType: EntityType;
    /** An id list of schemas with schema type content whose content documents should be found by the simple search.
The search by filters and aggregations are unaffected. */
    schemaIds?: string[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
}

export interface ContentsByIdsRequest {
    contentIds?: string[] | undefined;
}

export interface UserProfile {
    id?: string | undefined;
    emailAddress?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    languageCode?: string | undefined;
    address?: UserAddress | undefined;
    authorizationState: AuthorizationState;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

export { AuthClient, TokenAuthClient };