//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { Injector } from '@angular/core';
import { LazyGetter } from 'lazy-get-decorator';
import { AuthService } from './auth.service';
import { LiquidRenderingService } from './liquid-rendering.service';
import { PictureparkServiceBase } from './base.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const PICTUREPARK_API_URL = new InjectionToken<string>('PICTUREPARK_API_URL');

@Injectable({
    providedIn: 'root'
})
export class BusinessProcessService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get business process
     * @param id The business process id.
     * @return BusinessProcess
     */
    get(id: string | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create business process
     * @param request The business process create request.
     * @return BusinessProcess
     */
    create(request: BusinessProcessCreateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Change business process state
     * @param id The business process id.
     * @param request The business process state change request.
     * @return BusinessProcess
     */
    changeState(id: string | null, request: BusinessProcessStateChangeRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/state";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processChangeState(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update business process notification
     * @param id The business process id.
     * @param request The business process notification update request.
     */
    updateNotification(id: string | null, request: BusinessProcessNotificationUpdateRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/notification";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cancel business process
     * @param id The business process id.
     */
    cancel(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Wait for states
     * @param id The business process id.
     * @param states (optional) Business process states to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitResult
     */
    waitForStates(id: string | null, states: string[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForStateResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitStates?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "states=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForStates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessWaitForStateResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessWaitForStateResult>;
        }));
    }

    protected processWaitForStates(response: HttpResponseBase): Observable<BusinessProcessWaitForStateResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForStateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Wait for life cycles
     * @param id The business process id.
     * @param lifeCycles (optional) Business process life cycles to wait for.
     * @param timeout (optional) The timeout to wait for completion.
     * @return BusinessProcessWaitForLifeCycleResult
     */
    waitForLifeCycles(id: string | null, lifeCycles: BusinessProcessLifeCycle[] | null | undefined, timeout: string | null | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitLifeCycles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lifeCycles !== undefined && lifeCycles !== null)
            lifeCycles && lifeCycles.forEach(item => { url_ += "lifeCycles=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForLifeCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForLifeCycles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessWaitForLifeCycleResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessWaitForLifeCycleResult>;
        }));
    }

    protected processWaitForLifeCycles(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Wait for completion
     * @param id The business process id.
     * @param timeout (optional) The timeout to wait for completion.
     * @param waitForContinuationCompletion (optional) Waits for the completion of the continuation business process (if existing, recursively). Default to true.
     * @return BusinessProcessWaitResult
     */
    waitForCompletion(id: string | null, timeout: string | null | undefined, waitForContinuationCompletion: boolean | undefined): Observable<BusinessProcessWaitForLifeCycleResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/waitCompletion?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitForContinuationCompletion === null)
            throw new Error("The parameter 'waitForContinuationCompletion' cannot be null.");
        else if (waitForContinuationCompletion !== undefined)
            url_ += "waitForContinuationCompletion=" + encodeURIComponent("" + waitForContinuationCompletion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processWaitForCompletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitForCompletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessWaitForLifeCycleResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessWaitForLifeCycleResult>;
        }));
    }

    protected processWaitForCompletion(response: HttpResponseBase): Observable<BusinessProcessWaitForLifeCycleResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessWaitForLifeCycleResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get details
     * @param id The business process id.
     * @return BusinessProcessDetails
     * @deprecated
     */
    getDetails(id: string | null): Observable<BusinessProcessDetails> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/details";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessDetails>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<BusinessProcessDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a summary of the business process.
    Depending on the type of the business process, this can be not available at all or contain just a minimal set of information.
    If business process produces a batch based response, page over successful and failed items using respective endpoints.
     * @param id Business process id.
     * @return BusinessProcessSummaryBase
     */
    getSummary(id: string | null): Observable<BusinessProcessSummaryBase> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/summary";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessSummaryBase>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessSummaryBase>;
        }));
    }

    protected processGetSummary(response: HttpResponseBase): Observable<BusinessProcessSummaryBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessSummaryBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a page of successful items of a batch based business process.
    Use the page token to fetch next page.
     * @param id Business process id.
     * @param limit Number of items to fetch.
     * @param pageToken (optional) PageToken for paging.
     * @return BusinessProcessBatch
     */
    getSuccessfulItems(id: string | null, limit: number, pageToken: string | null | undefined): Observable<BusinessProcessBatch> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/items/successful?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (pageToken !== undefined && pageToken !== null)
            url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSuccessfulItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuccessfulItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessBatch>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessBatch>;
        }));
    }

    protected processGetSuccessfulItems(response: HttpResponseBase): Observable<BusinessProcessBatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessBatch.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a page of failed items of a batch based business process.
    Use the page token to fetch next page.
     * @param id Business process id.
     * @param limit Number of items to fetch.
     * @param pageToken (optional) PageToken for paging.
     * @return BusinessProcessBatch
     */
    getFailedItems(id: string | null, limit: number, pageToken: string | null | undefined): Observable<BusinessProcessBatch> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/{id}/items/failed?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (pageToken !== undefined && pageToken !== null)
            url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFailedItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFailedItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessBatch>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessBatch>;
        }));
    }

    protected processGetFailedItems(response: HttpResponseBase): Observable<BusinessProcessBatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessBatch.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search
     * @param request The business process request.
     * @return BusinessProcessSearchResult
     */
    search(request: BusinessProcessSearchRequest): Observable<BusinessProcessSearchResult> {
        let url_ = this.baseUrl + "/v1/BusinessProcesses/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcessSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcessSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<BusinessProcessSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcessSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BusinessRuleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get the current business rule configuration
     * @return BusinessRuleConfiguration
     */
    getConfiguration(): Observable<BusinessRuleConfiguration> {
        let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessRuleConfiguration>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessRuleConfiguration>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<BusinessRuleConfiguration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRuleConfiguration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the business rule configuration.
     * @param request Request containing the new configuration.
     * @return Business process
     */
    updateConfiguration(request: BusinessRuleConfigurationUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessRules/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateConfiguration(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Searches for trace logs produces by business rule execution.
     * @param request Request
     * @return Holds results of trace log search.
     */
    searchTraces(request: BusinessRuleTraceLogSearchRequest): Observable<BusinessRuleTraceLogSearchResult> {
        let url_ = this.baseUrl + "/v1/BusinessRules/traceLog/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchTraces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTraces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessRuleTraceLogSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessRuleTraceLogSearchResult>;
        }));
    }

    protected processSearchTraces(response: HttpResponseBase): Observable<BusinessRuleTraceLogSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessRuleTraceLogSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Runs the supplied business rule schedule immediately.
    Allows for testing of schedules.
     * @param schedule BusinessRuleSchedule
     * @return BusinessProcess of the metadata operation triggered by the schedule.
     */
    runSchedule(schedule: BusinessRuleSchedule): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/BusinessRules/schedule/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(schedule);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRunSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunSchedule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRunSchedule(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChannelService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all channels
     * @return List of channel
     */
    getAll(): Observable<Channel[]> {
        let url_ = this.baseUrl + "/v1/Channels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Channel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Channel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Channel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Channel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create channel
     * @param request The request containing information needed to create new channel.
     * @return Created channel
     */
    create(request: ChannelCreateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/Channels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Channel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Channel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get channel
     * @param id The channel ID.
     * @return Requested channel
     */
    get(id: string | null): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Channel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Channel>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update channel
     * @param id ID of channel to update
     * @param request The request containing information needed to update the channel.
     * @return Updated channel
     */
    update(id: string | null, request: ChannelUpdateRequest): Observable<Channel> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Channel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Channel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Channel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Channel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete channel
     * @param id ID of the channel that should be deleted.
     * @return OK
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Channels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used in an aggregator on any channel.
     * @return The list of fields
     */
    getAggregationFields(): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Channels/fields/aggregation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAggregationFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAggregationFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetAggregationFields(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used as sort fields on any channel.
     * @return The list of fields
     */
    getSortFields(): Observable<SortFieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Channels/fields/sort";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSortFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SortFieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SortFieldInfo[]>;
        }));
    }

    protected processGetSortFields(response: HttpResponseBase): Observable<SortFieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SortFieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used as filter fields on any channel.
     * @return The list of fields
     */
    getFilterFields(): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Channels/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFilterFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetFilterFields(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get content permission set
     * @param id Content permission set ID.
     * @return Detail of a content permission set
     */
    get(id: string | null): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentPermissionSetDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update content permission set
     * @param id Content permission set ID.
     * @param permissionSet Permission set
     * @return Detail of a content permission set
     */
    update(id: string | null, permissionSet: ContentPermissionSetUpdateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentPermissionSetDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete content permission set
     * @param id Content permission set ID.
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create content permission set
     * @param permissionSet Permission set
     * @return Detail of a content permission set
     */
    create(permissionSet: ContentPermissionSetCreateRequest): Observable<ContentPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentPermissionSetDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple content permission sets
     * @param ids (optional) Ids
     * @return Array of Detail of a content permission set
     */
    getMany(ids: string[] | null | undefined): Observable<ContentPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentPermissionSetDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentPermissionSetDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentPermissionSetDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership of content permission set
     * @param id Content permission set ID.
     * @param request Request to transfer the ownership of a permission set.
     */
    transferOwnership(id: string | null, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get permissions for content permission set
     * @param id Content permission set ID.
     * @return Array of Permission set rights
     */
    getPermissions(id: string | null): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetRight[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetRight[]>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple content permission sets
     * @param request Request to create multiple content permission sets.
     * @return Response to a bulk operation
     */
    createMany(request: ContentPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple content permission sets
     * @param request Request to update multiple content permission sets.
     * @return Response to a bulk operation
     */
    updateMany(request: ContentPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple content permission sets
     * @param request Request to delete multiple permission sets.
     * @return Response to a bulk operation
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership of multiple content permission sets
     * @param request Request to transfer the ownership of multiple permission sets.
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get permissions for multiple content permission sets
     * @param ids (optional) Ids
     * @return Array of Rights that the current user has on a permission set
     */
    getPermissionsMany(ids: string[] | null | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/many/permissions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetUserPermissionRights[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetUserPermissionRights[]>;
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search content permission set
     * @param request Request to search permission sets.
     * @return Result of a permission set search operation
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/ContentPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ContentService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
  @LazyGetter()
  protected get liquidRenderingService(): LiquidRenderingService {
    return this.injector.get(LiquidRenderingService);
  }

  constructor(
    protected injector: Injector,
    @Inject(AuthService) configuration: AuthService,
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string
  ) {
    super(configuration);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
  }

  create(
    resolveBehaviors: ContentResolveBehavior[] | null | undefined,
    allowMissingDependencies: boolean | undefined,
    timeout: string | null | undefined,
    waitSearchDocCreation: boolean | undefined,
    contentCreateRequest: ContentCreateRequest
  ): Observable<ContentDetail> {
    return this.createCore(
      resolveBehaviors,
      allowMissingDependencies,
      timeout,
      waitSearchDocCreation,
      contentCreateRequest
    ).pipe(
      _observableMergeMap(async content => {
        await this.liquidRenderingService.renderNestedDisplayValues(content);
        return content;
      })
    );
  }

  get(contentId: string, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail> {
    return this.getCore(contentId, resolveBehaviors).pipe(
      _observableMergeMap(async content => {
        await this.liquidRenderingService.renderNestedDisplayValues(content);
        return content;
      })
    );
  }

  getMany(
    ids: string[] | null,
    resolveBehaviors: ContentResolveBehavior[] | null | undefined
  ): Observable<ContentDetail[]> {
    return this.getManyCore(ids, resolveBehaviors).pipe(
      _observableMergeMap(async contents => {
        contents.forEach(async content => await this.liquidRenderingService.renderNestedDisplayValues(content));
        return contents;
      })
    );
  }

  search(contentSearchRequest: ContentSearchRequest): Observable<ContentSearchResult> {
    return this.searchCore(contentSearchRequest).pipe(
      _observableMergeMap(async searchResult => {
        await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
        return searchResult;
      })
    );
  }

  updateMetadata(
    contentId: string,
    resolveBehaviors: ContentResolveBehavior[] | null | undefined,
    allowMissingDependencies: boolean | undefined,
    timeout: string | null | undefined,
    waitSearchDocCreation: boolean | undefined,
    updateRequest: ContentMetadataUpdateRequest
  ): Observable<ContentDetail> {
    return this.updateMetadataCore(
      contentId,
      resolveBehaviors,
      allowMissingDependencies,
      timeout,
      waitSearchDocCreation,
      updateRequest
    ).pipe(
      _observableMergeMap(async content => {
        await this.liquidRenderingService.renderNestedDisplayValues(content);
        return content;
      })
    );
  }

  updatePermissions(
    contentId: string,
    resolveBehaviors: ContentResolveBehavior[] | null | undefined,
    timeout: string | null | undefined,
    waitSearchDocCreation: boolean | undefined,
    updateRequest: ContentPermissionsUpdateRequest
  ): Observable<ContentDetail> {
    return this.updatePermissionsCore(contentId, resolveBehaviors, timeout, waitSearchDocCreation, updateRequest).pipe(
      _observableMergeMap(async content => {
        await this.liquidRenderingService.renderNestedDisplayValues(content);
        return content;
      })
    );
  }

  setDisplayContent(
    id: string | null,
    resolveBehaviors: ContentResolveBehavior[] | null | undefined,
    timeout: string | null | undefined,
    waitForContinuation: boolean | undefined,
    setDisplayContentRequest: SetDisplayContentRequest
  ): Observable<ContentDetail> {
    return this.setDisplayContentCore(
      id,
      resolveBehaviors,
      timeout,
      waitForContinuation,
      setDisplayContentRequest
    ).pipe(
      _observableMergeMap(async content => {
        await this.liquidRenderingService.renderNestedDisplayValues(content);
        return content;
      })
    );
  }

    /**
     * Get content
     * @param id The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return Content detail
     */
    protected getCore(id: string | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete content
     * @param id The ID of the content to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the content should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(id: string | null, forceReferenceRemoval: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forceReferenceRemoval === null)
            throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
        else if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkBusinessException.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download content
     * @param contentId The content ID.
     * @param outputFormatId The output format ID.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000).
     */
    download(contentId: string, outputFormatId: string, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Contents/downloads/{contentId}/{outputFormatId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Edit output
     * @param contentId The content ID.
     * @param outputFormatId The output format ID.
     * @param conversionPreset The conversion preset.
     */
    editOutput(contentId: string | null, outputFormatId: string | null, conversionPreset: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Contents/downloads/{contentId}/{outputFormatId}/{conversionPreset}";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
        if (conversionPreset === undefined || conversionPreset === null)
            throw new Error("The parameter 'conversionPreset' must be defined.");
        url_ = url_.replace("{conversionPreset}", encodeURIComponent("" + conversionPreset));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processEditOutput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOutput(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEditOutput(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download thumbnail
     * @param id The content ID.
     * @param size Thumbnail size. Either small, medium or large.
     * @param width (optional) Optional width in pixels to resize image.
     * @param height (optional) Optional height in pixels to resize image.
     */
    downloadThumbnail(id: string | null, size: ThumbnailSize, width: number | null | undefined, height: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Contents/thumbnails/{id}/{size}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size));
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadThumbnail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadThumbnail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadThumbnail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create content
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request Content create request.
     * @return The content details
     */
    protected createCore(resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ContentCreateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents?";
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple contents
     * @param ids List of content IDs
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @return List of Content detail
     */
    protected getManyCore(ids: string[] | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined): Observable<ContentDetail[]> {
        let url_ = this.baseUrl + "/v1/Contents?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else if(ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ContentDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update content metadata
     * @param id The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param allowMissingDependencies (optional) Allows storing references to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request Content metadata update request.
     * @return Content detail
     */
    protected updateMetadataCore(id: string | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ContentMetadataUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/metadata?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail>;
        }));
    }

    protected processUpdateMetadata(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update content permissions
     * @param id The content ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request Content permissions update request.
     * @return Content detail
     */
    protected updatePermissionsCore(id: string | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ContentPermissionsUpdateRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/permissions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail>;
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore content
     * @param id The content ID.
     * @param allowMissingDependencies (optional) Allows restoring contents that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(id: string | null, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/restore?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer content ownership
     * @param id The content ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request Content ownership transfer request.
     * @return Ok
     */
    transferOwnership(id: string | null, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ContentOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/ownership?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Check if given changes of ContentSchemaId are possible without incurring data loss (due to assigned Layers and LayerSchemaIds)
     * @param request Changes to check
     * @return Result indicating if data loss would occur for given requests
     */
    checkContentSchemaChange(request: CheckContentSchemaIdChangeRequest): Observable<CheckContentSchemaIdChangeResult> {
        let url_ = this.baseUrl + "/v1/Contents/checkContentSchemaChange";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckContentSchemaChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckContentSchemaChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckContentSchemaIdChangeResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckContentSchemaIdChangeResult>;
        }));
    }

    protected processCheckContentSchemaChange(response: HttpResponseBase): Observable<CheckContentSchemaIdChangeResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckContentSchemaIdChangeResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Check if a file update is possible without incurring data loss
     * @param id The ID of the content to replace.
     * @param request Content file update request
     * @return Information about data loss, if any
     */
    checkUpdateFile(id: string | null, request: ContentFileUpdateCheckRequest): Observable<CheckContentSchemaIdChangeResult> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/file/check";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUpdateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckContentSchemaIdChangeResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckContentSchemaIdChangeResult>;
        }));
    }

    protected processCheckUpdateFile(response: HttpResponseBase): Observable<CheckContentSchemaIdChangeResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckContentSchemaIdChangeResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update content file
     * @param id The ID of the content to replace.
     * @param request Content file update request
     * @return Business process
     */
    updateFile(id: string | null, request: ContentFileUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/file";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateFile(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get content references
     * @param id The content ID whose references to retrieve.
     * @param request Content references request.
     * @return ContentReferencesResult
     */
    getReferences(id: string | null, request: ContentReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/references/search";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferences(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentReferencesResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentReferencesResult>;
        }));
    }

    protected processGetReferences(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get outputs
     * @param id ID of content.
     * @return Array of Result of output resolution.
     */
    getOutputs(id: string | null): Observable<OutputResolveResult[]> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/outputs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOutputs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutputs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputResolveResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputResolveResult[]>;
        }));
    }

    protected processGetOutputs(response: HttpResponseBase): Observable<OutputResolveResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutputResolveResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create download link
     * @param request Content download link request
     * @return Download link
     */
    createDownloadLink(request: ContentDownloadLinkCreateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/downloadLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDownloadLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateDownloadLink(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Resolve download token to Url
     * @param token Token
     * @return Download link information
     */
    getDownloadLink(token: string | null): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/Contents/downloadLink/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDownloadLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadLink>;
        }));
    }

    protected processGetDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple contents
     * @param request Content create many request.
     * @return Business process
     */
    createMany(request: ContentCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple content metadata
     * @param request Content metadata update many request.
     * @return Business process
     */
    updateMetadataMany(request: ContentMetadataUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/metadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMetadataMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMetadataMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMetadataMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple contents permissions
     * @param request Content permissions update many request.
     * @return Business process
     */
    updatePermissionsMany(request: ContentPermissionsUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdatePermissionsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer multiple contents ownerships
     * @param request Content ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: ContentOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple contents
     * @param request Delete many request.
     * @return Business process
     */
    deleteMany(request: ContentDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple contents - by filter
     * @param request Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(request: ContentDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore multiple contents
     * @param request Content restore many request.
     * @return Business process
     */
    restoreMany(request: ContentRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get many content references
     * @param request Content many references request.
     * @return Content references result
     */
    getReferencesMany(request: ContentManyReferencesRequest): Observable<ContentReferencesResult> {
        let url_ = this.baseUrl + "/v1/Contents/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentReferencesResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentReferencesResult>;
        }));
    }

    protected processGetReferencesMany(response: HttpResponseBase): Observable<ContentReferencesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get outputs
     * @param request Output resolve many request.
     * @return Array of Result of output resolution.
     */
    getOutputsMany(request: OutputResolveManyRequest): Observable<OutputResolveResult[]> {
        let url_ = this.baseUrl + "/v1/Contents/many/outputs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOutputsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutputsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputResolveResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputResolveResult[]>;
        }));
    }

    protected processGetOutputsMany(response: HttpResponseBase): Observable<OutputResolveResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutputResolveResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Repair contents by filter
     * @param request Content repair request.
     * @return Business process
     */
    repairContentsByFilter(request: ContentRepairByFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/repair/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRepairContentsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepairContentsByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRepairContentsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Repair contents
     * @param request Content repair request.
     * @return Business process
     */
    repairContentsBatch(request: ContentRepairBatchRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/repair/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRepairContentsBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRepairContentsBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRepairContentsBatch(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Batch update content fields - by IDs
     * @param request Content fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(request: ContentFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Batch update fields - by filter
     * @param request Content fields batch update filter request. It contains the changes that need to be applied to the contents and the filter request to identify the contents.
     * @return Business process
     */
    batchUpdateFieldsByFilter(request: ContentFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search contents
     * @param request Content search request.
     * @return Result for content search operation
     */
    protected searchCore(request: ContentSearchRequest): Observable<ContentSearchResult> {
        let url_ = this.baseUrl + "/v1/Contents/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ContentSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate contents on channel
     * @param request Content aggregation on channel request.
     * @return Object aggregation result
     */
    aggregateOnChannel(request: ContentAggregationOnChannelRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Contents/aggregateOnChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregateOnChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregateOnChannel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregateOnChannel(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate contents
     * @param request Content aggregation request.
     * @return Object aggregation result
     */
    aggregate(request: ContentAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Contents/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get historic versions
     * @param id Content ID.
     * @param request Request allowing for paging
     * @return Historic versions
     */
    getVersions(id: string | null, request: HistoricVersionSearchRequest): Observable<HistoricVersionSearchResult> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/versions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoricVersionSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoricVersionSearchResult>;
        }));
    }

    protected processGetVersions(response: HttpResponseBase): Observable<HistoricVersionSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoricVersionSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get historic version download link
     * @param id Content ID.
     * @param versionId Version ID.
     * @return Download token to be used with download/{token} endpoint
     */
    createVersionDownloadLink(id: string | null, versionId: number): Observable<string> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/versions/{versionId}/file";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateVersionDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVersionDownloadLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateVersionDownloadLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete historic version
     * @param id Content ID.
     * @param versionId Version ID.
     * @return OK
     */
    deleteVersion(id: string | null, versionId: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/versions/{versionId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get comment
     * @param id Content ID.
     * @param commentId Comment ID.
     * @return Comment if found
     */
    getComment(id: string | null, commentId: string | null): Observable<Comment> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processGetComment(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update comment
     * @param id Content ID.
     * @param commentId Comment ID.
     * @param timeout (optional) Operation timeout.
     * @param request Comment update.
     * @return Updated comment
     */
    updateComment(id: string | null, commentId: string | null, timeout: string | null | undefined, request: CommentEditable): Observable<Comment> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/comments/{commentId}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processUpdateComment(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete comment
     * @param id Content ID.
     * @param commentId Comment ID.
     * @param timeout (optional) Operation timeout.
     * @return OK
     */
    deleteComment(id: string | null, commentId: string | null, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/comments/{commentId}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create comment
     * @param id Content ID.
     * @param timeout (optional) Operation timeout.
     * @param request Comment creation request.
     * @return Created comment
     */
    createComment(id: string | null, timeout: string | null | undefined, request: CommentCreateRequest): Observable<Comment> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/comments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Comment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Comment>;
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<Comment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search comments
     * @param id Content ID.
     * @param request Search request.
     * @return List of found comments
     */
    searchComments(id: string | null, request: CommentSearchRequest): Observable<CommentSearchResult> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/comments/search";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommentSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommentSearchResult>;
        }));
    }

    protected processSearchComments(response: HttpResponseBase): Observable<CommentSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sets/unsets a DisplayContent for a content with an id given in the request
     * @param id Id of the content
     * @param resolveBehaviors (optional) List of enums that control which parts of the content are resolved and returned.
     * @param timeout (optional) Timeout for the operation
     * @param waitForContinuation (optional) Wait for the creation of the search doc update.
     * @param setDisplayContentRequest Request with DisplayContentId
     * @return Result of the operation
     */
    protected setDisplayContentCore(id: string | null, resolveBehaviors: ContentResolveBehavior[] | null | undefined, timeout: string | null | undefined, waitForContinuation: boolean | undefined, setDisplayContentRequest: SetDisplayContentRequest): Observable<ContentDetail> {
        let url_ = this.baseUrl + "/v1/Contents/{id}/displayContent?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitForContinuation === null)
            throw new Error("The parameter 'waitForContinuation' cannot be null.");
        else if (waitForContinuation !== undefined)
            url_ += "waitForContinuation=" + encodeURIComponent("" + waitForContinuation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setDisplayContentRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDisplayContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDisplayContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentDetail>;
        }));
    }

    protected processSetDisplayContent(response: HttpResponseBase): Observable<ContentDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Process many requests to set/unset display contents for given contents
     * @param setDisplayContentsManyRequest Set many display contents request
     * @return Business process
     */
    setManyDisplayContents(setDisplayContentsManyRequest: SetDisplayContentsManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Contents/many/displayContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setDisplayContentsManyRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetManyDisplayContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetManyDisplayContents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetManyDisplayContents(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ConversionPresetTemplateService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search conversion preset templates
     * @param request Conversion preset templates search request.
     * @return Result of the conversion preset templates search
     */
    search(request: ConversionPresetTemplateSearchRequest): Observable<ConversionPresetTemplateSearchResult> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversionPresetTemplateSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversionPresetTemplateSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ConversionPresetTemplateSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversionPresetTemplateSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create conversion preset template
     * @param timeout (optional) Timeout
     * @param request Request containing information needed to create new conversion preset template.
     * @return Represents the detail of a conversion preset template
     */
    create(timeout: string | null | undefined, request: ConversionPresetTemplateCreateRequest): Observable<ConversionPresetTemplateDetail> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates?";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversionPresetTemplateDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversionPresetTemplateDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ConversionPresetTemplateDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversionPresetTemplateDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple conversion preset templates
     * @param ids (optional) Conversion preset template IDs to get information about.
     * @return Array of Represents the detail of a conversion preset template
     */
    getMany(ids: string[] | null | undefined): Observable<ConversionPresetTemplateDetail[]> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversionPresetTemplateDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversionPresetTemplateDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ConversionPresetTemplateDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConversionPresetTemplateDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update conversion preset template
     * @param id Conversion preset template ID.
     * @param timeout (optional) Timeout
     * @param request Request containing information needed to update the conversion preset template.
     * @return Represents the detail of a conversion preset template
     */
    update(id: string | null, timeout: string | null | undefined, request: ConversionPresetTemplateUpdateRequest): Observable<ConversionPresetTemplateDetail> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversionPresetTemplateDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversionPresetTemplateDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConversionPresetTemplateDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversionPresetTemplateDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete conversion preset template
     * @param id Conversion preset template ID.
     * @param timeout (optional) Timeout
     */
    delete(id: string | null, timeout: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get conversion preset template
     * @param id Conversion preset template ID.
     * @return Represents the detail of a conversion preset template
     */
    get(id: string | null): Observable<ConversionPresetTemplateDetail> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConversionPresetTemplateDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConversionPresetTemplateDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ConversionPresetTemplateDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConversionPresetTemplateDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple conversion preset templates
     * @param request Request containing information needed to create new conversion preset template.
     * @return Business process
     */
    createMany(request: ConversionPresetTemplateCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple conversion preset templates
     * @param request Request containing information needed to update the conversion preset template.
     * @return Business process
     */
    updateMany(request: ConversionPresetTemplateUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple conversion preset templates
     * @param request The request with conversion preset template IDs to delete.
     * @return Business process
     */
    deleteMany(request: ConversionPresetTemplateDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ConversionPresetTemplates/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DisplayValueService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get status
     * @return VersionInfo
     */
    getStatus(): Observable<DisplayValueStatus> {
        let url_ = this.baseUrl + "/v1/DisplayValues/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DisplayValueStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DisplayValueStatus>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<DisplayValueStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DisplayValueStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Re-render the display values
     * @return VersionInfo
     */
    rerender(): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/DisplayValues/rerender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRerender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRerender(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRerender(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentHistoryService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @return Document history item
     */
    getCurrent(documentType: string | null, documentId: string | null): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentHistory>;
        }));
    }

    protected processGetCurrent(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document.
     * @return Document history item
     */
    getVersion(documentType: string | null, documentId: string | null, documentVersion: number): Observable<DocumentHistory> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentHistory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentHistory>;
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<DocumentHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Compare with current
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference.
     */
    compareWithCurrent(documentType: string | null, documentId: string | null, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/current/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithCurrent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithCurrent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentHistoryDifference>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentHistoryDifference>;
        }));
    }

    protected processCompareWithCurrent(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Compare with version
     * @param documentType The type of the document (e.g. Content).
     * @param documentId The ID of the document (e.g. contentId).
     * @param documentVersion The version of the document to use for the comparison.
     * @param version (optional) The version of the document to compare with.
     * @return Document history difference
     */
    compareWithVersion(documentType: string | null, documentId: string | null, documentVersion: number, version: number | undefined): Observable<DocumentHistoryDifference> {
        let url_ = this.baseUrl + "/v1/history/{documentType}/{documentId}/{documentVersion}/compare?";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        if (documentVersion === undefined || documentVersion === null)
            throw new Error("The parameter 'documentVersion' must be defined.");
        url_ = url_.replace("{documentVersion}", encodeURIComponent("" + documentVersion));
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCompareWithVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompareWithVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentHistoryDifference>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentHistoryDifference>;
        }));
    }

    protected processCompareWithVersion(response: HttpResponseBase): Observable<DocumentHistoryDifference> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistoryDifference.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search
     * @param request The document history search request.
     * @return Document history search result.
     */
    search(request: DocumentHistorySearchRequest): Observable<DocumentHistorySearchResult> {
        let url_ = this.baseUrl + "/v1/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentHistorySearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentHistorySearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<DocumentHistorySearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocumentHistorySearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class IdentityProviderService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get all identity providers
     * @return Array of identity providers
     */
    getAll(): Observable<IdentityProvider[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityProvider[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityProvider[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IdentityProvider[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get basic info for all providers
     * @return Array of identity provider basic information
     */
    getAllBasicInfos(): Observable<IdentityProviderBasicInfo[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/basicInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBasicInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBasicInfos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityProviderBasicInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityProviderBasicInfo[]>;
        }));
    }

    protected processGetAllBasicInfos(response: HttpResponseBase): Observable<IdentityProviderBasicInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityProviderBasicInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get identity provider
     * @param id Identity provider ID.
     * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
     */
    get(id: string | null): Observable<IdentityProvider> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityProvider>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityProvider>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IdentityProvider> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProvider.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update identity provider
     * @param id Identity provider ID.
     * @param provider Update request
     * @return Represents an identity provider defined in IdentityServer and its Picturepark configuration
     */
    update(id: string | null, provider: IdentityProviderEditable): Observable<IdentityProvider> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(provider);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityProvider>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityProvider>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IdentityProvider> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProvider.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get synchronizable attributes
     * @return Names of user attributes
     */
    getSynchronizableAttributes(): Observable<string[]> {
        let url_ = this.baseUrl + "/v1/IdentityProviders/synchronizableAttributes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSynchronizableAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSynchronizableAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetSynchronizableAttributes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InfoService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get version
     * @return VersionInfo
     */
    getVersion(): Observable<VersionInfo> {
        let url_ = this.baseUrl + "/v1/Info/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VersionInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VersionInfo>;
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get info
     * @return CustomerInfo
     */
    protected getInfoCore(): Observable<CustomerInfo> {
        let url_ = this.baseUrl + "/v1/Info/customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerInfo>;
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<CustomerInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get status
     * @return SystemStatus
     */
    getStatus(): Observable<SystemStatus> {
        let url_ = this.baseUrl + "/v1/Info/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SystemStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SystemStatus>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<SystemStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class JsonSchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get json schema
     * @param id The ID of the schema whose json schema to retrieve.
     */
    get(id: string | null): Observable<any> {
        let url_ = this.baseUrl + "/v1/JsonSchemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ListItemService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
  @LazyGetter()
  protected get liquidRenderingService(): LiquidRenderingService {
    return this.injector.get(LiquidRenderingService);
  }

  constructor(
    protected injector: Injector,
    @Inject(AuthService) configuration: AuthService,
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string
  ) {
    super(configuration);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
  }

  get(listItemId: string, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail> {
    return this.getCore(listItemId, resolveBehaviors).pipe(
      _observableMergeMap(async listItem => {
        await this.liquidRenderingService.renderNestedDisplayValues(listItem);
        return listItem;
      })
    );
  }

  search(listItemSearchRequest: ListItemSearchRequest): Observable<ListItemSearchResult> {
    return this.searchCore(listItemSearchRequest).pipe(
      _observableMergeMap(async searchResult => {
        await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
        return searchResult;
      })
    );
  }

    /**
     * Get list item
     * @param id The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @return List item detail
     */
    protected getCore(id: string | null, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update list item
     * @param id The list item ID.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request The list item update request.
     * @return List item detail
     */
    update(id: string | null, resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ListItemUpdateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete list item
     * @param id The ID of the list item to delete.
     * @param forceReferenceRemoval (optional) A value indicating whether references to the list item should be removed.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    delete(id: string | null, forceReferenceRemoval: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (forceReferenceRemoval === null)
            throw new Error("The parameter 'forceReferenceRemoval' cannot be null.");
        else if (forceReferenceRemoval !== undefined)
            url_ += "forceReferenceRemoval=" + encodeURIComponent("" + forceReferenceRemoval) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkBusinessException.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore list item
     * @param id The list item ID.
     * @param allowMissingDependencies (optional) Allows restoring list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @return Ok
     */
    restore(id: string | null, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}/restore?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get list item references
     * @param id The ID of the list item.
     * @param request Request options to specify how many references to fetch.
     * @return List item references
     */
    getReferences(id: string | null, request: ListItemReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/ListItems/{id}/references/search";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferences(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferences(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemReferencesResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemReferencesResult>;
        }));
    }

    protected processGetReferences(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create list item
     * @param resolveBehaviors (optional) List of enums that control which parts of the list item are resolved and returned.
     * @param allowMissingDependencies (optional) Allows creating list items that refer to list items or contents that don't exist in the system.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param waitSearchDocCreation (optional) Wait for the creation of the search document and the rendered display values.
                By default the endpoint waits for the search document creation. Passing false, the endpoint will return when the main entity has been created and the creation of the search document has been enqueued but not yet performed.
     * @param request List item create request.
     * @return List item detail
     */
    create(resolveBehaviors: ListItemResolveBehavior[] | null | undefined, allowMissingDependencies: boolean | undefined, timeout: string | null | undefined, waitSearchDocCreation: boolean | undefined, request: ListItemCreateRequest): Observable<ListItemDetail> {
        let url_ = this.baseUrl + "/v1/ListItems?";
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (allowMissingDependencies === null)
            throw new Error("The parameter 'allowMissingDependencies' cannot be null.");
        else if (allowMissingDependencies !== undefined)
            url_ += "allowMissingDependencies=" + encodeURIComponent("" + allowMissingDependencies) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (waitSearchDocCreation === null)
            throw new Error("The parameter 'waitSearchDocCreation' cannot be null.");
        else if (waitSearchDocCreation !== undefined)
            url_ += "waitSearchDocCreation=" + encodeURIComponent("" + waitSearchDocCreation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ListItemDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple list items
     * @param ids (optional) List of list item IDs.
     * @param resolveBehaviors (optional) List of enums that control which parts of the list items are resolved and returned.
     * @return List of list item details
     */
    getMany(ids: string[] | null | undefined, resolveBehaviors: ListItemResolveBehavior[] | null | undefined): Observable<ListItemDetail[]> {
        let url_ = this.baseUrl + "/v1/ListItems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<ListItemDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple list items
     * @param request List item create many request.
     * @return Business process
     */
    createMany(request: ListItemCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple list items
     * @param request List item update many request.
     * @return Business process
     */
    updateMany(request: ListItemUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple list items
     * @param request List item delete many request.
     * @return Business process
     */
    deleteMany(request: ListItemDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple list items - by filter
     * @param request Delete many by filter request.
     * @return Business process
     */
    deleteManyByFilter(request: ListItemDeleteManyFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/delete/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteManyByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteManyByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore multiple list items
     * @param request List item restore many request.
     * @return Business process
     */
    restoreMany(request: ListItemRestoreManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/many/restore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRestoreMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple list items references
     * @param request ListItemManyReferencesRequest
     * @return A list of references per list item.
     */
    getReferencesMany(request: ListItemManyReferencesRequest): Observable<ListItemReferencesResult> {
        let url_ = this.baseUrl + "/v1/ListItems/many/references/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferencesMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferencesMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemReferencesResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemReferencesResult>;
        }));
    }

    protected processGetReferencesMany(response: HttpResponseBase): Observable<ListItemReferencesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemReferencesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Batch update fields - by IDs
     * @param request List item fields batch update request.
     * @return Business process
     */
    batchUpdateFieldsByIds(request: ListItemFieldsBatchUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/batches/fields/ids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processBatchUpdateFieldsByIds(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Batch update fields - by filter
     * @param request List item fields batch update by filter request.
     * @return Business process
     */
    batchUpdateFieldsByFilter(request: ListItemFieldsBatchUpdateFilterRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/ListItems/batches/fields/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchUpdateFieldsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchUpdateFieldsByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processBatchUpdateFieldsByFilter(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search list items
     * @param request The list item search request.
     * @return List item search result
     */
    protected searchCore(request: ListItemSearchRequest): Observable<ListItemSearchResult> {
        let url_ = this.baseUrl + "/v1/ListItems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListItemSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListItemSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListItemSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate list items
     * @param request The list item aggregation request.
     * @return Object aggregation result
     */
    aggregate(request: ListItemAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/ListItems/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LiveStreamService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search
     * @param request Parameters for the search
     * @return Resulting live stream events
     */
    search(request: LiveStreamSearchRequest): Observable<LiveStreamSearchResult> {
        let url_ = this.baseUrl + "/v1/LiveStream/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LiveStreamSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LiveStreamSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<LiveStreamSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiveStreamSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MetadataService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get status
     * @return The overall status of the contents and list items in comparison to the actual schemas' structure
     */
    getStatus(): Observable<MetadataStatus> {
        let url_ = this.baseUrl + "/v1/Metadata/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MetadataStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MetadataStatus>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<MetadataStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MetadataStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update outdated
     * @return Business process
     */
    updateOutdated(): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Metadata/many/updateOutdated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateOutdated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOutdated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateOutdated(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NotificationService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get notification
     * @param id ID of notification
     * @return Notification
     */
    get(id: string | null): Observable<Notification> {
        let url_ = this.baseUrl + "/v1/Notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Notification>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Notification>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Notification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Mark notification as read
     * @param id ID of notification
     * @return Notification
     */
    markAsRead(id: string | null): Observable<Notification> {
        let url_ = this.baseUrl + "/v1/Notifications/{id}/markAsRead";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processMarkAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Notification>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Notification>;
        }));
    }

    protected processMarkAsRead(response: HttpResponseBase): Observable<Notification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search notifications
     * @param request Notification search request
     * @return Notification search result
     */
    search(request: NotificationSearchRequest): Observable<NotificationCompactResult> {
        let url_ = this.baseUrl + "/v1/Notifications/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationCompactResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationCompactResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<NotificationCompactResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationCompactResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate on notifications
     * @param request Notification aggregation request
     * @return Aggregation result
     */
    aggregate(request: NotificationAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Notifications/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Mark all notifications as read
     */
    markAllAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Notifications/markAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processMarkAllAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get email notification settings
     * @return Email notification settings
     */
    getEmailNotificationSettings(): Observable<EmailNotificationsSettings> {
        let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEmailNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailNotificationsSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailNotificationsSettings>;
        }));
    }

    protected processGetEmailNotificationSettings(response: HttpResponseBase): Observable<EmailNotificationsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailNotificationsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update email notification settings
     * @param configuration Email notification settings
     * @return Email notification settings
     */
    putEmailNotificationSettings(configuration: EmailNotificationsSettings): Observable<EmailNotificationsSettings> {
        let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(configuration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPutEmailNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutEmailNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailNotificationsSettings>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailNotificationsSettings>;
        }));
    }

    protected processPutEmailNotificationSettings(response: HttpResponseBase): Observable<EmailNotificationsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailNotificationsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get notification types available for email settings.
     */
    getAvailableNotificationTypes(): Observable<{ [key: string]: NotificationType[]; }> {
        let url_ = this.baseUrl + "/v1/Notifications/emailNotifications/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAvailableNotificationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableNotificationTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: NotificationType[]; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: NotificationType[]; }>;
        }));
    }

    protected processGetAvailableNotificationTypes(response: HttpResponseBase): Observable<{ [key: string]: NotificationType[]; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => NotificationType.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputFormatService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Sets the download file name patterns for an output format
     * @param id ID of the output format.
     * @param patterns Dictionary containing patterns per metadata language.
    If this is set, at least the customer's default language is required.
    Set any other language to an empty string and a fallback to the default language will occur.
    Set parameter to null to clear any already set patterns.
     * @return Business process
     */
    setDownloadFileNamePatterns(id: string | null, patterns: { [key: string]: string; }): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}/downloadFileNamePatterns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patterns);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDownloadFileNamePatterns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDownloadFileNamePatterns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetDownloadFileNamePatterns(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sets the download file name patterns for multiple output formats
     * @param request The request containing the patterns for each output format.
     * @return Business process
     */
    setDownloadFileNamePatternsMany(request: OutputFormatDownloadFileNamePatternUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/downloadFileNamePatterns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDownloadFileNamePatternsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDownloadFileNamePatternsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetDownloadFileNamePatternsMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Enables or disables XMP writeback for an output format
     * @param id ID of the output format.
     * @param request The request containing the state to be set for the output format.
     * @return Business process
     */
    setXmpWritebackState(id: string | null, request: OutputFormatSetXmpWritebackStateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}/xmpWriteback";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetXmpWritebackState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetXmpWritebackState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetXmpWritebackState(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Enables or disables XMP writeback for multiple output formats
     * @param request The request containing the state changes for each output format.
     * @return Business process
     */
    setXmpWritebackStateMany(request: OutputFormatSetXmpWritebackStateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/xmpWriteback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetXmpWritebackStateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetXmpWritebackStateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetXmpWritebackStateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates permission-related settings for an output format
     * @param id ID of the output format.
     * @param request The request containing the settings for the output format.
     * @return Business process
     */
    setPermission(id: string | null, request: OutputFormatSetPermissionRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}/permission";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetPermission(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates permission-related settings for multiple output formats
     * @param request The request containing the state changes for each output format.
     * @return Business process
     */
    setPermissionMany(request: OutputFormatSetPermissionManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSetPermissionMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissionMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processSetPermissionMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Render output format preview
     * @param request Information about the OutputFormat as well as which Content to use for the preview.
     * @return Rendered file
     */
    renderFormatPreview(request: OutputFormatRenderPreviewRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/OutputFormats/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRenderFormatPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenderFormatPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRenderFormatPreview(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple output formats
     * @param ids (optional) Output format IDs to get information about. If this is omitted, all output formats in the system will be returned.
     * @return Array of Represents an output format.
     */
    getMany(ids: string[] | null | undefined): Observable<OutputFormatDetail[]> {
        let url_ = this.baseUrl + "/v1/OutputFormats?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputFormatDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputFormatDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<OutputFormatDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutputFormatDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create output format
     * @param request Request containing information needed to create new output format.
     * @return Business process
     */
    create(request: OutputFormat): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update output format
     * @param id Output format ID.
     * @param request Request containing information needed to update the output format.
     * @return Business process
     */
    update(id: string | null, request: OutputFormatEditable): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete output format
     * @param id Output format ID.
     * @return Business process
     */
    delete(id: string | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get output format
     * @param id Output format ID.
     * @return Represents an output format.
     */
    get(id: string | null): Observable<OutputFormatDetail> {
        let url_ = this.baseUrl + "/v1/OutputFormats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputFormatDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputFormatDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputFormatDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputFormatDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple output formats
     * @param request Request containing information needed to create new output format.
     * @return Business process
     */
    createMany(request: OutputFormatCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple output formats
     * @param request Request containing information needed to update the output format.
     * @return Business process
     */
    updateMany(request: OutputFormatUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple output formats
     * @param request The request with output format IDs to delete.
     * @return Business process
     */
    deleteMany(request: OutputFormatDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/OutputFormats/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OutputService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get output
     * @param id Output ID.
     * @return Output detail
     */
    get(id: string | null): Observable<OutputDetail> {
        let url_ = this.baseUrl + "/v1/Outputs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutputDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search output documents
     * @param request The output search request.
     * @return Output result set
     */
    search(request: OutputSearchRequest): Observable<OutputSearchResult> {
        let url_ = this.baseUrl + "/v1/Outputs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutputSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutputSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<OutputSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutputSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Resets retry attempt counters.
     * @param request Request containing options to filter which outputs should be reset.
     * @return Business process tracking the resetting
     */
    resetRetryAttempts(request: OutputResetRetryAttemptsRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Outputs/resetRetryAttempts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processResetRetryAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetRetryAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processResetRetryAttempts(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProfileService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get
     * @return User profile
     */
    get(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfile>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfile>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update
     * @param request Request to update a user profile..
     * @return Updated user profile
     */
    update(request: UserProfileUpdateRequest): Observable<UserProfile> {
        let url_ = this.baseUrl + "/v1/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfile>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfile>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Request deletion
     * @return OK
     */
    requestDeletion(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Profile/requestDeletion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRequestDeletion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestDeletion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestDeletion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaPermissionSetService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema permission set
     * @param id Schema permission set ID.
     * @return Detail of a schema permission set
     */
    get(id: string | null): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaPermissionSetDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update schema permission set
     * @param id Schema permission set ID.
     * @param permissionSet Permission set
     * @return Detail of a schema permission set
     */
    update(id: string | null, permissionSet: SchemaPermissionSetUpdateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaPermissionSetDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete schema permission set
     * @param id Schema permission set ID.
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create schema permission set
     * @param permissionSet Permission set
     * @return Detail of a schema permission set
     */
    create(permissionSet: SchemaPermissionSetCreateRequest): Observable<SchemaPermissionSetDetail> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionSet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaPermissionSetDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaPermissionSetDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaPermissionSetDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaPermissionSetDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple schema permission sets
     * @param ids (optional) Ids
     * @return Array of Detail of a schema permission set
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaPermissionSetDetail[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaPermissionSetDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaPermissionSetDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaPermissionSetDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaPermissionSetDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership of schema permission set
     * @param id Schema permission set ID.
     * @param request Request to transfer the ownership of a permission set.
     */
    transferOwnership(id: string | null, request: PermissionSetOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/ownership";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get permissions for schema permission set
     * @param id Schema permission set ID.
     * @return Array of Permission set rights
     */
    getPermissions(id: string | null): Observable<PermissionSetRight[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetRight[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetRight[]>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionSetRight[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple schema permission sets
     * @param request Request to update multiple schema permission sets.
     * @return Response to a bulk operation
     */
    createMany(request: SchemaPermissionSetCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple schema permission sets
     * @param request Request to update multiple schema permissions sets.
     * @return Response to a bulk operation
     */
    updateMany(request: SchemaPermissionSetUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple schema permission sets
     * @param request Request to delete multiple permission sets.
     * @return Response to a bulk operation
     */
    deleteMany(request: PermissionSetDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership of multiple schema permission sets
     * @param request Request to transfer the ownership of multiple permission sets.
     */
    transferOwnershipMany(request: PermissionSetOwnershipTransferManyRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get permissions for multiple schema permission sets
     * @param ids (optional) Ids
     * @return Array of Rights that the current user has on a permission set
     */
    getPermissionsMany(ids: string[] | null | undefined): Observable<PermissionSetUserPermissionRights[]> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/many/permissions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetUserPermissionRights[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetUserPermissionRights[]>;
        }));
    }

    protected processGetPermissionsMany(response: HttpResponseBase): Observable<PermissionSetUserPermissionRights[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionSetUserPermissionRights.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search schema permission set
     * @param request Request to search permission sets.
     * @return Result of a permission set search operation
     */
    search(request: PermissionSetSearchRequest): Observable<PermissionSetSearchResult> {
        let url_ = this.baseUrl + "/v1/SchemaPermissionSets/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionSetSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionSetSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PermissionSetSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSetSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get schema
     * @param id The schema ID.
     * @return Schema detail
     */
    get(id: string | null): Observable<SchemaDetail> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SchemaDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update schema
     * @param id The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param request The schema update request.
     * @return Schema update result, containing the updated schema
     */
    update(id: string | null, timeout: string | null | undefined, request: SchemaUpdateRequest): Observable<SchemaUpdateResult> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaUpdateResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaUpdateResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SchemaUpdateResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaUpdateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete schema
     * @param id The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @return Schema delete result
     */
    delete(id: string | null, timeout: string | null | undefined): Observable<SchemaDeleteResult> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaDeleteResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaDeleteResult>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<SchemaDeleteResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaDeleteResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Exists schema
     * @param id The schema ID.
     * @return Schema Exists response
     */
    exists(id: string | null): Observable<SchemaExistsResponse> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/exists";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaExistsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaExistsResponse>;
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<SchemaExistsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Exists field in schema
     * @param schemaId The schema ID.
     * @param fieldId The field ID.
     * @return Field Exists response
     */
    fieldExists(schemaId: string | null, fieldId: string | null): Observable<FieldExistsResponse> {
        let url_ = this.baseUrl + "/v1/Schemas/{schemaId}/{fieldId}/exists";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processFieldExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFieldExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldExistsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldExistsResponse>;
        }));
    }

    protected processFieldExists(response: HttpResponseBase): Observable<FieldExistsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldExistsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets all schemas referenced by the schema specified in id
     * @param id The schema ID.
     * @param sourceSchema (optional) If true, the returned schemas contain also the source schema for which the referenced schemas were requested. If false, the source schema is not returned (default behavior).
     * @return Referenced schema details
     */
    getReferenced(id: string | null, sourceSchema: boolean | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/referenced?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sourceSchema === null)
            throw new Error("The parameter 'sourceSchema' cannot be null.");
        else if (sourceSchema !== undefined)
            url_ += "sourceSchema=" + encodeURIComponent("" + sourceSchema) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferenced(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaDetail[]>;
        }));
    }

    protected processGetReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership
     * @param id The schema ID.
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param request Request detailing which user to transfer to.
     * @return OK
     */
    transferOwnership(id: string | null, timeout: string | null | undefined, request: SchemaOwnershipTransferRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/ownership?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnership(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTransferOwnership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create schema
     * @param timeout (optional) Maximum time to wait for the operation to complete. If timeout is exceeded, the operation is not aborted but continues anyhow.
                Only the waiting is aborted, and the calls returned.
     * @param request The schema create request.
     * @return Schema create result, containing the created schema
     */
    create(timeout: string | null | undefined, request: SchemaCreateRequest): Observable<SchemaCreateResult> {
        let url_ = this.baseUrl + "/v1/Schemas?";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaCreateResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaCreateResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SchemaCreateResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaCreateResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple schemas
     * @param ids (optional) Comma separated list of schema IDs.
     * @return List of schema details
     */
    getMany(ids: string[] | null | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple schemas
     * @param request The schema create many request.
     * @return BusinessProcess which can be awaited
     */
    createMany(request: SchemaCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple schema
     * @param request Request to update multiple schemas.
     * @return BusinessProcess which can be awaited
     */
    updateMany(request: SchemaUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets all schemas referenced by the schemas specified in ids
     * @param ids (optional) The schema IDs.
     * @param sourceSchema (optional) If true, the returned schemas contain also the source schemas for which the referenced schemas were requested. If false, the source schemas are not returned (default behavior).
     * @return Referenced schema details
     */
    getManyReferenced(ids: string[] | null | undefined, sourceSchema: boolean | undefined): Observable<SchemaDetail[]> {
        let url_ = this.baseUrl + "/v1/Schemas/many/referenced?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (sourceSchema === null)
            throw new Error("The parameter 'sourceSchema' cannot be null.");
        else if (sourceSchema !== undefined)
            url_ += "sourceSchema=" + encodeURIComponent("" + sourceSchema) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetManyReferenced(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyReferenced(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaDetail[]>;
        }));
    }

    protected processGetManyReferenced(response: HttpResponseBase): Observable<SchemaDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SchemaDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Transfer ownership of multiple schemas
     * @param request Schema ownership transfer many request.
     * @return Business process
     */
    transferOwnershipMany(request: SchemaOwnershipTransferManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Schemas/many/ownership";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferOwnershipMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferOwnershipMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processTransferOwnershipMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search schemas
     * @param request The schema search request.
     * @return Schema search result
     */
    search(request: SchemaSearchRequest): Observable<SchemaSearchResult> {
        let url_ = this.baseUrl + "/v1/Schemas/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchemaSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchemaSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SchemaSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchemaSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used in an aggregator on a schema.
     * @param id The ID of the schema.
     * @return The list of fields
     */
    getAggregationFields(id: string | null): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/aggregationFields";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAggregationFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAggregationFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetAggregationFields(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used in an aggregator on multiple schemas.
     * @param ids (optional) The IDs of the schemas.
     * @return The list of fields
     */
    getAggregationFieldsMany(ids: string[] | null | undefined): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Schemas/many/aggregationFields?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAggregationFieldsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAggregationFieldsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetAggregationFieldsMany(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used in a filter on a schema.
     * @param id The ID of the schema.
     * @return The list of fields
     */
    getFilterFields(id: string | null): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Schemas/{id}/filterFields";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFilterFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetFilterFields(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used in a filter on multiple schemas.
     * @param ids (optional) The IDs of the schemas.
     * @return The list of fields
     */
    getFilterFieldsMany(ids: string[] | null | undefined): Observable<FieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Schemas/many/filterFields?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFilterFieldsMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterFieldsMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FieldInfo[]>;
        }));
    }

    protected processGetFilterFieldsMany(response: HttpResponseBase): Observable<FieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve the fields that can be used for sorting.
     * @param schemaTypes (optional) Schema types to include in search
     * @return The list of fields
     */
    getSortFieldsBySchemaTypes(schemaTypes: SchemaType[] | null | undefined): Observable<SortFieldInfo[]> {
        let url_ = this.baseUrl + "/v1/Schemas/many/sortFieldsBySchemaType?";
        if (schemaTypes !== undefined && schemaTypes !== null)
            schemaTypes && schemaTypes.forEach(item => { url_ += "schemaTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSortFieldsBySchemaTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortFieldsBySchemaTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SortFieldInfo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SortFieldInfo[]>;
        }));
    }

    protected processGetSortFieldsBySchemaTypes(response: HttpResponseBase): Observable<SortFieldInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SortFieldInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SchemaTransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Import schemas
     * @param request The schema import request.
     * @return Transfer
     */
    import(request: SchemaImportRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/SchemaTransfers/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Transfer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Transfer>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkBusinessException.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShareService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    
  @LazyGetter()
  protected get liquidRenderingService(): LiquidRenderingService {
    return this.injector.get(LiquidRenderingService);
  }

  constructor(
    protected injector: Injector,
    @Inject(AuthService) configuration: AuthService,
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string
  ) {
    super(configuration);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl('');
  }

  get(
    id: string | null,
    resolveBehaviors: ShareResolveBehavior[] | null | undefined,
    contentResolveLimit: number | null | undefined
  ): Observable<ShareDetail> {
    return this.getCore(id, resolveBehaviors, contentResolveLimit).pipe(
      _observableMergeMap(async shareDetail => {
        await this.liquidRenderingService.renderNestedDisplayValues(shareDetail);
        return shareDetail;
      })
    );
  }

  getShareByToken(
    token: string,
    lang: string | null | undefined,
    resolveBehaviors: ShareResolveBehavior[] | null | undefined,
    contentResolveLimit: number | null | undefined,
    cdnUrl?: string
  ): Observable<ShareDetail> {
    if (cdnUrl) {
      return this.getShareByTokenFromUrl(
        token,
        lang,
        resolveBehaviors,
        contentResolveLimit,
        cdnUrl + '/json/{token}?'
      ).pipe(
        _observableMergeMap(async shareJson => {
          await this.liquidRenderingService.renderNestedDisplayValues(shareJson);
          return shareJson;
        })
      );
    } else {
      return this.getShareJsonCore(token, lang, resolveBehaviors, contentResolveLimit).pipe(
        _observableMergeMap(async shareJson => {
          await this.liquidRenderingService.renderNestedDisplayValues(shareJson);
          return shareJson;
        })
      );
    }
  }

  getShareContents(
    token: string | null,
    lang: string | null | undefined,
    limit: number | undefined,
    pageToken: string | null | undefined,
    cdnUrl?: string
  ): Observable<ShareContentDetailResult> {
    if (cdnUrl) {
      return this.getShareContentsCoreFromUrl(token, lang, limit, pageToken, cdnUrl + 'json/{token}/contents?').pipe(
        _observableMergeMap(async shareJson => {
          await this.liquidRenderingService.renderNestedDisplayValues(shareJson);
          return shareJson;
        })
      );
    } else {
      return this.getShareContentsCore(token, lang, limit, pageToken).pipe(
        _observableMergeMap(async shareJson => {
          await this.liquidRenderingService.renderNestedDisplayValues(shareJson);
          return shareJson;
        })
      );
    }
  }

  /**
   * Get share contents
   * @param token Share token
   * @param lang (optional) Language code
   * @param limit (optional) Number of contents to return
   * @param pageToken (optional) PageToken to page over contents
   * @return ShareContentDetailResult
   */
  protected getShareContentsCoreFromUrl(
    token: string | null,
    lang: string | null | undefined,
    limit: number | undefined,
    pageToken: string | null | undefined,
    url: string
  ): Observable<ShareContentDetailResult> {
    let url_ = url;
    if (token === undefined || token === null) {
      throw new Error("The parameter 'token' must be defined.");
    }
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (lang !== undefined && lang !== null) {
      url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
    }
    if (limit === null) {
      throw new Error("The parameter 'limit' cannot be null.");
    } else if (limit !== undefined) {
      url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
    }
    if (pageToken !== undefined && pageToken !== null) {
      url_ += 'pageToken=' + encodeURIComponent('' + pageToken) + '&';
    }
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return _observableFrom(this.transformOptions(options_))
      .pipe(
        _observableMergeMap(transformedOptions_ => {
          return this.http.request('get', url_, transformedOptions_);
        })
      )
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShareContents(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShareContents(<any>response_);
            } catch (e) {
              return <Observable<ShareContentDetailResult>>(<any>_observableThrow(e));
            }
          } else {
            return <Observable<ShareContentDetailResult>>(<any>_observableThrow(response_));
          }
        })
      );
  }

  /**
   * Get share json
   * @param token Share token
   * @param lang (optional) Language code
   * @return ShareDetail
   */
  protected getShareByTokenFromUrl(
    token: string,
    lang: string | null | undefined,
    resolveBehaviors: ShareResolveBehavior[] | null | undefined,
    contentResolveLimit: number | null | undefined,
    url: string
  ): Observable<any> {
    let url_ = url;
    if (token === undefined || token === null) {
      throw new Error("The parameter 'token' must be defined.");
    }
    url_ = url_.replace('{token}', encodeURIComponent('' + token));
    if (lang !== undefined) {
      url_ += 'lang=' + encodeURIComponent('' + lang) + '&';
    }
    if (resolveBehaviors !== undefined && resolveBehaviors !== null) {
      resolveBehaviors.forEach(item => {
        url_ += 'resolveBehaviors=' + encodeURIComponent('' + item) + '&';
      });
    }
    if (contentResolveLimit !== undefined && contentResolveLimit !== null) {
      url_ += 'contentResolveLimit=' + encodeURIComponent('' + contentResolveLimit) + '&';
    }
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return _observableFrom(this.transformOptions(options_))
      .pipe(
        _observableMergeMap(transformedOptions_ => {
          return this.http.request('get', url_, transformedOptions_);
        })
      )
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShareJson(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShareJson(<any>response_);
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(e));
            }
          } else {
            return <Observable<any>>(<any>_observableThrow(response_));
          }
        })
      );
  }

  search(shareSearchRequest: ShareSearchRequest): Observable<ShareSearchResult> {
    return this.searchCore(shareSearchRequest).pipe(
      _observableMergeMap(async searchResult => {
        await this.liquidRenderingService.renderNestedDisplayValues(searchResult);
        return searchResult;
      })
    );
  }

    /**
     * Get share json
     * @param token Share token
     * @param lang (optional) Language code
     * @param resolveBehaviors (optional) List of enums that control which parts of the share are resolved and returned.
     * @param contentResolveLimit (optional) Optional limit the number of contents to resolve. Use a lower value for higher performance. If nothing is specified, everything is resolved.
     * @return ShareDetail
     */
    protected getShareJsonCore(token: string | null, lang: string | null | undefined, resolveBehaviors: ShareResolveBehavior[] | null | undefined, contentResolveLimit: number | null | undefined): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/Shares/json/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (lang !== undefined && lang !== null)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (contentResolveLimit !== undefined && contentResolveLimit !== null)
            url_ += "contentResolveLimit=" + encodeURIComponent("" + contentResolveLimit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareDetail>;
        }));
    }

    protected processGetShareJson(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get share contents
     * @param token Share token
     * @param lang (optional) Language code
     * @param limit (optional) Number of contents to return
     * @param pageToken (optional) PageToken to page over contents
     * @return ShareContentDetailResult
     */
    protected getShareContentsCore(token: string | null, lang: string | null | undefined, limit: number | undefined, pageToken: string | null | undefined): Observable<ShareContentDetailResult> {
        let url_ = this.baseUrl + "/v1/Shares/json/{token}/contents?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (lang !== undefined && lang !== null)
            url_ += "lang=" + encodeURIComponent("" + lang) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (pageToken !== undefined && pageToken !== null)
            url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetShareContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShareContents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareContentDetailResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareContentDetailResult>;
        }));
    }

    protected processGetShareContents(response: HttpResponseBase): Observable<ShareContentDetailResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareContentDetailResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get shared outputs
     * @param token Share token
     * @return List of OutputResolveResult
     */
    getOutputsInShare(token: string | null): Observable<ShareOutputsResult> {
        let url_ = this.baseUrl + "/v1/Shares/json/{token}/outputs";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOutputsInShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutputsInShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareOutputsResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareOutputsResult>;
        }));
    }

    protected processGetOutputsInShare(response: HttpResponseBase): Observable<ShareOutputsResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareOutputsResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     */
    download(token: string | null, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download selection of a share
     * @param token Share token
     * @param request Share download request
     * @return DownloadLink
     */
    createShareSelectionDownloadLink(token: string | null, request: ShareDownloadRequest): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateShareSelectionDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShareSelectionDownloadLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadLink>;
        }));
    }

    protected processCreateShareSelectionDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download shared output
     * @param token Share token
     * @param contentId The content id
     * @param outputFormatId The output format id
     * @param width (optional) Optional width in pixels to resize image
     * @param height (optional) Optional height in pixels to resize image
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     */
    downloadSingleContent(token: string | null, contentId: string | null, outputFormatId: string | null, width: number | null | undefined, height: number | null | undefined, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}/{contentId}/{outputFormatId}?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadSingleContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadSingleContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadSingleContent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download shared outputs
     * @param token Share token
     * @param conversionPreset Image editing specification
     * @param range (optional) The range of bytes to download (http range header): bytes={from}-{to} (e.g. bytes=0-100000)
     */
    downloadWithConversionPreset(token: string | null, conversionPreset: string | null, range: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/v1/Shares/d/{token}/{conversionPreset}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (conversionPreset === undefined || conversionPreset === null)
            throw new Error("The parameter 'conversionPreset' must be defined.");
        url_ = url_.replace("{conversionPreset}", encodeURIComponent("" + conversionPreset));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWithConversionPreset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWithConversionPreset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadWithConversionPreset(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download shared display content outputs
     * @param token Share token
     * @param contentId The content id
     * @param outputFormatId Id of the output format
     */
    downloadDisplayContentOutputs(token: string | null, contentId: string | null, outputFormatId: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/d/{token}/displayContent/{contentId}/{outputFormatId}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (outputFormatId === undefined || outputFormatId === null)
            throw new Error("The parameter 'outputFormatId' must be defined.");
        url_ = url_.replace("{outputFormatId}", encodeURIComponent("" + outputFormatId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadDisplayContentOutputs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDisplayContentOutputs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadDisplayContentOutputs(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 412) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get
     * @param id Share Id (not token, use [GetShareJson](#operation/Share_GetShareJson) to get share by token)
     * @param resolveBehaviors (optional) List of enums that control which parts of the share are resolved and returned.
     * @param contentResolveLimit (optional) Optional limit the number of contents to resolve. Use a lower value for higher performance. If nothing is specified, everything is resolved.
     * @return Share detail
     */
    protected getCore(id: string | null, resolveBehaviors: ShareResolveBehavior[] | null | undefined, contentResolveLimit: number | null | undefined): Observable<ShareDetail> {
        let url_ = this.baseUrl + "/v1/Shares/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (resolveBehaviors !== undefined && resolveBehaviors !== null)
            resolveBehaviors && resolveBehaviors.forEach(item => { url_ += "resolveBehaviors=" + encodeURIComponent("" + item) + "&"; });
        if (contentResolveLimit !== undefined && contentResolveLimit !== null)
            url_ += "contentResolveLimit=" + encodeURIComponent("" + contentResolveLimit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ShareDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update
     * @param id The share id.
     * @param request The share update request.
     * @return BusinessProcess
     */
    update(id: string | null, request: ShareBaseUpdateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get contents in share
     * @param id Share Id
     * @param limit (optional) Number of contents to return
     * @param pageToken (optional) PageToken to page over contents
     * @return ShareContentDetailResult
     */
    getContentsInShare(id: string | null, limit: number | undefined, pageToken: string | null | undefined): Observable<ShareContentDetailResult> {
        let url_ = this.baseUrl + "/v1/Shares/{id}/contents?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (pageToken !== undefined && pageToken !== null)
            url_ += "pageToken=" + encodeURIComponent("" + pageToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetContentsInShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContentsInShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareContentDetailResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareContentDetailResult>;
        }));
    }

    protected processGetContentsInShare(response: HttpResponseBase): Observable<ShareContentDetailResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareContentDetailResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create
     * @param request Polymorphic create contract. Use either ShareBasicCreateRequest or ShareEmbedCreateRequest
     * @return BusinessProcess
     */
    create(request: ShareBaseCreateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkBusinessException.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple shares
     * @param request A delete many request containing the ids of the shares to delete.
     * @return BusinessProcess
     */
    deleteMany(request: ShareDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Revokes multiple shares
     * @param request A revoke many request containing the ids of the shares to revoke.
     * @return BusinessProcess
     */
    revoke(request: ShareRevokeManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Shares/many/revoke";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRevoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processRevoke(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate
     * @param request Aggregation request
     * @return Share aggregation result
     */
    aggregate(request: ShareAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Shares/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search
     * @param request Search request
     * @return Share search result
     */
    protected searchCore(request: ShareSearchRequest): Observable<ShareSearchResult> {
        let url_ = this.baseUrl + "/v1/Shares/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShareSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShareSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ShareSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShareSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StatisticService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Retrieve single content statistics
     * @param contentId Id of Content
     * @param timeFrames (optional) Optionally aggregate data for given time frames
     */
    getSingleContentStatistics(contentId: string | null, timeFrames: string[] | null | undefined): Observable<ContentStatisticsAggregated> {
        let url_ = this.baseUrl + "/v1/Statistics/contents/{contentId}?";
        if (contentId === undefined || contentId === null)
            throw new Error("The parameter 'contentId' must be defined.");
        url_ = url_.replace("{contentId}", encodeURIComponent("" + contentId));
        if (timeFrames !== undefined && timeFrames !== null)
            timeFrames && timeFrames.forEach(item => { url_ += "timeFrames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSingleContentStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleContentStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContentStatisticsAggregated>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContentStatisticsAggregated>;
        }));
    }

    protected processGetSingleContentStatistics(response: HttpResponseBase): Observable<ContentStatisticsAggregated> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentStatisticsAggregated.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Export content statistics
     * @param request Request
     * @return Business process
     */
    exportContentStatistics(request: ExportContentStatisticsRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Statistics/contents/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processExportContentStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportContentStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processExportContentStatistics(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Resolve download link
     * @param referenceId Reference id
     * @return Download link information
     */
    resolveDownloadLink(referenceId: string | null): Observable<DownloadLink> {
        let url_ = this.baseUrl + "/v1/Statistics/downloadLink/{referenceId}";
        if (referenceId === undefined || referenceId === null)
            throw new Error("The parameter 'referenceId' must be defined.");
        url_ = url_.replace("{referenceId}", encodeURIComponent("" + referenceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processResolveDownloadLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveDownloadLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadLink>;
        }));
    }

    protected processResolveDownloadLink(response: HttpResponseBase): Observable<DownloadLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add content events
     * @param request Request
     * @return Business process
     */
    addContentEvents(request: AddContentEventsRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Statistics/contents/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddContentEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContentEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processAddContentEvents(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TemplateService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get template
     * @param id ID of template.
     * @return Template
     */
    get(id: string | null): Observable<Template> {
        let url_ = this.baseUrl + "/v1/Templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Template>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Template>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Template> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Template.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update template
     * @param id ID of template.
     * @param request Template
     * @return Template
     */
    update(id: string | null, request: TemplateUpdateRequest): Observable<Template> {
        let url_ = this.baseUrl + "/v1/Templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Template>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Template>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Template> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Template.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete template
     * @param id ID of template
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Templates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create template
     * @param request TemplateCreateRequest
     * @return Template
     */
    create(request: TemplateCreateRequest): Observable<Template> {
        let url_ = this.baseUrl + "/v1/Templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Template>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Template>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Template> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Template.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all templates
     * @return All templates
     */
    getAll(): Observable<Template[]> {
        let url_ = this.baseUrl + "/v1/Templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Template[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Template[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Template[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Template.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search templates
     * @param searchRequest The template search request.
     * @return Template search result
     */
    search(searchRequest: TemplateSearchRequest): Observable<TemplateSearchResult> {
        let url_ = this.baseUrl + "/v1/Templates/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<TemplateSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TransferService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Create transfer
     * @param request The create transfer request
     * @return Transfer
     */
    create(request: CreateTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Transfer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Transfer>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkException.fromJS(resultData400);
            return throwException("Internal server error", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get transfer details
     * @param id ID of transfer.
     * @return TransferDetail
     */
    get(id: string | null): Observable<TransferDetail> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransferDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransferDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete transfer
     * @param id ID of transfer.
     * @return OK
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Import transfer
     * @param id ID of transfer.
     * @param request The ImportTransfer request.
     * @return Transfer
     */
    import(id: string | null, request: ImportTransferRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/import";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Transfer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Transfer>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Import transfer partially
     * @param id ID of transfer.
     * @param request The ImportTransferPartial request.
     * @return Transfer
     */
    partialImport(id: string | null, request: ImportTransferPartialRequest): Observable<Transfer> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/partialImport";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPartialImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartialImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Transfer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Transfer>;
        }));
    }

    protected processPartialImport(response: HttpResponseBase): Observable<Transfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transfer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cancel transfer
     * @param id ID of transfer.
     * @return OK
     */
    cancel(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search
     * @param request The transfer search request
     * @return TransferSearchResult
     */
    search(request: TransferSearchRequest): Observable<TransferSearchResult> {
        let url_ = this.baseUrl + "/v1/Transfers/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransferSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransferSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<TransferSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get file
     * @param id ID of file transfer.
     * @return FileTransferDetail
     */
    getFile(id: string | null): Observable<FileTransferDetail> {
        let url_ = this.baseUrl + "/v1/Transfers/files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileTransferDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileTransferDetail>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileTransferDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search for files
     * @param request The file transfer search request
     * @return FileTransferSearchResult
     */
    searchFiles(request: FileTransferSearchRequest): Observable<FileTransferSearchResult> {
        let url_ = this.baseUrl + "/v1/Transfers/files/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearchFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileTransferSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileTransferSearchResult>;
        }));
    }

    protected processSearchFiles(response: HttpResponseBase): Observable<FileTransferSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileTransferSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete files
     * @param request The file transfer delete request
     */
    deleteFiles(request: FileTransferDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Transfers/files/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get blacklist
     * @return Blacklist
     */
    getBlacklist(): Observable<Blacklist> {
        let url_ = this.baseUrl + "/v1/Transfers/files/blacklist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBlacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlacklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Blacklist>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Blacklist>;
        }));
    }

    protected processGetBlacklist(response: HttpResponseBase): Observable<Blacklist> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Blacklist.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Upload file
     * @param chunkNumber Information about chunk.
     * @param currentChunkSize Information about chunk.
     * @param totalSize Information about chunk.
     * @param totalChunks Information about chunk.
     * @param transferId ID of transfer.
     * @param requestId Identifier of file.
     * @param body (optional) Body
     * @return OK
     */
    uploadFile(chunkNumber: number, currentChunkSize: number, totalSize: number, totalChunks: number, transferId: string | null, requestId: string | null, body: Blob | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/Transfers/{transferId}/files/{requestId}/upload?";
        if (transferId === undefined || transferId === null)
            throw new Error("The parameter 'transferId' must be defined.");
        url_ = url_.replace("{transferId}", encodeURIComponent("" + transferId));
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        if (chunkNumber === undefined || chunkNumber === null)
            throw new Error("The parameter 'chunkNumber' must be defined and cannot be null.");
        else
            url_ += "ChunkNumber=" + encodeURIComponent("" + chunkNumber) + "&";
        if (currentChunkSize === undefined || currentChunkSize === null)
            throw new Error("The parameter 'currentChunkSize' must be defined and cannot be null.");
        else
            url_ += "CurrentChunkSize=" + encodeURIComponent("" + currentChunkSize) + "&";
        if (totalSize === undefined || totalSize === null)
            throw new Error("The parameter 'totalSize' must be defined and cannot be null.");
        else
            url_ += "TotalSize=" + encodeURIComponent("" + totalSize) + "&";
        if (totalChunks === undefined || totalChunks === null)
            throw new Error("The parameter 'totalChunks' must be defined and cannot be null.");
        else
            url_ += "TotalChunks=" + encodeURIComponent("" + totalChunks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/octet-stream",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Search user roles
     * @param request User role search request.
     * @return Result of the user role search
     */
    search(request: UserRoleSearchRequest): Observable<UserRoleSearchResult> {
        let url_ = this.baseUrl + "/v1/UserRoles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserRoleSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple user roles
     * @param ids (optional) User role IDs to get information about.
     * @return Array of Represents a user role, which associates users with user rights.
     */
    getMany(ids: string[] | null | undefined): Observable<UserRoleDetail[]> {
        let url_ = this.baseUrl + "/v1/UserRoles?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserRoleDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create user role
     * @param request Request containing information needed to create new user role.
     * @return Represents a user role, which associates users with user rights.
     */
    create(request: UserRoleCreateRequest): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple user roles
     * @param request Request containing information needed to create new user role.
     * @return Response to a bulk operation
     */
    createMany(request: UserRoleCreateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple user roles
     * @param request Request containing information needed to update the user role.
     * @return Response to a bulk operation
     */
    updateMany(request: UserRoleUpdateManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple user roles
     * @param request The request with user role IDs to delete.
     * @return Response to a bulk operation
     */
    deleteMany(request: UserRoleDeleteManyRequest): Observable<BulkResponse> {
        let url_ = this.baseUrl + "/v1/UserRoles/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkResponse>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BulkResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user role
     * @param id User role ID.
     * @return Represents a user role, which associates users with user rights.
     */
    get(id: string | null): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update user role
     * @param id User role ID.
     * @param request Request containing information needed to update the user role.
     * @return Represents a user role, which associates users with user rights.
     */
    update(id: string | null, request: UserRoleEditable): Observable<UserRoleDetail> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRoleDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRoleDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserRoleDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRoleDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete user role
     * @param id User role ID.
     */
    delete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/UserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Get user
     * @param id User ID to search for.
     * @return Requested user details
     */
    get(id: string | null): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetail>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update user
     * @param id User ID to action on.
     * @param request New user information.
     * @return User details after the update of the user
     */
    update(id: string | null, request: UserUpdateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetail>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Lock / unlock user
     * @param id User ID to action on.
     * @param request Request detailing if the user should be locked or unlocked.
     * @return OK
     */
    lock(id: string | null, request: UserLockRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Change lock state of multiple users
     * @param request Information about users to update and the desired lock state
     * @return Business process
     */
    lockMany(request: UserLockManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processLockMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processLockMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Change user's review state
     * @param id User ID to action on.
     * @param request Request detailing if the user should be set as _reviewed_ or _to be reviewed_.
     * @return OK
     */
    review(id: string | null, request: UserReviewRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/review";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Change Review state of multiple users
     * @param request Information about users to update and the desired review state
     * @return Business process
     */
    reviewMany(request: UserReviewManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReviewMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReviewMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processReviewMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invite user
     * @param id User ID to action on.
     * @return OK
     */
    invite(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/invite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invite multiple users
     * @param request Information about users to invite
     * @return Business process
     */
    inviteMany(request: UserInviteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInviteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processInviteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Reinvite user
     * @param id User ID to action on.
     * @return OK
     */
    reinvite(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/reinvite";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReinvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReinvite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReinvite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Reinvite users
     * @param request Information about users to reinvite
     * @return Business process
     */
    reInviteMany(request: UserReinviteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/reinvite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processReInviteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReInviteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processReInviteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Assign or unassign userRoles
     * @param request Information about users to modify and kind of operation
     * @return Business process
     */
    assignUserRoles(request: UserRoleAssignManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/assignUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAssignUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processAssignUserRoles(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete user
     * @param id User ID
     * @param request Request with details about deletion
     * @return OK
     */
    delete(id: string | null, request: UserDeleteRequest): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Archive user
     * @param id User ID
     * @return OK
     */
    archive(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processArchive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processArchive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restore user
     * @param id User ID to action on.
     * @return OK
     */
    restore(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRestore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Cancels a user triggered deletion request and returns user to _Reviewed_ state.
     * @param id User ID to action on.
     * @return OK
     */
    cancelDeletionRequest(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Users/{id}/cancelDeletionRequest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelDeletionRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelDeletionRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelDeletionRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user by owner token
     * @param tokenId ID of the owner token.
     * @return User details of the user referenced by the owner token
     */
    getByOwnerToken(tokenId: string | null): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users/owner/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetByOwnerToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOwnerToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetail>;
        }));
    }

    protected processGetByOwnerToken(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create user
     * @param request Requested user information.
     * @return Newly created user
     */
    create(request: UserCreateRequest): Observable<UserDetail> {
        let url_ = this.baseUrl + "/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetail>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetail>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple users
     * @param ids (optional) User IDs.
     * @return Details of all the users who were found
     */
    getMany(ids: string[] | null | undefined): Observable<UserDetail[]> {
        let url_ = this.baseUrl + "/v1/Users/many?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetail[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<UserDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDetail.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search users
     * @param request User search request.
     * @return Result of the user search
     */
    search(request: UserSearchRequest): Observable<UserSearchResult> {
        let url_ = this.baseUrl + "/v1/Users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserSearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserSearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserSearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Aggregate users
     * @param request User aggregation request.
     * @return Aggregation based on the request
     */
    aggregate(request: UserAggregationRequest): Observable<ObjectAggregationResult> {
        let url_ = this.baseUrl + "/v1/Users/aggregate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAggregate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAggregate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectAggregationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectAggregationResult>;
        }));
    }

    protected processAggregate(response: HttpResponseBase): Observable<ObjectAggregationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectAggregationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update identity provider on multiple users
     * @param request User update identity provider request.
     * @return Business process
     */
    updateIdentityProviderMany(request: UserUpdateIdentityProviderManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/Users/many/updateIdentityProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateIdentityProviderMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdentityProviderMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateIdentityProviderMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * List users, result contains only essential info about user. Requires the `ListUsers` or the `ManageUsers` UserRight.
     * @param request User list request.
     * @return Result of the list users
     */
    list(request: UserListRequest): Observable<UserListResult> {
        let url_ = this.baseUrl + "/v1/Users/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserListResult>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<UserListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class XmpMappingService extends PictureparkServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AuthService) configuration: AuthService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(PICTUREPARK_API_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * Gets fields available for XMP mapping.
     * @return XmpMappingTargets containing both XMP fields and metadata fields that are available for mapping.
     */
    getAvailableTargets(): Observable<XmpMappingTargets> {
        let url_ = this.baseUrl + "/v1/XmpMappings/targets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAvailableTargets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableTargets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XmpMappingTargets>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XmpMappingTargets>;
        }));
    }

    protected processGetAvailableTargets(response: HttpResponseBase): Observable<XmpMappingTargets> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XmpMappingTargets.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Searches for XMP mappings
     * @param request Search request for getting configured XMP mappings.
     * @return Holds results of search for XMP mappings
     */
    search(request: XmpMappingEntrySearchRequest): Observable<XmpMappingEntrySearchResult> {
        let url_ = this.baseUrl + "/v1/XmpMappings/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XmpMappingEntrySearchResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XmpMappingEntrySearchResult>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<XmpMappingEntrySearchResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XmpMappingEntrySearchResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create xmp mapping
     * @param request Request containing information needed to create new xmp mapping.
     * @return Business process
     */
    create(request: XmpMappingEntryCreateRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get multiple xmp mappings
     * @param ids (optional) Xmp mapping IDs to get information about.
     * @return Array of XMP mapping entry
     */
    getMany(ids: string[] | null | undefined): Observable<XmpMappingEntry[]> {
        let url_ = this.baseUrl + "/v1/XmpMappings?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XmpMappingEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XmpMappingEntry[]>;
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<XmpMappingEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(XmpMappingEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update xmp mapping
     * @param id Xmp mapping ID.
     * @param request Request containing information needed to update the xmp mapping.
     * @return Business process
     */
    update(id: string | null, request: XmpMappingEntry): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete xmp mapping
     * @param id Xmp mapping ID.
     * @return Business process
     */
    delete(id: string | null): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get xmp mapping
     * @param id Xmp mapping ID.
     * @return XMP mapping entry
     */
    get(id: string | null): Observable<XmpMappingEntry> {
        let url_ = this.baseUrl + "/v1/XmpMappings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XmpMappingEntry>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XmpMappingEntry>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<XmpMappingEntry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XmpMappingEntry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple xmp mappings
     * @param request Request containing information needed to create new xmp mapping.
     * @return Business process
     */
    createMany(request: XmpMappingEntryCreateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processCreateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update multiple xmp mappings
     * @param request Request containing information needed to update the xmp mapping.
     * @return Business process
     */
    updateMany(request: XmpMappingEntryUpdateManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings/many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete multiple xmp mappings
     * @param request The request with xmp mapping IDs to delete.
     * @return Business process
     */
    deleteMany(request: XmpMappingEntryDeleteManyRequest): Observable<BusinessProcess> {
        let url_ = this.baseUrl + "/v1/XmpMappings/many/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessProcess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessProcess>;
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<BusinessProcess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BusinessProcess.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PictureparkValidationException.fromJS(resultData400);
            return throwException("Validation exception", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = PictureparkForbiddenException.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PictureparkNotFoundException.fromJS(resultData404);
            return throwException("Entity not found", status, _responseText, _headers, result404);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Method not allowed", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = PictureparkConflictException.fromJS(resultData409);
            return throwException("Version conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 429) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = PictureparkTooManyRequestsException.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PictureparkException.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Business process */
export class BusinessProcess implements IBusinessProcess {
    /** ID of the business process. */
    id!: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId!: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation!: boolean;
    /** Scope of the business process. */
    businessProcessScope!: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle!: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate!: Date;
    /** When the business process finished. */
    endDate!: Date;
    /** Is the business process finished. */
    finished!: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: BusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
    /** Id of the business process that will be automatically started after the completion of the current one, if any. */
    continuationBusinessProcessId?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.stateHistory) {
                this.stateHistory = [];
                for (let i = 0; i < data.stateHistory.length; i++) {
                    let item = data.stateHistory[i];
                    this.stateHistory[i] = item && !(<any>item).toJSON ? new BusinessProcessState(item) : <BusinessProcessState>item;
                }
            }
        }
        this._discriminator = "BusinessProcess";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processDefinitionId = _data["processDefinitionId"];
            this.referenceId = _data["referenceId"];
            this.referenceDocType = _data["referenceDocType"];
            this.supportsCancellation = _data["supportsCancellation"];
            this.businessProcessScope = _data["businessProcessScope"];
            this.lifeCycle = _data["lifeCycle"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.finished = _data["finished"];
            if (Array.isArray(_data["stateHistory"])) {
                this.stateHistory = [] as any;
                for (let item of _data["stateHistory"])
                    this.stateHistory!.push(BusinessProcessState.fromJS(item));
            }
            this.currentState = _data["currentState"];
            this.lastReportedProgress = _data["lastReportedProgress"] ? new Date(_data["lastReportedProgress"].toString()) : <any>undefined;
            this.continuationBusinessProcessId = _data["continuationBusinessProcessId"];
        }
    }

    static fromJS(data: any): BusinessProcess {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetails") {
            let result = new BusinessProcessDetails();
            result.init(data);
            return result;
        }
        let result = new BusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        data["processDefinitionId"] = this.processDefinitionId;
        data["referenceId"] = this.referenceId;
        data["referenceDocType"] = this.referenceDocType;
        data["supportsCancellation"] = this.supportsCancellation;
        data["businessProcessScope"] = this.businessProcessScope;
        data["lifeCycle"] = this.lifeCycle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["finished"] = this.finished;
        if (Array.isArray(this.stateHistory)) {
            data["stateHistory"] = [];
            for (let item of this.stateHistory)
                data["stateHistory"].push(item.toJSON());
        }
        data["currentState"] = this.currentState;
        data["lastReportedProgress"] = this.lastReportedProgress ? this.lastReportedProgress.toISOString() : <any>undefined;
        data["continuationBusinessProcessId"] = this.continuationBusinessProcessId;
        return data;
    }
}

/** Business process */
export interface IBusinessProcess {
    /** ID of the business process. */
    id: string;
    /** ID of the business process definition associated to the business process. */
    processDefinitionId: string;
    /** ID of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceId?: string | undefined;
    /** Type of the document that is modified by the running of the business process. Used during the cancellation of the business process. */
    referenceDocType?: string | undefined;
    /** True if the business process execution can be cancelled. False otherwise. */
    supportsCancellation: boolean;
    /** Scope of the business process. */
    businessProcessScope: BusinessProcessScope;
    /** Current life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** When the business process started. */
    startDate: Date;
    /** When the business process finished. */
    endDate: Date;
    /** Is the business process finished. */
    finished: boolean;
    /** List containing the history of all the state transitions of the business process. */
    stateHistory?: IBusinessProcessState[] | undefined;
    /** Current state of the business process. */
    currentState?: string | undefined;
    /** Timestamp when the business process last reported progress. */
    lastReportedProgress?: Date | undefined;
    /** Id of the business process that will be automatically started after the completion of the current one, if any. */
    continuationBusinessProcessId?: string | undefined;
}

/** Scope of the business process */
export enum BusinessProcessScope {
    System = "System",
    User = "User",
}

/** Life cycle of the business process */
export enum BusinessProcessLifeCycle {
    Draft = "Draft",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    Cancelled = "Cancelled",
    CancellationInProgress = "CancellationInProgress",
    Failed = "Failed",
    SucceededWithErrors = "SucceededWithErrors",
}

/** State transition information of a business process */
export class BusinessProcessState implements IBusinessProcessState {
    /** State of the business process */
    state!: string;
    /** Date and time of when the state transition was performed. */
    timestamp!: Date;
    /** Eventual error associated to the state transition. */
    error?: ErrorResponse | undefined;

    constructor(data?: IBusinessProcessState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.error = _data["error"] ? ErrorResponse.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessState {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

/** State transition information of a business process */
export interface IBusinessProcessState {
    /** State of the business process */
    state: string;
    /** Date and time of when the state transition was performed. */
    timestamp: Date;
    /** Eventual error associated to the state transition. */
    error?: IErrorResponse | undefined;
}

/** Error information with serialized exception */
export class ErrorResponse implements IErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exception = _data["exception"];
            this.traceId = _data["traceId"];
            this.traceJobId = _data["traceJobId"];
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        return data;
    }
}

/** Error information with serialized exception */
export interface IErrorResponse {
    /** Serialized PictureparkBusinessException. */
    exception?: string | undefined;
    /** Trace ID. */
    traceId?: string | undefined;
    /** Trace job ID. */
    traceJobId?: string | undefined;
}

export class Exception implements IException {

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IException {
}

export class PictureparkException extends Exception implements IPictureparkException {
    traceLevel?: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode?: number;
    exceptionMessage?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IPictureparkException) {
        super(data);
        this._discriminator = "PictureparkException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.traceLevel = _data["traceLevel"];
            this.traceId = _data["traceId"];
            this.traceJobId = _data["traceJobId"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.exceptionMessage = _data["exceptionMessage"];
        }
    }

    static override fromJS(data: any): PictureparkException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkBusinessException") {
            let result = new PictureparkBusinessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderDeleteException") {
            let result = new ServiceProviderDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderCreateException") {
            let result = new ServiceProviderCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ServiceProviderNotFoundException") {
            let result = new ServiceProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ElasticVersionUpdateException") {
            let result = new ElasticVersionUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidVersionException") {
            let result = new InvalidVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotDeactivatedException") {
            let result = new EnvironmentNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotFoundException") {
            let result = new EnvironmentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentDeactivationException") {
            let result = new EnvironmentDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerViolationException") {
            let result = new CustomerViolationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasNotFoundException") {
            let result = new CustomerAliasNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotDeactivatedException") {
            let result = new CustomerNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerDeactivationException") {
            let result = new CustomerDeactivationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerHostNotFoundException") {
            let result = new CustomerHostNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotFoundException") {
            let result = new CustomerNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotActiveException") {
            let result = new CustomerNotActiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationIndexNotFoundException") {
            let result = new ConfigurationIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAliasException") {
            let result = new DuplicateAliasException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RedisDatabaseExceededException") {
            let result = new RedisDatabaseExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumTransferSizeException") {
            let result = new MaximumTransferSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentNotAvailableException") {
            let result = new EnvironmentNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerNotAvailableException") {
            let result = new CustomerNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTooManyRequestsException") {
            let result = new PictureparkTooManyRequestsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentSchemaChangeException") {
            let result = new ContentSchemaChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentNotFoundException") {
            let result = new CommentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleException") {
            let result = new UnableToDeleteUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotDeactivatedException") {
            let result = new UserNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserWithOwnerTokensArchiveException") {
            let result = new UserWithOwnerTokensArchiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserAlreadyInRequestedLockStateException") {
            let result = new UserAlreadyInRequestedLockStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LoginUsingIncorrectIdentityProviderException") {
            let result = new LoginUsingIncorrectIdentityProviderException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IdentityProviderNotFoundException") {
            let result = new IdentityProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserDoesNotSupportLocalLoginException") {
            let result = new UserDoesNotSupportLocalLoginException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserAttributeNotSynchronizableException") {
            let result = new UserAttributeNotSynchronizableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToMapMultipleClaimTypesIntoSameAttributeException") {
            let result = new UnableToMapMultipleClaimTypesIntoSameAttributeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToChangeMappedUserRolesForFederatedUserException") {
            let result = new UnableToChangeMappedUserRolesForFederatedUserException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteDefaultUserRoleException") {
            let result = new UnableToDeleteDefaultUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException") {
            let result = new UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPropertyChangeNotSupportedException") {
            let result = new UserPropertyChangeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotLinkedWithIdsException") {
            let result = new UserNotLinkedWithIdsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageCodeNotExistingException") {
            let result = new LanguageCodeNotExistingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserByOwnerTokenNotFoundException") {
            let result = new UserByOwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FormatNotApplicableForRenderingException") {
            let result = new FormatNotApplicableForRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FocalPointCropSizeMissingException") {
            let result = new FocalPointCropSizeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputNotFoundException") {
            let result = new ShareOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSharedOutputException") {
            let result = new DuplicateSharedOutputException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateEmbedConversionPresetException") {
            let result = new DuplicateEmbedConversionPresetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnmodifiedOriginalOutputNotFoundException") {
            let result = new UnmodifiedOriginalOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputEditingNotSupportedException") {
            let result = new OutputEditingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupNotRequestedException") {
            let result = new OutputBackupNotRequestedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupHashMismatchException") {
            let result = new OutputBackupHashMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputOperationInProgressException") {
            let result = new OutputOperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DownloadLinkExpiredException") {
            let result = new DownloadLinkExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingNotAwaitedException") {
            let result = new RenderingNotAwaitedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateContentDownloadRequestException") {
            let result = new DuplicateContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentDownloadRequestException") {
            let result = new InvalidContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DownloadNotFoundException") {
            let result = new DownloadNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EmbedMultiDownloadException") {
            let result = new EmbedMultiDownloadException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageOptimizationLicensingException") {
            let result = new ImageOptimizationLicensingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardIndexNotAllowedException") {
            let result = new ReshardIndexNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidException") {
            let result = new ReshardNumberOfShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfRoutingShardsInvalidException") {
            let result = new ReshardNumberOfRoutingShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidForExistingRoutingShardsException") {
            let result = new ReshardNumberOfShardsInvalidForExistingRoutingShardsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorInNonRootAggregatorException") {
            let result = new InvalidUiBehaviorInNonRootAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorConfigurationException") {
            let result = new InvalidUiBehaviorConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSearchFieldInAggregatorException") {
            let result = new InvalidSearchFieldInAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringTooLongException") {
            let result = new SearchStringTooLongException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameMissingException") {
            let result = new AggregationNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFieldMissingException") {
            let result = new AggregationFieldMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationPathMissingException") {
            let result = new AggregationPathMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemResolveBehaviorNotSupportedException") {
            let result = new ListItemResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidLogoFileExtensionException") {
            let result = new InvalidLogoFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UploadFailedException") {
            let result = new UploadFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumNumberOfChunksExceededException") {
            let result = new MaximumNumberOfChunksExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumFileSizeExceededException") {
            let result = new MaximumFileSizeExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException") {
            let result = new InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException") {
            let result = new SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemasMetadataProtectionException") {
            let result = new SchemasMetadataProtectionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterTemplateRenderingException") {
            let result = new FilterTemplateRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ResolvedLinkedItemsThresholdReachedException") {
            let result = new ResolvedLinkedItemsThresholdReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotFilterableException") {
            let result = new SchemaFieldNotFilterableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSortableInUseException") {
            let result = new SchemaFieldSortableInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsNotSupportedForStructsException") {
            let result = new SchemaMetadataProtectionSettingsNotSupportedForStructsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException") {
            let result = new SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCountLimitReachedException") {
            let result = new SchemaCountLimitReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldActivityInUseException") {
            let result = new SchemaFieldActivityInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaChangeNotAllowedException") {
            let result = new SchemaFieldReferencedSchemaChangeNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaSystemSchemaException") {
            let result = new SchemaFieldReferencedSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationRelationTypeIdModificationNotAllowedException") {
            let result = new SchemaFieldRelationRelationTypeIdModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationTargetDocTypeModificationNotAllowedException") {
            let result = new SchemaFieldRelationTargetDocTypeModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldMarkdownNotMultilineException") {
            let result = new SchemaFieldMarkdownNotMultilineException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException") {
            let result = new IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDynamicViewFieldInvalidFilterTemplateException") {
            let result = new SchemaFieldDynamicViewFieldInvalidFilterTemplateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentHistoricVersionNotFoundException") {
            let result = new ContentHistoricVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException") {
            let result = new UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConcurrentFileReplacementDuringRepairException") {
            let result = new ConcurrentFileReplacementDuringRepairException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentResolveBehaviorNotSupportedException") {
            let result = new ContentResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TooManyBusinessProcessesException") {
            let result = new TooManyBusinessProcessesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessContinuationException") {
            let result = new BusinessProcessContinuationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotBatchBasedException") {
            let result = new BusinessProcessSummaryNotBatchBasedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotFoundException") {
            let result = new BusinessProcessSummaryNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationNotFoundException") {
            let result = new NotificationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointException") {
            let result = new BusinessRuleConditionInvalidTriggerPointException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationInvalidIdException") {
            let result = new BusinessRuleNotificationInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationNoRecipientsException") {
            let result = new BusinessRuleNotificationNoRecipientsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserRoleIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserRoleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceInvalidIdException") {
            let result = new BusinessRuleNumberSequenceInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceIdDuplicationException") {
            let result = new BusinessRuleNumberSequenceIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleInvalidCronExpressionException") {
            let result = new BusinessRuleScheduleInvalidCronExpressionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleFilterMissingException") {
            let result = new BusinessRuleScheduleFilterMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleRulesMissingException") {
            let result = new BusinessRuleScheduleRulesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleStringContainsConditionValuesToMatchMissingException") {
            let result = new BusinessRuleStringContainsConditionValuesToMatchMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException") {
            let result = new BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDateMathTransformationTimeSpanInvalidException") {
            let result = new BusinessRuleDateMathTransformationTimeSpanInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransferOwnershipTransferUserIdMissingException") {
            let result = new BusinessRuleTransferOwnershipTransferUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleOutputFormatIdMissingException") {
            let result = new BusinessRuleOutputFormatIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException") {
            let result = new BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTagsFoundException") {
            let result = new NoTagsFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotAvailableException") {
            let result = new OutputNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ModelNotFoundException") {
            let result = new ModelNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatNotFoundException") {
            let result = new OutputFormatNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionForFormatException") {
            let result = new NotSupportedFileExtensionForFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackNotSupportedException") {
            let result = new OutputFormatXmpWritebackNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException") {
            let result = new OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatsInUseException") {
            let result = new OutputFormatsInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatOperationInProgressException") {
            let result = new OutputFormatOperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StaticOutputFormatModificationNotSupportedException") {
            let result = new StaticOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OriginalOutputFormatModificationNotSupportedException") {
            let result = new OriginalOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotValidForRenderingCategoryException") {
            let result = new OutputFormatSourceNotValidForRenderingCategoryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionModificationNotAllowedException") {
            let result = new CollectionModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionNotFoundException") {
            let result = new CollectionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NonDefaultTemplateNameNotAllowedException") {
            let result = new NonDefaultTemplateNameNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemTemplateModificationNotAllowedException") {
            let result = new SystemTemplateModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateDuplicationException") {
            let result = new TemplateDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateLanguageCodeNotSupportedException") {
            let result = new TemplateLanguageCodeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesMissingException") {
            let result = new TemplateMediaTypesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesNotSupportedException") {
            let result = new TemplateMediaTypesNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateNotFoundException") {
            let result = new TemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotSupported") {
            let result = new XmpMappingFieldNotSupported();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotFoundException") {
            let result = new XmpMappingFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingSchemaNotAvailableForFileContentSchemaException") {
            let result = new XmpMappingSchemaNotAvailableForFileContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException") {
            let result = new XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException") {
            let result = new XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldInUseException") {
            let result = new XmpMappingFieldInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingConfigurationInvalidException") {
            let result = new XmpMappingConfigurationInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ActivityMappingInvalidException") {
            let result = new ActivityMappingInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsExportNotEnabledException") {
            let result = new StatisticsExportNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsFeatureNotEnabledException") {
            throw new Error("The abstract class 'StatisticsFeatureNotEnabledException' cannot be instantiated.");
        }
        if (data["kind"] === "StatisticsReadNotEnabledException") {
            let result = new StatisticsReadNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsWriteNotEnabledException") {
            let result = new StatisticsWriteNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConversionPresetTemplateNotFoundException") {
            let result = new ConversionPresetTemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentOwnershipFailureException") {
            let result = new CommentOwnershipFailureException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyDeletionException") {
            let result = new CommentReplyDeletionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyParentException") {
            let result = new CommentReplyParentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyContentMismatchException") {
            let result = new CommentReplyContentMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VirtualDisplayContentNotSupportedException") {
            let result = new VirtualDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SelfReferencingDisplayContentNotSupportedException") {
            let result = new SelfReferencingDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["traceLevel"] = this.traceLevel;
        data["traceId"] = this.traceId;
        data["traceJobId"] = this.traceJobId;
        data["httpStatusCode"] = this.httpStatusCode;
        data["exceptionMessage"] = this.exceptionMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkException extends IException {
    traceLevel?: TraceLevel;
    traceId?: string | undefined;
    traceJobId?: string | undefined;
    httpStatusCode?: number;
    exceptionMessage?: string | undefined;
}

export class PictureparkBusinessException extends PictureparkException implements IPictureparkBusinessException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IPictureparkBusinessException) {
        super(data);
        this._discriminator = "PictureparkBusinessException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerAlias = _data["customerAlias"];
            this.userId = _data["userId"];
        }
    }

    static override fromJS(data: any): PictureparkBusinessException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PictureparkValidationException") {
            let result = new PictureparkValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkForbiddenException") {
            let result = new PictureparkForbiddenException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkNotFoundException") {
            let result = new PictureparkNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkConflictException") {
            let result = new PictureparkConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTooManyRequestsException") {
            let result = new PictureparkTooManyRequestsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferencesUpdateException") {
            let result = new ReferencesUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReferenceUpdateException") {
            let result = new ReferenceUpdateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentSchemaChangeException") {
            let result = new ContentSchemaChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentNotFoundException") {
            let result = new CommentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleException") {
            let result = new UnableToDeleteUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotDeactivatedException") {
            let result = new UserNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserWithOwnerTokensArchiveException") {
            let result = new UserWithOwnerTokensArchiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceNotNewestException") {
            let result = new TermsOfServiceNotNewestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnauthorizedException") {
            let result = new UnauthorizedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserAlreadyInRequestedLockStateException") {
            let result = new UserAlreadyInRequestedLockStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LoginUsingIncorrectIdentityProviderException") {
            let result = new LoginUsingIncorrectIdentityProviderException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IdentityProviderNotFoundException") {
            let result = new IdentityProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserDoesNotSupportLocalLoginException") {
            let result = new UserDoesNotSupportLocalLoginException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserAttributeNotSynchronizableException") {
            let result = new UserAttributeNotSynchronizableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToMapMultipleClaimTypesIntoSameAttributeException") {
            let result = new UnableToMapMultipleClaimTypesIntoSameAttributeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToChangeMappedUserRolesForFederatedUserException") {
            let result = new UnableToChangeMappedUserRolesForFederatedUserException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteDefaultUserRoleException") {
            let result = new UnableToDeleteDefaultUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException") {
            let result = new UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPropertyChangeNotSupportedException") {
            let result = new UserPropertyChangeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotLinkedWithIdsException") {
            let result = new UserNotLinkedWithIdsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageCodeNotExistingException") {
            let result = new LanguageCodeNotExistingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserByOwnerTokenNotFoundException") {
            let result = new UserByOwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingException") {
            let result = new RenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FormatNotApplicableForRenderingException") {
            let result = new FormatNotApplicableForRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FocalPointCropSizeMissingException") {
            let result = new FocalPointCropSizeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputNotFoundException") {
            let result = new ShareOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TokenGenerationException") {
            let result = new TokenGenerationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareExpiredException") {
            let result = new ShareExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSharedOutputException") {
            let result = new DuplicateSharedOutputException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateEmbedConversionPresetException") {
            let result = new DuplicateEmbedConversionPresetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnmodifiedOriginalOutputNotFoundException") {
            let result = new UnmodifiedOriginalOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputEditingNotSupportedException") {
            let result = new OutputEditingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupNotRequestedException") {
            let result = new OutputBackupNotRequestedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupHashMismatchException") {
            let result = new OutputBackupHashMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputOperationInProgressException") {
            let result = new OutputOperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DownloadLinkExpiredException") {
            let result = new DownloadLinkExpiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RenderingNotAwaitedException") {
            let result = new RenderingNotAwaitedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateContentDownloadRequestException") {
            let result = new DuplicateContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentDownloadRequestException") {
            let result = new InvalidContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DownloadNotFoundException") {
            let result = new DownloadNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EmbedMultiDownloadException") {
            let result = new EmbedMultiDownloadException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageOptimizationLicensingException") {
            let result = new ImageOptimizationLicensingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LeaseNotAcquiredException") {
            let result = new LeaseNotAcquiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OperationInProgressException") {
            let result = new OperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectTypeMismatchException") {
            let result = new ObjectTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FailedToLockException") {
            let result = new FailedToLockException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkOperationCanceledException") {
            let result = new PictureparkOperationCanceledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkApplicationException") {
            let result = new PictureparkApplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "UnknownException") {
            let result = new UnknownException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardIndexNotAllowedException") {
            let result = new ReshardIndexNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidException") {
            let result = new ReshardNumberOfShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfRoutingShardsInvalidException") {
            let result = new ReshardNumberOfRoutingShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidForExistingRoutingShardsException") {
            let result = new ReshardNumberOfShardsInvalidForExistingRoutingShardsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSearchIndexDocException") {
            let result = new DuplicateSearchIndexDocException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexDocNotFoundException") {
            let result = new SearchIndexDocNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexDocumentNotFoundException") {
            let result = new IndexDocumentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexNotFoundException") {
            let result = new SearchIndexNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultSearchIndexDeleteException") {
            let result = new DefaultSearchIndexDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchIndexInUseException") {
            let result = new SearchIndexInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexException") {
            let result = new IndexException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexMappingException") {
            let result = new IndexMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorInNonRootAggregatorException") {
            let result = new InvalidUiBehaviorInNonRootAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorConfigurationException") {
            let result = new InvalidUiBehaviorConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSearchFieldInAggregatorException") {
            let result = new InvalidSearchFieldInAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringTooLongException") {
            let result = new SearchStringTooLongException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameMissingException") {
            let result = new AggregationNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFieldMissingException") {
            let result = new AggregationFieldMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationPathMissingException") {
            let result = new AggregationPathMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreResponseException") {
            let result = new ObjectStoreResponseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ObjectStoreException") {
            let result = new ObjectStoreException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "QueryException") {
            let result = new QueryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemCyclicDependencyException") {
            let result = new ListItemCyclicDependencyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemUpdateManyException") {
            let result = new ListItemUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemResolveBehaviorNotSupportedException") {
            let result = new ListItemResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidLogoFileExtensionException") {
            let result = new InvalidLogoFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidTransferTypeException") {
            let result = new InvalidTransferTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UploadFailedException") {
            let result = new UploadFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumNumberOfChunksExceededException") {
            let result = new MaximumNumberOfChunksExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumFileSizeExceededException") {
            let result = new MaximumFileSizeExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException") {
            let result = new InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationNotFoundException") {
            let result = new RelationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeNotFoundException") {
            let result = new RelationTypeNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeTargetDocTypeMismatchException") {
            let result = new RelationTypeTargetDocTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationTypeMissingException") {
            let result = new RelationTypeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException") {
            let result = new SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemasMetadataProtectionException") {
            let result = new SchemasMetadataProtectionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterTemplateRenderingException") {
            let result = new FilterTemplateRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ResolvedLinkedItemsThresholdReachedException") {
            let result = new ResolvedLinkedItemsThresholdReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaInfoException") {
            let result = new DuplicateSchemaInfoException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotFilterableException") {
            let result = new SchemaFieldNotFilterableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSortableInUseException") {
            let result = new SchemaFieldSortableInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsNotSupportedForStructsException") {
            let result = new SchemaMetadataProtectionSettingsNotSupportedForStructsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException") {
            let result = new SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaCountLimitReachedException") {
            let result = new SchemaCountLimitReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldActivityInUseException") {
            let result = new SchemaFieldActivityInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaChangeNotAllowedException") {
            let result = new SchemaFieldReferencedSchemaChangeNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaSystemSchemaException") {
            let result = new SchemaFieldReferencedSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationRelationTypeIdModificationNotAllowedException") {
            let result = new SchemaFieldRelationRelationTypeIdModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationTargetDocTypeModificationNotAllowedException") {
            let result = new SchemaFieldRelationTargetDocTypeModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldMarkdownNotMultilineException") {
            let result = new SchemaFieldMarkdownNotMultilineException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException") {
            let result = new IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDynamicViewFieldInvalidFilterTemplateException") {
            let result = new SchemaFieldDynamicViewFieldInvalidFilterTemplateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentMetadataUpdateManyException") {
            let result = new ContentMetadataUpdateManyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentBackupFailedException") {
            let result = new ContentBackupFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentHistoricVersionNotFoundException") {
            let result = new ContentHistoricVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException") {
            let result = new UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConcurrentFileReplacementDuringRepairException") {
            let result = new ConcurrentFileReplacementDuringRepairException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentResolveBehaviorNotSupportedException") {
            let result = new ContentResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessEngineRequestException") {
            let result = new BusinessProcessEngineRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TooManyBusinessProcessesException") {
            let result = new TooManyBusinessProcessesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionCreateException") {
            let result = new BusinessProcessDefinitionCreateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessContinuationException") {
            let result = new BusinessProcessContinuationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotBatchBasedException") {
            let result = new BusinessProcessSummaryNotBatchBasedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotFoundException") {
            let result = new BusinessProcessSummaryNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotFailedException") {
            let result = new SnapshotFailedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTermsOfServiceDefinedException") {
            let result = new NoTermsOfServiceDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationNotFoundException") {
            let result = new NotificationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointException") {
            let result = new BusinessRuleConditionInvalidTriggerPointException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationInvalidIdException") {
            let result = new BusinessRuleNotificationInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationNoRecipientsException") {
            let result = new BusinessRuleNotificationNoRecipientsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserRoleIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserRoleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceInvalidIdException") {
            let result = new BusinessRuleNumberSequenceInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceIdDuplicationException") {
            let result = new BusinessRuleNumberSequenceIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleInvalidCronExpressionException") {
            let result = new BusinessRuleScheduleInvalidCronExpressionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleFilterMissingException") {
            let result = new BusinessRuleScheduleFilterMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleRulesMissingException") {
            let result = new BusinessRuleScheduleRulesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleStringContainsConditionValuesToMatchMissingException") {
            let result = new BusinessRuleStringContainsConditionValuesToMatchMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException") {
            let result = new BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDateMathTransformationTimeSpanInvalidException") {
            let result = new BusinessRuleDateMathTransformationTimeSpanInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransferOwnershipTransferUserIdMissingException") {
            let result = new BusinessRuleTransferOwnershipTransferUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleOutputFormatIdMissingException") {
            let result = new BusinessRuleOutputFormatIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException") {
            let result = new BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoTagsFoundException") {
            let result = new NoTagsFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotAvailableException") {
            let result = new OutputNotAvailableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ModelNotFoundException") {
            let result = new ModelNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatNotFoundException") {
            let result = new OutputFormatNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionForFormatException") {
            let result = new NotSupportedFileExtensionForFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackNotSupportedException") {
            let result = new OutputFormatXmpWritebackNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException") {
            let result = new OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatsInUseException") {
            let result = new OutputFormatsInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatOperationInProgressException") {
            let result = new OutputFormatOperationInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StaticOutputFormatModificationNotSupportedException") {
            let result = new StaticOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OriginalOutputFormatModificationNotSupportedException") {
            let result = new OriginalOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotValidForRenderingCategoryException") {
            let result = new OutputFormatSourceNotValidForRenderingCategoryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionModificationNotAllowedException") {
            let result = new CollectionModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionNotFoundException") {
            let result = new CollectionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NonDefaultTemplateNameNotAllowedException") {
            let result = new NonDefaultTemplateNameNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemTemplateModificationNotAllowedException") {
            let result = new SystemTemplateModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateDuplicationException") {
            let result = new TemplateDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateLanguageCodeNotSupportedException") {
            let result = new TemplateLanguageCodeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesMissingException") {
            let result = new TemplateMediaTypesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesNotSupportedException") {
            let result = new TemplateMediaTypesNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateNotFoundException") {
            let result = new TemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotSupported") {
            let result = new XmpMappingFieldNotSupported();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotFoundException") {
            let result = new XmpMappingFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingSchemaNotAvailableForFileContentSchemaException") {
            let result = new XmpMappingSchemaNotAvailableForFileContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException") {
            let result = new XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException") {
            let result = new XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldInUseException") {
            let result = new XmpMappingFieldInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingConfigurationInvalidException") {
            let result = new XmpMappingConfigurationInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ActivityMappingInvalidException") {
            let result = new ActivityMappingInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsExportNotEnabledException") {
            let result = new StatisticsExportNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsFeatureNotEnabledException") {
            throw new Error("The abstract class 'StatisticsFeatureNotEnabledException' cannot be instantiated.");
        }
        if (data["kind"] === "StatisticsReadNotEnabledException") {
            let result = new StatisticsReadNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsWriteNotEnabledException") {
            let result = new StatisticsWriteNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConversionPresetTemplateNotFoundException") {
            let result = new ConversionPresetTemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentOwnershipFailureException") {
            let result = new CommentOwnershipFailureException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyDeletionException") {
            let result = new CommentReplyDeletionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyParentException") {
            let result = new CommentReplyParentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyContentMismatchException") {
            let result = new CommentReplyContentMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VirtualDisplayContentNotSupportedException") {
            let result = new VirtualDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SelfReferencingDisplayContentNotSupportedException") {
            let result = new SelfReferencingDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkBusinessException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkBusinessException extends IPictureparkException {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    userId?: string | undefined;
}

export class PictureparkValidationException extends PictureparkBusinessException implements IPictureparkValidationException {

    constructor(data?: IPictureparkValidationException) {
        super(data);
        this._discriminator = "PictureparkValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkTimeoutException") {
            let result = new PictureparkTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RequestSizeLimitExceededException") {
            let result = new RequestSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentSchemaChangeException") {
            let result = new ContentSchemaChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PictureparkArgumentNullException") {
            let result = new PictureparkArgumentNullException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaValidationException") {
            let result = new SchemaValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseException") {
            let result = new SchemaInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSchemaException") {
            let result = new DuplicateSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionValidationException") {
            let result = new PermissionValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserEmailAlreadyExistsException") {
            let result = new UserEmailAlreadyExistsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleException") {
            let result = new UnableToDeleteUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotDeactivatedException") {
            let result = new UserNotDeactivatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserWithOwnerTokensArchiveException") {
            let result = new UserWithOwnerTokensArchiveException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInactiveOrDeletedException") {
            let result = new UserInactiveOrDeletedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IllegalAuthorizationStateTransitionException") {
            let result = new IllegalAuthorizationStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserUnlockDisallowedException") {
            let result = new UserUnlockDisallowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserDoesNotSupportLocalLoginException") {
            let result = new UserDoesNotSupportLocalLoginException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserAttributeNotSynchronizableException") {
            let result = new UserAttributeNotSynchronizableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToMapMultipleClaimTypesIntoSameAttributeException") {
            let result = new UnableToMapMultipleClaimTypesIntoSameAttributeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToChangeMappedUserRolesForFederatedUserException") {
            let result = new UnableToChangeMappedUserRolesForFederatedUserException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteDefaultUserRoleException") {
            let result = new UnableToDeleteDefaultUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException") {
            let result = new UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserPropertyChangeNotSupportedException") {
            let result = new UserPropertyChangeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageCodeNotExistingException") {
            let result = new LanguageCodeNotExistingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FocalPointCropSizeMissingException") {
            let result = new FocalPointCropSizeMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DefaultChannelDeleteException") {
            let result = new DefaultChannelDeleteException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SuperAdminRolesNotAssignableToChannelException") {
            let result = new SuperAdminRolesNotAssignableToChannelException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerClonesNotAcceptedException") {
            let result = new CustomerClonesNotAcceptedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareSizeLimitExceededException") {
            let result = new ShareSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateSharedOutputException") {
            let result = new DuplicateSharedOutputException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateEmbedConversionPresetException") {
            let result = new DuplicateEmbedConversionPresetException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToCreateOrModifyStaticOutputFormatException") {
            let result = new UnableToCreateOrModifyStaticOutputFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingException") {
            let result = new NotSupportedFileMappingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionException") {
            let result = new NotSupportedFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateOutputFormatIdException") {
            let result = new DuplicateOutputFormatIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputEditingNotSupportedException") {
            let result = new OutputEditingNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupNotRequestedException") {
            let result = new OutputBackupNotRequestedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputBackupHashMismatchException") {
            let result = new OutputBackupHashMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateContentDownloadRequestException") {
            let result = new DuplicateContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentDownloadRequestException") {
            let result = new InvalidContentDownloadRequestException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EmbedMultiDownloadException") {
            let result = new EmbedMultiDownloadException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageOptimizationLicensingException") {
            let result = new ImageOptimizationLicensingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateException") {
            let result = new InvalidStateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingCustomerDefaultLanguageException") {
            let result = new MissingCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PartialOperationNotSupportedException") {
            let result = new PartialOperationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContractMismatchException") {
            let result = new ContractMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidArgumentException") {
            let result = new InvalidArgumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "OwnerTokenInUseException") {
            let result = new OwnerTokenInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ItemIdDuplicatedException") {
            let result = new ItemIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasInUseException") {
            let result = new CustomerAliasInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesInvalidException") {
            let result = new CustomerBoostValuesInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotRetentionTimeTooShortException") {
            let result = new SnapshotRetentionTimeTooShortException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardIndexNotAllowedException") {
            let result = new ReshardIndexNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidException") {
            let result = new ReshardNumberOfShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfRoutingShardsInvalidException") {
            let result = new ReshardNumberOfRoutingShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidForExistingRoutingShardsException") {
            let result = new ReshardNumberOfShardsInvalidForExistingRoutingShardsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedSearchBehaviorException") {
            let result = new DuplicatedSearchBehaviorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringLeadingWildcardException") {
            let result = new SearchStringLeadingWildcardException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateAggregatorException") {
            let result = new DuplicateAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDateTimeFormatException") {
            let result = new InvalidDateTimeFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSortFieldException") {
            let result = new InvalidSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorInNonRootAggregatorException") {
            let result = new InvalidUiBehaviorInNonRootAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidUiBehaviorConfigurationException") {
            let result = new InvalidUiBehaviorConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidSearchFieldInAggregatorException") {
            let result = new InvalidSearchFieldInAggregatorException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchStringTooLongException") {
            let result = new SearchStringTooLongException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameInvalidException") {
            let result = new AggregationNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationNameMissingException") {
            let result = new AggregationNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationSizeInvalidException") {
            let result = new AggregationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilterNotSupportedException") {
            let result = new AggregationFilterNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFieldMissingException") {
            let result = new AggregationFieldMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationPathMissingException") {
            let result = new AggregationPathMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateDocumentException") {
            let result = new DuplicateDocumentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionOwnershipTransferException") {
            let result = new PermissionOwnershipTransferException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetAggregateException") {
            let result = new PermissionSetAggregateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateRightException") {
            let result = new DuplicateRightException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInUseException") {
            let result = new PermissionSetInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionException") {
            let result = new ContentPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemPermissionException") {
            let result = new ListItemPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionException") {
            let result = new SchemaPermissionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetValidationException") {
            let result = new PermissionSetValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsupportedListItemChangeCommandException") {
            let result = new UnsupportedListItemChangeCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemLayerException") {
            let result = new ListItemLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteListItemsWithReferencesException") {
            let result = new DeleteListItemsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemSchemaMismatchException") {
            let result = new ListItemSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemResolveBehaviorNotSupportedException") {
            let result = new ListItemResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidLogoFileExtensionException") {
            let result = new InvalidLogoFileExtensionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WrongChunkSizeException") {
            let result = new WrongChunkSizeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChunkSizeOutOfRangeException") {
            let result = new ChunkSizeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileIdDuplicatedException") {
            let result = new FileIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumNumberOfChunksExceededException") {
            let result = new MaximumNumberOfChunksExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MaximumFileSizeExceededException") {
            let result = new MaximumFileSizeExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDependenciesException") {
            let result = new MissingDependenciesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelationSelfReferencingException") {
            let result = new RelationSelfReferencingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldTypeInvalidException") {
            let result = new InvalidChangeCommandFieldTypeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandFieldNotFoundException") {
            let result = new InvalidChangeCommandFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidChangeCommandSchemaChangeInvalidException") {
            let result = new InvalidChangeCommandSchemaChangeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException") {
            let result = new InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidMetadataException") {
            let result = new InvalidMetadataException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicatedItemAssignedException") {
            let result = new DuplicatedItemAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InvalidDataTypeException") {
            let result = new InvalidDataTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInvalidException") {
            let result = new LayerAssignmentInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutdatedMetadataUpdateInProgressException") {
            let result = new OutdatedMetadataUpdateInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException") {
            let result = new SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemasMetadataProtectionException") {
            let result = new SchemasMetadataProtectionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FilterTemplateRenderingException") {
            let result = new FilterTemplateRenderingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ResolvedLinkedItemsThresholdReachedException") {
            let result = new ResolvedLinkedItemsThresholdReachedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteTypeMismatchException") {
            let result = new SchemaFieldOverwriteTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldOverwriteIdException") {
            let result = new SchemaFieldOverwriteIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdDuplicatedException") {
            let result = new SchemaFieldIdDuplicatedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdPreviouslyUsedException") {
            let result = new SchemaFieldIdPreviouslyUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdAlreadyExistsInSchemaHierarchyException") {
            let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoSimpleSearchNestingException") {
            let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSchemaIndexInfoNestingException") {
            let result = new SchemaFieldSchemaIndexInfoNestingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdUppercaseException") {
            let result = new SchemaFieldIdUppercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdLowercaseException") {
            let result = new SchemaIdLowercaseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexedFieldThresholdExceededException") {
            let result = new IndexedFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SortableFieldThresholdExceededException") {
            let result = new SortableFieldThresholdExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNumberRangeException") {
            let result = new SchemaFieldNumberRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentSchemaException") {
            let result = new SchemaInUseContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignmentInUseWithContentsException") {
            let result = new LayerAssignmentInUseWithContentsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseListItemException") {
            let result = new SchemaInUseListItemException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseContentException") {
            let result = new SchemaInUseContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInUseFieldException") {
            let result = new SchemaInUseFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DuplicateMetadataDisplayPatternException") {
            let result = new DuplicateMetadataDisplayPatternException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportEmptyException") {
            let result = new SchemaImportEmptyException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaImportVersionMismatchException") {
            let result = new SchemaImportVersionMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceFieldIndexDeviationException") {
            let result = new SchemaInheritanceFieldIndexDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInheritanceTypeDeviationException") {
            let result = new SchemaInheritanceTypeDeviationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaSortFieldException") {
            let result = new SchemaSortFieldException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldIdException") {
            let result = new SchemaFieldIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldTypeChangeException") {
            let result = new SchemaFieldTypeChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotFilterableException") {
            let result = new SchemaFieldNotFilterableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSortableException") {
            let result = new SchemaFieldNotSortableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSearchableException") {
            let result = new SchemaFieldNotSearchableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldInvalidBoostException") {
            let result = new SchemaFieldInvalidBoostException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldSortableInUseException") {
            let result = new SchemaFieldSortableInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoContentException") {
            let result = new SchemaNoContentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaParentChangeException") {
            let result = new SchemaParentChangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMissingTypeException") {
            let result = new SchemaMissingTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaPermissionConfigurationException") {
            let result = new SchemaPermissionConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsNotSupportedForStructsException") {
            let result = new SchemaMetadataProtectionSettingsNotSupportedForStructsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException") {
            let result = new SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNoLayerException") {
            let result = new SchemaNoLayerException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaIdException") {
            let result = new SchemaIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemSchemaInvalidModificationException") {
            let result = new SystemSchemaInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaSystemSchemaException") {
            let result = new SchemaFieldRelationSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationSchemaTypeUnsupportedException") {
            let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaMultipleTypesException") {
            let result = new SchemaMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MissingDisplayPatternForCustomerDefaultLanguageException") {
            let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaViewForAllException") {
            let result = new SchemaViewForAllException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemLayerReferenceInvalidModificationException") {
            let result = new SystemLayerReferenceInvalidModificationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldAnalyzerInvalidException") {
            let result = new SchemaFieldAnalyzerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationMultipleTypesException") {
            let result = new SchemaFieldRelationMultipleTypesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotRequirableException") {
            let result = new SchemaFieldNotRequirableException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayPatternTypeNotSupportedException") {
            let result = new DisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldActivityInUseException") {
            let result = new SchemaFieldActivityInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaChangeNotAllowedException") {
            let result = new SchemaFieldReferencedSchemaChangeNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldReferencedSchemaSystemSchemaException") {
            let result = new SchemaFieldReferencedSchemaSystemSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationRelationTypeIdModificationNotAllowedException") {
            let result = new SchemaFieldRelationRelationTypeIdModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldRelationTargetDocTypeModificationNotAllowedException") {
            let result = new SchemaFieldRelationTargetDocTypeModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportMismatchException") {
            let result = new SchemaFieldImportMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportRelatedSchemaMismatchException") {
            let result = new SchemaFieldImportRelatedSchemaMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldImportTypeMismatchException") {
            let result = new SchemaFieldImportTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldNotSupportedException") {
            let result = new SchemaFieldNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDisplayPatternTypeNotSupportedException") {
            let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldMarkdownNotMultilineException") {
            let result = new SchemaFieldMarkdownNotMultilineException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException") {
            let result = new IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaFieldDynamicViewFieldInvalidFilterTemplateException") {
            let result = new SchemaFieldDynamicViewFieldInvalidFilterTemplateException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DeleteContentsWithReferencesException") {
            let result = new DeleteContentsWithReferencesException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerInvalidException") {
            let result = new ContentLayerInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFileReplaceTypeMismatchException") {
            let result = new ContentFileReplaceTypeMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentLayerSameRootException") {
            let result = new ContentLayerSameRootException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException") {
            let result = new UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentResolveBehaviorNotSupportedException") {
            let result = new ContentResolveBehaviorNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationNotSupportedException") {
            let result = new BusinessProcessCancellationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotBatchBasedException") {
            let result = new BusinessProcessSummaryNotBatchBasedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessAlreadyRunningException") {
            let result = new EnvironmentProcessAlreadyRunningException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AtLeastOneActiveTermsOfServiceMustExistException") {
            let result = new AtLeastOneActiveTermsOfServiceMustExistException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ForbiddenHtmlElementsUsedException") {
            let result = new ForbiddenHtmlElementsUsedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OnlyAccessibleToRecipientException") {
            let result = new OnlyAccessibleToRecipientException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerAliasHeaderMissingException") {
            let result = new CustomerAliasHeaderMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionInvalidDocumentTypeException") {
            let result = new BusinessRuleActionInvalidDocumentTypeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleActionsMissingException") {
            let result = new BusinessRuleActionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionMissingException") {
            let result = new BusinessRuleConditionMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionsMissingException") {
            let result = new BusinessRuleConditionsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConfigurationValidationException") {
            let result = new BusinessRuleConfigurationValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleSchemaIdInvalidException") {
            let result = new BusinessRuleSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePermissionSetIdInvalidException") {
            let result = new BusinessRulePermissionSetIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdDuplicationException") {
            let result = new BusinessRuleRuleIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRuleIdMissingException") {
            let result = new BusinessRuleRuleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTriggerPointMissingException") {
            let result = new BusinessRuleTriggerPointMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleValidationException") {
            let result = new BusinessRuleValidationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRegularExpressionInvalidException") {
            let result = new BusinessRuleRegularExpressionInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleConditionInvalidTriggerPointException") {
            let result = new BusinessRuleConditionInvalidTriggerPointException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleRefIdsMissingException") {
            let result = new BusinessRuleRefIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePathInvalidException") {
            let result = new BusinessRulePathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldIdInvalidException") {
            let result = new BusinessRuleFieldIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleContentPermissionSetIdsMissingException") {
            let result = new BusinessRuleContentPermissionSetIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFieldPathInvalidException") {
            let result = new BusinessRuleFieldPathInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRulePolygonInvalidException") {
            let result = new BusinessRulePolygonInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleArrayIndexInvalidException") {
            let result = new BusinessRuleArrayIndexInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDictionaryKeyInvalidException") {
            let result = new BusinessRuleDictionaryKeyInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleProjectionTransformationsMissingException") {
            let result = new BusinessRuleProjectionTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleInvalidVariableNameException") {
            let result = new BusinessRuleInvalidVariableNameException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupTransformationsMissingException") {
            let result = new BusinessRuleTransformationGroupTransformationsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransformationGroupInputsMissingException") {
            let result = new BusinessRuleTransformationGroupInputsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNamedCacheNameInvalidException") {
            let result = new BusinessRuleNamedCacheNameInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationSizeInvalidException") {
            let result = new BusinessRuleNGramTransformationSizeInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMinWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNGramTransformationMaxWordLengthInvalidException") {
            let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationInvalidIdException") {
            let result = new BusinessRuleNotificationInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationNoRecipientsException") {
            let result = new BusinessRuleNotificationNoRecipientsException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNotificationRecipientUserRoleIdMissingException") {
            let result = new BusinessRuleNotificationRecipientUserRoleIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceInvalidIdException") {
            let result = new BusinessRuleNumberSequenceInvalidIdException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleNumberSequenceIdDuplicationException") {
            let result = new BusinessRuleNumberSequenceIdDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleInvalidCronExpressionException") {
            let result = new BusinessRuleScheduleInvalidCronExpressionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleFilterMissingException") {
            let result = new BusinessRuleScheduleFilterMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScheduleRulesMissingException") {
            let result = new BusinessRuleScheduleRulesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleStringContainsConditionValuesToMatchMissingException") {
            let result = new BusinessRuleStringContainsConditionValuesToMatchMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException") {
            let result = new BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleDateMathTransformationTimeSpanInvalidException") {
            let result = new BusinessRuleDateMathTransformationTimeSpanInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleTransferOwnershipTransferUserIdMissingException") {
            let result = new BusinessRuleTransferOwnershipTransferUserIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleOutputFormatIdMissingException") {
            let result = new BusinessRuleOutputFormatIdMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException") {
            let result = new BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheConfigurationException") {
            let result = new NamedCacheConfigurationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameMissingException") {
            let result = new NamedCacheNameMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NamedCacheNameDuplicationException") {
            let result = new NamedCacheNameDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheSchemaIdInvalidException") {
            let result = new ListItemNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNamedCacheKeyFieldsInvalidException") {
            let result = new ListItemNamedCacheKeyFieldsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException") {
            let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DisplayValueRerenderingInProgressException") {
            let result = new DisplayValueRerenderingInProgressException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotDefinedException") {
            let result = new OutputFormatSourceNotDefinedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotSupportedFileExtensionForFormatException") {
            let result = new NotSupportedFileExtensionForFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackNotSupportedException") {
            let result = new OutputFormatXmpWritebackNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException") {
            let result = new OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatsInUseException") {
            let result = new OutputFormatsInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StaticOutputFormatModificationNotSupportedException") {
            let result = new StaticOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OriginalOutputFormatModificationNotSupportedException") {
            let result = new OriginalOutputFormatModificationNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatSourceNotValidForRenderingCategoryException") {
            let result = new OutputFormatSourceNotValidForRenderingCategoryException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionSizeLimitExceededException") {
            let result = new CollectionSizeLimitExceededException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionModificationNotAllowedException") {
            let result = new CollectionModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NonDefaultTemplateNameNotAllowedException") {
            let result = new NonDefaultTemplateNameNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SystemTemplateModificationNotAllowedException") {
            let result = new SystemTemplateModificationNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateDuplicationException") {
            let result = new TemplateDuplicationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateLanguageCodeNotSupportedException") {
            let result = new TemplateLanguageCodeNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesMissingException") {
            let result = new TemplateMediaTypesMissingException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateMediaTypesNotSupportedException") {
            let result = new TemplateMediaTypesNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotSupported") {
            let result = new XmpMappingFieldNotSupported();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldNotFoundException") {
            let result = new XmpMappingFieldNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingSchemaNotAvailableForFileContentSchemaException") {
            let result = new XmpMappingSchemaNotAvailableForFileContentSchemaException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException") {
            let result = new XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException") {
            let result = new XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingFieldInUseException") {
            let result = new XmpMappingFieldInUseException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "XmpMappingConfigurationInvalidException") {
            let result = new XmpMappingConfigurationInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ActivityMappingInvalidException") {
            let result = new ActivityMappingInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsExportNotEnabledException") {
            let result = new StatisticsExportNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsFeatureNotEnabledException") {
            throw new Error("The abstract class 'StatisticsFeatureNotEnabledException' cannot be instantiated.");
        }
        if (data["kind"] === "StatisticsReadNotEnabledException") {
            let result = new StatisticsReadNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsWriteNotEnabledException") {
            let result = new StatisticsWriteNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentOwnershipFailureException") {
            let result = new CommentOwnershipFailureException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyDeletionException") {
            let result = new CommentReplyDeletionException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyParentException") {
            let result = new CommentReplyParentException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentReplyContentMismatchException") {
            let result = new CommentReplyContentMismatchException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SelfReferencingDisplayContentNotSupportedException") {
            let result = new SelfReferencingDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkValidationException extends IPictureparkBusinessException {
}

export enum TraceLevel {
    Critical = "Critical",
    Error = "Error",
    Warning = "Warning",
    Information = "Information",
    Verbose = "Verbose",
}

export class PictureparkConflictException extends PictureparkBusinessException implements IPictureparkConflictException {

    constructor(data?: IPictureparkConflictException) {
        super(data);
        this._discriminator = "PictureparkConflictException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkConflictException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentVersionConflictException") {
            let result = new DocumentVersionConflictException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConcurrentFileReplacementDuringRepairException") {
            let result = new ConcurrentFileReplacementDuringRepairException();
            result.init(data);
            return result;
        }
        let result = new PictureparkConflictException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkConflictException extends IPictureparkBusinessException {
}

export class PictureparkTimeoutException extends PictureparkValidationException implements IPictureparkTimeoutException {

    constructor(data?: IPictureparkTimeoutException) {
        super(data);
        this._discriminator = "PictureparkTimeoutException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkTimeoutException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessLifeCycleNotHitException") {
            let result = new BusinessProcessLifeCycleNotHitException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SnapshotTimeoutException") {
            let result = new SnapshotTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AddMetadataLanguageTimeoutException") {
            let result = new AddMetadataLanguageTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessWaitTimeoutException") {
            let result = new EnvironmentProcessWaitTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerBoostValuesUpdateTimeoutException") {
            let result = new CustomerBoostValuesUpdateTimeoutException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessStateNotHitException") {
            let result = new BusinessProcessStateNotHitException();
            result.init(data);
            return result;
        }
        let result = new PictureparkTimeoutException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkTimeoutException extends IPictureparkValidationException {
}

export class PictureparkForbiddenException extends PictureparkBusinessException implements IPictureparkForbiddenException {

    constructor(data?: IPictureparkForbiddenException) {
        super(data);
        this._discriminator = "PictureparkForbiddenException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkForbiddenException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "InactiveOrDeletedUserRefusedAccessException") {
            let result = new InactiveOrDeletedUserRefusedAccessException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsOfServiceConsentRequiredException") {
            let result = new TermsOfServiceConsentRequiredException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LoginUsingIncorrectIdentityProviderException") {
            let result = new LoginUsingIncorrectIdentityProviderException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotExternalException") {
            let result = new BusinessProcessNotExternalException();
            result.init(data);
            return result;
        }
        let result = new PictureparkForbiddenException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkForbiddenException extends IPictureparkBusinessException {
}

export class UserEmailAlreadyExistsException extends PictureparkValidationException implements IUserEmailAlreadyExistsException {
    email?: string | undefined;

    constructor(data?: IUserEmailAlreadyExistsException) {
        super(data);
        this._discriminator = "UserEmailAlreadyExistsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["email"];
        }
    }

    static override fromJS(data: any): UserEmailAlreadyExistsException {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailAlreadyExistsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        super.toJSON(data);
        return data;
    }
}

export interface IUserEmailAlreadyExistsException extends IPictureparkValidationException {
    email?: string | undefined;
}

export class UnableToDeleteUserRoleException extends PictureparkValidationException implements IUnableToDeleteUserRoleException {
    userRoleId?: string | undefined;

    constructor(data?: IUnableToDeleteUserRoleException) {
        super(data);
        this._discriminator = "UnableToDeleteUserRoleException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userRoleId = _data["userRoleId"];
        }
    }

    static override fromJS(data: any): UnableToDeleteUserRoleException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UserRoleAssignedException") {
            let result = new UserRoleAssignedException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteDefaultUserRoleException") {
            let result = new UnableToDeleteDefaultUserRoleException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException") {
            let result = new UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException();
            result.init(data);
            return result;
        }
        let result = new UnableToDeleteUserRoleException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToDeleteUserRoleException extends IPictureparkValidationException {
    userRoleId?: string | undefined;
}

export class UserRoleAssignedException extends UnableToDeleteUserRoleException implements IUserRoleAssignedException {

    constructor(data?: IUserRoleAssignedException) {
        super(data);
        this._discriminator = "UserRoleAssignedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserRoleAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUserRoleAssignedException extends IUnableToDeleteUserRoleException {
}

export class PictureparkNotFoundException extends PictureparkBusinessException implements IPictureparkNotFoundException {
    reference?: string | undefined;

    constructor(data?: IPictureparkNotFoundException) {
        super(data);
        this._discriminator = "PictureparkNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
        }
    }

    static override fromJS(data: any): PictureparkNotFoundException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ContentNotFoundException") {
            let result = new ContentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CommentNotFoundException") {
            let result = new CommentNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaNotFoundException") {
            let result = new SchemaNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FileTransferNotFoundException") {
            let result = new FileTransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareNotFoundException") {
            let result = new ShareNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserNotFoundException") {
            let result = new UserNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRolesNotFoundException") {
            let result = new UserRolesNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "IdentityProviderNotFoundException") {
            let result = new IdentityProviderNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserByOwnerTokenNotFoundException") {
            let result = new UserByOwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentVersionNotFoundException") {
            let result = new DocumentVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChannelsNotFoundException") {
            let result = new ChannelsNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputNotFoundException") {
            let result = new ShareOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareByTokenNotFoundException") {
            let result = new ShareByTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputIdNotFoundException") {
            let result = new OutputIdNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputNotFoundException") {
            let result = new OutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnmodifiedOriginalOutputNotFoundException") {
            let result = new UnmodifiedOriginalOutputNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DownloadNotFoundException") {
            let result = new DownloadNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerTokenNotFoundException") {
            let result = new OwnerTokenNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PermissionSetNotFoundException") {
            let result = new PermissionSetNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ListItemNotFoundException") {
            let result = new ListItemNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferInfoNotFoundException") {
            let result = new TransferInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TransferNotFoundException") {
            let result = new TransferNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaInfoNotFoundException") {
            let result = new SchemaInfoNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentHistoricVersionNotFoundException") {
            let result = new ContentHistoricVersionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessNotFoundException") {
            let result = new BusinessProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDefinitionNotFoundException") {
            let result = new BusinessProcessDefinitionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryNotFoundException") {
            let result = new BusinessProcessSummaryNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnvironmentProcessNotFoundException") {
            let result = new EnvironmentProcessNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationNotFoundException") {
            let result = new NotificationNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ModelNotFoundException") {
            let result = new ModelNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatNotFoundException") {
            let result = new OutputFormatNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CollectionNotFoundException") {
            let result = new CollectionNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TemplateNotFoundException") {
            let result = new TemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConversionPresetTemplateNotFoundException") {
            let result = new ConversionPresetTemplateNotFoundException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VirtualDisplayContentNotSupportedException") {
            let result = new VirtualDisplayContentNotSupportedException();
            result.init(data);
            return result;
        }
        let result = new PictureparkNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkNotFoundException extends IPictureparkBusinessException {
    reference?: string | undefined;
}

export class UserNotFoundException extends PictureparkNotFoundException implements IUserNotFoundException {
    missingUserId?: string | undefined;

    constructor(data?: IUserNotFoundException) {
        super(data);
        this._discriminator = "UserNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.missingUserId = _data["missingUserId"];
        }
    }

    static override fromJS(data: any): UserNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingUserId"] = this.missingUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserNotFoundException extends IPictureparkNotFoundException {
    missingUserId?: string | undefined;
}

export class UserNotDeactivatedException extends PictureparkValidationException implements IUserNotDeactivatedException {
    notDeactivatedUserId?: string | undefined;

    constructor(data?: IUserNotDeactivatedException) {
        super(data);
        this._discriminator = "UserNotDeactivatedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.notDeactivatedUserId = _data["notDeactivatedUserId"];
        }
    }

    static override fromJS(data: any): UserNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotDeactivatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notDeactivatedUserId"] = this.notDeactivatedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserNotDeactivatedException extends IPictureparkValidationException {
    notDeactivatedUserId?: string | undefined;
}

export class UserWithOwnerTokensArchiveException extends PictureparkValidationException implements IUserWithOwnerTokensArchiveException {
    notArchivedUserId?: string | undefined;

    constructor(data?: IUserWithOwnerTokensArchiveException) {
        super(data);
        this._discriminator = "UserWithOwnerTokensArchiveException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.notArchivedUserId = _data["notArchivedUserId"];
        }
    }

    static override fromJS(data: any): UserWithOwnerTokensArchiveException {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithOwnerTokensArchiveException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notArchivedUserId"] = this.notArchivedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserWithOwnerTokensArchiveException extends IPictureparkValidationException {
    notArchivedUserId?: string | undefined;
}

export class UserInactiveOrDeletedException extends PictureparkValidationException implements IUserInactiveOrDeletedException {
    /** The ID of the inactive or deleted user in question. */
    affectedUserId?: string | undefined;

    constructor(data?: IUserInactiveOrDeletedException) {
        super(data);
        this._discriminator = "UserInactiveOrDeletedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
        }
    }

    static override fromJS(data: any): UserInactiveOrDeletedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserInactiveOrDeletedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserInactiveOrDeletedException extends IPictureparkValidationException {
    /** The ID of the inactive or deleted user in question. */
    affectedUserId?: string | undefined;
}

export class InactiveOrDeletedUserRefusedAccessException extends PictureparkForbiddenException implements IInactiveOrDeletedUserRefusedAccessException {

    constructor(data?: IInactiveOrDeletedUserRefusedAccessException) {
        super(data);
        this._discriminator = "InactiveOrDeletedUserRefusedAccessException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): InactiveOrDeletedUserRefusedAccessException {
        data = typeof data === 'object' ? data : {};
        let result = new InactiveOrDeletedUserRefusedAccessException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IInactiveOrDeletedUserRefusedAccessException extends IPictureparkForbiddenException {
}

export class TermsOfServiceNotNewestException extends PictureparkBusinessException implements ITermsOfServiceNotNewestException {

    constructor(data?: ITermsOfServiceNotNewestException) {
        super(data);
        this._discriminator = "TermsOfServiceNotNewestException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TermsOfServiceNotNewestException {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOfServiceNotNewestException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITermsOfServiceNotNewestException extends IPictureparkBusinessException {
}

export class IllegalAuthorizationStateTransitionException extends PictureparkValidationException implements IIllegalAuthorizationStateTransitionException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;
    transition?: string | undefined;

    constructor(data?: IIllegalAuthorizationStateTransitionException) {
        super(data);
        this._discriminator = "IllegalAuthorizationStateTransitionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestedUserId = _data["requestedUserId"];
            this.authorizationState = _data["authorizationState"];
            this.transition = _data["transition"];
        }
    }

    static override fromJS(data: any): IllegalAuthorizationStateTransitionException {
        data = typeof data === 'object' ? data : {};
        let result = new IllegalAuthorizationStateTransitionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedUserId"] = this.requestedUserId;
        data["authorizationState"] = this.authorizationState;
        data["transition"] = this.transition;
        super.toJSON(data);
        return data;
    }
}

export interface IIllegalAuthorizationStateTransitionException extends IPictureparkValidationException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;
    transition?: string | undefined;
}

/** User authorization state */
export enum AuthorizationState {
    Reviewed = "Reviewed",
    ToBeReviewed = "ToBeReviewed",
    Invited = "Invited",
    UserTriggeredDeactivation = "UserTriggeredDeactivation",
}

export class TermsOfServiceConsentRequiredException extends PictureparkForbiddenException implements ITermsOfServiceConsentRequiredException {

    constructor(data?: ITermsOfServiceConsentRequiredException) {
        super(data);
        this._discriminator = "TermsOfServiceConsentRequiredException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TermsOfServiceConsentRequiredException {
        data = typeof data === 'object' ? data : {};
        let result = new TermsOfServiceConsentRequiredException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITermsOfServiceConsentRequiredException extends IPictureparkForbiddenException {
}

export class UserRolesNotFoundException extends PictureparkNotFoundException implements IUserRolesNotFoundException {
    userRoleIds?: string[] | undefined;

    constructor(data?: IUserRolesNotFoundException) {
        super(data);
        this._discriminator = "UserRolesNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): UserRolesNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUserRolesNotFoundException extends IPictureparkNotFoundException {
    userRoleIds?: string[] | undefined;
}

export class UnauthorizedException extends PictureparkBusinessException implements IUnauthorizedException {

    constructor(data?: IUnauthorizedException) {
        super(data);
        this._discriminator = "UnauthorizedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UnauthorizedException {
        data = typeof data === 'object' ? data : {};
        let result = new UnauthorizedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUnauthorizedException extends IPictureparkBusinessException {
}

export class UserUnlockDisallowedException extends PictureparkValidationException implements IUserUnlockDisallowedException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;

    constructor(data?: IUserUnlockDisallowedException) {
        super(data);
        this._discriminator = "UserUnlockDisallowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestedUserId = _data["requestedUserId"];
            this.authorizationState = _data["authorizationState"];
        }
    }

    static override fromJS(data: any): UserUnlockDisallowedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserUnlockDisallowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedUserId"] = this.requestedUserId;
        data["authorizationState"] = this.authorizationState;
        super.toJSON(data);
        return data;
    }
}

export interface IUserUnlockDisallowedException extends IPictureparkValidationException {
    requestedUserId?: string | undefined;
    authorizationState?: AuthorizationState;
}

export class UserAlreadyInRequestedLockStateException extends PictureparkBusinessException implements IUserAlreadyInRequestedLockStateException {
    affectedUserId?: string | undefined;
    userIsLocked?: boolean;

    constructor(data?: IUserAlreadyInRequestedLockStateException) {
        super(data);
        this._discriminator = "UserAlreadyInRequestedLockStateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
            this.userIsLocked = _data["userIsLocked"];
        }
    }

    static override fromJS(data: any): UserAlreadyInRequestedLockStateException {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlreadyInRequestedLockStateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        data["userIsLocked"] = this.userIsLocked;
        super.toJSON(data);
        return data;
    }
}

export interface IUserAlreadyInRequestedLockStateException extends IPictureparkBusinessException {
    affectedUserId?: string | undefined;
    userIsLocked?: boolean;
}

export class LoginUsingIncorrectIdentityProviderException extends PictureparkForbiddenException implements ILoginUsingIncorrectIdentityProviderException {
    affectedUserId?: string | undefined;

    constructor(data?: ILoginUsingIncorrectIdentityProviderException) {
        super(data);
        this._discriminator = "LoginUsingIncorrectIdentityProviderException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
        }
    }

    static override fromJS(data: any): LoginUsingIncorrectIdentityProviderException {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUsingIncorrectIdentityProviderException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface ILoginUsingIncorrectIdentityProviderException extends IPictureparkForbiddenException {
    affectedUserId?: string | undefined;
}

export class IdentityProviderNotFoundException extends PictureparkNotFoundException implements IIdentityProviderNotFoundException {
    missingIdentityProviderId?: string | undefined;
    external?: boolean;

    constructor(data?: IIdentityProviderNotFoundException) {
        super(data);
        this._discriminator = "IdentityProviderNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.missingIdentityProviderId = _data["missingIdentityProviderId"];
            this.external = _data["external"];
        }
    }

    static override fromJS(data: any): IdentityProviderNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProviderNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingIdentityProviderId"] = this.missingIdentityProviderId;
        data["external"] = this.external;
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityProviderNotFoundException extends IPictureparkNotFoundException {
    missingIdentityProviderId?: string | undefined;
    external?: boolean;
}

export class UserDoesNotSupportLocalLoginException extends PictureparkValidationException implements IUserDoesNotSupportLocalLoginException {
    affectedUserId?: string | undefined;

    constructor(data?: IUserDoesNotSupportLocalLoginException) {
        super(data);
        this._discriminator = "UserDoesNotSupportLocalLoginException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
        }
    }

    static override fromJS(data: any): UserDoesNotSupportLocalLoginException {
        data = typeof data === 'object' ? data : {};
        let result = new UserDoesNotSupportLocalLoginException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserDoesNotSupportLocalLoginException extends IPictureparkValidationException {
    affectedUserId?: string | undefined;
}

export class UserAttributeNotSynchronizableException extends PictureparkValidationException implements IUserAttributeNotSynchronizableException {
    attributePath?: string | undefined;

    constructor(data?: IUserAttributeNotSynchronizableException) {
        super(data);
        this._discriminator = "UserAttributeNotSynchronizableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attributePath = _data["attributePath"];
        }
    }

    static override fromJS(data: any): UserAttributeNotSynchronizableException {
        data = typeof data === 'object' ? data : {};
        let result = new UserAttributeNotSynchronizableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributePath"] = this.attributePath;
        super.toJSON(data);
        return data;
    }
}

export interface IUserAttributeNotSynchronizableException extends IPictureparkValidationException {
    attributePath?: string | undefined;
}

export class UnableToMapMultipleClaimTypesIntoSameAttributeException extends PictureparkValidationException implements IUnableToMapMultipleClaimTypesIntoSameAttributeException {
    attributePath?: string | undefined;

    constructor(data?: IUnableToMapMultipleClaimTypesIntoSameAttributeException) {
        super(data);
        this._discriminator = "UnableToMapMultipleClaimTypesIntoSameAttributeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attributePath = _data["attributePath"];
        }
    }

    static override fromJS(data: any): UnableToMapMultipleClaimTypesIntoSameAttributeException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToMapMultipleClaimTypesIntoSameAttributeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributePath"] = this.attributePath;
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToMapMultipleClaimTypesIntoSameAttributeException extends IPictureparkValidationException {
    attributePath?: string | undefined;
}

export class UnableToChangeMappedUserRolesForFederatedUserException extends PictureparkValidationException implements IUnableToChangeMappedUserRolesForFederatedUserException {
    affectedUserId?: string | undefined;
    userRoleIds?: string[] | undefined;

    constructor(data?: IUnableToChangeMappedUserRolesForFederatedUserException) {
        super(data);
        this._discriminator = "UnableToChangeMappedUserRolesForFederatedUserException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): UnableToChangeMappedUserRolesForFederatedUserException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToChangeMappedUserRolesForFederatedUserException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToChangeMappedUserRolesForFederatedUserException extends IPictureparkValidationException {
    affectedUserId?: string | undefined;
    userRoleIds?: string[] | undefined;
}

export class UnableToDeleteDefaultUserRoleException extends UnableToDeleteUserRoleException implements IUnableToDeleteDefaultUserRoleException {

    constructor(data?: IUnableToDeleteDefaultUserRoleException) {
        super(data);
        this._discriminator = "UnableToDeleteDefaultUserRoleException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UnableToDeleteDefaultUserRoleException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToDeleteDefaultUserRoleException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToDeleteDefaultUserRoleException extends IUnableToDeleteUserRoleException {
}

export class UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException extends UnableToDeleteUserRoleException implements IUnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException {
    identityProviderIds?: string[] | undefined;

    constructor(data?: IUnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException) {
        super(data);
        this._discriminator = "UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["identityProviderIds"])) {
                this.identityProviderIds = [] as any;
                for (let item of _data["identityProviderIds"])
                    this.identityProviderIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.identityProviderIds)) {
            data["identityProviderIds"] = [];
            for (let item of this.identityProviderIds)
                data["identityProviderIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToDeleteUserRoleReferencedInIdentityProviderGroupMappingException extends IUnableToDeleteUserRoleException {
    identityProviderIds?: string[] | undefined;
}

export class UserPropertyChangeNotSupportedException extends PictureparkValidationException implements IUserPropertyChangeNotSupportedException {
    propertyPath?: string | undefined;
    affectedUserId?: string | undefined;

    constructor(data?: IUserPropertyChangeNotSupportedException) {
        super(data);
        this._discriminator = "UserPropertyChangeNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.propertyPath = _data["propertyPath"];
            this.affectedUserId = _data["affectedUserId"];
        }
    }

    static override fromJS(data: any): UserPropertyChangeNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new UserPropertyChangeNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyPath"] = this.propertyPath;
        data["affectedUserId"] = this.affectedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserPropertyChangeNotSupportedException extends IPictureparkValidationException {
    propertyPath?: string | undefined;
    affectedUserId?: string | undefined;
}

export class UserNotLinkedWithIdsException extends PictureparkBusinessException implements IUserNotLinkedWithIdsException {
    affectedUserId?: string | undefined;

    constructor(data?: IUserNotLinkedWithIdsException) {
        super(data);
        this._discriminator = "UserNotLinkedWithIdsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.affectedUserId = _data["affectedUserId"];
        }
    }

    static override fromJS(data: any): UserNotLinkedWithIdsException {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotLinkedWithIdsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affectedUserId"] = this.affectedUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserNotLinkedWithIdsException extends IPictureparkBusinessException {
    affectedUserId?: string | undefined;
}

export class LanguageCodeNotExistingException extends PictureparkValidationException implements ILanguageCodeNotExistingException {
    languageCode?: string | undefined;
    existingLanguageCodes?: string[] | undefined;

    constructor(data?: ILanguageCodeNotExistingException) {
        super(data);
        this._discriminator = "LanguageCodeNotExistingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.languageCode = _data["languageCode"];
            if (Array.isArray(_data["existingLanguageCodes"])) {
                this.existingLanguageCodes = [] as any;
                for (let item of _data["existingLanguageCodes"])
                    this.existingLanguageCodes!.push(item);
            }
        }
    }

    static override fromJS(data: any): LanguageCodeNotExistingException {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageCodeNotExistingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        if (Array.isArray(this.existingLanguageCodes)) {
            data["existingLanguageCodes"] = [];
            for (let item of this.existingLanguageCodes)
                data["existingLanguageCodes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILanguageCodeNotExistingException extends IPictureparkValidationException {
    languageCode?: string | undefined;
    existingLanguageCodes?: string[] | undefined;
}

export class UserByOwnerTokenNotFoundException extends PictureparkNotFoundException implements IUserByOwnerTokenNotFoundException {
    ownerToken?: string | undefined;

    constructor(data?: IUserByOwnerTokenNotFoundException) {
        super(data);
        this._discriminator = "UserByOwnerTokenNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ownerToken = _data["ownerToken"];
        }
    }

    static override fromJS(data: any): UserByOwnerTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UserByOwnerTokenNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerToken"] = this.ownerToken;
        super.toJSON(data);
        return data;
    }
}

export interface IUserByOwnerTokenNotFoundException extends IPictureparkNotFoundException {
    ownerToken?: string | undefined;
}

export class RenderingException extends PictureparkBusinessException implements IRenderingException {

    constructor(data?: IRenderingException) {
        super(data);
        this._discriminator = "RenderingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RenderingException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FormatNotApplicableForRenderingException") {
            let result = new FormatNotApplicableForRenderingException();
            result.init(data);
            return result;
        }
        let result = new RenderingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRenderingException extends IPictureparkBusinessException {
}

export class FormatNotApplicableForRenderingException extends RenderingException implements IFormatNotApplicableForRenderingException {
    contentRenderingType?: RenderingCategory;
    outputFormatId?: string | undefined;

    constructor(data?: IFormatNotApplicableForRenderingException) {
        super(data);
        this._discriminator = "FormatNotApplicableForRenderingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentRenderingType = _data["contentRenderingType"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): FormatNotApplicableForRenderingException {
        data = typeof data === 'object' ? data : {};
        let result = new FormatNotApplicableForRenderingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentRenderingType"] = this.contentRenderingType;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IFormatNotApplicableForRenderingException extends IRenderingException {
    contentRenderingType?: RenderingCategory;
    outputFormatId?: string | undefined;
}

export enum RenderingCategory {
    Unknown = "Unknown",
    Image = "Image",
    Document = "Document",
    Video = "Video",
    Audio = "Audio",
    Vector = "Vector",
}

export class FocalPointCropSizeMissingException extends PictureparkValidationException implements IFocalPointCropSizeMissingException {
    contentId?: string | undefined;
    focalPointId?: string | undefined;

    constructor(data?: IFocalPointCropSizeMissingException) {
        super(data);
        this._discriminator = "FocalPointCropSizeMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.focalPointId = _data["focalPointId"];
        }
    }

    static override fromJS(data: any): FocalPointCropSizeMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new FocalPointCropSizeMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["focalPointId"] = this.focalPointId;
        super.toJSON(data);
        return data;
    }
}

export interface IFocalPointCropSizeMissingException extends IPictureparkValidationException {
    contentId?: string | undefined;
    focalPointId?: string | undefined;
}

export class ServiceProviderDeleteException extends PictureparkException implements IServiceProviderDeleteException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderDeleteException) {
        super(data);
        this._discriminator = "ServiceProviderDeleteException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.serviceProviderId = _data["serviceProviderId"];
            this.detailedErrorMessage = _data["detailedErrorMessage"];
        }
    }

    static override fromJS(data: any): ServiceProviderDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderDeleteException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["detailedErrorMessage"] = this.detailedErrorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IServiceProviderDeleteException extends IPictureparkException {
    serviceProviderId?: string | undefined;
    detailedErrorMessage?: string | undefined;
}

export class ServiceProviderCreateException extends PictureparkException implements IServiceProviderCreateException {
    externalId?: string | undefined;
    detailErrorMessage?: string | undefined;

    constructor(data?: IServiceProviderCreateException) {
        super(data);
        this._discriminator = "ServiceProviderCreateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.externalId = _data["externalId"];
            this.detailErrorMessage = _data["detailErrorMessage"];
        }
    }

    static override fromJS(data: any): ServiceProviderCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderCreateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalId"] = this.externalId;
        data["detailErrorMessage"] = this.detailErrorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IServiceProviderCreateException extends IPictureparkException {
    externalId?: string | undefined;
    detailErrorMessage?: string | undefined;
}

export class ServiceProviderNotFoundException extends PictureparkException implements IServiceProviderNotFoundException {
    missingServiceProviderId?: string | undefined;

    constructor(data?: IServiceProviderNotFoundException) {
        super(data);
        this._discriminator = "ServiceProviderNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.missingServiceProviderId = _data["missingServiceProviderId"];
        }
    }

    static override fromJS(data: any): ServiceProviderNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingServiceProviderId"] = this.missingServiceProviderId;
        super.toJSON(data);
        return data;
    }
}

export interface IServiceProviderNotFoundException extends IPictureparkException {
    missingServiceProviderId?: string | undefined;
}

export class DocumentVersionNotFoundException extends PictureparkNotFoundException implements IDocumentVersionNotFoundException {
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentVersion?: string | undefined;

    constructor(data?: IDocumentVersionNotFoundException) {
        super(data);
        this._discriminator = "DocumentVersionNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.documentType = _data["documentType"];
            this.documentId = _data["documentId"];
            this.documentVersion = _data["documentVersion"];
        }
    }

    static override fromJS(data: any): DocumentVersionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentVersionNotFoundException extends IPictureparkNotFoundException {
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentVersion?: string | undefined;
}

export class DefaultChannelDeleteException extends PictureparkValidationException implements IDefaultChannelDeleteException {

    constructor(data?: IDefaultChannelDeleteException) {
        super(data);
        this._discriminator = "DefaultChannelDeleteException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DefaultChannelDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultChannelDeleteException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IDefaultChannelDeleteException extends IPictureparkValidationException {
}

export class ChannelsNotFoundException extends PictureparkNotFoundException implements IChannelsNotFoundException {

    constructor(data?: IChannelsNotFoundException) {
        super(data);
        this._discriminator = "ChannelsNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ChannelsNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelsNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChannelsNotFoundException extends IPictureparkNotFoundException {
}

export class SuperAdminRolesNotAssignableToChannelException extends PictureparkValidationException implements ISuperAdminRolesNotAssignableToChannelException {

    constructor(data?: ISuperAdminRolesNotAssignableToChannelException) {
        super(data);
        this._discriminator = "SuperAdminRolesNotAssignableToChannelException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SuperAdminRolesNotAssignableToChannelException {
        data = typeof data === 'object' ? data : {};
        let result = new SuperAdminRolesNotAssignableToChannelException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISuperAdminRolesNotAssignableToChannelException extends IPictureparkValidationException {
}

export class ElasticVersionUpdateException extends PictureparkException implements IElasticVersionUpdateException {
    expectedVersion?: string | undefined;
    actualVersion?: string | undefined;

    constructor(data?: IElasticVersionUpdateException) {
        super(data);
        this._discriminator = "ElasticVersionUpdateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expectedVersion = _data["expectedVersion"];
            this.actualVersion = _data["actualVersion"];
        }
    }

    static override fromJS(data: any): ElasticVersionUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ElasticVersionUpdateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedVersion"] = this.expectedVersion;
        data["actualVersion"] = this.actualVersion;
        super.toJSON(data);
        return data;
    }
}

export interface IElasticVersionUpdateException extends IPictureparkException {
    expectedVersion?: string | undefined;
    actualVersion?: string | undefined;
}

export class InvalidVersionException extends PictureparkException implements IInvalidVersionException {
    component?: string | undefined;
    version?: string | undefined;
    expectedVersion?: string | undefined;

    constructor(data?: IInvalidVersionException) {
        super(data);
        this._discriminator = "InvalidVersionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.component = _data["component"];
            this.version = _data["version"];
            this.expectedVersion = _data["expectedVersion"];
        }
    }

    static override fromJS(data: any): InvalidVersionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidVersionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component;
        data["version"] = this.version;
        data["expectedVersion"] = this.expectedVersion;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidVersionException extends IPictureparkException {
    component?: string | undefined;
    version?: string | undefined;
    expectedVersion?: string | undefined;
}

export class EnvironmentNotDeactivatedException extends PictureparkException implements IEnvironmentNotDeactivatedException {

    constructor(data?: IEnvironmentNotDeactivatedException) {
        super(data);
        this._discriminator = "EnvironmentNotDeactivatedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): EnvironmentNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotDeactivatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentNotDeactivatedException extends IPictureparkException {
}

export class EnvironmentNotFoundException extends PictureparkException implements IEnvironmentNotFoundException {

    constructor(data?: IEnvironmentNotFoundException) {
        super(data);
        this._discriminator = "EnvironmentNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): EnvironmentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentNotFoundException extends IPictureparkException {
}

export class EnvironmentDeactivationException extends PictureparkException implements IEnvironmentDeactivationException {
    deactivationMessage?: string | undefined;

    constructor(data?: IEnvironmentDeactivationException) {
        super(data);
        this._discriminator = "EnvironmentDeactivationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deactivationMessage = _data["deactivationMessage"];
        }
    }

    static override fromJS(data: any): EnvironmentDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentDeactivationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deactivationMessage"] = this.deactivationMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentDeactivationException extends IPictureparkException {
    deactivationMessage?: string | undefined;
}

export class CustomerClonesNotAcceptedException extends PictureparkValidationException implements ICustomerClonesNotAcceptedException {

    constructor(data?: ICustomerClonesNotAcceptedException) {
        super(data);
        this._discriminator = "CustomerClonesNotAcceptedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CustomerClonesNotAcceptedException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerClonesNotAcceptedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerClonesNotAcceptedException extends IPictureparkValidationException {
}

export class ShareOutputNotFoundException extends PictureparkNotFoundException implements IShareOutputNotFoundException {
    contentId?: string | undefined;

    constructor(data?: IShareOutputNotFoundException) {
        super(data);
        this._discriminator = "ShareOutputNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
        }
    }

    static override fromJS(data: any): ShareOutputNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data;
    }
}

export interface IShareOutputNotFoundException extends IPictureparkNotFoundException {
    contentId?: string | undefined;
}

export class ShareNotFoundException extends PictureparkNotFoundException implements IShareNotFoundException {
    shareId?: string | undefined;

    constructor(data?: IShareNotFoundException) {
        super(data);
        this._discriminator = "ShareNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shareId = _data["shareId"];
        }
    }

    static override fromJS(data: any): ShareNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        super.toJSON(data);
        return data;
    }
}

export interface IShareNotFoundException extends IPictureparkNotFoundException {
    shareId?: string | undefined;
}

export class ShareByTokenNotFoundException extends PictureparkNotFoundException implements IShareByTokenNotFoundException {
    token?: string | undefined;

    constructor(data?: IShareByTokenNotFoundException) {
        super(data);
        this._discriminator = "ShareByTokenNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): ShareByTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareByTokenNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IShareByTokenNotFoundException extends IPictureparkNotFoundException {
    token?: string | undefined;
}

export class TokenGenerationException extends PictureparkBusinessException implements ITokenGenerationException {
    retries?: number;

    constructor(data?: ITokenGenerationException) {
        super(data);
        this._discriminator = "TokenGenerationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retries = _data["retries"];
        }
    }

    static override fromJS(data: any): TokenGenerationException {
        data = typeof data === 'object' ? data : {};
        let result = new TokenGenerationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retries"] = this.retries;
        super.toJSON(data);
        return data;
    }
}

export interface ITokenGenerationException extends IPictureparkBusinessException {
    retries?: number;
}

export class ShareExpiredException extends PictureparkBusinessException implements IShareExpiredException {
    token?: string | undefined;

    constructor(data?: IShareExpiredException) {
        super(data);
        this._discriminator = "ShareExpiredException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): ShareExpiredException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareExpiredException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IShareExpiredException extends IPictureparkBusinessException {
    token?: string | undefined;
}

export class ShareSizeLimitExceededException extends PictureparkValidationException implements IShareSizeLimitExceededException {
    shareId?: string | undefined;
    limit?: number;

    constructor(data?: IShareSizeLimitExceededException) {
        super(data);
        this._discriminator = "ShareSizeLimitExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shareId = _data["shareId"];
            this.limit = _data["limit"];
        }
    }

    static override fromJS(data: any): ShareSizeLimitExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSizeLimitExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        data["limit"] = this.limit;
        super.toJSON(data);
        return data;
    }
}

export interface IShareSizeLimitExceededException extends IPictureparkValidationException {
    shareId?: string | undefined;
    limit?: number;
}

export class DuplicateSharedOutputException extends PictureparkValidationException implements IDuplicateSharedOutputException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IDuplicateSharedOutputException) {
        super(data);
        this._discriminator = "DuplicateSharedOutputException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): DuplicateSharedOutputException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSharedOutputException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateSharedOutputException extends IPictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class DuplicateEmbedConversionPresetException extends PictureparkValidationException implements IDuplicateEmbedConversionPresetException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IDuplicateEmbedConversionPresetException) {
        super(data);
        this._discriminator = "DuplicateEmbedConversionPresetException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): DuplicateEmbedConversionPresetException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateEmbedConversionPresetException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateEmbedConversionPresetException extends IPictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class OutputIdNotFoundException extends PictureparkNotFoundException implements IOutputIdNotFoundException {
    outputId?: string | undefined;

    constructor(data?: IOutputIdNotFoundException) {
        super(data);
        this._discriminator = "OutputIdNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputId = _data["outputId"];
        }
    }

    static override fromJS(data: any): OutputIdNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputIdNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputId"] = this.outputId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputIdNotFoundException extends IPictureparkNotFoundException {
    outputId?: string | undefined;
}

export class OutputNotFoundException extends PictureparkNotFoundException implements IOutputNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputNotFoundException) {
        super(data);
        this._discriminator = "OutputNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputNotFoundException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UnmodifiedOriginalOutputNotFoundException") {
            let result = new UnmodifiedOriginalOutputNotFoundException();
            result.init(data);
            return result;
        }
        let result = new OutputNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputNotFoundException extends IPictureparkNotFoundException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class UnmodifiedOriginalOutputNotFoundException extends OutputNotFoundException implements IUnmodifiedOriginalOutputNotFoundException {

    constructor(data?: IUnmodifiedOriginalOutputNotFoundException) {
        super(data);
        this._discriminator = "UnmodifiedOriginalOutputNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UnmodifiedOriginalOutputNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new UnmodifiedOriginalOutputNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUnmodifiedOriginalOutputNotFoundException extends IOutputNotFoundException {
}

export class UnableToCreateOrModifyStaticOutputFormatException extends PictureparkValidationException implements IUnableToCreateOrModifyStaticOutputFormatException {

    constructor(data?: IUnableToCreateOrModifyStaticOutputFormatException) {
        super(data);
        this._discriminator = "UnableToCreateOrModifyStaticOutputFormatException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UnableToCreateOrModifyStaticOutputFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToCreateOrModifyStaticOutputFormatException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToCreateOrModifyStaticOutputFormatException extends IPictureparkValidationException {
}

export class NotSupportedFileMappingException extends PictureparkValidationException implements INotSupportedFileMappingException {
    inputExtension?: string | undefined;
    targetFormatKind?: string | undefined;

    constructor(data?: INotSupportedFileMappingException) {
        super(data);
        this._discriminator = "NotSupportedFileMappingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.inputExtension = _data["inputExtension"];
            this.targetFormatKind = _data["targetFormatKind"];
        }
    }

    static override fromJS(data: any): NotSupportedFileMappingException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotSupportedFileMappingForDynamicFormatException") {
            let result = new NotSupportedFileMappingForDynamicFormatException();
            result.init(data);
            return result;
        }
        let result = new NotSupportedFileMappingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputExtension"] = this.inputExtension;
        data["targetFormatKind"] = this.targetFormatKind;
        super.toJSON(data);
        return data;
    }
}

export interface INotSupportedFileMappingException extends IPictureparkValidationException {
    inputExtension?: string | undefined;
    targetFormatKind?: string | undefined;
}

export class NotSupportedFileMappingForDynamicFormatException extends NotSupportedFileMappingException implements INotSupportedFileMappingForDynamicFormatException {
    formatId?: string | undefined;

    constructor(data?: INotSupportedFileMappingForDynamicFormatException) {
        super(data);
        this._discriminator = "NotSupportedFileMappingForDynamicFormatException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.formatId = _data["formatId"];
        }
    }

    static override fromJS(data: any): NotSupportedFileMappingForDynamicFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new NotSupportedFileMappingForDynamicFormatException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formatId"] = this.formatId;
        super.toJSON(data);
        return data;
    }
}

export interface INotSupportedFileMappingForDynamicFormatException extends INotSupportedFileMappingException {
    formatId?: string | undefined;
}

export class NotSupportedFileExtensionException extends PictureparkValidationException implements INotSupportedFileExtensionException {
    extension?: string | undefined;

    constructor(data?: INotSupportedFileExtensionException) {
        super(data);
        this._discriminator = "NotSupportedFileExtensionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.extension = _data["extension"];
        }
    }

    static override fromJS(data: any): NotSupportedFileExtensionException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotSupportedFileExtensionForFormatException") {
            let result = new NotSupportedFileExtensionForFormatException();
            result.init(data);
            return result;
        }
        let result = new NotSupportedFileExtensionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        super.toJSON(data);
        return data;
    }
}

export interface INotSupportedFileExtensionException extends IPictureparkValidationException {
    extension?: string | undefined;
}

export class DuplicateOutputFormatIdException extends PictureparkValidationException implements IDuplicateOutputFormatIdException {
    id?: string | undefined;

    constructor(data?: IDuplicateOutputFormatIdException) {
        super(data);
        this._discriminator = "DuplicateOutputFormatIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): DuplicateOutputFormatIdException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateOutputFormatIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateOutputFormatIdException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class OutputEditingNotSupportedException extends PictureparkValidationException implements IOutputEditingNotSupportedException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IOutputEditingNotSupportedException) {
        super(data);
        this._discriminator = "OutputEditingNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputEditingNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputEditingNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputEditingNotSupportedException extends IPictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class OutputBackupNotRequestedException extends PictureparkValidationException implements IOutputBackupNotRequestedException {

    constructor(data?: IOutputBackupNotRequestedException) {
        super(data);
        this._discriminator = "OutputBackupNotRequestedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputBackupNotRequestedException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputBackupNotRequestedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutputBackupNotRequestedException extends IPictureparkValidationException {
}

export class OutputBackupHashMismatchException extends PictureparkValidationException implements IOutputBackupHashMismatchException {
    requestedHash?: string | undefined;
    documentHash?: string | undefined;

    constructor(data?: IOutputBackupHashMismatchException) {
        super(data);
        this._discriminator = "OutputBackupHashMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestedHash = _data["requestedHash"];
            this.documentHash = _data["documentHash"];
        }
    }

    static override fromJS(data: any): OutputBackupHashMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputBackupHashMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedHash"] = this.requestedHash;
        data["documentHash"] = this.documentHash;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputBackupHashMismatchException extends IPictureparkValidationException {
    requestedHash?: string | undefined;
    documentHash?: string | undefined;
}

export class OutputOperationInProgressException extends PictureparkBusinessException implements IOutputOperationInProgressException {

    constructor(data?: IOutputOperationInProgressException) {
        super(data);
        this._discriminator = "OutputOperationInProgressException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputOperationInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputOperationInProgressException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutputOperationInProgressException extends IPictureparkBusinessException {
}

export class DownloadLinkExpiredException extends PictureparkBusinessException implements IDownloadLinkExpiredException {

    constructor(data?: IDownloadLinkExpiredException) {
        super(data);
        this._discriminator = "DownloadLinkExpiredException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DownloadLinkExpiredException {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadLinkExpiredException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IDownloadLinkExpiredException extends IPictureparkBusinessException {
}

export class RenderingNotAwaitedException extends PictureparkBusinessException implements IRenderingNotAwaitedException {

    constructor(data?: IRenderingNotAwaitedException) {
        super(data);
        this._discriminator = "RenderingNotAwaitedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RenderingNotAwaitedException {
        data = typeof data === 'object' ? data : {};
        let result = new RenderingNotAwaitedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRenderingNotAwaitedException extends IPictureparkBusinessException {
}

export class DuplicateContentDownloadRequestException extends PictureparkValidationException implements IDuplicateContentDownloadRequestException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: IDuplicateContentDownloadRequestException) {
        super(data);
        this._discriminator = "DuplicateContentDownloadRequestException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): DuplicateContentDownloadRequestException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateContentDownloadRequestException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateContentDownloadRequestException extends IPictureparkValidationException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
}

export class InvalidContentDownloadRequestException extends PictureparkValidationException implements IInvalidContentDownloadRequestException {

    constructor(data?: IInvalidContentDownloadRequestException) {
        super(data);
        this._discriminator = "InvalidContentDownloadRequestException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): InvalidContentDownloadRequestException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidContentDownloadRequestException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidContentDownloadRequestException extends IPictureparkValidationException {
}

export class DownloadNotFoundException extends PictureparkNotFoundException implements IDownloadNotFoundException {
    token?: string | undefined;

    constructor(data?: IDownloadNotFoundException) {
        super(data);
        this._discriminator = "DownloadNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): DownloadNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IDownloadNotFoundException extends IPictureparkNotFoundException {
    token?: string | undefined;
}

export class EmbedMultiDownloadException extends PictureparkValidationException implements IEmbedMultiDownloadException {
    token?: string | undefined;

    constructor(data?: IEmbedMultiDownloadException) {
        super(data);
        this._discriminator = "EmbedMultiDownloadException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): EmbedMultiDownloadException {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedMultiDownloadException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface IEmbedMultiDownloadException extends IPictureparkValidationException {
    token?: string | undefined;
}

export class ImageOptimizationLicensingException extends PictureparkValidationException implements IImageOptimizationLicensingException {

    constructor(data?: IImageOptimizationLicensingException) {
        super(data);
        this._discriminator = "ImageOptimizationLicensingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ImageOptimizationLicensingException {
        data = typeof data === 'object' ? data : {};
        let result = new ImageOptimizationLicensingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IImageOptimizationLicensingException extends IPictureparkValidationException {
}

export class LeaseNotAcquiredException extends PictureparkBusinessException implements ILeaseNotAcquiredException {
    resourceId?: string | undefined;

    constructor(data?: ILeaseNotAcquiredException) {
        super(data);
        this._discriminator = "LeaseNotAcquiredException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resourceId = _data["resourceId"];
        }
    }

    static override fromJS(data: any): LeaseNotAcquiredException {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseNotAcquiredException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data;
    }
}

export interface ILeaseNotAcquiredException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class OperationInProgressException extends PictureparkBusinessException implements IOperationInProgressException {
    leaseResourceType?: LeaseResourceType;

    constructor(data?: IOperationInProgressException) {
        super(data);
        this._discriminator = "OperationInProgressException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.leaseResourceType = _data["leaseResourceType"];
        }
    }

    static override fromJS(data: any): OperationInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OperationInProgressException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseResourceType"] = this.leaseResourceType;
        super.toJSON(data);
        return data;
    }
}

export interface IOperationInProgressException extends IPictureparkBusinessException {
    leaseResourceType?: LeaseResourceType;
}

export enum LeaseResourceType {
    SchemaEditing = "SchemaEditing",
}

export class OwnerTokenNotFoundException extends PictureparkNotFoundException implements IOwnerTokenNotFoundException {
    ownerTokenUserIds?: string[] | undefined;

    constructor(data?: IOwnerTokenNotFoundException) {
        super(data);
        this._discriminator = "OwnerTokenNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["ownerTokenUserIds"])) {
                this.ownerTokenUserIds = [] as any;
                for (let item of _data["ownerTokenUserIds"])
                    this.ownerTokenUserIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): OwnerTokenNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ownerTokenUserIds)) {
            data["ownerTokenUserIds"] = [];
            for (let item of this.ownerTokenUserIds)
                data["ownerTokenUserIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOwnerTokenNotFoundException extends IPictureparkNotFoundException {
    ownerTokenUserIds?: string[] | undefined;
}

export class InvalidStateException extends PictureparkValidationException implements IInvalidStateException {
    resourceId?: string | undefined;
    state?: string | undefined;

    constructor(data?: IInvalidStateException) {
        super(data);
        this._discriminator = "InvalidStateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.state = _data["state"];
        }
    }

    static override fromJS(data: any): InvalidStateException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "InvalidStateTransitionException") {
            let result = new InvalidStateTransitionException();
            result.init(data);
            return result;
        }
        let result = new InvalidStateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["state"] = this.state;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidStateException extends IPictureparkValidationException {
    resourceId?: string | undefined;
    state?: string | undefined;
}

export class PictureparkArgumentNullException extends PictureparkValidationException implements IPictureparkArgumentNullException {
    argumentName?: string | undefined;

    constructor(data?: IPictureparkArgumentNullException) {
        super(data);
        this._discriminator = "PictureparkArgumentNullException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.argumentName = _data["argumentName"];
        }
    }

    static override fromJS(data: any): PictureparkArgumentNullException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkArgumentNullException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkArgumentNullException extends IPictureparkValidationException {
    argumentName?: string | undefined;
}

export class ObjectTypeMismatchException extends PictureparkBusinessException implements IObjectTypeMismatchException {
    type?: string | undefined;

    constructor(data?: IObjectTypeMismatchException) {
        super(data);
        this._discriminator = "ObjectTypeMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): ObjectTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectTypeMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IObjectTypeMismatchException extends IPictureparkBusinessException {
    type?: string | undefined;
}

export class InvalidStateTransitionException extends InvalidStateException implements IInvalidStateTransitionException {
    transition?: string | undefined;

    constructor(data?: IInvalidStateTransitionException) {
        super(data);
        this._discriminator = "InvalidStateTransitionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transition = _data["transition"];
        }
    }

    static override fromJS(data: any): InvalidStateTransitionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidStateTransitionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transition"] = this.transition;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidStateTransitionException extends IInvalidStateException {
    transition?: string | undefined;
}

export class FailedToLockException extends PictureparkBusinessException implements IFailedToLockException {
    resourceId?: string | undefined;

    constructor(data?: IFailedToLockException) {
        super(data);
        this._discriminator = "FailedToLockException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resourceId = _data["resourceId"];
        }
    }

    static override fromJS(data: any): FailedToLockException {
        data = typeof data === 'object' ? data : {};
        let result = new FailedToLockException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        super.toJSON(data);
        return data;
    }
}

export interface IFailedToLockException extends IPictureparkBusinessException {
    resourceId?: string | undefined;
}

export class PictureparkOperationCanceledException extends PictureparkBusinessException implements IPictureparkOperationCanceledException {

    constructor(data?: IPictureparkOperationCanceledException) {
        super(data);
        this._discriminator = "PictureparkOperationCanceledException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkOperationCanceledException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkOperationCanceledException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkOperationCanceledException extends IPictureparkBusinessException {
}

export class PictureparkApplicationException extends PictureparkBusinessException implements IPictureparkApplicationException {

    constructor(data?: IPictureparkApplicationException) {
        super(data);
        this._discriminator = "PictureparkApplicationException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkApplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new PictureparkApplicationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkApplicationException extends IPictureparkBusinessException {
}

export class MissingCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingCustomerDefaultLanguageException {
    customerDefaultLanguage?: string | undefined;

    constructor(data?: IMissingCustomerDefaultLanguageException) {
        super(data);
        this._discriminator = "MissingCustomerDefaultLanguageException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerDefaultLanguage = _data["customerDefaultLanguage"];
        }
    }

    static override fromJS(data: any): MissingCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerDefaultLanguage"] = this.customerDefaultLanguage;
        super.toJSON(data);
        return data;
    }
}

export interface IMissingCustomerDefaultLanguageException extends IPictureparkValidationException {
    customerDefaultLanguage?: string | undefined;
}

export class PartialOperationNotSupportedException extends PictureparkValidationException implements IPartialOperationNotSupportedException {

    constructor(data?: IPartialOperationNotSupportedException) {
        super(data);
        this._discriminator = "PartialOperationNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PartialOperationNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new PartialOperationNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPartialOperationNotSupportedException extends IPictureparkValidationException {
}

export class ContractMismatchException extends PictureparkValidationException implements IContractMismatchException {

    constructor(data?: IContractMismatchException) {
        super(data);
        this._discriminator = "ContractMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContractMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ContractMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IContractMismatchException extends IPictureparkValidationException {
}

export class PictureparkTooManyRequestsException extends PictureparkBusinessException implements IPictureparkTooManyRequestsException {

    constructor(data?: IPictureparkTooManyRequestsException) {
        super(data);
        this._discriminator = "PictureparkTooManyRequestsException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PictureparkTooManyRequestsException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TooManyBusinessProcessesException") {
            let result = new TooManyBusinessProcessesException();
            result.init(data);
            return result;
        }
        let result = new PictureparkTooManyRequestsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPictureparkTooManyRequestsException extends IPictureparkBusinessException {
}

export class InvalidArgumentException extends PictureparkValidationException implements IInvalidArgumentException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;

    constructor(data?: IInvalidArgumentException) {
        super(data);
        this._discriminator = "InvalidArgumentException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.argumentName = _data["argumentName"];
            this.argumentValue = _data["argumentValue"];
        }
    }

    static override fromJS(data: any): InvalidArgumentException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ArgumentRangeException") {
            throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
        }
        if (data["kind"] === "InvalidValueFormatException") {
            let result = new InvalidValueFormatException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        let result = new InvalidArgumentException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        data["argumentValue"] = this.argumentValue;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidArgumentException extends IPictureparkValidationException {
    argumentName?: string | undefined;
    argumentValue?: string | undefined;
}

export abstract class ArgumentRangeException extends InvalidArgumentException implements IArgumentRangeException {
    minAcceptableValue?: string | undefined;
    maxAcceptableValue?: string | undefined;

    constructor(data?: IArgumentRangeException) {
        super(data);
        this._discriminator = "ArgumentRangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minAcceptableValue = _data["minAcceptableValue"];
            this.maxAcceptableValue = _data["maxAcceptableValue"];
        }
    }

    static override fromJS(data: any): ArgumentRangeException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputFormatRetentionTimeOutOfRangeException") {
            let result = new OutputFormatRetentionTimeOutOfRangeException();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ArgumentRangeException' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAcceptableValue"] = this.minAcceptableValue;
        data["maxAcceptableValue"] = this.maxAcceptableValue;
        super.toJSON(data);
        return data;
    }
}

export interface IArgumentRangeException extends IInvalidArgumentException {
    minAcceptableValue?: string | undefined;
    maxAcceptableValue?: string | undefined;
}

export class UnknownException extends PictureparkBusinessException implements IUnknownException {

    constructor(data?: IUnknownException) {
        super(data);
        this._discriminator = "UnknownException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UnknownException {
        data = typeof data === 'object' ? data : {};
        let result = new UnknownException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUnknownException extends IPictureparkBusinessException {
}

export class OwnerTokenInUseException extends PictureparkValidationException implements IOwnerTokenInUseException {
    ownerTokenUserId?: string | undefined;

    constructor(data?: IOwnerTokenInUseException) {
        super(data);
        this._discriminator = "OwnerTokenInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ownerTokenUserId = _data["ownerTokenUserId"];
        }
    }

    static override fromJS(data: any): OwnerTokenInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerTokenInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerTokenUserId"] = this.ownerTokenUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IOwnerTokenInUseException extends IPictureparkValidationException {
    ownerTokenUserId?: string | undefined;
}

export class InvalidValueFormatException extends InvalidArgumentException implements IInvalidValueFormatException {
    expectedFormat?: string | undefined;

    constructor(data?: IInvalidValueFormatException) {
        super(data);
        this._discriminator = "InvalidValueFormatException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expectedFormat = _data["expectedFormat"];
        }
    }

    static override fromJS(data: any): InvalidValueFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidValueFormatException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedFormat"] = this.expectedFormat;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidValueFormatException extends IInvalidArgumentException {
    expectedFormat?: string | undefined;
}

export class ItemIdDuplicatedException extends PictureparkValidationException implements IItemIdDuplicatedException {
    id?: string | undefined;

    constructor(data?: IItemIdDuplicatedException) {
        super(data);
        this._discriminator = "ItemIdDuplicatedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): ItemIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdDuplicatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IItemIdDuplicatedException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class RequestSizeLimitExceededException extends PictureparkValidationException implements IRequestSizeLimitExceededException {
    argumentName?: string | undefined;
    limit?: number;
    requestedAmount?: number;

    constructor(data?: IRequestSizeLimitExceededException) {
        super(data);
        this._discriminator = "RequestSizeLimitExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.argumentName = _data["argumentName"];
            this.limit = _data["limit"];
            this.requestedAmount = _data["requestedAmount"];
        }
    }

    static override fromJS(data: any): RequestSizeLimitExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new RequestSizeLimitExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentName"] = this.argumentName;
        data["limit"] = this.limit;
        data["requestedAmount"] = this.requestedAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IRequestSizeLimitExceededException extends IPictureparkValidationException {
    argumentName?: string | undefined;
    limit?: number;
    requestedAmount?: number;
}

export class CustomerViolationException extends PictureparkException implements ICustomerViolationException {
    expectedCustomerId?: string | undefined;
    currentCustomerId?: string | undefined;

    constructor(data?: ICustomerViolationException) {
        super(data);
        this._discriminator = "CustomerViolationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expectedCustomerId = _data["expectedCustomerId"];
            this.currentCustomerId = _data["currentCustomerId"];
        }
    }

    static override fromJS(data: any): CustomerViolationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerViolationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedCustomerId"] = this.expectedCustomerId;
        data["currentCustomerId"] = this.currentCustomerId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerViolationException extends IPictureparkException {
    expectedCustomerId?: string | undefined;
    currentCustomerId?: string | undefined;
}

export class CustomerAliasNotFoundException extends PictureparkException implements ICustomerAliasNotFoundException {
    customerAlias?: string | undefined;

    constructor(data?: ICustomerAliasNotFoundException) {
        super(data);
        this._discriminator = "CustomerAliasNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerAlias = _data["customerAlias"];
        }
    }

    static override fromJS(data: any): CustomerAliasNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerAlias"] = this.customerAlias;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerAliasNotFoundException extends IPictureparkException {
    customerAlias?: string | undefined;
}

export class CustomerAliasInUseException extends PictureparkValidationException implements ICustomerAliasInUseException {
    existingCustomerId?: string | undefined;
    alias?: string | undefined;

    constructor(data?: ICustomerAliasInUseException) {
        super(data);
        this._discriminator = "CustomerAliasInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.existingCustomerId = _data["existingCustomerId"];
            this.alias = _data["alias"];
        }
    }

    static override fromJS(data: any): CustomerAliasInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingCustomerId"] = this.existingCustomerId;
        data["alias"] = this.alias;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerAliasInUseException extends IPictureparkValidationException {
    existingCustomerId?: string | undefined;
    alias?: string | undefined;
}

export class CustomerNotDeactivatedException extends PictureparkException implements ICustomerNotDeactivatedException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotDeactivatedException) {
        super(data);
        this._discriminator = "CustomerNotDeactivatedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static override fromJS(data: any): CustomerNotDeactivatedException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotDeactivatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerNotDeactivatedException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerDeactivationException extends PictureparkException implements ICustomerDeactivationException {
    customerId?: string | undefined;
    deactivationMessage?: string | undefined;

    constructor(data?: ICustomerDeactivationException) {
        super(data);
        this._discriminator = "CustomerDeactivationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            this.deactivationMessage = _data["deactivationMessage"];
        }
    }

    static override fromJS(data: any): CustomerDeactivationException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDeactivationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["deactivationMessage"] = this.deactivationMessage;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerDeactivationException extends IPictureparkException {
    customerId?: string | undefined;
    deactivationMessage?: string | undefined;
}

export class CustomerHostNotFoundException extends PictureparkException implements ICustomerHostNotFoundException {
    hostName?: string | undefined;

    constructor(data?: ICustomerHostNotFoundException) {
        super(data);
        this._discriminator = "CustomerHostNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.hostName = _data["hostName"];
        }
    }

    static override fromJS(data: any): CustomerHostNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerHostNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerHostNotFoundException extends IPictureparkException {
    hostName?: string | undefined;
}

export class CustomerNotFoundException extends PictureparkException implements ICustomerNotFoundException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotFoundException) {
        super(data);
        this._discriminator = "CustomerNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static override fromJS(data: any): CustomerNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerNotFoundException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerNotActiveException extends PictureparkException implements ICustomerNotActiveException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotActiveException) {
        super(data);
        this._discriminator = "CustomerNotActiveException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static override fromJS(data: any): CustomerNotActiveException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotActiveException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerNotActiveException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerBoostValuesInvalidException extends PictureparkValidationException implements ICustomerBoostValuesInvalidException {

    constructor(data?: ICustomerBoostValuesInvalidException) {
        super(data);
        this._discriminator = "CustomerBoostValuesInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CustomerBoostValuesInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBoostValuesInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerBoostValuesInvalidException extends IPictureparkValidationException {
}

export class SnapshotRetentionTimeTooShortException extends PictureparkValidationException implements ISnapshotRetentionTimeTooShortException {
    snapshotRetentionTime?: string;
    minimumRetentionTime?: string;

    constructor(data?: ISnapshotRetentionTimeTooShortException) {
        super(data);
        this._discriminator = "SnapshotRetentionTimeTooShortException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.snapshotRetentionTime = _data["snapshotRetentionTime"];
            this.minimumRetentionTime = _data["minimumRetentionTime"];
        }
    }

    static override fromJS(data: any): SnapshotRetentionTimeTooShortException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotRetentionTimeTooShortException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snapshotRetentionTime"] = this.snapshotRetentionTime;
        data["minimumRetentionTime"] = this.minimumRetentionTime;
        super.toJSON(data);
        return data;
    }
}

export interface ISnapshotRetentionTimeTooShortException extends IPictureparkValidationException {
    snapshotRetentionTime?: string;
    minimumRetentionTime?: string;
}

export class ReshardIndexNotAllowedException extends PictureparkValidationException implements IReshardIndexNotAllowedException {

    constructor(data?: IReshardIndexNotAllowedException) {
        super(data);
        this._discriminator = "ReshardIndexNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReshardIndexNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new ReshardIndexNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReshardIndexNotAllowedException extends IPictureparkValidationException {
}

export class ReshardNumberOfShardsInvalidException extends PictureparkValidationException implements IReshardNumberOfShardsInvalidException {

    constructor(data?: IReshardNumberOfShardsInvalidException) {
        super(data);
        this._discriminator = "ReshardNumberOfShardsInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReshardNumberOfShardsInvalidException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ReshardNumberOfRoutingShardsInvalidException") {
            let result = new ReshardNumberOfRoutingShardsInvalidException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReshardNumberOfShardsInvalidForExistingRoutingShardsException") {
            let result = new ReshardNumberOfShardsInvalidForExistingRoutingShardsException();
            result.init(data);
            return result;
        }
        let result = new ReshardNumberOfShardsInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReshardNumberOfShardsInvalidException extends IPictureparkValidationException {
}

export class ReshardNumberOfRoutingShardsInvalidException extends ReshardNumberOfShardsInvalidException implements IReshardNumberOfRoutingShardsInvalidException {

    constructor(data?: IReshardNumberOfRoutingShardsInvalidException) {
        super(data);
        this._discriminator = "ReshardNumberOfRoutingShardsInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReshardNumberOfRoutingShardsInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ReshardNumberOfRoutingShardsInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReshardNumberOfRoutingShardsInvalidException extends IReshardNumberOfShardsInvalidException {
}

export class ReshardNumberOfShardsInvalidForExistingRoutingShardsException extends ReshardNumberOfShardsInvalidException implements IReshardNumberOfShardsInvalidForExistingRoutingShardsException {

    constructor(data?: IReshardNumberOfShardsInvalidForExistingRoutingShardsException) {
        super(data);
        this._discriminator = "ReshardNumberOfShardsInvalidForExistingRoutingShardsException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ReshardNumberOfShardsInvalidForExistingRoutingShardsException {
        data = typeof data === 'object' ? data : {};
        let result = new ReshardNumberOfShardsInvalidForExistingRoutingShardsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IReshardNumberOfShardsInvalidForExistingRoutingShardsException extends IReshardNumberOfShardsInvalidException {
}

export class ConfigurationIndexNotFoundException extends PictureparkException implements IConfigurationIndexNotFoundException {
    configurationIndex?: string | undefined;

    constructor(data?: IConfigurationIndexNotFoundException) {
        super(data);
        this._discriminator = "ConfigurationIndexNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.configurationIndex = _data["configurationIndex"];
        }
    }

    static override fromJS(data: any): ConfigurationIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIndexNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configurationIndex"] = this.configurationIndex;
        super.toJSON(data);
        return data;
    }
}

export interface IConfigurationIndexNotFoundException extends IPictureparkException {
    configurationIndex?: string | undefined;
}

export class DuplicateSearchIndexDocException extends PictureparkBusinessException implements IDuplicateSearchIndexDocException {
    searchIndexDocId?: string | undefined;

    constructor(data?: IDuplicateSearchIndexDocException) {
        super(data);
        this._discriminator = "DuplicateSearchIndexDocException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchIndexDocId = _data["searchIndexDocId"];
        }
    }

    static override fromJS(data: any): DuplicateSearchIndexDocException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSearchIndexDocException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexDocId"] = this.searchIndexDocId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateSearchIndexDocException extends IPictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export class SearchIndexDocNotFoundException extends PictureparkBusinessException implements ISearchIndexDocNotFoundException {
    searchIndexDocId?: string | undefined;

    constructor(data?: ISearchIndexDocNotFoundException) {
        super(data);
        this._discriminator = "SearchIndexDocNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchIndexDocId = _data["searchIndexDocId"];
        }
    }

    static override fromJS(data: any): SearchIndexDocNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexDocNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexDocId"] = this.searchIndexDocId;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchIndexDocNotFoundException extends IPictureparkBusinessException {
    searchIndexDocId?: string | undefined;
}

export class IndexDocumentNotFoundException extends PictureparkBusinessException implements IIndexDocumentNotFoundException {
    indexId?: string | undefined;

    constructor(data?: IIndexDocumentNotFoundException) {
        super(data);
        this._discriminator = "IndexDocumentNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexId = _data["indexId"];
        }
    }

    static override fromJS(data: any): IndexDocumentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocumentNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexId"] = this.indexId;
        super.toJSON(data);
        return data;
    }
}

export interface IIndexDocumentNotFoundException extends IPictureparkBusinessException {
    indexId?: string | undefined;
}

export class DuplicateAliasException extends PictureparkException implements IDuplicateAliasException {
    indexAlias?: string | undefined;

    constructor(data?: IDuplicateAliasException) {
        super(data);
        this._discriminator = "DuplicateAliasException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexAlias = _data["indexAlias"];
        }
    }

    static override fromJS(data: any): DuplicateAliasException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAliasException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexAlias"] = this.indexAlias;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateAliasException extends IPictureparkException {
    indexAlias?: string | undefined;
}

export class SearchIndexNotFoundException extends PictureparkBusinessException implements ISearchIndexNotFoundException {
    searchIndexId?: string | undefined;

    constructor(data?: ISearchIndexNotFoundException) {
        super(data);
        this._discriminator = "SearchIndexNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchIndexId = _data["searchIndexId"];
        }
    }

    static override fromJS(data: any): SearchIndexNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndexId"] = this.searchIndexId;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchIndexNotFoundException extends IPictureparkBusinessException {
    searchIndexId?: string | undefined;
}

export class DefaultSearchIndexDeleteException extends PictureparkBusinessException implements IDefaultSearchIndexDeleteException {

    constructor(data?: IDefaultSearchIndexDeleteException) {
        super(data);
        this._discriminator = "DefaultSearchIndexDeleteException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DefaultSearchIndexDeleteException {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultSearchIndexDeleteException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IDefaultSearchIndexDeleteException extends IPictureparkBusinessException {
}

export class SearchIndexInUseException extends PictureparkBusinessException implements ISearchIndexInUseException {
    searchIndex?: string | undefined;

    constructor(data?: ISearchIndexInUseException) {
        super(data);
        this._discriminator = "SearchIndexInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchIndex = _data["searchIndex"];
        }
    }

    static override fromJS(data: any): SearchIndexInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchIndexInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndex"] = this.searchIndex;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchIndexInUseException extends IPictureparkBusinessException {
    searchIndex?: string | undefined;
}

export class IndexException extends PictureparkBusinessException implements IIndexException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexException) {
        super(data);
        this._discriminator = "IndexException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexName = _data["indexName"];
            this.debugInformation = _data["debugInformation"];
        }
    }

    static override fromJS(data: any): IndexException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data;
    }
}

export interface IIndexException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class IndexMappingException extends PictureparkBusinessException implements IIndexMappingException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;

    constructor(data?: IIndexMappingException) {
        super(data);
        this._discriminator = "IndexMappingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexName = _data["indexName"];
            this.debugInformation = _data["debugInformation"];
        }
    }

    static override fromJS(data: any): IndexMappingException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexMappingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexName"] = this.indexName;
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data;
    }
}

export interface IIndexMappingException extends IPictureparkBusinessException {
    indexName?: string | undefined;
    debugInformation?: string | undefined;
}

export class DuplicatedSearchBehaviorException extends PictureparkValidationException implements IDuplicatedSearchBehaviorException {
    duplicatedSearchBehaviors?: string | undefined;

    constructor(data?: IDuplicatedSearchBehaviorException) {
        super(data);
        this._discriminator = "DuplicatedSearchBehaviorException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.duplicatedSearchBehaviors = _data["duplicatedSearchBehaviors"];
        }
    }

    static override fromJS(data: any): DuplicatedSearchBehaviorException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatedSearchBehaviorException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duplicatedSearchBehaviors"] = this.duplicatedSearchBehaviors;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicatedSearchBehaviorException extends IPictureparkValidationException {
    duplicatedSearchBehaviors?: string | undefined;
}

export class SearchStringLeadingWildcardException extends PictureparkValidationException implements ISearchStringLeadingWildcardException {

    constructor(data?: ISearchStringLeadingWildcardException) {
        super(data);
        this._discriminator = "SearchStringLeadingWildcardException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SearchStringLeadingWildcardException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStringLeadingWildcardException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISearchStringLeadingWildcardException extends IPictureparkValidationException {
}

export class DuplicateAggregatorException extends PictureparkValidationException implements IDuplicateAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IDuplicateAggregatorException) {
        super(data);
        this._discriminator = "DuplicateAggregatorException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregatorName = _data["aggregatorName"];
        }
    }

    static override fromJS(data: any): DuplicateAggregatorException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateAggregatorException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateAggregatorException extends IPictureparkValidationException {
    aggregatorName?: string | undefined;
}

export class InvalidDateTimeFormatException extends PictureparkValidationException implements IInvalidDateTimeFormatException {
    value?: string | undefined;
    expectedFormat?: string | undefined;

    constructor(data?: IInvalidDateTimeFormatException) {
        super(data);
        this._discriminator = "InvalidDateTimeFormatException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
            this.expectedFormat = _data["expectedFormat"];
        }
    }

    static override fromJS(data: any): InvalidDateTimeFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidDateTimeFormatException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["expectedFormat"] = this.expectedFormat;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidDateTimeFormatException extends IPictureparkValidationException {
    value?: string | undefined;
    expectedFormat?: string | undefined;
}

export class InvalidSortFieldException extends PictureparkValidationException implements IInvalidSortFieldException {
    fieldName?: string | undefined;

    constructor(data?: IInvalidSortFieldException) {
        super(data);
        this._discriminator = "InvalidSortFieldException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldName = _data["fieldName"];
        }
    }

    static override fromJS(data: any): InvalidSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidSortFieldException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidSortFieldException extends IPictureparkValidationException {
    fieldName?: string | undefined;
}

export class InvalidUiBehaviorInNonRootAggregatorException extends PictureparkValidationException implements IInvalidUiBehaviorInNonRootAggregatorException {
    aggregatorName?: string | undefined;

    constructor(data?: IInvalidUiBehaviorInNonRootAggregatorException) {
        super(data);
        this._discriminator = "InvalidUiBehaviorInNonRootAggregatorException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregatorName = _data["aggregatorName"];
        }
    }

    static override fromJS(data: any): InvalidUiBehaviorInNonRootAggregatorException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidUiBehaviorInNonRootAggregatorException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidUiBehaviorInNonRootAggregatorException extends IPictureparkValidationException {
    aggregatorName?: string | undefined;
}

export class InvalidUiBehaviorConfigurationException extends PictureparkValidationException implements IInvalidUiBehaviorConfigurationException {
    aggregatorName?: string | undefined;

    constructor(data?: IInvalidUiBehaviorConfigurationException) {
        super(data);
        this._discriminator = "InvalidUiBehaviorConfigurationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregatorName = _data["aggregatorName"];
        }
    }

    static override fromJS(data: any): InvalidUiBehaviorConfigurationException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidUiBehaviorConfigurationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidUiBehaviorConfigurationException extends IPictureparkValidationException {
    aggregatorName?: string | undefined;
}

export class InvalidSearchFieldInAggregatorException extends PictureparkValidationException implements IInvalidSearchFieldInAggregatorException {
    fieldName?: string | undefined;
    aggregatorName?: string | undefined;

    constructor(data?: IInvalidSearchFieldInAggregatorException) {
        super(data);
        this._discriminator = "InvalidSearchFieldInAggregatorException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.aggregatorName = _data["aggregatorName"];
        }
    }

    static override fromJS(data: any): InvalidSearchFieldInAggregatorException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidSearchFieldInAggregatorException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["aggregatorName"] = this.aggregatorName;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidSearchFieldInAggregatorException extends IPictureparkValidationException {
    fieldName?: string | undefined;
    aggregatorName?: string | undefined;
}

export class SearchStringTooLongException extends PictureparkValidationException implements ISearchStringTooLongException {
    limit?: number;

    constructor(data?: ISearchStringTooLongException) {
        super(data);
        this._discriminator = "SearchStringTooLongException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.limit = _data["limit"];
        }
    }

    static override fromJS(data: any): SearchStringTooLongException {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStringTooLongException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchStringTooLongException extends IPictureparkValidationException {
    limit?: number;
}

export class AggregationNameInvalidException extends PictureparkValidationException implements IAggregationNameInvalidException {
    aggregationName?: string | undefined;
    aggregationPrefix?: string | undefined;

    constructor(data?: IAggregationNameInvalidException) {
        super(data);
        this._discriminator = "AggregationNameInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
            this.aggregationPrefix = _data["aggregationPrefix"];
        }
    }

    static override fromJS(data: any): AggregationNameInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationNameInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["aggregationPrefix"] = this.aggregationPrefix;
        super.toJSON(data);
        return data;
    }
}

export interface IAggregationNameInvalidException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
    aggregationPrefix?: string | undefined;
}

export class AggregationNameMissingException extends PictureparkValidationException implements IAggregationNameMissingException {

    constructor(data?: IAggregationNameMissingException) {
        super(data);
        this._discriminator = "AggregationNameMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AggregationNameMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationNameMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAggregationNameMissingException extends IPictureparkValidationException {
}

/** Size of the aggregation is invalid. */
export class AggregationSizeInvalidException extends PictureparkValidationException implements IAggregationSizeInvalidException {
    /** The name identifying the aggregation. */
    aggregationName?: string | undefined;
    /** The invalid size of the aggregation: size must be equal or greater than 1. */
    aggregationSize?: number;

    constructor(data?: IAggregationSizeInvalidException) {
        super(data);
        this._discriminator = "AggregationSizeInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
            this.aggregationSize = _data["aggregationSize"];
        }
    }

    static override fromJS(data: any): AggregationSizeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationSizeInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["aggregationSize"] = this.aggregationSize;
        super.toJSON(data);
        return data;
    }
}

/** Size of the aggregation is invalid. */
export interface IAggregationSizeInvalidException extends IPictureparkValidationException {
    /** The name identifying the aggregation. */
    aggregationName?: string | undefined;
    /** The invalid size of the aggregation: size must be equal or greater than 1. */
    aggregationSize?: number;
}

export class AggregationFilterNotSupportedException extends PictureparkValidationException implements IAggregationFilterNotSupportedException {
    aggregationName?: string | undefined;
    notSupportedFilterType?: string | undefined;
    supportedFilterTypes?: string[] | undefined;

    constructor(data?: IAggregationFilterNotSupportedException) {
        super(data);
        this._discriminator = "AggregationFilterNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
            this.notSupportedFilterType = _data["notSupportedFilterType"];
            if (Array.isArray(_data["supportedFilterTypes"])) {
                this.supportedFilterTypes = [] as any;
                for (let item of _data["supportedFilterTypes"])
                    this.supportedFilterTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): AggregationFilterNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFilterNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["notSupportedFilterType"] = this.notSupportedFilterType;
        if (Array.isArray(this.supportedFilterTypes)) {
            data["supportedFilterTypes"] = [];
            for (let item of this.supportedFilterTypes)
                data["supportedFilterTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAggregationFilterNotSupportedException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
    notSupportedFilterType?: string | undefined;
    supportedFilterTypes?: string[] | undefined;
}

export class AggregationFieldMissingException extends PictureparkValidationException implements IAggregationFieldMissingException {
    aggregationName?: string | undefined;

    constructor(data?: IAggregationFieldMissingException) {
        super(data);
        this._discriminator = "AggregationFieldMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
        }
    }

    static override fromJS(data: any): AggregationFieldMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFieldMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        super.toJSON(data);
        return data;
    }
}

export interface IAggregationFieldMissingException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
}

export class AggregationPathMissingException extends PictureparkValidationException implements IAggregationPathMissingException {
    aggregationName?: string | undefined;

    constructor(data?: IAggregationPathMissingException) {
        super(data);
        this._discriminator = "AggregationPathMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
        }
    }

    static override fromJS(data: any): AggregationPathMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationPathMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        super.toJSON(data);
        return data;
    }
}

export interface IAggregationPathMissingException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
}

export class DocumentVersionConflictException extends PictureparkConflictException implements IDocumentVersionConflictException {
    documentId?: string | undefined;
    documentType?: string | undefined;
    documentVersion?: number;

    constructor(data?: IDocumentVersionConflictException) {
        super(data);
        this._discriminator = "DocumentVersionConflictException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentType = _data["documentType"];
            this.documentVersion = _data["documentVersion"];
        }
    }

    static override fromJS(data: any): DocumentVersionConflictException {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersionConflictException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        data["documentVersion"] = this.documentVersion;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentVersionConflictException extends IPictureparkConflictException {
    documentId?: string | undefined;
    documentType?: string | undefined;
    documentVersion?: number;
}

export class RedisDatabaseExceededException extends PictureparkException implements IRedisDatabaseExceededException {
    customerId?: string | undefined;
    customerCount?: number;
    maxCount?: number;
    startIndex?: number;
    redisDatabaseCount?: number;

    constructor(data?: IRedisDatabaseExceededException) {
        super(data);
        this._discriminator = "RedisDatabaseExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerCount = _data["customerCount"];
            this.maxCount = _data["maxCount"];
            this.startIndex = _data["startIndex"];
            this.redisDatabaseCount = _data["redisDatabaseCount"];
        }
    }

    static override fromJS(data: any): RedisDatabaseExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new RedisDatabaseExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerCount"] = this.customerCount;
        data["maxCount"] = this.maxCount;
        data["startIndex"] = this.startIndex;
        data["redisDatabaseCount"] = this.redisDatabaseCount;
        super.toJSON(data);
        return data;
    }
}

export interface IRedisDatabaseExceededException extends IPictureparkException {
    customerId?: string | undefined;
    customerCount?: number;
    maxCount?: number;
    startIndex?: number;
    redisDatabaseCount?: number;
}

export class DuplicateDocumentException extends PictureparkValidationException implements IDuplicateDocumentException {
    documentId?: string | undefined;
    documentType?: string | undefined;

    constructor(data?: IDuplicateDocumentException) {
        super(data);
        this._discriminator = "DuplicateDocumentException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentType = _data["documentType"];
        }
    }

    static override fromJS(data: any): DuplicateDocumentException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateDocumentException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateDocumentException extends IPictureparkValidationException {
    documentId?: string | undefined;
    documentType?: string | undefined;
}

export class ObjectStoreResponseException extends PictureparkBusinessException implements IObjectStoreResponseException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;

    constructor(data?: IObjectStoreResponseException) {
        super(data);
        this._discriminator = "ObjectStoreResponseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rowErrorMessages = _data["rowErrorMessages"];
            this.message = _data["message"];
        }
    }

    static override fromJS(data: any): ObjectStoreResponseException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreResponseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["message"] = this.message;
        super.toJSON(data);
        return data;
    }
}

export interface IObjectStoreResponseException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    message?: string | undefined;
}

export class ObjectStoreException extends PictureparkBusinessException implements IObjectStoreException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IObjectStoreException) {
        super(data);
        this._discriminator = "ObjectStoreException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rowErrorMessages = _data["rowErrorMessages"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static override fromJS(data: any): ObjectStoreException {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectStoreException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowErrorMessages"] = this.rowErrorMessages;
        data["errorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IObjectStoreException extends IPictureparkBusinessException {
    rowErrorMessages?: string | undefined;
    errorMessage?: string | undefined;
}

export class QueryException extends PictureparkBusinessException implements IQueryException {
    debugInformation?: string | undefined;

    constructor(data?: IQueryException) {
        super(data);
        this._discriminator = "QueryException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.debugInformation = _data["debugInformation"];
        }
    }

    static override fromJS(data: any): QueryException {
        data = typeof data === 'object' ? data : {};
        let result = new QueryException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugInformation"] = this.debugInformation;
        super.toJSON(data);
        return data;
    }
}

export interface IQueryException extends IPictureparkBusinessException {
    debugInformation?: string | undefined;
}

export class PermissionOwnershipTransferException extends PictureparkValidationException implements IPermissionOwnershipTransferException {
    transferUserId?: string | undefined;
    missingUserRight?: UserRight;

    constructor(data?: IPermissionOwnershipTransferException) {
        super(data);
        this._discriminator = "PermissionOwnershipTransferException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferUserId = _data["transferUserId"];
            this.missingUserRight = _data["missingUserRight"];
        }
    }

    static override fromJS(data: any): PermissionOwnershipTransferException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOwnershipTransferException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        data["missingUserRight"] = this.missingUserRight;
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionOwnershipTransferException extends IPictureparkValidationException {
    transferUserId?: string | undefined;
    missingUserRight?: UserRight;
}

export enum UserRight {
    ManageContent = "ManageContent",
    ManageSharings = "ManageSharings",
    ManageTransfer = "ManageTransfer",
    ManageChannels = "ManageChannels",
    ManageSchemas = "ManageSchemas",
    ManageUsers = "ManageUsers",
    ManageUserRoles = "ManageUserRoles",
    ManagePermissions = "ManagePermissions",
    ManageSearchIndexes = "ManageSearchIndexes",
    ManageListItems = "ManageListItems",
    ManageServiceProviders = "ManageServiceProviders",
    ManageEmbeds = "ManageEmbeds",
    ManageTemplates = "ManageTemplates",
    ManageTermsOfService = "ManageTermsOfService",
    ManageLiveStream = "ManageLiveStream",
    ManageDocumentHistory = "ManageDocumentHistory",
    ManageAllShares = "ManageAllShares",
    ManageOutputFormats = "ManageOutputFormats",
    ManageBusinessProcesses = "ManageBusinessProcesses",
    ManageIdentityProviders = "ManageIdentityProviders",
    ManageXmpMappings = "ManageXmpMappings",
    ReadStatistics = "ReadStatistics",
    WriteStatistics = "WriteStatistics",
    ExportStatistics = "ExportStatistics",
    EditImages = "EditImages",
    ManageConversionPresetTemplates = "ManageConversionPresetTemplates",
    ManageComments = "ManageComments",
    ManageAllComments = "ManageAllComments",
    ListUsers = "ListUsers",
}

export class PermissionSetNotFoundException extends PictureparkNotFoundException implements IPermissionSetNotFoundException {
    permissionSetIds?: string[] | undefined;

    constructor(data?: IPermissionSetNotFoundException) {
        super(data);
        this._discriminator = "PermissionSetNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["permissionSetIds"])) {
                this.permissionSetIds = [] as any;
                for (let item of _data["permissionSetIds"])
                    this.permissionSetIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): PermissionSetNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissionSetIds)) {
            data["permissionSetIds"] = [];
            for (let item of this.permissionSetIds)
                data["permissionSetIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionSetNotFoundException extends IPictureparkNotFoundException {
    permissionSetIds?: string[] | undefined;
}

export class PermissionSetAggregateException extends PictureparkValidationException implements IPermissionSetAggregateException {
    exceptions?: PictureparkException[] | undefined;

    constructor(data?: IPermissionSetAggregateException) {
        super(data);
        this._discriminator = "PermissionSetAggregateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(PictureparkException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PermissionSetAggregateException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetAggregateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionSetAggregateException extends IPictureparkValidationException {
    exceptions?: PictureparkException[] | undefined;
}

export class DuplicateRightException extends PictureparkValidationException implements IDuplicateRightException {
    permissionSetId?: string | undefined;

    constructor(data?: IDuplicateRightException) {
        super(data);
        this._discriminator = "DuplicateRightException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): DuplicateRightException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateRightException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateRightException extends IPictureparkValidationException {
    permissionSetId?: string | undefined;
}

export class PermissionValidationException extends PictureparkValidationException implements IPermissionValidationException {
    permission?: string | undefined;
    operation?: string | undefined;

    constructor(data?: IPermissionValidationException) {
        super(data);
        this._discriminator = "PermissionValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permission = _data["permission"];
            this.operation = _data["operation"];
        }
    }

    static override fromJS(data: any): PermissionValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["operation"] = this.operation;
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionValidationException extends IPictureparkValidationException {
    permission?: string | undefined;
    operation?: string | undefined;
}

export class PermissionSetInUseException extends PictureparkValidationException implements IPermissionSetInUseException {
    reference?: string | undefined;
    referenceCount?: number;

    constructor(data?: IPermissionSetInUseException) {
        super(data);
        this._discriminator = "PermissionSetInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.referenceCount = _data["referenceCount"];
        }
    }

    static override fromJS(data: any): PermissionSetInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["referenceCount"] = this.referenceCount;
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionSetInUseException extends IPictureparkValidationException {
    reference?: string | undefined;
    referenceCount?: number;
}

export class ContentPermissionException extends PictureparkValidationException implements IContentPermissionException {
    contentId?: string | undefined;
    contentRights?: ContentRight[] | undefined;

    constructor(data?: IContentPermissionException) {
        super(data);
        this._discriminator = "ContentPermissionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            if (Array.isArray(_data["contentRights"])) {
                this.contentRights = [] as any;
                for (let item of _data["contentRights"])
                    this.contentRights!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (Array.isArray(this.contentRights)) {
            data["contentRights"] = [];
            for (let item of this.contentRights)
                data["contentRights"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentPermissionException extends IPictureparkValidationException {
    contentId?: string | undefined;
    contentRights?: ContentRight[] | undefined;
}

/** Content rights */
export enum ContentRight {
    View = "View",
    AccessOriginal = "AccessOriginal",
    EditMetadata = "EditMetadata",
    EditContent = "EditContent",
    ManagePermissions = "ManagePermissions",
    Delete = "Delete",
    ManageHistoricVersions = "ManageHistoricVersions",
}

export class ListItemPermissionException extends PictureparkValidationException implements IListItemPermissionException {
    listItemId?: string | undefined;
    metadataRight?: MetadataRight;

    constructor(data?: IListItemPermissionException) {
        super(data);
        this._discriminator = "ListItemPermissionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.listItemId = _data["listItemId"];
            this.metadataRight = _data["metadataRight"];
        }
    }

    static override fromJS(data: any): ListItemPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemPermissionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemId"] = this.listItemId;
        data["metadataRight"] = this.metadataRight;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemPermissionException extends IPictureparkValidationException {
    listItemId?: string | undefined;
    metadataRight?: MetadataRight;
}

/** Metadata rights */
export enum MetadataRight {
    View = "View",
    ManageItems = "ManageItems",
    ManageSchema = "ManageSchema",
}

export class SchemaPermissionException extends PictureparkValidationException implements ISchemaPermissionException {
    schemaId?: string | undefined;
    metadataRight?: MetadataRight;

    constructor(data?: ISchemaPermissionException) {
        super(data);
        this._discriminator = "SchemaPermissionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.metadataRight = _data["metadataRight"];
        }
    }

    static override fromJS(data: any): SchemaPermissionException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["metadataRight"] = this.metadataRight;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaPermissionException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    metadataRight?: MetadataRight;
}

/** This exception is an abstract base for permission set validation. */
export class PermissionSetValidationException extends PictureparkValidationException implements IPermissionSetValidationException {
    permissionSetId?: string | undefined;

    constructor(data?: IPermissionSetValidationException) {
        super(data);
        this._discriminator = "PermissionSetValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): PermissionSetValidationException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "PermissionSetInvalidRightCombinationException") {
            let result = new PermissionSetInvalidRightCombinationException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AmbiguousUserRoleRightsException") {
            let result = new AmbiguousUserRoleRightsException();
            result.init(data);
            return result;
        }
        let result = new PermissionSetValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

/** This exception is an abstract base for permission set validation. */
export interface IPermissionSetValidationException extends IPictureparkValidationException {
    permissionSetId?: string | undefined;
}

export class PermissionSetInvalidRightCombinationException extends PermissionSetValidationException implements IPermissionSetInvalidRightCombinationException {

    constructor(data?: IPermissionSetInvalidRightCombinationException) {
        super(data);
        this._discriminator = "PermissionSetInvalidRightCombinationException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PermissionSetInvalidRightCombinationException {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetInvalidRightCombinationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionSetInvalidRightCombinationException extends IPermissionSetValidationException {
}

export class AmbiguousUserRoleRightsException extends PermissionSetValidationException implements IAmbiguousUserRoleRightsException {

    constructor(data?: IAmbiguousUserRoleRightsException) {
        super(data);
        this._discriminator = "AmbiguousUserRoleRightsException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AmbiguousUserRoleRightsException {
        data = typeof data === 'object' ? data : {};
        let result = new AmbiguousUserRoleRightsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAmbiguousUserRoleRightsException extends IPermissionSetValidationException {
}

export class UnsupportedListItemChangeCommandException extends PictureparkValidationException implements IUnsupportedListItemChangeCommandException {
    commandType?: string | undefined;

    constructor(data?: IUnsupportedListItemChangeCommandException) {
        super(data);
        this._discriminator = "UnsupportedListItemChangeCommandException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commandType = _data["commandType"];
        }
    }

    static override fromJS(data: any): UnsupportedListItemChangeCommandException {
        data = typeof data === 'object' ? data : {};
        let result = new UnsupportedListItemChangeCommandException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandType"] = this.commandType;
        super.toJSON(data);
        return data;
    }
}

export interface IUnsupportedListItemChangeCommandException extends IPictureparkValidationException {
    commandType?: string | undefined;
}

export class ListItemLayerException extends PictureparkValidationException implements IListItemLayerException {
    listItemId?: string | undefined;

    constructor(data?: IListItemLayerException) {
        super(data);
        this._discriminator = "ListItemLayerException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.listItemId = _data["listItemId"];
        }
    }

    static override fromJS(data: any): ListItemLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemLayerException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemId"] = this.listItemId;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemLayerException extends IPictureparkValidationException {
    listItemId?: string | undefined;
}

export class ListItemNotFoundException extends PictureparkNotFoundException implements IListItemNotFoundException {
    listItemIds?: string[] | undefined;

    constructor(data?: IListItemNotFoundException) {
        super(data);
        this._discriminator = "ListItemNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ListItemNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListItemNotFoundException extends IPictureparkNotFoundException {
    listItemIds?: string[] | undefined;
}

export class ListItemCyclicDependencyException extends PictureparkBusinessException implements IListItemCyclicDependencyException {
    listItemIds?: string[] | undefined;

    constructor(data?: IListItemCyclicDependencyException) {
        super(data);
        this._discriminator = "ListItemCyclicDependencyException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ListItemCyclicDependencyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCyclicDependencyException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListItemCyclicDependencyException extends IPictureparkBusinessException {
    listItemIds?: string[] | undefined;
}

export class DeleteListItemsWithReferencesException extends PictureparkValidationException implements IDeleteListItemsWithReferencesException {
    numberOfReferences?: number;

    constructor(data?: IDeleteListItemsWithReferencesException) {
        super(data);
        this._discriminator = "DeleteListItemsWithReferencesException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.numberOfReferences = _data["numberOfReferences"];
        }
    }

    static override fromJS(data: any): DeleteListItemsWithReferencesException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteListItemsWithReferencesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfReferences"] = this.numberOfReferences;
        super.toJSON(data);
        return data;
    }
}

export interface IDeleteListItemsWithReferencesException extends IPictureparkValidationException {
    numberOfReferences?: number;
}

export class ListItemUpdateManyException extends PictureparkBusinessException implements IListItemUpdateManyException {
    failedItemsCount?: number;
    totalItemsCount?: number;

    constructor(data?: IListItemUpdateManyException) {
        super(data);
        this._discriminator = "ListItemUpdateManyException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.failedItemsCount = _data["failedItemsCount"];
            this.totalItemsCount = _data["totalItemsCount"];
        }
    }

    static override fromJS(data: any): ListItemUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["failedItemsCount"] = this.failedItemsCount;
        data["totalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount?: number;
    totalItemsCount?: number;
}

export class ListItemSchemaMismatchException extends PictureparkValidationException implements IListItemSchemaMismatchException {
    listItemId?: string | undefined;
    listItemSchemaId?: string | undefined;
    fieldSchemaId?: string | undefined;

    constructor(data?: IListItemSchemaMismatchException) {
        super(data);
        this._discriminator = "ListItemSchemaMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.listItemId = _data["listItemId"];
            this.listItemSchemaId = _data["listItemSchemaId"];
            this.fieldSchemaId = _data["fieldSchemaId"];
        }
    }

    static override fromJS(data: any): ListItemSchemaMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSchemaMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listItemId"] = this.listItemId;
        data["listItemSchemaId"] = this.listItemSchemaId;
        data["fieldSchemaId"] = this.fieldSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemSchemaMismatchException extends IPictureparkValidationException {
    listItemId?: string | undefined;
    listItemSchemaId?: string | undefined;
    fieldSchemaId?: string | undefined;
}

export class ListItemResolveBehaviorNotSupportedException extends PictureparkValidationException implements IListItemResolveBehaviorNotSupportedException {
    behaviors?: ListItemResolveBehavior[] | undefined;

    constructor(data?: IListItemResolveBehaviorNotSupportedException) {
        super(data);
        this._discriminator = "ListItemResolveBehaviorNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["behaviors"])) {
                this.behaviors = [] as any;
                for (let item of _data["behaviors"])
                    this.behaviors!.push(item);
            }
        }
    }

    static override fromJS(data: any): ListItemResolveBehaviorNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemResolveBehaviorNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.behaviors)) {
            data["behaviors"] = [];
            for (let item of this.behaviors)
                data["behaviors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListItemResolveBehaviorNotSupportedException extends IPictureparkValidationException {
    behaviors?: ListItemResolveBehavior[] | undefined;
}

export enum ListItemResolveBehavior {
    Content = "Content",
    LinkedListItems = "LinkedListItems",
    InnerDisplayValueThumbnail = "InnerDisplayValueThumbnail",
    InnerDisplayValueList = "InnerDisplayValueList",
    InnerDisplayValueDetail = "InnerDisplayValueDetail",
    InnerDisplayValueName = "InnerDisplayValueName",
    OuterDisplayValueThumbnail = "OuterDisplayValueThumbnail",
    OuterDisplayValueList = "OuterDisplayValueList",
    OuterDisplayValueDetail = "OuterDisplayValueDetail",
    OuterDisplayValueName = "OuterDisplayValueName",
    DynamicViewFields = "DynamicViewFields",
    DynamicViewFieldsWithHasItems = "DynamicViewFieldsWithHasItems",
}

export class InvalidLogoFileExtensionException extends PictureparkValidationException implements IInvalidLogoFileExtensionException {
    fileExtension?: string | undefined;
    supportedExtensions?: string[] | undefined;

    constructor(data?: IInvalidLogoFileExtensionException) {
        super(data);
        this._discriminator = "InvalidLogoFileExtensionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileExtension = _data["fileExtension"];
            if (Array.isArray(_data["supportedExtensions"])) {
                this.supportedExtensions = [] as any;
                for (let item of _data["supportedExtensions"])
                    this.supportedExtensions!.push(item);
            }
        }
    }

    static override fromJS(data: any): InvalidLogoFileExtensionException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidLogoFileExtensionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileExtension"] = this.fileExtension;
        if (Array.isArray(this.supportedExtensions)) {
            data["supportedExtensions"] = [];
            for (let item of this.supportedExtensions)
                data["supportedExtensions"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidLogoFileExtensionException extends IPictureparkValidationException {
    fileExtension?: string | undefined;
    supportedExtensions?: string[] | undefined;
}

export class TransferInfoNotFoundException extends PictureparkNotFoundException implements ITransferInfoNotFoundException {
    transferInfoId?: string | undefined;

    constructor(data?: ITransferInfoNotFoundException) {
        super(data);
        this._discriminator = "TransferInfoNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferInfoId = _data["transferInfoId"];
        }
    }

    static override fromJS(data: any): TransferInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferInfoNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferInfoId"] = this.transferInfoId;
        super.toJSON(data);
        return data;
    }
}

export interface ITransferInfoNotFoundException extends IPictureparkNotFoundException {
    transferInfoId?: string | undefined;
}

export class FileTransferNotFoundException extends PictureparkNotFoundException implements IFileTransferNotFoundException {
    fileTransferId?: string | undefined;

    constructor(data?: IFileTransferNotFoundException) {
        super(data);
        this._discriminator = "FileTransferNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileTransferId = _data["fileTransferId"];
        }
    }

    static override fromJS(data: any): FileTransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        super.toJSON(data);
        return data;
    }
}

export interface IFileTransferNotFoundException extends IPictureparkNotFoundException {
    fileTransferId?: string | undefined;
}

export class InvalidTransferTypeException extends PictureparkBusinessException implements IInvalidTransferTypeException {
    transferType?: TransferType;

    constructor(data?: IInvalidTransferTypeException) {
        super(data);
        this._discriminator = "InvalidTransferTypeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferType = _data["transferType"];
        }
    }

    static override fromJS(data: any): InvalidTransferTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidTransferTypeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferType"] = this.transferType;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidTransferTypeException extends IPictureparkBusinessException {
    transferType?: TransferType;
}

/** Type of the transfer */
export enum TransferType {
    FileUpload = "FileUpload",
    FileUploadAutoImport = "FileUploadAutoImport",
    WebDownload = "WebDownload",
    SchemaImport = "SchemaImport",
}

export class TransferNotFoundException extends PictureparkNotFoundException implements ITransferNotFoundException {
    transferId?: string | undefined;

    constructor(data?: ITransferNotFoundException) {
        super(data);
        this._discriminator = "TransferNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferId = _data["transferId"];
        }
    }

    static override fromJS(data: any): TransferNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TransferNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        super.toJSON(data);
        return data;
    }
}

export interface ITransferNotFoundException extends IPictureparkNotFoundException {
    transferId?: string | undefined;
}

export class WrongChunkSizeException extends PictureparkValidationException implements IWrongChunkSizeException {
    actual?: number;
    expected?: number;

    constructor(data?: IWrongChunkSizeException) {
        super(data);
        this._discriminator = "WrongChunkSizeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.actual = _data["actual"];
            this.expected = _data["expected"];
        }
    }

    static override fromJS(data: any): WrongChunkSizeException {
        data = typeof data === 'object' ? data : {};
        let result = new WrongChunkSizeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actual"] = this.actual;
        data["expected"] = this.expected;
        super.toJSON(data);
        return data;
    }
}

export interface IWrongChunkSizeException extends IPictureparkValidationException {
    actual?: number;
    expected?: number;
}

export class ChunkSizeOutOfRangeException extends PictureparkValidationException implements IChunkSizeOutOfRangeException {
    actual?: number;
    minimum?: number;
    maximum?: number;

    constructor(data?: IChunkSizeOutOfRangeException) {
        super(data);
        this._discriminator = "ChunkSizeOutOfRangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.actual = _data["actual"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static override fromJS(data: any): ChunkSizeOutOfRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new ChunkSizeOutOfRangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actual"] = this.actual;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        super.toJSON(data);
        return data;
    }
}

export interface IChunkSizeOutOfRangeException extends IPictureparkValidationException {
    actual?: number;
    minimum?: number;
    maximum?: number;
}

export class MaximumTransferSizeException extends PictureparkException implements IMaximumTransferSizeException {
    transferSize?: number;
    maximumTransferSize?: number;
    transferId?: string | undefined;

    constructor(data?: IMaximumTransferSizeException) {
        super(data);
        this._discriminator = "MaximumTransferSizeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferSize = _data["transferSize"];
            this.maximumTransferSize = _data["maximumTransferSize"];
            this.transferId = _data["transferId"];
        }
    }

    static override fromJS(data: any): MaximumTransferSizeException {
        data = typeof data === 'object' ? data : {};
        let result = new MaximumTransferSizeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferSize"] = this.transferSize;
        data["maximumTransferSize"] = this.maximumTransferSize;
        data["transferId"] = this.transferId;
        super.toJSON(data);
        return data;
    }
}

export interface IMaximumTransferSizeException extends IPictureparkException {
    transferSize?: number;
    maximumTransferSize?: number;
    transferId?: string | undefined;
}

export class FileIdDuplicatedException extends PictureparkValidationException implements IFileIdDuplicatedException {
    fileId?: string | undefined;

    constructor(data?: IFileIdDuplicatedException) {
        super(data);
        this._discriminator = "FileIdDuplicatedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileId = _data["fileId"];
        }
    }

    static override fromJS(data: any): FileIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new FileIdDuplicatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        super.toJSON(data);
        return data;
    }
}

export interface IFileIdDuplicatedException extends IPictureparkValidationException {
    fileId?: string | undefined;
}

export class UploadFailedException extends PictureparkBusinessException implements IUploadFailedException {

    constructor(data?: IUploadFailedException) {
        super(data);
        this._discriminator = "UploadFailedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UploadFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFailedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUploadFailedException extends IPictureparkBusinessException {
}

export class MaximumNumberOfChunksExceededException extends PictureparkValidationException implements IMaximumNumberOfChunksExceededException {
    transferId?: string | undefined;
    numberOfChunks?: number;
    maximumNumberOfChunks?: number;

    constructor(data?: IMaximumNumberOfChunksExceededException) {
        super(data);
        this._discriminator = "MaximumNumberOfChunksExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferId = _data["transferId"];
            this.numberOfChunks = _data["numberOfChunks"];
            this.maximumNumberOfChunks = _data["maximumNumberOfChunks"];
        }
    }

    static override fromJS(data: any): MaximumNumberOfChunksExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new MaximumNumberOfChunksExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        data["numberOfChunks"] = this.numberOfChunks;
        data["maximumNumberOfChunks"] = this.maximumNumberOfChunks;
        super.toJSON(data);
        return data;
    }
}

export interface IMaximumNumberOfChunksExceededException extends IPictureparkValidationException {
    transferId?: string | undefined;
    numberOfChunks?: number;
    maximumNumberOfChunks?: number;
}

export class MaximumFileSizeExceededException extends PictureparkValidationException implements IMaximumFileSizeExceededException {
    transferId?: string | undefined;
    declaredFileSize?: number;
    maximumFileSize?: number;

    constructor(data?: IMaximumFileSizeExceededException) {
        super(data);
        this._discriminator = "MaximumFileSizeExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferId = _data["transferId"];
            this.declaredFileSize = _data["declaredFileSize"];
            this.maximumFileSize = _data["maximumFileSize"];
        }
    }

    static override fromJS(data: any): MaximumFileSizeExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new MaximumFileSizeExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        data["declaredFileSize"] = this.declaredFileSize;
        data["maximumFileSize"] = this.maximumFileSize;
        super.toJSON(data);
        return data;
    }
}

export interface IMaximumFileSizeExceededException extends IPictureparkValidationException {
    transferId?: string | undefined;
    declaredFileSize?: number;
    maximumFileSize?: number;
}

export class MissingDependenciesException extends PictureparkValidationException implements IMissingDependenciesException {
    itemIds?: string | undefined;

    constructor(data?: IMissingDependenciesException) {
        super(data);
        this._discriminator = "MissingDependenciesException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.itemIds = _data["itemIds"];
        }
    }

    static override fromJS(data: any): MissingDependenciesException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDependenciesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemIds"] = this.itemIds;
        super.toJSON(data);
        return data;
    }
}

export interface IMissingDependenciesException extends IPictureparkValidationException {
    itemIds?: string | undefined;
}

export class RelationSelfReferencingException extends PictureparkValidationException implements IRelationSelfReferencingException {
    itemId?: string | undefined;
    itemType?: string | undefined;

    constructor(data?: IRelationSelfReferencingException) {
        super(data);
        this._discriminator = "RelationSelfReferencingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.itemId = _data["itemId"];
            this.itemType = _data["itemType"];
        }
    }

    static override fromJS(data: any): RelationSelfReferencingException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationSelfReferencingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["itemType"] = this.itemType;
        super.toJSON(data);
        return data;
    }
}

export interface IRelationSelfReferencingException extends IPictureparkValidationException {
    itemId?: string | undefined;
    itemType?: string | undefined;
}

export class InvalidChangeCommandFieldTypeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandFieldTypeInvalidException {
    commandType?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldActualType?: string | undefined;
    fieldExpectedType?: string | undefined;

    constructor(data?: IInvalidChangeCommandFieldTypeInvalidException) {
        super(data);
        this._discriminator = "InvalidChangeCommandFieldTypeInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commandType = _data["commandType"];
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
            this.fieldActualType = _data["fieldActualType"];
            this.fieldExpectedType = _data["fieldExpectedType"];
        }
    }

    static override fromJS(data: any): InvalidChangeCommandFieldTypeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldTypeInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandType"] = this.commandType;
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        data["fieldActualType"] = this.fieldActualType;
        data["fieldExpectedType"] = this.fieldExpectedType;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidChangeCommandFieldTypeInvalidException extends IPictureparkValidationException {
    commandType?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldActualType?: string | undefined;
    fieldExpectedType?: string | undefined;
}

export class InvalidChangeCommandFieldNotFoundException extends PictureparkValidationException implements IInvalidChangeCommandFieldNotFoundException {
    commandTypeName?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IInvalidChangeCommandFieldNotFoundException) {
        super(data);
        this._discriminator = "InvalidChangeCommandFieldNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commandTypeName = _data["commandTypeName"];
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): InvalidChangeCommandFieldNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandFieldNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandTypeName"] = this.commandTypeName;
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidChangeCommandFieldNotFoundException extends IPictureparkValidationException {
    commandTypeName?: string | undefined;
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidChangeCommandSchemaChangeInvalidException extends PictureparkValidationException implements IInvalidChangeCommandSchemaChangeInvalidException {
    commandTypeName?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IInvalidChangeCommandSchemaChangeInvalidException) {
        super(data);
        this._discriminator = "InvalidChangeCommandSchemaChangeInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commandTypeName = _data["commandTypeName"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): InvalidChangeCommandSchemaChangeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidChangeCommandSchemaChangeInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandTypeName"] = this.commandTypeName;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidChangeCommandSchemaChangeInvalidException extends IPictureparkValidationException {
    commandTypeName?: string | undefined;
    schemaId?: string | undefined;
}

export class InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException extends PictureparkValidationException implements IInvalidContentSchemaForMetadataValuesSchemaRemoveCommandException {
    schemaId?: string | undefined;

    constructor(data?: IInvalidContentSchemaForMetadataValuesSchemaRemoveCommandException) {
        super(data);
        this._discriminator = "InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidContentSchemaForMetadataValuesSchemaRemoveCommandException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidContentSchemaForMetadataValuesSchemaRemoveCommandException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class InvalidMetadataException extends PictureparkValidationException implements IInvalidMetadataException {
    metadataErrors?: MetadataError[] | undefined;
    validationErrors?: PictureparkBusinessException[] | undefined;

    constructor(data?: IInvalidMetadataException) {
        super(data);
        if (data) {
            if (data.metadataErrors) {
                this.metadataErrors = [];
                for (let i = 0; i < data.metadataErrors.length; i++) {
                    let item = data.metadataErrors[i];
                    this.metadataErrors[i] = item && !(<any>item).toJSON ? new MetadataError(item) : <MetadataError>item;
                }
            }
        }
        this._discriminator = "InvalidMetadataException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["metadataErrors"])) {
                this.metadataErrors = [] as any;
                for (let item of _data["metadataErrors"])
                    this.metadataErrors!.push(MetadataError.fromJS(item));
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InvalidMetadataException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidMetadataException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.metadataErrors)) {
            data["metadataErrors"] = [];
            for (let item of this.metadataErrors)
                data["metadataErrors"].push(item.toJSON());
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidMetadataException extends IPictureparkValidationException {
    metadataErrors?: IMetadataError[] | undefined;
    validationErrors?: PictureparkBusinessException[] | undefined;
}

export class MetadataError implements IMetadataError {
    errorType?: string | undefined;
    lineNumber!: number;
    linePosition!: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: IMetadataError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorType = _data["errorType"];
            this.lineNumber = _data["lineNumber"];
            this.linePosition = _data["linePosition"];
            this.path = _data["path"];
            this.message = _data["message"];
            this.schemaId = _data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataError {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorType"] = this.errorType;
        data["lineNumber"] = this.lineNumber;
        data["linePosition"] = this.linePosition;
        data["path"] = this.path;
        data["message"] = this.message;
        data["schemaId"] = this.schemaId;
        return data;
    }
}

export interface IMetadataError {
    errorType?: string | undefined;
    lineNumber: number;
    linePosition: number;
    path?: string | undefined;
    message?: string | undefined;
    schemaId?: string | undefined;
}

export class RelationNotFoundException extends PictureparkBusinessException implements IRelationNotFoundException {
    relationId?: string | undefined;

    constructor(data?: IRelationNotFoundException) {
        super(data);
        this._discriminator = "RelationNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.relationId = _data["relationId"];
        }
    }

    static override fromJS(data: any): RelationNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationId"] = this.relationId;
        super.toJSON(data);
        return data;
    }
}

export interface IRelationNotFoundException extends IPictureparkBusinessException {
    relationId?: string | undefined;
}

export class RelationTypeNotFoundException extends PictureparkBusinessException implements IRelationTypeNotFoundException {
    relationType?: string | undefined;

    constructor(data?: IRelationTypeNotFoundException) {
        super(data);
        this._discriminator = "RelationTypeNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.relationType = _data["relationType"];
        }
    }

    static override fromJS(data: any): RelationTypeNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationType"] = this.relationType;
        super.toJSON(data);
        return data;
    }
}

export interface IRelationTypeNotFoundException extends IPictureparkBusinessException {
    relationType?: string | undefined;
}

export class RelationTypeTargetDocTypeMismatchException extends PictureparkBusinessException implements IRelationTypeTargetDocTypeMismatchException {
    relationType?: string | undefined;
    targetDocType?: string | undefined;
    expectedTargetDocType?: string | undefined;

    constructor(data?: IRelationTypeTargetDocTypeMismatchException) {
        super(data);
        this._discriminator = "RelationTypeTargetDocTypeMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.relationType = _data["relationType"];
            this.targetDocType = _data["targetDocType"];
            this.expectedTargetDocType = _data["expectedTargetDocType"];
        }
    }

    static override fromJS(data: any): RelationTypeTargetDocTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeTargetDocTypeMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationType"] = this.relationType;
        data["targetDocType"] = this.targetDocType;
        data["expectedTargetDocType"] = this.expectedTargetDocType;
        super.toJSON(data);
        return data;
    }
}

export interface IRelationTypeTargetDocTypeMismatchException extends IPictureparkBusinessException {
    relationType?: string | undefined;
    targetDocType?: string | undefined;
    expectedTargetDocType?: string | undefined;
}

export class RelationTypeMissingException extends PictureparkBusinessException implements IRelationTypeMissingException {

    constructor(data?: IRelationTypeMissingException) {
        super(data);
        this._discriminator = "RelationTypeMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RelationTypeMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new RelationTypeMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRelationTypeMissingException extends IPictureparkBusinessException {
}

export class ReferencesUpdateException extends PictureparkBusinessException implements IReferencesUpdateException {
    exceptions?: ReferenceUpdateException[] | undefined;

    constructor(data?: IReferencesUpdateException) {
        super(data);
        this._discriminator = "ReferencesUpdateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(ReferenceUpdateException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ReferencesUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ReferencesUpdateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IReferencesUpdateException extends IPictureparkBusinessException {
    exceptions?: ReferenceUpdateException[] | undefined;
}

export class ReferenceUpdateException extends PictureparkBusinessException implements IReferenceUpdateException {
    /** This is the source of the reference. */
    referenceItemId?: string | undefined;
    /** This is the DocType of the source of the reference. */
    referenceType?: string | undefined;
    /** These exceptions describe why the source metadata item could not be updated. */
    exceptions?: PictureparkException[] | undefined;

    constructor(data?: IReferenceUpdateException) {
        super(data);
        this._discriminator = "ReferenceUpdateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.referenceItemId = _data["referenceItemId"];
            this.referenceType = _data["referenceType"];
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(PictureparkException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ReferenceUpdateException {
        data = typeof data === 'object' ? data : {};
        let result = new ReferenceUpdateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referenceItemId"] = this.referenceItemId;
        data["referenceType"] = this.referenceType;
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IReferenceUpdateException extends IPictureparkBusinessException {
    /** This is the source of the reference. */
    referenceItemId?: string | undefined;
    /** This is the DocType of the source of the reference. */
    referenceType?: string | undefined;
    /** These exceptions describe why the source metadata item could not be updated. */
    exceptions?: PictureparkException[] | undefined;
}

export class DuplicatedItemAssignedException extends PictureparkValidationException implements IDuplicatedItemAssignedException {
    itemId?: string | undefined;
    itemPath?: string | undefined;

    constructor(data?: IDuplicatedItemAssignedException) {
        super(data);
        this._discriminator = "DuplicatedItemAssignedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.itemId = _data["itemId"];
            this.itemPath = _data["itemPath"];
        }
    }

    static override fromJS(data: any): DuplicatedItemAssignedException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatedItemAssignedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["itemPath"] = this.itemPath;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicatedItemAssignedException extends IPictureparkValidationException {
    itemId?: string | undefined;
    itemPath?: string | undefined;
}

export class InvalidDataTypeException extends PictureparkValidationException implements IInvalidDataTypeException {
    value?: any | undefined;

    constructor(data?: IInvalidDataTypeException) {
        super(data);
        this._discriminator = "InvalidDataTypeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): InvalidDataTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidDataTypeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IInvalidDataTypeException extends IPictureparkValidationException {
    value?: any | undefined;
}

export class LayerAssignmentInvalidException extends PictureparkValidationException implements ILayerAssignmentInvalidException {
    layerId?: string | undefined;
    value?: any | undefined;

    constructor(data?: ILayerAssignmentInvalidException) {
        super(data);
        this._discriminator = "LayerAssignmentInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): LayerAssignmentInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new LayerAssignmentInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ILayerAssignmentInvalidException extends IPictureparkValidationException {
    layerId?: string | undefined;
    value?: any | undefined;
}

export class OutdatedMetadataUpdateInProgressException extends PictureparkValidationException implements IOutdatedMetadataUpdateInProgressException {

    constructor(data?: IOutdatedMetadataUpdateInProgressException) {
        super(data);
        this._discriminator = "OutdatedMetadataUpdateInProgressException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutdatedMetadataUpdateInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OutdatedMetadataUpdateInProgressException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutdatedMetadataUpdateInProgressException extends IPictureparkValidationException {
}

export class SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException extends PictureparkValidationException implements ISortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException {
    aggregationName?: string | undefined;

    constructor(data?: ISortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException) {
        super(data);
        this._discriminator = "SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
        }
    }

    static override fromJS(data: any): SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException {
        data = typeof data === 'object' ? data : {};
        let result = new SortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        super.toJSON(data);
        return data;
    }
}

export interface ISortingSupportedOnlyOnTermsAndTermsRelationAggregatorsException extends IPictureparkValidationException {
    aggregationName?: string | undefined;
}

export class SchemasMetadataProtectionException extends PictureparkValidationException implements ISchemasMetadataProtectionException {
    schemaIds?: string[] | undefined;
    operation?: string | undefined;

    constructor(data?: ISchemasMetadataProtectionException) {
        super(data);
        this._discriminator = "SchemasMetadataProtectionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            this.operation = _data["operation"];
        }
    }

    static override fromJS(data: any): SchemasMetadataProtectionException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemasMetadataProtectionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["operation"] = this.operation;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemasMetadataProtectionException extends IPictureparkValidationException {
    schemaIds?: string[] | undefined;
    operation?: string | undefined;
}

export class FilterTemplateRenderingException extends PictureparkValidationException implements IFilterTemplateRenderingException {

    constructor(data?: IFilterTemplateRenderingException) {
        super(data);
        this._discriminator = "FilterTemplateRenderingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FilterTemplateRenderingException {
        data = typeof data === 'object' ? data : {};
        let result = new FilterTemplateRenderingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFilterTemplateRenderingException extends IPictureparkValidationException {
}

export class ResolvedLinkedItemsThresholdReachedException extends PictureparkValidationException implements IResolvedLinkedItemsThresholdReachedException {
    metadataItemId?: string | undefined;

    constructor(data?: IResolvedLinkedItemsThresholdReachedException) {
        super(data);
        this._discriminator = "ResolvedLinkedItemsThresholdReachedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.metadataItemId = _data["metadataItemId"];
        }
    }

    static override fromJS(data: any): ResolvedLinkedItemsThresholdReachedException {
        data = typeof data === 'object' ? data : {};
        let result = new ResolvedLinkedItemsThresholdReachedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metadataItemId"] = this.metadataItemId;
        super.toJSON(data);
        return data;
    }
}

export interface IResolvedLinkedItemsThresholdReachedException extends IPictureparkValidationException {
    metadataItemId?: string | undefined;
}

export class SchemaFieldOverwriteTypeMismatchException extends PictureparkValidationException implements ISchemaFieldOverwriteTypeMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    fieldOverwriteType?: string | undefined;
    fieldType?: string | undefined;

    constructor(data?: ISchemaFieldOverwriteTypeMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldOverwriteTypeMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.fieldOverwriteType = _data["fieldOverwriteType"];
            this.fieldType = _data["fieldType"];
        }
    }

    static override fromJS(data: any): SchemaFieldOverwriteTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteTypeMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["fieldOverwriteType"] = this.fieldOverwriteType;
        data["fieldType"] = this.fieldType;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldOverwriteTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    fieldOverwriteType?: string | undefined;
    fieldType?: string | undefined;
}

export class SchemaFieldOverwriteIdException extends PictureparkValidationException implements ISchemaFieldOverwriteIdException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldOverwriteIdException) {
        super(data);
        this._discriminator = "SchemaFieldOverwriteIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldOverwriteIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldOverwriteIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldOverwriteIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdDuplicatedException extends PictureparkValidationException implements ISchemaFieldIdDuplicatedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdDuplicatedException) {
        super(data);
        this._discriminator = "SchemaFieldIdDuplicatedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldIdDuplicatedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdDuplicatedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldIdDuplicatedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdPreviouslyUsedException extends PictureparkValidationException implements ISchemaFieldIdPreviouslyUsedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    usedInSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldIdPreviouslyUsedException) {
        super(data);
        this._discriminator = "SchemaFieldIdPreviouslyUsedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.usedInSchemaId = _data["usedInSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldIdPreviouslyUsedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdPreviouslyUsedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["usedInSchemaId"] = this.usedInSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldIdPreviouslyUsedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    usedInSchemaId?: string | undefined;
}

export class SchemaFieldIdAlreadyExistsInSchemaHierarchyException extends PictureparkValidationException implements ISchemaFieldIdAlreadyExistsInSchemaHierarchyException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    existingInSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldIdAlreadyExistsInSchemaHierarchyException) {
        super(data);
        this._discriminator = "SchemaFieldIdAlreadyExistsInSchemaHierarchyException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.existingInSchemaId = _data["existingInSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldIdAlreadyExistsInSchemaHierarchyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdAlreadyExistsInSchemaHierarchyException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["existingInSchemaId"] = this.existingInSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldIdAlreadyExistsInSchemaHierarchyException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    existingInSchemaId?: string | undefined;
}

export class SchemaFieldSchemaIndexInfoSimpleSearchNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoSimpleSearchNestingException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;

    constructor(data?: ISchemaFieldSchemaIndexInfoSimpleSearchNestingException) {
        super(data);
        this._discriminator = "SchemaFieldSchemaIndexInfoSimpleSearchNestingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.relatedFieldId = _data["relatedFieldId"];
            this.relatedOuterFieldId = _data["relatedOuterFieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldSchemaIndexInfoSimpleSearchNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoSimpleSearchNestingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relatedFieldId"] = this.relatedFieldId;
        data["relatedOuterFieldId"] = this.relatedOuterFieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldSchemaIndexInfoSimpleSearchNestingException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export class SchemaFieldSchemaIndexInfoNestingException extends PictureparkValidationException implements ISchemaFieldSchemaIndexInfoNestingException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;

    constructor(data?: ISchemaFieldSchemaIndexInfoNestingException) {
        super(data);
        this._discriminator = "SchemaFieldSchemaIndexInfoNestingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.relatedFieldId = _data["relatedFieldId"];
            this.relatedOuterFieldId = _data["relatedOuterFieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldSchemaIndexInfoNestingException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSchemaIndexInfoNestingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relatedFieldId"] = this.relatedFieldId;
        data["relatedOuterFieldId"] = this.relatedOuterFieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldSchemaIndexInfoNestingException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
    relatedOuterFieldId?: string | undefined;
}

export class SchemaFieldIdUppercaseException extends PictureparkValidationException implements ISchemaFieldIdUppercaseException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdUppercaseException) {
        super(data);
        this._discriminator = "SchemaFieldIdUppercaseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldIdUppercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdUppercaseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldIdUppercaseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaIdLowercaseException extends PictureparkValidationException implements ISchemaIdLowercaseException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaIdLowercaseException) {
        super(data);
        this._discriminator = "SchemaIdLowercaseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaIdLowercaseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdLowercaseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaIdLowercaseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInfoNotFoundException extends PictureparkNotFoundException implements ISchemaInfoNotFoundException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInfoNotFoundException) {
        super(data);
        this._discriminator = "SchemaInfoNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaInfoNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInfoNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInfoNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string | undefined;
}

export class IndexedFieldThresholdExceededException extends PictureparkValidationException implements IIndexedFieldThresholdExceededException {
    schemaIds?: string[] | undefined;
    indexedFieldCount?: number;
    indexedFieldThreshold?: number;

    constructor(data?: IIndexedFieldThresholdExceededException) {
        super(data);
        this._discriminator = "IndexedFieldThresholdExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            this.indexedFieldCount = _data["indexedFieldCount"];
            this.indexedFieldThreshold = _data["indexedFieldThreshold"];
        }
    }

    static override fromJS(data: any): IndexedFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexedFieldThresholdExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["indexedFieldCount"] = this.indexedFieldCount;
        data["indexedFieldThreshold"] = this.indexedFieldThreshold;
        super.toJSON(data);
        return data;
    }
}

export interface IIndexedFieldThresholdExceededException extends IPictureparkValidationException {
    schemaIds?: string[] | undefined;
    indexedFieldCount?: number;
    indexedFieldThreshold?: number;
}

export class SortableFieldThresholdExceededException extends PictureparkValidationException implements ISortableFieldThresholdExceededException {
    schemaIds?: string[] | undefined;
    sortableFieldCount?: number;
    sortableFieldThreshold?: number;

    constructor(data?: ISortableFieldThresholdExceededException) {
        super(data);
        this._discriminator = "SortableFieldThresholdExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            this.sortableFieldCount = _data["sortableFieldCount"];
            this.sortableFieldThreshold = _data["sortableFieldThreshold"];
        }
    }

    static override fromJS(data: any): SortableFieldThresholdExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new SortableFieldThresholdExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["sortableFieldCount"] = this.sortableFieldCount;
        data["sortableFieldThreshold"] = this.sortableFieldThreshold;
        super.toJSON(data);
        return data;
    }
}

export interface ISortableFieldThresholdExceededException extends IPictureparkValidationException {
    schemaIds?: string[] | undefined;
    sortableFieldCount?: number;
    sortableFieldThreshold?: number;
}

export class DuplicateSchemaInfoException extends PictureparkBusinessException implements IDuplicateSchemaInfoException {
    schemaId?: string | undefined;

    constructor(data?: IDuplicateSchemaInfoException) {
        super(data);
        this._discriminator = "DuplicateSchemaInfoException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): DuplicateSchemaInfoException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaInfoException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateSchemaInfoException extends IPictureparkBusinessException {
    schemaId?: string | undefined;
}

export class SchemaFieldNumberRangeException extends PictureparkValidationException implements ISchemaFieldNumberRangeException {
    fieldId?: string | undefined;
    propertyName?: string | undefined;
    minValue?: number;
    maxValue?: number;

    constructor(data?: ISchemaFieldNumberRangeException) {
        super(data);
        this._discriminator = "SchemaFieldNumberRangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.propertyName = _data["propertyName"];
            this.minValue = _data["minValue"];
            this.maxValue = _data["maxValue"];
        }
    }

    static override fromJS(data: any): SchemaFieldNumberRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNumberRangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["propertyName"] = this.propertyName;
        data["minValue"] = this.minValue;
        data["maxValue"] = this.maxValue;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNumberRangeException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    propertyName?: string | undefined;
    minValue?: number;
    maxValue?: number;
}

export class SchemaInUseContentSchemaException extends PictureparkValidationException implements ISchemaInUseContentSchemaException {
    schemaId?: string | undefined;
    contentSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaInUseContentSchemaException) {
        super(data);
        this._discriminator = "SchemaInUseContentSchemaException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["contentSchemaIds"])) {
                this.contentSchemaIds = [] as any;
                for (let item of _data["contentSchemaIds"])
                    this.contentSchemaIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaInUseContentSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentSchemaException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.contentSchemaIds)) {
            data["contentSchemaIds"] = [];
            for (let item of this.contentSchemaIds)
                data["contentSchemaIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInUseContentSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    contentSchemaIds?: string[] | undefined;
}

export class LayerAssignmentInUseWithContentsException extends PictureparkValidationException implements ILayerAssignmentInUseWithContentsException {
    schemaId?: string | undefined;
    usedAssignmentSchemaIds?: string[] | undefined;

    constructor(data?: ILayerAssignmentInUseWithContentsException) {
        super(data);
        this._discriminator = "LayerAssignmentInUseWithContentsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["usedAssignmentSchemaIds"])) {
                this.usedAssignmentSchemaIds = [] as any;
                for (let item of _data["usedAssignmentSchemaIds"])
                    this.usedAssignmentSchemaIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): LayerAssignmentInUseWithContentsException {
        data = typeof data === 'object' ? data : {};
        let result = new LayerAssignmentInUseWithContentsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.usedAssignmentSchemaIds)) {
            data["usedAssignmentSchemaIds"] = [];
            for (let item of this.usedAssignmentSchemaIds)
                data["usedAssignmentSchemaIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILayerAssignmentInUseWithContentsException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    usedAssignmentSchemaIds?: string[] | undefined;
}

export class SchemaInUseListItemException extends PictureparkValidationException implements ISchemaInUseListItemException {
    schemaId?: string | undefined;
    listItemCount?: number;

    constructor(data?: ISchemaInUseListItemException) {
        super(data);
        this._discriminator = "SchemaInUseListItemException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.listItemCount = _data["listItemCount"];
        }
    }

    static override fromJS(data: any): SchemaInUseListItemException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseListItemException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["listItemCount"] = this.listItemCount;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInUseListItemException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    listItemCount?: number;
}

export class SchemaInUseContentException extends PictureparkValidationException implements ISchemaInUseContentException {
    schemaId?: string | undefined;
    contentCount?: number;

    constructor(data?: ISchemaInUseContentException) {
        super(data);
        this._discriminator = "SchemaInUseContentException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.contentCount = _data["contentCount"];
        }
    }

    static override fromJS(data: any): SchemaInUseContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseContentException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["contentCount"] = this.contentCount;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInUseContentException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    contentCount?: number;
}

export class SchemaInUseFieldException extends PictureparkValidationException implements ISchemaInUseFieldException {
    schemaId?: string | undefined;
    fieldNamespaces?: string[] | undefined;

    constructor(data?: ISchemaInUseFieldException) {
        super(data);
        this._discriminator = "SchemaInUseFieldException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["fieldNamespaces"])) {
                this.fieldNamespaces = [] as any;
                for (let item of _data["fieldNamespaces"])
                    this.fieldNamespaces!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaInUseFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseFieldException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.fieldNamespaces)) {
            data["fieldNamespaces"] = [];
            for (let item of this.fieldNamespaces)
                data["fieldNamespaces"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInUseFieldException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldNamespaces?: string[] | undefined;
}

export class DuplicateMetadataDisplayPatternException extends PictureparkValidationException implements IDuplicateMetadataDisplayPatternException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;

    constructor(data?: IDuplicateMetadataDisplayPatternException) {
        super(data);
        this._discriminator = "DuplicateMetadataDisplayPatternException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.displayPatternId = _data["displayPatternId"];
        }
    }

    static override fromJS(data: any): DuplicateMetadataDisplayPatternException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateMetadataDisplayPatternException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["displayPatternId"] = this.displayPatternId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateMetadataDisplayPatternException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;
}

export class DuplicateSchemaException extends PictureparkValidationException implements IDuplicateSchemaException {
    schemaId?: string | undefined;

    constructor(data?: IDuplicateSchemaException) {
        super(data);
        this._discriminator = "DuplicateSchemaException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): DuplicateSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateSchemaException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaImportEmptyException extends PictureparkValidationException implements ISchemaImportEmptyException {

    constructor(data?: ISchemaImportEmptyException) {
        super(data);
        this._discriminator = "SchemaImportEmptyException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaImportEmptyException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportEmptyException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaImportEmptyException extends IPictureparkValidationException {
}

export class SchemaImportVersionMismatchException extends PictureparkValidationException implements ISchemaImportVersionMismatchException {
    providedVersion?: string | undefined;
    expectedVersion?: string | undefined;

    constructor(data?: ISchemaImportVersionMismatchException) {
        super(data);
        this._discriminator = "SchemaImportVersionMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.providedVersion = _data["providedVersion"];
            this.expectedVersion = _data["expectedVersion"];
        }
    }

    static override fromJS(data: any): SchemaImportVersionMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportVersionMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providedVersion"] = this.providedVersion;
        data["expectedVersion"] = this.expectedVersion;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaImportVersionMismatchException extends IPictureparkValidationException {
    providedVersion?: string | undefined;
    expectedVersion?: string | undefined;
}

export class SchemaInheritanceFieldIndexDeviationException extends PictureparkValidationException implements ISchemaInheritanceFieldIndexDeviationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInheritanceFieldIndexDeviationException) {
        super(data);
        this._discriminator = "SchemaInheritanceFieldIndexDeviationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaInheritanceFieldIndexDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceFieldIndexDeviationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInheritanceFieldIndexDeviationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInheritanceTypeDeviationException extends PictureparkValidationException implements ISchemaInheritanceTypeDeviationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaInheritanceTypeDeviationException) {
        super(data);
        this._discriminator = "SchemaInheritanceTypeDeviationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaInheritanceTypeDeviationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInheritanceTypeDeviationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInheritanceTypeDeviationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaValidationException extends PictureparkValidationException implements ISchemaValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaValidationException) {
        super(data);
        this._discriminator = "SchemaValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SchemaValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaValidationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class SchemaSortFieldException extends PictureparkValidationException implements ISchemaSortFieldException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaSortFieldException) {
        super(data);
        this._discriminator = "SchemaSortFieldException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaSortFieldException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSortFieldException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaSortFieldException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldIdException extends PictureparkValidationException implements ISchemaFieldIdException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldIdException) {
        super(data);
        this._discriminator = "SchemaFieldIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldTypeChangeException extends PictureparkValidationException implements ISchemaFieldTypeChangeException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldTypeName?: string | undefined;
    newTypeName?: string | undefined;

    constructor(data?: ISchemaFieldTypeChangeException) {
        super(data);
        this._discriminator = "SchemaFieldTypeChangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.oldTypeName = _data["oldTypeName"];
            this.newTypeName = _data["newTypeName"];
        }
    }

    static override fromJS(data: any): SchemaFieldTypeChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldTypeChangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["oldTypeName"] = this.oldTypeName;
        data["newTypeName"] = this.newTypeName;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldTypeChangeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldTypeName?: string | undefined;
    newTypeName?: string | undefined;
}

export class SchemaFieldNotFilterableException extends PictureparkValidationException implements ISchemaFieldNotFilterableException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldNotFilterableException) {
        super(data);
        this._discriminator = "SchemaFieldNotFilterableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldNotFilterableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotFilterableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNotFilterableException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldNotSortableException extends PictureparkValidationException implements ISchemaFieldNotSortableException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldNotSortableException) {
        super(data);
        this._discriminator = "SchemaFieldNotSortableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldNotSortableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSortableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNotSortableException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class SchemaFieldNotSearchableException extends PictureparkValidationException implements ISchemaFieldNotSearchableException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldNotSearchableException) {
        super(data);
        this._discriminator = "SchemaFieldNotSearchableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldNotSearchableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSearchableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNotSearchableException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class SchemaFieldInvalidBoostException extends PictureparkValidationException implements ISchemaFieldInvalidBoostException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    boost?: number;
    allowedBoostValues?: number[] | undefined;

    constructor(data?: ISchemaFieldInvalidBoostException) {
        super(data);
        this._discriminator = "SchemaFieldInvalidBoostException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
            this.boost = _data["boost"];
            if (Array.isArray(_data["allowedBoostValues"])) {
                this.allowedBoostValues = [] as any;
                for (let item of _data["allowedBoostValues"])
                    this.allowedBoostValues!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaFieldInvalidBoostException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldInvalidBoostException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        data["boost"] = this.boost;
        if (Array.isArray(this.allowedBoostValues)) {
            data["allowedBoostValues"] = [];
            for (let item of this.allowedBoostValues)
                data["allowedBoostValues"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldInvalidBoostException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    boost?: number;
    allowedBoostValues?: number[] | undefined;
}

export class SchemaFieldSortableInUseException extends PictureparkValidationException implements ISchemaFieldSortableInUseException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    channelIds?: string[] | undefined;

    constructor(data?: ISchemaFieldSortableInUseException) {
        super(data);
        this._discriminator = "SchemaFieldSortableInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["channelIds"])) {
                this.channelIds = [] as any;
                for (let item of _data["channelIds"])
                    this.channelIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaFieldSortableInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldSortableInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.channelIds)) {
            data["channelIds"] = [];
            for (let item of this.channelIds)
                data["channelIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldSortableInUseException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    channelIds?: string[] | undefined;
}

export class SchemaNoContentException extends PictureparkValidationException implements ISchemaNoContentException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNoContentException) {
        super(data);
        this._discriminator = "SchemaNoContentException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaNoContentException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoContentException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaNoContentException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaParentChangeException extends PictureparkValidationException implements ISchemaParentChangeException {
    schemaId?: string | undefined;
    oldSchemaParentId?: string | undefined;
    newSchemaParentId?: string | undefined;

    constructor(data?: ISchemaParentChangeException) {
        super(data);
        this._discriminator = "SchemaParentChangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.oldSchemaParentId = _data["oldSchemaParentId"];
            this.newSchemaParentId = _data["newSchemaParentId"];
        }
    }

    static override fromJS(data: any): SchemaParentChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaParentChangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["oldSchemaParentId"] = this.oldSchemaParentId;
        data["newSchemaParentId"] = this.newSchemaParentId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaParentChangeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    oldSchemaParentId?: string | undefined;
    newSchemaParentId?: string | undefined;
}

export class SchemaMissingTypeException extends PictureparkValidationException implements ISchemaMissingTypeException {
    schemaId?: string | undefined;
    expectedSchemaTypes?: SchemaType[] | undefined;

    constructor(data?: ISchemaMissingTypeException) {
        super(data);
        this._discriminator = "SchemaMissingTypeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["expectedSchemaTypes"])) {
                this.expectedSchemaTypes = [] as any;
                for (let item of _data["expectedSchemaTypes"])
                    this.expectedSchemaTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaMissingTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMissingTypeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.expectedSchemaTypes)) {
            data["expectedSchemaTypes"] = [];
            for (let item of this.expectedSchemaTypes)
                data["expectedSchemaTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaMissingTypeException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    expectedSchemaTypes?: SchemaType[] | undefined;
}

/** Type of the schema */
export enum SchemaType {
    Content = "Content",
    Layer = "Layer",
    List = "List",
    Struct = "Struct",
}

export class SchemaPermissionConfigurationException extends PictureparkValidationException implements ISchemaPermissionConfigurationException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaPermissionConfigurationException) {
        super(data);
        this._discriminator = "SchemaPermissionConfigurationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaPermissionConfigurationException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionConfigurationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaPermissionConfigurationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaMetadataProtectionSettingsNotSupportedForStructsException extends PictureparkValidationException implements ISchemaMetadataProtectionSettingsNotSupportedForStructsException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaMetadataProtectionSettingsNotSupportedForStructsException) {
        super(data);
        this._discriminator = "SchemaMetadataProtectionSettingsNotSupportedForStructsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaMetadataProtectionSettingsNotSupportedForStructsException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMetadataProtectionSettingsNotSupportedForStructsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaMetadataProtectionSettingsNotSupportedForStructsException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException extends PictureparkValidationException implements ISchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException) {
        super(data);
        this._discriminator = "SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaMetadataProtectionSettingsChangeNotAllowedForXmpMappedLayersException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaNoLayerException extends PictureparkValidationException implements ISchemaNoLayerException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNoLayerException) {
        super(data);
        this._discriminator = "SchemaNoLayerException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaNoLayerException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNoLayerException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaNoLayerException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaIdException extends PictureparkValidationException implements ISchemaIdException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaIdException) {
        super(data);
        this._discriminator = "SchemaIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaIdException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaIdException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaInUseException extends PictureparkValidationException implements ISchemaInUseException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;

    constructor(data?: ISchemaInUseException) {
        super(data);
        this._discriminator = "SchemaInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(PictureparkBusinessException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SchemaInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaInUseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    exceptions?: PictureparkBusinessException[] | undefined;
}

export class SchemaNotFoundException extends PictureparkNotFoundException implements ISchemaNotFoundException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaNotFoundException) {
        super(data);
        this._discriminator = "SchemaNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaNotFoundException extends IPictureparkNotFoundException {
    schemaId?: string | undefined;
}

export class SchemaCountLimitReachedException extends PictureparkBusinessException implements ISchemaCountLimitReachedException {

    constructor(data?: ISchemaCountLimitReachedException) {
        super(data);
        this._discriminator = "SchemaCountLimitReachedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaCountLimitReachedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCountLimitReachedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaCountLimitReachedException extends IPictureparkBusinessException {
}

export class SystemSchemaInvalidModificationException extends PictureparkValidationException implements ISystemSchemaInvalidModificationException {
    schemaId?: string | undefined;

    constructor(data?: ISystemSchemaInvalidModificationException) {
        super(data);
        this._discriminator = "SystemSchemaInvalidModificationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SystemSchemaInvalidModificationException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSchemaInvalidModificationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISystemSchemaInvalidModificationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaFieldRelationSchemaSystemSchemaException extends PictureparkValidationException implements ISchemaFieldRelationSchemaSystemSchemaException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldRelationSchemaSystemSchemaException) {
        super(data);
        this._discriminator = "SchemaFieldRelationSchemaSystemSchemaException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.relationSchemaId = _data["relationSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldRelationSchemaSystemSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaSystemSchemaException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relationSchemaId"] = this.relationSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldRelationSchemaSystemSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export class SchemaFieldRelationSchemaTypeUnsupportedException extends PictureparkValidationException implements ISchemaFieldRelationSchemaTypeUnsupportedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldRelationSchemaTypeUnsupportedException) {
        super(data);
        this._discriminator = "SchemaFieldRelationSchemaTypeUnsupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.relationSchemaId = _data["relationSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldRelationSchemaTypeUnsupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationSchemaTypeUnsupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relationSchemaId"] = this.relationSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldRelationSchemaTypeUnsupportedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relationSchemaId?: string | undefined;
}

export class SchemaMultipleTypesException extends PictureparkValidationException implements ISchemaMultipleTypesException {
    schemaId?: string | undefined;
    schemaTypes?: string[] | undefined;

    constructor(data?: ISchemaMultipleTypesException) {
        super(data);
        this._discriminator = "SchemaMultipleTypesException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["schemaTypes"])) {
                this.schemaTypes = [] as any;
                for (let item of _data["schemaTypes"])
                    this.schemaTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaMultipleTypesException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaMultipleTypesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.schemaTypes)) {
            data["schemaTypes"] = [];
            for (let item of this.schemaTypes)
                data["schemaTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaMultipleTypesException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    schemaTypes?: string[] | undefined;
}

export class MissingDisplayPatternForCustomerDefaultLanguageException extends PictureparkValidationException implements IMissingDisplayPatternForCustomerDefaultLanguageException {
    schemaId?: string | undefined;
    missingTypes?: DisplayPatternType[] | undefined;

    constructor(data?: IMissingDisplayPatternForCustomerDefaultLanguageException) {
        super(data);
        this._discriminator = "MissingDisplayPatternForCustomerDefaultLanguageException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["missingTypes"])) {
                this.missingTypes = [] as any;
                for (let item of _data["missingTypes"])
                    this.missingTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): MissingDisplayPatternForCustomerDefaultLanguageException {
        data = typeof data === 'object' ? data : {};
        let result = new MissingDisplayPatternForCustomerDefaultLanguageException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.missingTypes)) {
            data["missingTypes"] = [];
            for (let item of this.missingTypes)
                data["missingTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMissingDisplayPatternForCustomerDefaultLanguageException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    missingTypes?: DisplayPatternType[] | undefined;
}

/** The display pattern type */
export enum DisplayPatternType {
    Thumbnail = "Thumbnail",
    List = "List",
    Detail = "Detail",
    Name = "Name",
    DownloadFileName = "DownloadFileName",
}

export class SchemaViewForAllException extends PictureparkValidationException implements ISchemaViewForAllException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaViewForAllException) {
        super(data);
        this._discriminator = "SchemaViewForAllException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaViewForAllException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaViewForAllException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaViewForAllException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SystemLayerReferenceInvalidModificationException extends PictureparkValidationException implements ISystemLayerReferenceInvalidModificationException {
    schemaId?: string | undefined;

    constructor(data?: ISystemLayerReferenceInvalidModificationException) {
        super(data);
        this._discriminator = "SystemLayerReferenceInvalidModificationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SystemLayerReferenceInvalidModificationException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemLayerReferenceInvalidModificationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISystemLayerReferenceInvalidModificationException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class SchemaFieldAnalyzerInvalidException extends PictureparkValidationException implements ISchemaFieldAnalyzerInvalidException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    analyzers?: Analyzer[] | undefined;
    allowedAnalyzers?: Analyzer[] | undefined;

    constructor(data?: ISchemaFieldAnalyzerInvalidException) {
        super(data);
        this._discriminator = "SchemaFieldAnalyzerInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["analyzers"])) {
                this.analyzers = [] as any;
                for (let item of _data["analyzers"])
                    this.analyzers!.push(item);
            }
            if (Array.isArray(_data["allowedAnalyzers"])) {
                this.allowedAnalyzers = [] as any;
                for (let item of _data["allowedAnalyzers"])
                    this.allowedAnalyzers!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaFieldAnalyzerInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldAnalyzerInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.analyzers)) {
            data["analyzers"] = [];
            for (let item of this.analyzers)
                data["analyzers"].push(item);
        }
        if (Array.isArray(this.allowedAnalyzers)) {
            data["allowedAnalyzers"] = [];
            for (let item of this.allowedAnalyzers)
                data["allowedAnalyzers"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldAnalyzerInvalidException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    analyzers?: Analyzer[] | undefined;
    allowedAnalyzers?: Analyzer[] | undefined;
}

export enum Analyzer {
    None = "None",
    Simple = "Simple",
    Language = "Language",
    PathHierarchy = "PathHierarchy",
    EdgeNGram = "EdgeNGram",
    NGram = "NGram",
    NoDiacritics = "NoDiacritics",
    KeywordLowercase = "KeywordLowercase",
}

export class SchemaFieldRelationMultipleTypesException extends PictureparkValidationException implements ISchemaFieldRelationMultipleTypesException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldRelationMultipleTypesException) {
        super(data);
        this._discriminator = "SchemaFieldRelationMultipleTypesException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldRelationMultipleTypesException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationMultipleTypesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldRelationMultipleTypesException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldNotRequirableException extends PictureparkValidationException implements ISchemaFieldNotRequirableException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldNotRequirableException) {
        super(data);
        this._discriminator = "SchemaFieldNotRequirableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldNotRequirableException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotRequirableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNotRequirableException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class DisplayPatternTypeNotSupportedException extends PictureparkValidationException implements IDisplayPatternTypeNotSupportedException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;

    constructor(data?: IDisplayPatternTypeNotSupportedException) {
        super(data);
        this._discriminator = "DisplayPatternTypeNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.displayPatternId = _data["displayPatternId"];
        }
    }

    static override fromJS(data: any): DisplayPatternTypeNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayPatternTypeNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["displayPatternId"] = this.displayPatternId;
        super.toJSON(data);
        return data;
    }
}

export interface IDisplayPatternTypeNotSupportedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    displayPatternId?: string | undefined;
}

export class SchemaFieldActivityInUseException extends PictureparkValidationException implements ISchemaFieldActivityInUseException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldActivityInUseException) {
        super(data);
        this._discriminator = "SchemaFieldActivityInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldActivityInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldActivityInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldActivityInUseException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class SchemaFieldReferencedSchemaChangeNotAllowedException extends PictureparkValidationException implements ISchemaFieldReferencedSchemaChangeNotAllowedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldReferencedSchemaId?: string | undefined;
    newReferencedSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldReferencedSchemaChangeNotAllowedException) {
        super(data);
        this._discriminator = "SchemaFieldReferencedSchemaChangeNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.oldReferencedSchemaId = _data["oldReferencedSchemaId"];
            this.newReferencedSchemaId = _data["newReferencedSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldReferencedSchemaChangeNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldReferencedSchemaChangeNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["oldReferencedSchemaId"] = this.oldReferencedSchemaId;
        data["newReferencedSchemaId"] = this.newReferencedSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldReferencedSchemaChangeNotAllowedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    oldReferencedSchemaId?: string | undefined;
    newReferencedSchemaId?: string | undefined;
}

export class SchemaFieldReferencedSchemaSystemSchemaException extends PictureparkValidationException implements ISchemaFieldReferencedSchemaSystemSchemaException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    referencedSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldReferencedSchemaSystemSchemaException) {
        super(data);
        this._discriminator = "SchemaFieldReferencedSchemaSystemSchemaException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.referencedSchemaId = _data["referencedSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldReferencedSchemaSystemSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldReferencedSchemaSystemSchemaException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["referencedSchemaId"] = this.referencedSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldReferencedSchemaSystemSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    referencedSchemaId?: string | undefined;
}

export class SchemaFieldRelationRelationTypeIdModificationNotAllowedException extends PictureparkValidationException implements ISchemaFieldRelationRelationTypeIdModificationNotAllowedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldRelationRelationTypeIdModificationNotAllowedException) {
        super(data);
        this._discriminator = "SchemaFieldRelationRelationTypeIdModificationNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldRelationRelationTypeIdModificationNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationRelationTypeIdModificationNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldRelationRelationTypeIdModificationNotAllowedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldRelationTargetDocTypeModificationNotAllowedException extends PictureparkValidationException implements ISchemaFieldRelationTargetDocTypeModificationNotAllowedException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: ISchemaFieldRelationTargetDocTypeModificationNotAllowedException) {
        super(data);
        this._discriminator = "SchemaFieldRelationTargetDocTypeModificationNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): SchemaFieldRelationTargetDocTypeModificationNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldRelationTargetDocTypeModificationNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldRelationTargetDocTypeModificationNotAllowedException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class SchemaFieldImportMismatchException extends PictureparkValidationException implements ISchemaFieldImportMismatchException {
    schemaId?: string | undefined;
    importingFieldIds?: string | undefined;
    existingFieldIds?: string | undefined;

    constructor(data?: ISchemaFieldImportMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.importingFieldIds = _data["importingFieldIds"];
            this.existingFieldIds = _data["existingFieldIds"];
        }
    }

    static override fromJS(data: any): SchemaFieldImportMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["importingFieldIds"] = this.importingFieldIds;
        data["existingFieldIds"] = this.existingFieldIds;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldImportMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    importingFieldIds?: string | undefined;
    existingFieldIds?: string | undefined;
}

export class SchemaFieldImportRelatedSchemaMismatchException extends PictureparkValidationException implements ISchemaFieldImportRelatedSchemaMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingRelatedSchemaId?: string | undefined;
    existingRelatedSchemaId?: string | undefined;

    constructor(data?: ISchemaFieldImportRelatedSchemaMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportRelatedSchemaMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.importingRelatedSchemaId = _data["importingRelatedSchemaId"];
            this.existingRelatedSchemaId = _data["existingRelatedSchemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldImportRelatedSchemaMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportRelatedSchemaMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["importingRelatedSchemaId"] = this.importingRelatedSchemaId;
        data["existingRelatedSchemaId"] = this.existingRelatedSchemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldImportRelatedSchemaMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingRelatedSchemaId?: string | undefined;
    existingRelatedSchemaId?: string | undefined;
}

export class SchemaFieldImportTypeMismatchException extends PictureparkValidationException implements ISchemaFieldImportTypeMismatchException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingFieldType?: string | undefined;
    existingFieldType?: string | undefined;

    constructor(data?: ISchemaFieldImportTypeMismatchException) {
        super(data);
        this._discriminator = "SchemaFieldImportTypeMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.importingFieldType = _data["importingFieldType"];
            this.existingFieldType = _data["existingFieldType"];
        }
    }

    static override fromJS(data: any): SchemaFieldImportTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldImportTypeMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["importingFieldType"] = this.importingFieldType;
        data["existingFieldType"] = this.existingFieldType;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldImportTypeMismatchException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    importingFieldType?: string | undefined;
    existingFieldType?: string | undefined;
}

export class SchemaFieldNotSupportedException extends PictureparkValidationException implements ISchemaFieldNotSupportedException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldType?: string | undefined;

    constructor(data?: ISchemaFieldNotSupportedException) {
        super(data);
        this._discriminator = "SchemaFieldNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
            this.fieldType = _data["fieldType"];
        }
    }

    static override fromJS(data: any): SchemaFieldNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        data["fieldType"] = this.fieldType;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldNotSupportedException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
    fieldType?: string | undefined;
}

export class SchemaFieldDisplayPatternTypeNotSupportedException extends PictureparkValidationException implements ISchemaFieldDisplayPatternTypeNotSupportedException {
    fieldId?: string | undefined;
    displayPatternType?: DisplayPatternType;
    supportedDisplayPatternTypes?: DisplayPatternType[] | undefined;

    constructor(data?: ISchemaFieldDisplayPatternTypeNotSupportedException) {
        super(data);
        this._discriminator = "SchemaFieldDisplayPatternTypeNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.displayPatternType = _data["displayPatternType"];
            if (Array.isArray(_data["supportedDisplayPatternTypes"])) {
                this.supportedDisplayPatternTypes = [] as any;
                for (let item of _data["supportedDisplayPatternTypes"])
                    this.supportedDisplayPatternTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaFieldDisplayPatternTypeNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldDisplayPatternTypeNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["displayPatternType"] = this.displayPatternType;
        if (Array.isArray(this.supportedDisplayPatternTypes)) {
            data["supportedDisplayPatternTypes"] = [];
            for (let item of this.supportedDisplayPatternTypes)
                data["supportedDisplayPatternTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldDisplayPatternTypeNotSupportedException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    displayPatternType?: DisplayPatternType;
    supportedDisplayPatternTypes?: DisplayPatternType[] | undefined;
}

export class SchemaFieldMarkdownNotMultilineException extends PictureparkValidationException implements ISchemaFieldMarkdownNotMultilineException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;

    constructor(data?: ISchemaFieldMarkdownNotMultilineException) {
        super(data);
        this._discriminator = "SchemaFieldMarkdownNotMultilineException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaFieldMarkdownNotMultilineException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldMarkdownNotMultilineException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldMarkdownNotMultilineException extends IPictureparkValidationException {
    fieldId?: string | undefined;
    schemaId?: string | undefined;
}

export class IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException extends PictureparkValidationException implements IIndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;

    constructor(data?: IIndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException) {
        super(data);
        this._discriminator = "IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            this.relatedFieldId = _data["relatedFieldId"];
        }
    }

    static override fromJS(data: any): IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException {
        data = typeof data === 'object' ? data : {};
        let result = new IndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        data["relatedFieldId"] = this.relatedFieldId;
        super.toJSON(data);
        return data;
    }
}

export interface IIndexingDisplayValueInFilterOnlySupportedForIndexedTagboxFieldsException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    relatedFieldId?: string | undefined;
}

export class SchemaFieldDynamicViewFieldInvalidFilterTemplateException extends PictureparkValidationException implements ISchemaFieldDynamicViewFieldInvalidFilterTemplateException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    errors?: string[] | undefined;

    constructor(data?: ISchemaFieldDynamicViewFieldInvalidFilterTemplateException) {
        super(data);
        this._discriminator = "SchemaFieldDynamicViewFieldInvalidFilterTemplateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static override fromJS(data: any): SchemaFieldDynamicViewFieldInvalidFilterTemplateException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaFieldDynamicViewFieldInvalidFilterTemplateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaFieldDynamicViewFieldInvalidFilterTemplateException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
    errors?: string[] | undefined;
}

export class DeleteContentsWithReferencesException extends PictureparkValidationException implements IDeleteContentsWithReferencesException {
    numberOfReferences?: number;
    numberOfShares?: number;

    constructor(data?: IDeleteContentsWithReferencesException) {
        super(data);
        this._discriminator = "DeleteContentsWithReferencesException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.numberOfReferences = _data["numberOfReferences"];
            this.numberOfShares = _data["numberOfShares"];
        }
    }

    static override fromJS(data: any): DeleteContentsWithReferencesException {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteContentsWithReferencesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfReferences"] = this.numberOfReferences;
        data["numberOfShares"] = this.numberOfShares;
        super.toJSON(data);
        return data;
    }
}

export interface IDeleteContentsWithReferencesException extends IPictureparkValidationException {
    numberOfReferences?: number;
    numberOfShares?: number;
}

export class ContentMetadataUpdateManyException extends PictureparkBusinessException implements IContentMetadataUpdateManyException {
    failedItemsCount?: number;
    totalItemsCount?: number;

    constructor(data?: IContentMetadataUpdateManyException) {
        super(data);
        this._discriminator = "ContentMetadataUpdateManyException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.failedItemsCount = _data["failedItemsCount"];
            this.totalItemsCount = _data["totalItemsCount"];
        }
    }

    static override fromJS(data: any): ContentMetadataUpdateManyException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["failedItemsCount"] = this.failedItemsCount;
        data["totalItemsCount"] = this.totalItemsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IContentMetadataUpdateManyException extends IPictureparkBusinessException {
    failedItemsCount?: number;
    totalItemsCount?: number;
}

export class ContentNotFoundException extends PictureparkNotFoundException implements IContentNotFoundException {
    contentIds?: string[] | undefined;

    constructor(data?: IContentNotFoundException) {
        super(data);
        this._discriminator = "ContentNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentNotFoundException extends IPictureparkNotFoundException {
    contentIds?: string[] | undefined;
}

export class ContentLayerInvalidException extends PictureparkValidationException implements IContentLayerInvalidException {
    contentId?: string | undefined;
    layerIds?: string | undefined;

    constructor(data?: IContentLayerInvalidException) {
        super(data);
        this._discriminator = "ContentLayerInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.layerIds = _data["layerIds"];
        }
    }

    static override fromJS(data: any): ContentLayerInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentLayerInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["layerIds"] = this.layerIds;
        super.toJSON(data);
        return data;
    }
}

export interface IContentLayerInvalidException extends IPictureparkValidationException {
    contentId?: string | undefined;
    layerIds?: string | undefined;
}

export class ContentFileReplaceTypeMismatchException extends PictureparkValidationException implements IContentFileReplaceTypeMismatchException {
    contentId?: string | undefined;
    originalContentType?: ContentType;
    newContentType?: ContentType;

    constructor(data?: IContentFileReplaceTypeMismatchException) {
        super(data);
        this._discriminator = "ContentFileReplaceTypeMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.originalContentType = _data["originalContentType"];
            this.newContentType = _data["newContentType"];
        }
    }

    static override fromJS(data: any): ContentFileReplaceTypeMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileReplaceTypeMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["originalContentType"] = this.originalContentType;
        data["newContentType"] = this.newContentType;
        super.toJSON(data);
        return data;
    }
}

export interface IContentFileReplaceTypeMismatchException extends IPictureparkValidationException {
    contentId?: string | undefined;
    originalContentType?: ContentType;
    newContentType?: ContentType;
}

/** Content types */
export enum ContentType {
    Unknown = "Unknown",
    Bitmap = "Bitmap",
    VectorGraphic = "VectorGraphic",
    RawImage = "RawImage",
    InterchangeDocument = "InterchangeDocument",
    WordProcessingDocument = "WordProcessingDocument",
    TextDocument = "TextDocument",
    DesktopPublishingDocument = "DesktopPublishingDocument",
    Presentation = "Presentation",
    Spreadsheet = "Spreadsheet",
    Archive = "Archive",
    Audio = "Audio",
    Video = "Video",
    Font = "Font",
    Multimedia = "Multimedia",
    Application = "Application",
    SourceCode = "SourceCode",
    Database = "Database",
    Cad = "Cad",
    Model3d = "Model3d",
    Virtual = "Virtual",
}

export class ContentBackupFailedException extends PictureparkBusinessException implements IContentBackupFailedException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    outputId?: string | undefined;

    constructor(data?: IContentBackupFailedException) {
        super(data);
        this._discriminator = "ContentBackupFailedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
            this.outputId = _data["outputId"];
        }
    }

    static override fromJS(data: any): ContentBackupFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentBackupFailedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["outputId"] = this.outputId;
        super.toJSON(data);
        return data;
    }
}

export interface IContentBackupFailedException extends IPictureparkBusinessException {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    outputId?: string | undefined;
}

export class ContentLayerSameRootException extends PictureparkValidationException implements IContentLayerSameRootException {
    contentId?: string | undefined;
    layerIdsByRootSchema?: LayerIdsByRootSchema[] | undefined;

    constructor(data?: IContentLayerSameRootException) {
        super(data);
        if (data) {
            if (data.layerIdsByRootSchema) {
                this.layerIdsByRootSchema = [];
                for (let i = 0; i < data.layerIdsByRootSchema.length; i++) {
                    let item = data.layerIdsByRootSchema[i];
                    this.layerIdsByRootSchema[i] = item && !(<any>item).toJSON ? new LayerIdsByRootSchema(item) : <LayerIdsByRootSchema>item;
                }
            }
        }
        this._discriminator = "ContentLayerSameRootException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            if (Array.isArray(_data["layerIdsByRootSchema"])) {
                this.layerIdsByRootSchema = [] as any;
                for (let item of _data["layerIdsByRootSchema"])
                    this.layerIdsByRootSchema!.push(LayerIdsByRootSchema.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentLayerSameRootException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentLayerSameRootException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        if (Array.isArray(this.layerIdsByRootSchema)) {
            data["layerIdsByRootSchema"] = [];
            for (let item of this.layerIdsByRootSchema)
                data["layerIdsByRootSchema"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentLayerSameRootException extends IPictureparkValidationException {
    contentId?: string | undefined;
    layerIdsByRootSchema?: ILayerIdsByRootSchema[] | undefined;
}

export class LayerIdsByRootSchema implements ILayerIdsByRootSchema {
    rootSchemaId?: string | undefined;
    layerSchemaIds?: string[] | undefined;

    constructor(data?: ILayerIdsByRootSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootSchemaId = _data["rootSchemaId"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
        }
    }

    static fromJS(data: any): LayerIdsByRootSchema {
        data = typeof data === 'object' ? data : {};
        let result = new LayerIdsByRootSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootSchemaId"] = this.rootSchemaId;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        return data;
    }
}

export interface ILayerIdsByRootSchema {
    rootSchemaId?: string | undefined;
    layerSchemaIds?: string[] | undefined;
}

export class ContentHistoricVersionNotFoundException extends PictureparkNotFoundException implements IContentHistoricVersionNotFoundException {
    contentId?: string | undefined;
    version?: number;

    constructor(data?: IContentHistoricVersionNotFoundException) {
        super(data);
        this._discriminator = "ContentHistoricVersionNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): ContentHistoricVersionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentHistoricVersionNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IContentHistoricVersionNotFoundException extends IPictureparkNotFoundException {
    contentId?: string | undefined;
    version?: number;
}

export class UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException extends PictureparkValidationException implements IUnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException {
    contentId?: string | undefined;
    version?: number;

    constructor(data?: IUnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException) {
        super(data);
        this._discriminator = "UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException {
        data = typeof data === 'object' ? data : {};
        let result = new UnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IUnableToDeleteLatestXmpWritebackGeneratedContentHistoricVersionException extends IPictureparkValidationException {
    contentId?: string | undefined;
    version?: number;
}

export class ContentSchemaChangeException extends PictureparkValidationException implements IContentSchemaChangeException {
    /** Content for which a change to RequestedContentSchemaId would cause data loss */
    contentId?: string | undefined;
    /** ContentSchemaId to which the Content would have been changed */
    requestedContentSchemaId?: string | undefined;
    /** Layers assigned to this Content which are not allowed for contents of type RequestedContentSchemaId */
    incompatibleLayerAssignments?: string[] | undefined;

    constructor(data?: IContentSchemaChangeException) {
        super(data);
        this._discriminator = "ContentSchemaChangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.requestedContentSchemaId = _data["requestedContentSchemaId"];
            if (Array.isArray(_data["incompatibleLayerAssignments"])) {
                this.incompatibleLayerAssignments = [] as any;
                for (let item of _data["incompatibleLayerAssignments"])
                    this.incompatibleLayerAssignments!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentSchemaChangeException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSchemaChangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["requestedContentSchemaId"] = this.requestedContentSchemaId;
        if (Array.isArray(this.incompatibleLayerAssignments)) {
            data["incompatibleLayerAssignments"] = [];
            for (let item of this.incompatibleLayerAssignments)
                data["incompatibleLayerAssignments"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentSchemaChangeException extends IPictureparkValidationException {
    /** Content for which a change to RequestedContentSchemaId would cause data loss */
    contentId?: string | undefined;
    /** ContentSchemaId to which the Content would have been changed */
    requestedContentSchemaId?: string | undefined;
    /** Layers assigned to this Content which are not allowed for contents of type RequestedContentSchemaId */
    incompatibleLayerAssignments?: string[] | undefined;
}

export class ConcurrentFileReplacementDuringRepairException extends PictureparkConflictException implements IConcurrentFileReplacementDuringRepairException {
    contentId?: string | undefined;
    expectedOriginalFileVersion?: number;
    actualOriginalFileVersion?: number;

    constructor(data?: IConcurrentFileReplacementDuringRepairException) {
        super(data);
        this._discriminator = "ConcurrentFileReplacementDuringRepairException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.expectedOriginalFileVersion = _data["expectedOriginalFileVersion"];
            this.actualOriginalFileVersion = _data["actualOriginalFileVersion"];
        }
    }

    static override fromJS(data: any): ConcurrentFileReplacementDuringRepairException {
        data = typeof data === 'object' ? data : {};
        let result = new ConcurrentFileReplacementDuringRepairException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["expectedOriginalFileVersion"] = this.expectedOriginalFileVersion;
        data["actualOriginalFileVersion"] = this.actualOriginalFileVersion;
        super.toJSON(data);
        return data;
    }
}

export interface IConcurrentFileReplacementDuringRepairException extends IPictureparkConflictException {
    contentId?: string | undefined;
    expectedOriginalFileVersion?: number;
    actualOriginalFileVersion?: number;
}

export class ContentResolveBehaviorNotSupportedException extends PictureparkValidationException implements IContentResolveBehaviorNotSupportedException {
    behaviors?: ContentResolveBehavior[] | undefined;

    constructor(data?: IContentResolveBehaviorNotSupportedException) {
        super(data);
        this._discriminator = "ContentResolveBehaviorNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["behaviors"])) {
                this.behaviors = [] as any;
                for (let item of _data["behaviors"])
                    this.behaviors!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentResolveBehaviorNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new ContentResolveBehaviorNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.behaviors)) {
            data["behaviors"] = [];
            for (let item of this.behaviors)
                data["behaviors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentResolveBehaviorNotSupportedException extends IPictureparkValidationException {
    behaviors?: ContentResolveBehavior[] | undefined;
}

export enum ContentResolveBehavior {
    Content = "Content",
    LinkedListItems = "LinkedListItems",
    Metadata = "Metadata",
    Outputs = "Outputs",
    InnerDisplayValueThumbnail = "InnerDisplayValueThumbnail",
    InnerDisplayValueList = "InnerDisplayValueList",
    InnerDisplayValueDetail = "InnerDisplayValueDetail",
    InnerDisplayValueName = "InnerDisplayValueName",
    Owner = "Owner",
    Permissions = "Permissions",
    OuterDisplayValueThumbnail = "OuterDisplayValueThumbnail",
    OuterDisplayValueList = "OuterDisplayValueList",
    OuterDisplayValueDetail = "OuterDisplayValueDetail",
    OuterDisplayValueName = "OuterDisplayValueName",
    HistoricVersionCount = "HistoricVersionCount",
    DynamicViewFields = "DynamicViewFields",
    DynamicViewFieldsWithHasItems = "DynamicViewFieldsWithHasItems",
    DisplayContentOutputs = "DisplayContentOutputs",
}

export class BusinessProcessEngineRequestException extends PictureparkBusinessException implements IBusinessProcessEngineRequestException {
    businessProcessId?: string | undefined;
    engineError?: string | undefined;

    constructor(data?: IBusinessProcessEngineRequestException) {
        super(data);
        this._discriminator = "BusinessProcessEngineRequestException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.engineError = _data["engineError"];
        }
    }

    static override fromJS(data: any): BusinessProcessEngineRequestException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessEngineRequestException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["engineError"] = this.engineError;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessEngineRequestException extends IPictureparkBusinessException {
    businessProcessId?: string | undefined;
    engineError?: string | undefined;
}

export class BusinessProcessNotFoundException extends PictureparkNotFoundException implements IBusinessProcessNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessNotFoundException extends IPictureparkNotFoundException {
    businessProcessId?: string | undefined;
}

export class TooManyBusinessProcessesException extends PictureparkTooManyRequestsException implements ITooManyBusinessProcessesException {

    constructor(data?: ITooManyBusinessProcessesException) {
        super(data);
        this._discriminator = "TooManyBusinessProcessesException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TooManyBusinessProcessesException {
        data = typeof data === 'object' ? data : {};
        let result = new TooManyBusinessProcessesException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITooManyBusinessProcessesException extends IPictureparkTooManyRequestsException {
}

export class BusinessProcessDefinitionNotFoundException extends PictureparkNotFoundException implements IBusinessProcessDefinitionNotFoundException {
    processDefinitionId?: string | undefined;

    constructor(data?: IBusinessProcessDefinitionNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.processDefinitionId = _data["processDefinitionId"];
        }
    }

    static override fromJS(data: any): BusinessProcessDefinitionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefinitionId"] = this.processDefinitionId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessDefinitionNotFoundException extends IPictureparkNotFoundException {
    processDefinitionId?: string | undefined;
}

export class BusinessProcessDefinitionCreateException extends PictureparkBusinessException implements IBusinessProcessDefinitionCreateException {
    processDefinitionIds?: string[] | undefined;

    constructor(data?: IBusinessProcessDefinitionCreateException) {
        super(data);
        this._discriminator = "BusinessProcessDefinitionCreateException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["processDefinitionIds"])) {
                this.processDefinitionIds = [] as any;
                for (let item of _data["processDefinitionIds"])
                    this.processDefinitionIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): BusinessProcessDefinitionCreateException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDefinitionCreateException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.processDefinitionIds)) {
            data["processDefinitionIds"] = [];
            for (let item of this.processDefinitionIds)
                data["processDefinitionIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessDefinitionCreateException extends IPictureparkBusinessException {
    processDefinitionIds?: string[] | undefined;
}

export class BusinessProcessNotExternalException extends PictureparkForbiddenException implements IBusinessProcessNotExternalException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessNotExternalException) {
        super(data);
        this._discriminator = "BusinessProcessNotExternalException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessNotExternalException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotExternalException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessNotExternalException extends IPictureparkForbiddenException {
    businessProcessId?: string | undefined;
}

export class BusinessProcessCancellationNotSupportedException extends PictureparkValidationException implements IBusinessProcessCancellationNotSupportedException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessCancellationNotSupportedException) {
        super(data);
        this._discriminator = "BusinessProcessCancellationNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessCancellationNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessCancellationNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessCancellationNotSupportedException extends IPictureparkValidationException {
    businessProcessId?: string | undefined;
}

export class BusinessProcessContinuationException extends PictureparkBusinessException implements IBusinessProcessContinuationException {
    continuationBusinessProcessId?: string | undefined;
    precedingBusinessProcessId?: string | undefined;
    precedingBusinessProcessException?: PictureparkException | undefined;

    constructor(data?: IBusinessProcessContinuationException) {
        super(data);
        this._discriminator = "BusinessProcessContinuationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.continuationBusinessProcessId = _data["continuationBusinessProcessId"];
            this.precedingBusinessProcessId = _data["precedingBusinessProcessId"];
            this.precedingBusinessProcessException = _data["precedingBusinessProcessException"] ? PictureparkException.fromJS(_data["precedingBusinessProcessException"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BusinessProcessContinuationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessContinuationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["continuationBusinessProcessId"] = this.continuationBusinessProcessId;
        data["precedingBusinessProcessId"] = this.precedingBusinessProcessId;
        data["precedingBusinessProcessException"] = this.precedingBusinessProcessException ? this.precedingBusinessProcessException.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessContinuationException extends IPictureparkBusinessException {
    continuationBusinessProcessId?: string | undefined;
    precedingBusinessProcessId?: string | undefined;
    precedingBusinessProcessException?: PictureparkException | undefined;
}

export class BusinessProcessSummaryNotBatchBasedException extends PictureparkValidationException implements IBusinessProcessSummaryNotBatchBasedException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessSummaryNotBatchBasedException) {
        super(data);
        this._discriminator = "BusinessProcessSummaryNotBatchBasedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessSummaryNotBatchBasedException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSummaryNotBatchBasedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessSummaryNotBatchBasedException extends IPictureparkValidationException {
    businessProcessId?: string | undefined;
}

export class BusinessProcessSummaryNotFoundException extends PictureparkNotFoundException implements IBusinessProcessSummaryNotFoundException {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessSummaryNotFoundException) {
        super(data);
        this._discriminator = "BusinessProcessSummaryNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessSummaryNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSummaryNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessSummaryNotFoundException extends IPictureparkNotFoundException {
    businessProcessId?: string | undefined;
}

export class SnapshotTimeoutException extends PictureparkTimeoutException implements ISnapshotTimeoutException {

    constructor(data?: ISnapshotTimeoutException) {
        super(data);
        this._discriminator = "SnapshotTimeoutException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SnapshotTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotTimeoutException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISnapshotTimeoutException extends IPictureparkTimeoutException {
}

export class SnapshotFailedException extends PictureparkBusinessException implements ISnapshotFailedException {

    constructor(data?: ISnapshotFailedException) {
        super(data);
        this._discriminator = "SnapshotFailedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SnapshotFailedException {
        data = typeof data === 'object' ? data : {};
        let result = new SnapshotFailedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISnapshotFailedException extends IPictureparkBusinessException {
}

export class AddMetadataLanguageTimeoutException extends PictureparkTimeoutException implements IAddMetadataLanguageTimeoutException {
    environmentProcessId?: string | undefined;

    constructor(data?: IAddMetadataLanguageTimeoutException) {
        super(data);
        this._discriminator = "AddMetadataLanguageTimeoutException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.environmentProcessId = _data["environmentProcessId"];
        }
    }

    static override fromJS(data: any): AddMetadataLanguageTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new AddMetadataLanguageTimeoutException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IAddMetadataLanguageTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export class EnvironmentProcessAlreadyRunningException extends PictureparkValidationException implements IEnvironmentProcessAlreadyRunningException {
    environmentProcessType?: EnvironmentProcessType;

    constructor(data?: IEnvironmentProcessAlreadyRunningException) {
        super(data);
        this._discriminator = "EnvironmentProcessAlreadyRunningException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.environmentProcessType = _data["environmentProcessType"];
        }
    }

    static override fromJS(data: any): EnvironmentProcessAlreadyRunningException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessAlreadyRunningException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessType"] = this.environmentProcessType;
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentProcessAlreadyRunningException extends IPictureparkValidationException {
    environmentProcessType?: EnvironmentProcessType;
}

export enum EnvironmentProcessType {
    AddMetadataLanguage = "AddMetadataLanguage",
    CustomerUpdate = "CustomerUpdate",
    EnvironmentUpdate = "EnvironmentUpdate",
    CustomerBoostValuesUpdate = "CustomerBoostValuesUpdate",
    CustomerReshard = "CustomerReshard",
}

export class EnvironmentProcessNotFoundException extends PictureparkNotFoundException implements IEnvironmentProcessNotFoundException {
    environmentProcessId?: string | undefined;

    constructor(data?: IEnvironmentProcessNotFoundException) {
        super(data);
        this._discriminator = "EnvironmentProcessNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.environmentProcessId = _data["environmentProcessId"];
        }
    }

    static override fromJS(data: any): EnvironmentProcessNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentProcessNotFoundException extends IPictureparkNotFoundException {
    environmentProcessId?: string | undefined;
}

export class EnvironmentProcessWaitTimeoutException extends PictureparkTimeoutException implements IEnvironmentProcessWaitTimeoutException {
    environmentProcessId?: string | undefined;
    waitedLifecycles?: string | undefined;

    constructor(data?: IEnvironmentProcessWaitTimeoutException) {
        super(data);
        this._discriminator = "EnvironmentProcessWaitTimeoutException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.environmentProcessId = _data["environmentProcessId"];
            this.waitedLifecycles = _data["waitedLifecycles"];
        }
    }

    static override fromJS(data: any): EnvironmentProcessWaitTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentProcessWaitTimeoutException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        data["waitedLifecycles"] = this.waitedLifecycles;
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentProcessWaitTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
    waitedLifecycles?: string | undefined;
}

export class CustomerBoostValuesUpdateTimeoutException extends PictureparkTimeoutException implements ICustomerBoostValuesUpdateTimeoutException {
    environmentProcessId?: string | undefined;

    constructor(data?: ICustomerBoostValuesUpdateTimeoutException) {
        super(data);
        this._discriminator = "CustomerBoostValuesUpdateTimeoutException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.environmentProcessId = _data["environmentProcessId"];
        }
    }

    static override fromJS(data: any): CustomerBoostValuesUpdateTimeoutException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBoostValuesUpdateTimeoutException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environmentProcessId"] = this.environmentProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerBoostValuesUpdateTimeoutException extends IPictureparkTimeoutException {
    environmentProcessId?: string | undefined;
}

export class NoTermsOfServiceDefinedException extends PictureparkBusinessException implements INoTermsOfServiceDefinedException {

    constructor(data?: INoTermsOfServiceDefinedException) {
        super(data);
        this._discriminator = "NoTermsOfServiceDefinedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NoTermsOfServiceDefinedException {
        data = typeof data === 'object' ? data : {};
        let result = new NoTermsOfServiceDefinedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INoTermsOfServiceDefinedException extends IPictureparkBusinessException {
}

export class AtLeastOneActiveTermsOfServiceMustExistException extends PictureparkValidationException implements IAtLeastOneActiveTermsOfServiceMustExistException {

    constructor(data?: IAtLeastOneActiveTermsOfServiceMustExistException) {
        super(data);
        this._discriminator = "AtLeastOneActiveTermsOfServiceMustExistException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AtLeastOneActiveTermsOfServiceMustExistException {
        data = typeof data === 'object' ? data : {};
        let result = new AtLeastOneActiveTermsOfServiceMustExistException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAtLeastOneActiveTermsOfServiceMustExistException extends IPictureparkValidationException {
}

export class ForbiddenHtmlElementsUsedException extends PictureparkValidationException implements IForbiddenHtmlElementsUsedException {

    constructor(data?: IForbiddenHtmlElementsUsedException) {
        super(data);
        this._discriminator = "ForbiddenHtmlElementsUsedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ForbiddenHtmlElementsUsedException {
        data = typeof data === 'object' ? data : {};
        let result = new ForbiddenHtmlElementsUsedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IForbiddenHtmlElementsUsedException extends IPictureparkValidationException {
}

export class BusinessProcessStateNotHitException extends PictureparkTimeoutException implements IBusinessProcessStateNotHitException {
    businessProcessId?: string | undefined;
    expected?: string[] | undefined;
    actual?: string | undefined;

    constructor(data?: IBusinessProcessStateNotHitException) {
        super(data);
        this._discriminator = "BusinessProcessStateNotHitException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            if (Array.isArray(_data["expected"])) {
                this.expected = [] as any;
                for (let item of _data["expected"])
                    this.expected!.push(item);
            }
            this.actual = _data["actual"];
        }
    }

    static override fromJS(data: any): BusinessProcessStateNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessStateNotHitException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        if (Array.isArray(this.expected)) {
            data["expected"] = [];
            for (let item of this.expected)
                data["expected"].push(item);
        }
        data["actual"] = this.actual;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessStateNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: string[] | undefined;
    actual?: string | undefined;
}

export class BusinessProcessLifeCycleNotHitException extends PictureparkTimeoutException implements IBusinessProcessLifeCycleNotHitException {
    businessProcessId?: string | undefined;
    expected?: BusinessProcessLifeCycle[] | undefined;
    actual?: BusinessProcessLifeCycle;

    constructor(data?: IBusinessProcessLifeCycleNotHitException) {
        super(data);
        this._discriminator = "BusinessProcessLifeCycleNotHitException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            if (Array.isArray(_data["expected"])) {
                this.expected = [] as any;
                for (let item of _data["expected"])
                    this.expected!.push(item);
            }
            this.actual = _data["actual"];
        }
    }

    static override fromJS(data: any): BusinessProcessLifeCycleNotHitException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessLifeCycleNotHitException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        if (Array.isArray(this.expected)) {
            data["expected"] = [];
            for (let item of this.expected)
                data["expected"].push(item);
        }
        data["actual"] = this.actual;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessLifeCycleNotHitException extends IPictureparkTimeoutException {
    businessProcessId?: string | undefined;
    expected?: BusinessProcessLifeCycle[] | undefined;
    actual?: BusinessProcessLifeCycle;
}

export class OnlyAccessibleToRecipientException extends PictureparkValidationException implements IOnlyAccessibleToRecipientException {

    constructor(data?: IOnlyAccessibleToRecipientException) {
        super(data);
        this._discriminator = "OnlyAccessibleToRecipientException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OnlyAccessibleToRecipientException {
        data = typeof data === 'object' ? data : {};
        let result = new OnlyAccessibleToRecipientException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOnlyAccessibleToRecipientException extends IPictureparkValidationException {
}

export class NotificationNotFoundException extends PictureparkNotFoundException implements INotificationNotFoundException {
    notificationId?: string | undefined;

    constructor(data?: INotificationNotFoundException) {
        super(data);
        this._discriminator = "NotificationNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.notificationId = _data["notificationId"];
        }
    }

    static override fromJS(data: any): NotificationNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationNotFoundException extends IPictureparkNotFoundException {
    notificationId?: string | undefined;
}

export class EnvironmentNotAvailableException extends PictureparkException implements IEnvironmentNotAvailableException {

    constructor(data?: IEnvironmentNotAvailableException) {
        super(data);
        this._discriminator = "EnvironmentNotAvailableException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): EnvironmentNotAvailableException {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentNotAvailableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEnvironmentNotAvailableException extends IPictureparkException {
}

export class CustomerNotAvailableException extends PictureparkException implements ICustomerNotAvailableException {
    customerId?: string | undefined;

    constructor(data?: ICustomerNotAvailableException) {
        super(data);
        this._discriminator = "CustomerNotAvailableException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
        }
    }

    static override fromJS(data: any): CustomerNotAvailableException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerNotAvailableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerNotAvailableException extends IPictureparkException {
    customerId?: string | undefined;
}

export class CustomerAliasHeaderMissingException extends PictureparkValidationException implements ICustomerAliasHeaderMissingException {

    constructor(data?: ICustomerAliasHeaderMissingException) {
        super(data);
        this._discriminator = "CustomerAliasHeaderMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CustomerAliasHeaderMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAliasHeaderMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerAliasHeaderMissingException extends IPictureparkValidationException {
}

export class BusinessRuleActionInvalidDocumentTypeException extends PictureparkValidationException implements IBusinessRuleActionInvalidDocumentTypeException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;

    constructor(data?: IBusinessRuleActionInvalidDocumentTypeException) {
        super(data);
        this._discriminator = "BusinessRuleActionInvalidDocumentTypeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["allowedDocumentTypes"])) {
                this.allowedDocumentTypes = [] as any;
                for (let item of _data["allowedDocumentTypes"])
                    this.allowedDocumentTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): BusinessRuleActionInvalidDocumentTypeException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleActionInvalidDocumentTypeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedDocumentTypes)) {
            data["allowedDocumentTypes"] = [];
            for (let item of this.allowedDocumentTypes)
                data["allowedDocumentTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleActionInvalidDocumentTypeException extends IPictureparkValidationException {
    allowedDocumentTypes?: BusinessRuleTriggerDocType[] | undefined;
}

export enum BusinessRuleTriggerDocType {
    Content = "Content",
    ListItem = "ListItem",
}

export class BusinessRuleActionsMissingException extends PictureparkValidationException implements IBusinessRuleActionsMissingException {

    constructor(data?: IBusinessRuleActionsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleActionsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleActionsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleActionsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleActionsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConditionMissingException extends PictureparkValidationException implements IBusinessRuleConditionMissingException {

    constructor(data?: IBusinessRuleConditionMissingException) {
        super(data);
        this._discriminator = "BusinessRuleConditionMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleConditionMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConditionMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleConditionMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConditionsMissingException extends PictureparkValidationException implements IBusinessRuleConditionsMissingException {

    constructor(data?: IBusinessRuleConditionsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleConditionsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleConditionsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConditionsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleConditionsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleConfigurationValidationException extends PictureparkValidationException implements IBusinessRuleConfigurationValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;

    constructor(data?: IBusinessRuleConfigurationValidationException) {
        super(data);
        this._discriminator = "BusinessRuleConfigurationValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["innerExceptions"])) {
                this.innerExceptions = [] as any;
                for (let item of _data["innerExceptions"])
                    this.innerExceptions!.push(PictureparkValidationException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessRuleConfigurationValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfigurationValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.innerExceptions)) {
            data["innerExceptions"] = [];
            for (let item of this.innerExceptions)
                data["innerExceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleConfigurationValidationException extends IPictureparkValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export class BusinessRuleSchemaIdInvalidException extends PictureparkValidationException implements IBusinessRuleSchemaIdInvalidException {
    schemaId?: string | undefined;

    constructor(data?: IBusinessRuleSchemaIdInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleSchemaIdInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): BusinessRuleSchemaIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleSchemaIdInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleSchemaIdInvalidException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class BusinessRulePermissionSetIdInvalidException extends PictureparkValidationException implements IBusinessRulePermissionSetIdInvalidException {
    permissionSetId?: string | undefined;

    constructor(data?: IBusinessRulePermissionSetIdInvalidException) {
        super(data);
        this._discriminator = "BusinessRulePermissionSetIdInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): BusinessRulePermissionSetIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRulePermissionSetIdInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRulePermissionSetIdInvalidException extends IPictureparkValidationException {
    permissionSetId?: string | undefined;
}

export class BusinessRuleRuleIdDuplicationException extends PictureparkValidationException implements IBusinessRuleRuleIdDuplicationException {

    constructor(data?: IBusinessRuleRuleIdDuplicationException) {
        super(data);
        this._discriminator = "BusinessRuleRuleIdDuplicationException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleRuleIdDuplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRuleIdDuplicationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleRuleIdDuplicationException extends IPictureparkValidationException {
}

export class BusinessRuleRuleIdMissingException extends PictureparkValidationException implements IBusinessRuleRuleIdMissingException {

    constructor(data?: IBusinessRuleRuleIdMissingException) {
        super(data);
        this._discriminator = "BusinessRuleRuleIdMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleRuleIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRuleIdMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleRuleIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleTriggerPointMissingException extends PictureparkValidationException implements IBusinessRuleTriggerPointMissingException {

    constructor(data?: IBusinessRuleTriggerPointMissingException) {
        super(data);
        this._discriminator = "BusinessRuleTriggerPointMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleTriggerPointMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTriggerPointMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleTriggerPointMissingException extends IPictureparkValidationException {
}

export class BusinessRuleValidationException extends PictureparkValidationException implements IBusinessRuleValidationException {
    ruleId?: string | undefined;
    innerExceptions?: PictureparkValidationException[] | undefined;

    constructor(data?: IBusinessRuleValidationException) {
        super(data);
        this._discriminator = "BusinessRuleValidationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ruleId = _data["ruleId"];
            if (Array.isArray(_data["innerExceptions"])) {
                this.innerExceptions = [] as any;
                for (let item of _data["innerExceptions"])
                    this.innerExceptions!.push(PictureparkValidationException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessRuleValidationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleValidationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        if (Array.isArray(this.innerExceptions)) {
            data["innerExceptions"] = [];
            for (let item of this.innerExceptions)
                data["innerExceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleValidationException extends IPictureparkValidationException {
    ruleId?: string | undefined;
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export class BusinessRuleRegularExpressionInvalidException extends PictureparkValidationException implements IBusinessRuleRegularExpressionInvalidException {
    regex?: string | undefined;

    constructor(data?: IBusinessRuleRegularExpressionInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleRegularExpressionInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.regex = _data["regex"];
        }
    }

    static override fromJS(data: any): BusinessRuleRegularExpressionInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRegularExpressionInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regex"] = this.regex;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleRegularExpressionInvalidException extends IPictureparkValidationException {
    regex?: string | undefined;
}

export class BusinessRuleConditionInvalidTriggerPointException extends PictureparkValidationException implements IBusinessRuleConditionInvalidTriggerPointException {
    allowedDocTypes?: BusinessRuleTriggerDocType[] | undefined;
    allowedActions?: BusinessRuleTriggerAction[] | undefined;

    constructor(data?: IBusinessRuleConditionInvalidTriggerPointException) {
        super(data);
        this._discriminator = "BusinessRuleConditionInvalidTriggerPointException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["allowedDocTypes"])) {
                this.allowedDocTypes = [] as any;
                for (let item of _data["allowedDocTypes"])
                    this.allowedDocTypes!.push(item);
            }
            if (Array.isArray(_data["allowedActions"])) {
                this.allowedActions = [] as any;
                for (let item of _data["allowedActions"])
                    this.allowedActions!.push(item);
            }
        }
    }

    static override fromJS(data: any): BusinessRuleConditionInvalidTriggerPointException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConditionInvalidTriggerPointException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedDocTypes)) {
            data["allowedDocTypes"] = [];
            for (let item of this.allowedDocTypes)
                data["allowedDocTypes"].push(item);
        }
        if (Array.isArray(this.allowedActions)) {
            data["allowedActions"] = [];
            for (let item of this.allowedActions)
                data["allowedActions"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleConditionInvalidTriggerPointException extends IPictureparkValidationException {
    allowedDocTypes?: BusinessRuleTriggerDocType[] | undefined;
    allowedActions?: BusinessRuleTriggerAction[] | undefined;
}

export enum BusinessRuleTriggerAction {
    Create = "Create",
    Update = "Update",
    FileReplacement = "FileReplacement",
    Schedule = "Schedule",
}

export class BusinessRuleRefIdsMissingException extends PictureparkValidationException implements IBusinessRuleRefIdsMissingException {

    constructor(data?: IBusinessRuleRefIdsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleRefIdsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleRefIdsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleRefIdsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleRefIdsMissingException extends IPictureparkValidationException {
}

export class BusinessRulePathInvalidException extends PictureparkValidationException implements IBusinessRulePathInvalidException {
    path?: string | undefined;

    constructor(data?: IBusinessRulePathInvalidException) {
        super(data);
        this._discriminator = "BusinessRulePathInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
        }
    }

    static override fromJS(data: any): BusinessRulePathInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRulePathInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRulePathInvalidException extends IPictureparkValidationException {
    path?: string | undefined;
}

export class BusinessRuleFieldIdInvalidException extends PictureparkValidationException implements IBusinessRuleFieldIdInvalidException {
    fieldId?: string | undefined;

    constructor(data?: IBusinessRuleFieldIdInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleFieldIdInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): BusinessRuleFieldIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleFieldIdInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleFieldIdInvalidException extends IPictureparkValidationException {
    fieldId?: string | undefined;
}

export class BusinessRuleContentPermissionSetIdsMissingException extends PictureparkValidationException implements IBusinessRuleContentPermissionSetIdsMissingException {

    constructor(data?: IBusinessRuleContentPermissionSetIdsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleContentPermissionSetIdsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleContentPermissionSetIdsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleContentPermissionSetIdsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleContentPermissionSetIdsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleFieldPathInvalidException extends PictureparkValidationException implements IBusinessRuleFieldPathInvalidException {
    fieldPath?: string | undefined;

    constructor(data?: IBusinessRuleFieldPathInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleFieldPathInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): BusinessRuleFieldPathInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleFieldPathInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleFieldPathInvalidException extends IPictureparkValidationException {
    fieldPath?: string | undefined;
}

export class BusinessRulePolygonInvalidException extends PictureparkValidationException implements IBusinessRulePolygonInvalidException {

    constructor(data?: IBusinessRulePolygonInvalidException) {
        super(data);
        this._discriminator = "BusinessRulePolygonInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRulePolygonInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRulePolygonInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRulePolygonInvalidException extends IPictureparkValidationException {
}

export class BusinessRuleArrayIndexInvalidException extends PictureparkValidationException implements IBusinessRuleArrayIndexInvalidException {
    index?: string | undefined;

    constructor(data?: IBusinessRuleArrayIndexInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleArrayIndexInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.index = _data["index"];
        }
    }

    static override fromJS(data: any): BusinessRuleArrayIndexInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleArrayIndexInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleArrayIndexInvalidException extends IPictureparkValidationException {
    index?: string | undefined;
}

export class BusinessRuleDictionaryKeyInvalidException extends PictureparkValidationException implements IBusinessRuleDictionaryKeyInvalidException {
    key?: string | undefined;

    constructor(data?: IBusinessRuleDictionaryKeyInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleDictionaryKeyInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.key = _data["key"];
        }
    }

    static override fromJS(data: any): BusinessRuleDictionaryKeyInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleDictionaryKeyInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleDictionaryKeyInvalidException extends IPictureparkValidationException {
    key?: string | undefined;
}

export class BusinessRuleProjectionTransformationsMissingException extends PictureparkValidationException implements IBusinessRuleProjectionTransformationsMissingException {

    constructor(data?: IBusinessRuleProjectionTransformationsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleProjectionTransformationsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleProjectionTransformationsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleProjectionTransformationsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleProjectionTransformationsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleInvalidVariableNameException extends PictureparkValidationException implements IBusinessRuleInvalidVariableNameException {
    name?: string | undefined;

    constructor(data?: IBusinessRuleInvalidVariableNameException) {
        super(data);
        this._discriminator = "BusinessRuleInvalidVariableNameException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): BusinessRuleInvalidVariableNameException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleInvalidVariableNameException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleInvalidVariableNameException extends IPictureparkValidationException {
    name?: string | undefined;
}

export class BusinessRuleTransformationGroupTransformationsMissingException extends PictureparkValidationException implements IBusinessRuleTransformationGroupTransformationsMissingException {

    constructor(data?: IBusinessRuleTransformationGroupTransformationsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleTransformationGroupTransformationsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleTransformationGroupTransformationsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTransformationGroupTransformationsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleTransformationGroupTransformationsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleTransformationGroupInputsMissingException extends PictureparkValidationException implements IBusinessRuleTransformationGroupInputsMissingException {

    constructor(data?: IBusinessRuleTransformationGroupInputsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleTransformationGroupInputsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleTransformationGroupInputsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTransformationGroupInputsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleTransformationGroupInputsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleNamedCacheNameInvalidException extends PictureparkValidationException implements IBusinessRuleNamedCacheNameInvalidException {
    cacheName?: string | undefined;

    constructor(data?: IBusinessRuleNamedCacheNameInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleNamedCacheNameInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cacheName = _data["cacheName"];
        }
    }

    static override fromJS(data: any): BusinessRuleNamedCacheNameInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNamedCacheNameInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cacheName"] = this.cacheName;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNamedCacheNameInvalidException extends IPictureparkValidationException {
    cacheName?: string | undefined;
}

export class BusinessRuleNGramTransformationSizeInvalidException extends PictureparkValidationException implements IBusinessRuleNGramTransformationSizeInvalidException {
    size?: number;
    minSize?: number;
    maxSize?: number;

    constructor(data?: IBusinessRuleNGramTransformationSizeInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleNGramTransformationSizeInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.size = _data["size"];
            this.minSize = _data["minSize"];
            this.maxSize = _data["maxSize"];
        }
    }

    static override fromJS(data: any): BusinessRuleNGramTransformationSizeInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNGramTransformationSizeInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["minSize"] = this.minSize;
        data["maxSize"] = this.maxSize;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNGramTransformationSizeInvalidException extends IPictureparkValidationException {
    size?: number;
    minSize?: number;
    maxSize?: number;
}

export class BusinessRuleNGramTransformationMinWordLengthInvalidException extends PictureparkValidationException implements IBusinessRuleNGramTransformationMinWordLengthInvalidException {
    minWordLength?: number;

    constructor(data?: IBusinessRuleNGramTransformationMinWordLengthInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleNGramTransformationMinWordLengthInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.minWordLength = _data["minWordLength"];
        }
    }

    static override fromJS(data: any): BusinessRuleNGramTransformationMinWordLengthInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNGramTransformationMinWordLengthInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minWordLength"] = this.minWordLength;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNGramTransformationMinWordLengthInvalidException extends IPictureparkValidationException {
    minWordLength?: number;
}

export class BusinessRuleNGramTransformationMaxWordLengthInvalidException extends PictureparkValidationException implements IBusinessRuleNGramTransformationMaxWordLengthInvalidException {
    maxWordLength?: number;

    constructor(data?: IBusinessRuleNGramTransformationMaxWordLengthInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleNGramTransformationMaxWordLengthInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maxWordLength = _data["maxWordLength"];
        }
    }

    static override fromJS(data: any): BusinessRuleNGramTransformationMaxWordLengthInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNGramTransformationMaxWordLengthInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxWordLength"] = this.maxWordLength;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNGramTransformationMaxWordLengthInvalidException extends IPictureparkValidationException {
    maxWordLength?: number;
}

export class BusinessRuleNotificationInvalidIdException extends PictureparkValidationException implements IBusinessRuleNotificationInvalidIdException {
    id?: string | undefined;

    constructor(data?: IBusinessRuleNotificationInvalidIdException) {
        super(data);
        this._discriminator = "BusinessRuleNotificationInvalidIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): BusinessRuleNotificationInvalidIdException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNotificationInvalidIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNotificationInvalidIdException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class BusinessRuleNotificationNoRecipientsException extends PictureparkValidationException implements IBusinessRuleNotificationNoRecipientsException {

    constructor(data?: IBusinessRuleNotificationNoRecipientsException) {
        super(data);
        this._discriminator = "BusinessRuleNotificationNoRecipientsException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleNotificationNoRecipientsException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNotificationNoRecipientsException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNotificationNoRecipientsException extends IPictureparkValidationException {
}

export class BusinessRuleNotificationRecipientUserIdMissingException extends PictureparkValidationException implements IBusinessRuleNotificationRecipientUserIdMissingException {

    constructor(data?: IBusinessRuleNotificationRecipientUserIdMissingException) {
        super(data);
        this._discriminator = "BusinessRuleNotificationRecipientUserIdMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleNotificationRecipientUserIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNotificationRecipientUserIdMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNotificationRecipientUserIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleNotificationRecipientUserRoleIdMissingException extends PictureparkValidationException implements IBusinessRuleNotificationRecipientUserRoleIdMissingException {

    constructor(data?: IBusinessRuleNotificationRecipientUserRoleIdMissingException) {
        super(data);
        this._discriminator = "BusinessRuleNotificationRecipientUserRoleIdMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleNotificationRecipientUserRoleIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNotificationRecipientUserRoleIdMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNotificationRecipientUserRoleIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleNumberSequenceInvalidIdException extends PictureparkValidationException implements IBusinessRuleNumberSequenceInvalidIdException {
    id?: string | undefined;

    constructor(data?: IBusinessRuleNumberSequenceInvalidIdException) {
        super(data);
        this._discriminator = "BusinessRuleNumberSequenceInvalidIdException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): BusinessRuleNumberSequenceInvalidIdException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNumberSequenceInvalidIdException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNumberSequenceInvalidIdException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class BusinessRuleNumberSequenceIdDuplicationException extends PictureparkValidationException implements IBusinessRuleNumberSequenceIdDuplicationException {
    id?: string | undefined;

    constructor(data?: IBusinessRuleNumberSequenceIdDuplicationException) {
        super(data);
        this._discriminator = "BusinessRuleNumberSequenceIdDuplicationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): BusinessRuleNumberSequenceIdDuplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNumberSequenceIdDuplicationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleNumberSequenceIdDuplicationException extends IPictureparkValidationException {
    id?: string | undefined;
}

export class BusinessRuleScheduleInvalidCronExpressionException extends PictureparkValidationException implements IBusinessRuleScheduleInvalidCronExpressionException {
    expression?: string | undefined;

    constructor(data?: IBusinessRuleScheduleInvalidCronExpressionException) {
        super(data);
        this._discriminator = "BusinessRuleScheduleInvalidCronExpressionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expression = _data["expression"];
        }
    }

    static override fromJS(data: any): BusinessRuleScheduleInvalidCronExpressionException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleScheduleInvalidCronExpressionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expression"] = this.expression;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleScheduleInvalidCronExpressionException extends IPictureparkValidationException {
    expression?: string | undefined;
}

export class BusinessRuleScheduleFilterMissingException extends PictureparkValidationException implements IBusinessRuleScheduleFilterMissingException {

    constructor(data?: IBusinessRuleScheduleFilterMissingException) {
        super(data);
        this._discriminator = "BusinessRuleScheduleFilterMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleScheduleFilterMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleScheduleFilterMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleScheduleFilterMissingException extends IPictureparkValidationException {
}

export class BusinessRuleScheduleRulesMissingException extends PictureparkValidationException implements IBusinessRuleScheduleRulesMissingException {

    constructor(data?: IBusinessRuleScheduleRulesMissingException) {
        super(data);
        this._discriminator = "BusinessRuleScheduleRulesMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleScheduleRulesMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleScheduleRulesMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleScheduleRulesMissingException extends IPictureparkValidationException {
}

export class BusinessRuleStringContainsConditionValuesToMatchMissingException extends PictureparkValidationException implements IBusinessRuleStringContainsConditionValuesToMatchMissingException {

    constructor(data?: IBusinessRuleStringContainsConditionValuesToMatchMissingException) {
        super(data);
        this._discriminator = "BusinessRuleStringContainsConditionValuesToMatchMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleStringContainsConditionValuesToMatchMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleStringContainsConditionValuesToMatchMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleStringContainsConditionValuesToMatchMissingException extends IPictureparkValidationException {
}

export class BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException extends PictureparkValidationException implements IBusinessRuleUserInUserRolesConditionUserRoleIdsMissingException {

    constructor(data?: IBusinessRuleUserInUserRolesConditionUserRoleIdsMissingException) {
        super(data);
        this._discriminator = "BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleUserInUserRolesConditionUserRoleIdsMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleUserInUserRolesConditionUserRoleIdsMissingException extends IPictureparkValidationException {
}

export class BusinessRuleDateMathTransformationTimeSpanInvalidException extends PictureparkValidationException implements IBusinessRuleDateMathTransformationTimeSpanInvalidException {
    timeSpan?: string | undefined;

    constructor(data?: IBusinessRuleDateMathTransformationTimeSpanInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleDateMathTransformationTimeSpanInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.timeSpan = _data["timeSpan"];
        }
    }

    static override fromJS(data: any): BusinessRuleDateMathTransformationTimeSpanInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleDateMathTransformationTimeSpanInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleDateMathTransformationTimeSpanInvalidException extends IPictureparkValidationException {
    timeSpan?: string | undefined;
}

export class BusinessRuleTransferOwnershipTransferUserIdMissingException extends PictureparkValidationException implements IBusinessRuleTransferOwnershipTransferUserIdMissingException {

    constructor(data?: IBusinessRuleTransferOwnershipTransferUserIdMissingException) {
        super(data);
        this._discriminator = "BusinessRuleTransferOwnershipTransferUserIdMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleTransferOwnershipTransferUserIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTransferOwnershipTransferUserIdMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleTransferOwnershipTransferUserIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleOutputFormatIdMissingException extends PictureparkValidationException implements IBusinessRuleOutputFormatIdMissingException {

    constructor(data?: IBusinessRuleOutputFormatIdMissingException) {
        super(data);
        this._discriminator = "BusinessRuleOutputFormatIdMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleOutputFormatIdMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleOutputFormatIdMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleOutputFormatIdMissingException extends IPictureparkValidationException {
}

export class BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException extends PictureparkValidationException implements IBusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException {
    expirationDate?: string | undefined;

    constructor(data?: IBusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException) {
        super(data);
        this._discriminator = "BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.expirationDate = _data["expirationDate"];
        }
    }

    static override fromJS(data: any): BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expirationDate"] = this.expirationDate;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleEnqueueCreateEmbedActionExpirationDateInvalidException extends IPictureparkValidationException {
    expirationDate?: string | undefined;
}

export class NamedCacheConfigurationException extends PictureparkValidationException implements INamedCacheConfigurationException {
    innerExceptions?: PictureparkValidationException[] | undefined;

    constructor(data?: INamedCacheConfigurationException) {
        super(data);
        this._discriminator = "NamedCacheConfigurationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["innerExceptions"])) {
                this.innerExceptions = [] as any;
                for (let item of _data["innerExceptions"])
                    this.innerExceptions!.push(PictureparkValidationException.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): NamedCacheConfigurationException {
        data = typeof data === 'object' ? data : {};
        let result = new NamedCacheConfigurationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.innerExceptions)) {
            data["innerExceptions"] = [];
            for (let item of this.innerExceptions)
                data["innerExceptions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INamedCacheConfigurationException extends IPictureparkValidationException {
    innerExceptions?: PictureparkValidationException[] | undefined;
}

export class NamedCacheNameMissingException extends PictureparkValidationException implements INamedCacheNameMissingException {

    constructor(data?: INamedCacheNameMissingException) {
        super(data);
        this._discriminator = "NamedCacheNameMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NamedCacheNameMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new NamedCacheNameMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INamedCacheNameMissingException extends IPictureparkValidationException {
}

export class NamedCacheNameDuplicationException extends PictureparkValidationException implements INamedCacheNameDuplicationException {
    name?: string | undefined;

    constructor(data?: INamedCacheNameDuplicationException) {
        super(data);
        this._discriminator = "NamedCacheNameDuplicationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): NamedCacheNameDuplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new NamedCacheNameDuplicationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface INamedCacheNameDuplicationException extends IPictureparkValidationException {
    name?: string | undefined;
}

export class ListItemNamedCacheSchemaIdInvalidException extends PictureparkValidationException implements IListItemNamedCacheSchemaIdInvalidException {
    schemaId?: string | undefined;

    constructor(data?: IListItemNamedCacheSchemaIdInvalidException) {
        super(data);
        this._discriminator = "ListItemNamedCacheSchemaIdInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): ListItemNamedCacheSchemaIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNamedCacheSchemaIdInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemNamedCacheSchemaIdInvalidException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class ListItemNamedCacheKeyFieldsInvalidException extends PictureparkValidationException implements IListItemNamedCacheKeyFieldsInvalidException {

    constructor(data?: IListItemNamedCacheKeyFieldsInvalidException) {
        super(data);
        this._discriminator = "ListItemNamedCacheKeyFieldsInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ListItemNamedCacheKeyFieldsInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNamedCacheKeyFieldsInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IListItemNamedCacheKeyFieldsInvalidException extends IPictureparkValidationException {
}

export class SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException extends PictureparkValidationException implements ISchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException {
    schemaId?: string | undefined;

    constructor(data?: ISchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException) {
        super(data);
        this._discriminator = "SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface ISchemaTagboxFilterLookupNamedCacheSchemaIdInvalidException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class NoTagsFoundException extends PictureparkBusinessException implements INoTagsFoundException {

    constructor(data?: INoTagsFoundException) {
        super(data);
        this._discriminator = "NoTagsFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NoTagsFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new NoTagsFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INoTagsFoundException extends IPictureparkBusinessException {
}

export class OutputNotAvailableException extends PictureparkBusinessException implements IOutputNotAvailableException {

    constructor(data?: IOutputNotAvailableException) {
        super(data);
        this._discriminator = "OutputNotAvailableException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputNotAvailableException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputNotAvailableException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutputNotAvailableException extends IPictureparkBusinessException {
}

export class ModelNotFoundException extends PictureparkNotFoundException implements IModelNotFoundException {

    constructor(data?: IModelNotFoundException) {
        super(data);
        this._discriminator = "ModelNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ModelNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ModelNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IModelNotFoundException extends IPictureparkNotFoundException {
}

export class DisplayValueRerenderingInProgressException extends PictureparkValidationException implements IDisplayValueRerenderingInProgressException {

    constructor(data?: IDisplayValueRerenderingInProgressException) {
        super(data);
        this._discriminator = "DisplayValueRerenderingInProgressException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DisplayValueRerenderingInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayValueRerenderingInProgressException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IDisplayValueRerenderingInProgressException extends IPictureparkValidationException {
}

export class OutputFormatNotFoundException extends PictureparkNotFoundException implements IOutputFormatNotFoundException {
    outputFormatId?: string | undefined;

    constructor(data?: IOutputFormatNotFoundException) {
        super(data);
        this._discriminator = "OutputFormatNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputFormatNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatNotFoundException extends IPictureparkNotFoundException {
    outputFormatId?: string | undefined;
}

export class OutputFormatSourceNotDefinedException extends PictureparkValidationException implements IOutputFormatSourceNotDefinedException {
    outputFormatId?: string | undefined;

    constructor(data?: IOutputFormatSourceNotDefinedException) {
        super(data);
        this._discriminator = "OutputFormatSourceNotDefinedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputFormatSourceNotDefinedException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSourceNotDefinedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatSourceNotDefinedException extends IPictureparkValidationException {
    outputFormatId?: string | undefined;
}

export class OutputFormatRetentionTimeOutOfRangeException extends ArgumentRangeException implements IOutputFormatRetentionTimeOutOfRangeException {
    outputFormatId?: string | undefined;

    constructor(data?: IOutputFormatRetentionTimeOutOfRangeException) {
        super(data);
        this._discriminator = "OutputFormatRetentionTimeOutOfRangeException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputFormatRetentionTimeOutOfRangeException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatRetentionTimeOutOfRangeException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatRetentionTimeOutOfRangeException extends IArgumentRangeException {
    outputFormatId?: string | undefined;
}

export class NotSupportedFileExtensionForFormatException extends NotSupportedFileExtensionException implements INotSupportedFileExtensionForFormatException {
    formatKind?: string | undefined;
    outputFormatId?: string | undefined;

    constructor(data?: INotSupportedFileExtensionForFormatException) {
        super(data);
        this._discriminator = "NotSupportedFileExtensionForFormatException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.formatKind = _data["formatKind"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): NotSupportedFileExtensionForFormatException {
        data = typeof data === 'object' ? data : {};
        let result = new NotSupportedFileExtensionForFormatException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formatKind"] = this.formatKind;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface INotSupportedFileExtensionForFormatException extends INotSupportedFileExtensionException {
    formatKind?: string | undefined;
    outputFormatId?: string | undefined;
}

export class OutputFormatXmpWritebackNotSupportedException extends PictureparkValidationException implements IOutputFormatXmpWritebackNotSupportedException {
    outputFormatId?: string | undefined;

    constructor(data?: IOutputFormatXmpWritebackNotSupportedException) {
        super(data);
        this._discriminator = "OutputFormatXmpWritebackNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): OutputFormatXmpWritebackNotSupportedException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException") {
            let result = new OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException();
            result.init(data);
            return result;
        }
        let result = new OutputFormatXmpWritebackNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatXmpWritebackNotSupportedException extends IPictureparkValidationException {
    outputFormatId?: string | undefined;
}

export class OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException extends OutputFormatXmpWritebackNotSupportedException implements IOutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException {
    derivingCopyFormatIds?: string[] | undefined;

    constructor(data?: IOutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException) {
        super(data);
        this._discriminator = "OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["derivingCopyFormatIds"])) {
                this.derivingCopyFormatIds = [] as any;
                for (let item of _data["derivingCopyFormatIds"])
                    this.derivingCopyFormatIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.derivingCopyFormatIds)) {
            data["derivingCopyFormatIds"] = [];
            for (let item of this.derivingCopyFormatIds)
                data["derivingCopyFormatIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatXmpWritebackDerivedFromCopyFormatNotSupportedException extends IOutputFormatXmpWritebackNotSupportedException {
    derivingCopyFormatIds?: string[] | undefined;
}

export class OutputFormatsInUseException extends PictureparkValidationException implements IOutputFormatsInUseException {
    outputFormatIds?: string[] | undefined;
    dependentOutputFormatIds?: string[] | undefined;

    constructor(data?: IOutputFormatsInUseException) {
        super(data);
        this._discriminator = "OutputFormatsInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["outputFormatIds"])) {
                this.outputFormatIds = [] as any;
                for (let item of _data["outputFormatIds"])
                    this.outputFormatIds!.push(item);
            }
            if (Array.isArray(_data["dependentOutputFormatIds"])) {
                this.dependentOutputFormatIds = [] as any;
                for (let item of _data["dependentOutputFormatIds"])
                    this.dependentOutputFormatIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): OutputFormatsInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatsInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.outputFormatIds)) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        if (Array.isArray(this.dependentOutputFormatIds)) {
            data["dependentOutputFormatIds"] = [];
            for (let item of this.dependentOutputFormatIds)
                data["dependentOutputFormatIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatsInUseException extends IPictureparkValidationException {
    outputFormatIds?: string[] | undefined;
    dependentOutputFormatIds?: string[] | undefined;
}

export class OutputFormatOperationInProgressException extends PictureparkBusinessException implements IOutputFormatOperationInProgressException {

    constructor(data?: IOutputFormatOperationInProgressException) {
        super(data);
        this._discriminator = "OutputFormatOperationInProgressException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputFormatOperationInProgressException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatOperationInProgressException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatOperationInProgressException extends IPictureparkBusinessException {
}

export class StaticOutputFormatModificationNotSupportedException extends PictureparkValidationException implements IStaticOutputFormatModificationNotSupportedException {
    outputFormatId?: string | undefined;
    property?: string | undefined;

    constructor(data?: IStaticOutputFormatModificationNotSupportedException) {
        super(data);
        this._discriminator = "StaticOutputFormatModificationNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
            this.property = _data["property"];
        }
    }

    static override fromJS(data: any): StaticOutputFormatModificationNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new StaticOutputFormatModificationNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        data["property"] = this.property;
        super.toJSON(data);
        return data;
    }
}

export interface IStaticOutputFormatModificationNotSupportedException extends IPictureparkValidationException {
    outputFormatId?: string | undefined;
    property?: string | undefined;
}

export class OriginalOutputFormatModificationNotSupportedException extends PictureparkValidationException implements IOriginalOutputFormatModificationNotSupportedException {

    constructor(data?: IOriginalOutputFormatModificationNotSupportedException) {
        super(data);
        this._discriminator = "OriginalOutputFormatModificationNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OriginalOutputFormatModificationNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalOutputFormatModificationNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOriginalOutputFormatModificationNotSupportedException extends IPictureparkValidationException {
}

export class OutputFormatSourceNotValidForRenderingCategoryException extends PictureparkValidationException implements IOutputFormatSourceNotValidForRenderingCategoryException {
    outputFormatId?: string | undefined;
    sourceFormatId?: string | undefined;
    renderingCategory?: RenderingCategory;

    constructor(data?: IOutputFormatSourceNotValidForRenderingCategoryException) {
        super(data);
        this._discriminator = "OutputFormatSourceNotValidForRenderingCategoryException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
            this.sourceFormatId = _data["sourceFormatId"];
            this.renderingCategory = _data["renderingCategory"];
        }
    }

    static override fromJS(data: any): OutputFormatSourceNotValidForRenderingCategoryException {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSourceNotValidForRenderingCategoryException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        data["sourceFormatId"] = this.sourceFormatId;
        data["renderingCategory"] = this.renderingCategory;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatSourceNotValidForRenderingCategoryException extends IPictureparkValidationException {
    outputFormatId?: string | undefined;
    sourceFormatId?: string | undefined;
    renderingCategory?: RenderingCategory;
}

export class CollectionSizeLimitExceededException extends PictureparkValidationException implements ICollectionSizeLimitExceededException {
    collectionId?: string | undefined;
    limit?: number;

    constructor(data?: ICollectionSizeLimitExceededException) {
        super(data);
        this._discriminator = "CollectionSizeLimitExceededException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collectionId = _data["collectionId"];
            this.limit = _data["limit"];
        }
    }

    static override fromJS(data: any): CollectionSizeLimitExceededException {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionSizeLimitExceededException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionId"] = this.collectionId;
        data["limit"] = this.limit;
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionSizeLimitExceededException extends IPictureparkValidationException {
    collectionId?: string | undefined;
    limit?: number;
}

export class CollectionModificationNotAllowedException extends PictureparkValidationException implements ICollectionModificationNotAllowedException {
    collectionId?: string | undefined;

    constructor(data?: ICollectionModificationNotAllowedException) {
        super(data);
        this._discriminator = "CollectionModificationNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collectionId = _data["collectionId"];
        }
    }

    static override fromJS(data: any): CollectionModificationNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionModificationNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionId"] = this.collectionId;
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionModificationNotAllowedException extends IPictureparkValidationException {
    collectionId?: string | undefined;
}

export class CollectionNotFoundException extends PictureparkNotFoundException implements ICollectionNotFoundException {
    collectionId?: string | undefined;

    constructor(data?: ICollectionNotFoundException) {
        super(data);
        this._discriminator = "CollectionNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collectionId = _data["collectionId"];
        }
    }

    static override fromJS(data: any): CollectionNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionId"] = this.collectionId;
        super.toJSON(data);
        return data;
    }
}

export interface ICollectionNotFoundException extends IPictureparkNotFoundException {
    collectionId?: string | undefined;
}

export class NonDefaultTemplateNameNotAllowedException extends PictureparkValidationException implements INonDefaultTemplateNameNotAllowedException {
    name?: string | undefined;

    constructor(data?: INonDefaultTemplateNameNotAllowedException) {
        super(data);
        this._discriminator = "NonDefaultTemplateNameNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static override fromJS(data: any): NonDefaultTemplateNameNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new NonDefaultTemplateNameNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface INonDefaultTemplateNameNotAllowedException extends IPictureparkValidationException {
    name?: string | undefined;
}

export class SystemTemplateModificationNotAllowedException extends PictureparkValidationException implements ISystemTemplateModificationNotAllowedException {
    templateId?: string | undefined;

    constructor(data?: ISystemTemplateModificationNotAllowedException) {
        super(data);
        this._discriminator = "SystemTemplateModificationNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.templateId = _data["templateId"];
        }
    }

    static override fromJS(data: any): SystemTemplateModificationNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new SystemTemplateModificationNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        super.toJSON(data);
        return data;
    }
}

export interface ISystemTemplateModificationNotAllowedException extends IPictureparkValidationException {
    templateId?: string | undefined;
}

export class TemplateDuplicationException extends PictureparkValidationException implements ITemplateDuplicationException {
    duplicatedTemplateId?: string | undefined;

    constructor(data?: ITemplateDuplicationException) {
        super(data);
        this._discriminator = "TemplateDuplicationException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.duplicatedTemplateId = _data["duplicatedTemplateId"];
        }
    }

    static override fromJS(data: any): TemplateDuplicationException {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDuplicationException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duplicatedTemplateId"] = this.duplicatedTemplateId;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateDuplicationException extends IPictureparkValidationException {
    duplicatedTemplateId?: string | undefined;
}

export class TemplateLanguageCodeNotSupportedException extends PictureparkValidationException implements ITemplateLanguageCodeNotSupportedException {
    languageCode?: string | undefined;
    supportedLanguageCodes?: string[] | undefined;

    constructor(data?: ITemplateLanguageCodeNotSupportedException) {
        super(data);
        this._discriminator = "TemplateLanguageCodeNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.languageCode = _data["languageCode"];
            if (Array.isArray(_data["supportedLanguageCodes"])) {
                this.supportedLanguageCodes = [] as any;
                for (let item of _data["supportedLanguageCodes"])
                    this.supportedLanguageCodes!.push(item);
            }
        }
    }

    static override fromJS(data: any): TemplateLanguageCodeNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateLanguageCodeNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        if (Array.isArray(this.supportedLanguageCodes)) {
            data["supportedLanguageCodes"] = [];
            for (let item of this.supportedLanguageCodes)
                data["supportedLanguageCodes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateLanguageCodeNotSupportedException extends IPictureparkValidationException {
    languageCode?: string | undefined;
    supportedLanguageCodes?: string[] | undefined;
}

export class TemplateMediaTypesMissingException extends PictureparkValidationException implements ITemplateMediaTypesMissingException {
    requiredMediaTypes?: string[] | undefined;

    constructor(data?: ITemplateMediaTypesMissingException) {
        super(data);
        this._discriminator = "TemplateMediaTypesMissingException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["requiredMediaTypes"])) {
                this.requiredMediaTypes = [] as any;
                for (let item of _data["requiredMediaTypes"])
                    this.requiredMediaTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): TemplateMediaTypesMissingException {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateMediaTypesMissingException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requiredMediaTypes)) {
            data["requiredMediaTypes"] = [];
            for (let item of this.requiredMediaTypes)
                data["requiredMediaTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateMediaTypesMissingException extends IPictureparkValidationException {
    requiredMediaTypes?: string[] | undefined;
}

export class TemplateMediaTypesNotSupportedException extends PictureparkValidationException implements ITemplateMediaTypesNotSupportedException {
    unsupportedMediaTypes?: string[] | undefined;

    constructor(data?: ITemplateMediaTypesNotSupportedException) {
        super(data);
        this._discriminator = "TemplateMediaTypesNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["unsupportedMediaTypes"])) {
                this.unsupportedMediaTypes = [] as any;
                for (let item of _data["unsupportedMediaTypes"])
                    this.unsupportedMediaTypes!.push(item);
            }
        }
    }

    static override fromJS(data: any): TemplateMediaTypesNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateMediaTypesNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.unsupportedMediaTypes)) {
            data["unsupportedMediaTypes"] = [];
            for (let item of this.unsupportedMediaTypes)
                data["unsupportedMediaTypes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateMediaTypesNotSupportedException extends IPictureparkValidationException {
    unsupportedMediaTypes?: string[] | undefined;
}

export class TemplateNotFoundException extends PictureparkNotFoundException implements ITemplateNotFoundException {

    constructor(data?: ITemplateNotFoundException) {
        super(data);
        this._discriminator = "TemplateNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TemplateNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateNotFoundException extends IPictureparkNotFoundException {
}

export class XmpMappingFieldNotSupported extends PictureparkValidationException implements IXmpMappingFieldNotSupported {
    fieldPath?: string | undefined;

    constructor(data?: IXmpMappingFieldNotSupported) {
        super(data);
        this._discriminator = "XmpMappingFieldNotSupported";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): XmpMappingFieldNotSupported {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingFieldNotSupported();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingFieldNotSupported extends IPictureparkValidationException {
    fieldPath?: string | undefined;
}

export class XmpMappingFieldNotFoundException extends PictureparkValidationException implements IXmpMappingFieldNotFoundException {
    fieldPath?: string | undefined;

    constructor(data?: IXmpMappingFieldNotFoundException) {
        super(data);
        this._discriminator = "XmpMappingFieldNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): XmpMappingFieldNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingFieldNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingFieldNotFoundException extends IPictureparkValidationException {
    fieldPath?: string | undefined;
}

export class XmpMappingSchemaNotAvailableForFileContentSchemaException extends PictureparkValidationException implements IXmpMappingSchemaNotAvailableForFileContentSchemaException {
    schemaId?: string | undefined;

    constructor(data?: IXmpMappingSchemaNotAvailableForFileContentSchemaException) {
        super(data);
        this._discriminator = "XmpMappingSchemaNotAvailableForFileContentSchemaException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): XmpMappingSchemaNotAvailableForFileContentSchemaException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingSchemaNotAvailableForFileContentSchemaException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingSchemaNotAvailableForFileContentSchemaException extends IPictureparkValidationException {
    schemaId?: string | undefined;
}

export class XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException extends PictureparkValidationException implements IXmpMappingFieldToLayerWithRequiredFieldsNotAllowedException {
    layerId?: string | undefined;

    constructor(data?: IXmpMappingFieldToLayerWithRequiredFieldsNotAllowedException) {
        super(data);
        this._discriminator = "XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
        }
    }

    static override fromJS(data: any): XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingFieldToLayerWithRequiredFieldsNotAllowedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingFieldToLayerWithRequiredFieldsNotAllowedException extends IPictureparkValidationException {
    layerId?: string | undefined;
}

export class XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException extends PictureparkValidationException implements IXmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException {
    layerId?: string | undefined;

    constructor(data?: IXmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException) {
        super(data);
        this._discriminator = "XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
        }
    }

    static override fromJS(data: any): XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingFieldToLayerWithMetadataProtectionForCreateOrUpdateNotSupportedException extends IPictureparkValidationException {
    layerId?: string | undefined;
}

export class XmpMappingFieldInUseException extends PictureparkValidationException implements IXmpMappingFieldInUseException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;

    constructor(data?: IXmpMappingFieldInUseException) {
        super(data);
        this._discriminator = "XmpMappingFieldInUseException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.fieldId = _data["fieldId"];
        }
    }

    static override fromJS(data: any): XmpMappingFieldInUseException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingFieldInUseException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["fieldId"] = this.fieldId;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingFieldInUseException extends IPictureparkValidationException {
    schemaId?: string | undefined;
    fieldId?: string | undefined;
}

export class XmpMappingConfigurationInvalidException extends PictureparkValidationException implements IXmpMappingConfigurationInvalidException {
    fieldPath?: string | undefined;
    expectedConfiguration?: string | undefined;

    constructor(data?: IXmpMappingConfigurationInvalidException) {
        super(data);
        this._discriminator = "XmpMappingConfigurationInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.expectedConfiguration = _data["expectedConfiguration"];
        }
    }

    static override fromJS(data: any): XmpMappingConfigurationInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingConfigurationInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["expectedConfiguration"] = this.expectedConfiguration;
        super.toJSON(data);
        return data;
    }
}

export interface IXmpMappingConfigurationInvalidException extends IPictureparkValidationException {
    fieldPath?: string | undefined;
    expectedConfiguration?: string | undefined;
}

export class ActivityMappingInvalidException extends PictureparkValidationException implements IActivityMappingInvalidException {
    activityMapping?: string | undefined;

    constructor(data?: IActivityMappingInvalidException) {
        super(data);
        this._discriminator = "ActivityMappingInvalidException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.activityMapping = _data["activityMapping"];
        }
    }

    static override fromJS(data: any): ActivityMappingInvalidException {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityMappingInvalidException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityMapping"] = this.activityMapping;
        super.toJSON(data);
        return data;
    }
}

export interface IActivityMappingInvalidException extends IPictureparkValidationException {
    activityMapping?: string | undefined;
}

export abstract class StatisticsFeatureNotEnabledException extends PictureparkValidationException implements IStatisticsFeatureNotEnabledException {
    scope?: string | undefined;

    constructor(data?: IStatisticsFeatureNotEnabledException) {
        super(data);
        this._discriminator = "StatisticsFeatureNotEnabledException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.scope = _data["scope"];
        }
    }

    static override fromJS(data: any): StatisticsFeatureNotEnabledException {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "StatisticsExportNotEnabledException") {
            let result = new StatisticsExportNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsReadNotEnabledException") {
            let result = new StatisticsReadNotEnabledException();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StatisticsWriteNotEnabledException") {
            let result = new StatisticsWriteNotEnabledException();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'StatisticsFeatureNotEnabledException' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        super.toJSON(data);
        return data;
    }
}

export interface IStatisticsFeatureNotEnabledException extends IPictureparkValidationException {
    scope?: string | undefined;
}

export class StatisticsExportNotEnabledException extends StatisticsFeatureNotEnabledException implements IStatisticsExportNotEnabledException {

    constructor(data?: IStatisticsExportNotEnabledException) {
        super(data);
        this._discriminator = "StatisticsExportNotEnabledException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StatisticsExportNotEnabledException {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsExportNotEnabledException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStatisticsExportNotEnabledException extends IStatisticsFeatureNotEnabledException {
}

export class StatisticsReadNotEnabledException extends StatisticsFeatureNotEnabledException implements IStatisticsReadNotEnabledException {

    constructor(data?: IStatisticsReadNotEnabledException) {
        super(data);
        this._discriminator = "StatisticsReadNotEnabledException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StatisticsReadNotEnabledException {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsReadNotEnabledException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStatisticsReadNotEnabledException extends IStatisticsFeatureNotEnabledException {
}

export class StatisticsWriteNotEnabledException extends StatisticsFeatureNotEnabledException implements IStatisticsWriteNotEnabledException {

    constructor(data?: IStatisticsWriteNotEnabledException) {
        super(data);
        this._discriminator = "StatisticsWriteNotEnabledException";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): StatisticsWriteNotEnabledException {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsWriteNotEnabledException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IStatisticsWriteNotEnabledException extends IStatisticsFeatureNotEnabledException {
}

export class ConversionPresetTemplateNotFoundException extends PictureparkNotFoundException implements IConversionPresetTemplateNotFoundException {
    conversionPresetTemplateId?: string | undefined;

    constructor(data?: IConversionPresetTemplateNotFoundException) {
        super(data);
        this._discriminator = "ConversionPresetTemplateNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.conversionPresetTemplateId = _data["conversionPresetTemplateId"];
        }
    }

    static override fromJS(data: any): ConversionPresetTemplateNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conversionPresetTemplateId"] = this.conversionPresetTemplateId;
        super.toJSON(data);
        return data;
    }
}

export interface IConversionPresetTemplateNotFoundException extends IPictureparkNotFoundException {
    conversionPresetTemplateId?: string | undefined;
}

export class CommentNotFoundException extends PictureparkNotFoundException implements ICommentNotFoundException {
    id?: string | undefined;

    constructor(data?: ICommentNotFoundException) {
        super(data);
        this._discriminator = "CommentNotFoundException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): CommentNotFoundException {
        data = typeof data === 'object' ? data : {};
        let result = new CommentNotFoundException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentNotFoundException extends IPictureparkNotFoundException {
    id?: string | undefined;
}

export class CommentOwnershipFailureException extends PictureparkValidationException implements ICommentOwnershipFailureException {
    commentId?: string | undefined;

    constructor(data?: ICommentOwnershipFailureException) {
        super(data);
        this._discriminator = "CommentOwnershipFailureException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commentId = _data["commentId"];
        }
    }

    static override fromJS(data: any): CommentOwnershipFailureException {
        data = typeof data === 'object' ? data : {};
        let result = new CommentOwnershipFailureException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentOwnershipFailureException extends IPictureparkValidationException {
    commentId?: string | undefined;
}

export class CommentReplyDeletionException extends PictureparkValidationException implements ICommentReplyDeletionException {
    commentId?: string | undefined;

    constructor(data?: ICommentReplyDeletionException) {
        super(data);
        this._discriminator = "CommentReplyDeletionException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.commentId = _data["commentId"];
        }
    }

    static override fromJS(data: any): CommentReplyDeletionException {
        data = typeof data === 'object' ? data : {};
        let result = new CommentReplyDeletionException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentReplyDeletionException extends IPictureparkValidationException {
    commentId?: string | undefined;
}

export class CommentReplyParentException extends PictureparkValidationException implements ICommentReplyParentException {
    parentId?: string | undefined;

    constructor(data?: ICommentReplyParentException) {
        super(data);
        this._discriminator = "CommentReplyParentException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentId = _data["parentId"];
        }
    }

    static override fromJS(data: any): CommentReplyParentException {
        data = typeof data === 'object' ? data : {};
        let result = new CommentReplyParentException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentReplyParentException extends IPictureparkValidationException {
    parentId?: string | undefined;
}

export class CommentReplyContentMismatchException extends PictureparkValidationException implements ICommentReplyContentMismatchException {
    parentId?: string | undefined;
    contentId?: string | undefined;

    constructor(data?: ICommentReplyContentMismatchException) {
        super(data);
        this._discriminator = "CommentReplyContentMismatchException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentId = _data["parentId"];
            this.contentId = _data["contentId"];
        }
    }

    static override fromJS(data: any): CommentReplyContentMismatchException {
        data = typeof data === 'object' ? data : {};
        let result = new CommentReplyContentMismatchException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentReplyContentMismatchException extends IPictureparkValidationException {
    parentId?: string | undefined;
    contentId?: string | undefined;
}

export class VirtualDisplayContentNotSupportedException extends PictureparkNotFoundException implements IVirtualDisplayContentNotSupportedException {
    contentIds?: string[] | undefined;

    constructor(data?: IVirtualDisplayContentNotSupportedException) {
        super(data);
        this._discriminator = "VirtualDisplayContentNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): VirtualDisplayContentNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualDisplayContentNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVirtualDisplayContentNotSupportedException extends IPictureparkNotFoundException {
    contentIds?: string[] | undefined;
}

export class SelfReferencingDisplayContentNotSupportedException extends PictureparkValidationException implements ISelfReferencingDisplayContentNotSupportedException {
    contentIds?: string[] | undefined;

    constructor(data?: ISelfReferencingDisplayContentNotSupportedException) {
        super(data);
        this._discriminator = "SelfReferencingDisplayContentNotSupportedException";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): SelfReferencingDisplayContentNotSupportedException {
        data = typeof data === 'object' ? data : {};
        let result = new SelfReferencingDisplayContentNotSupportedException();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISelfReferencingDisplayContentNotSupportedException extends IPictureparkValidationException {
    contentIds?: string[] | undefined;
}

/** Create request to create a BusinessProcess. */
export class BusinessProcessCreateRequest implements IBusinessProcessCreateRequest {
    /** Indicates if the system starting the business process supports cancellation. */
    supportsCancellation!: boolean;
    /** Notification data to send to the user when creating the business process.
Set to null to not create a notification. */
    notification?: BusinessProcessNotificationUpdate | undefined;
    /** Initial state of the business process. */
    initialState!: string;

    constructor(data?: IBusinessProcessCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.notification = data.notification && !(<any>data.notification).toJSON ? new BusinessProcessNotificationUpdate(data.notification) : <BusinessProcessNotificationUpdate>this.notification;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supportsCancellation = _data["supportsCancellation"];
            this.notification = _data["notification"] ? BusinessProcessNotificationUpdate.fromJS(_data["notification"]) : <any>undefined;
            this.initialState = _data["initialState"];
        }
    }

    static fromJS(data: any): BusinessProcessCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportsCancellation"] = this.supportsCancellation;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["initialState"] = this.initialState;
        return data;
    }
}

/** Create request to create a BusinessProcess. */
export interface IBusinessProcessCreateRequest {
    /** Indicates if the system starting the business process supports cancellation. */
    supportsCancellation: boolean;
    /** Notification data to send to the user when creating the business process.
Set to null to not create a notification. */
    notification?: IBusinessProcessNotificationUpdate | undefined;
    /** Initial state of the business process. */
    initialState: string;
}

/** Notification update for a business process. */
export class BusinessProcessNotificationUpdate implements IBusinessProcessNotificationUpdate {
    /** The title the message that is shown to the user should have. */
    title!: TranslatedStringDictionary;
    /** The message shown to the user. */
    message!: TranslatedStringDictionary;
    /** An optional navigation link that allows the user to jump to a page giving more information
about the process. */
    navigationLink?: string | undefined;
    /** The event type of the notification. */
    eventType!: NotificationEventType;

    constructor(data?: IBusinessProcessNotificationUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.title = data.title && !(<any>data.title).toJSON ? new TranslatedStringDictionary(data.title) : <TranslatedStringDictionary>this.title;
            this.message = data.message && !(<any>data.message).toJSON ? new TranslatedStringDictionary(data.message) : <TranslatedStringDictionary>this.message;
        }
        if (!data) {
            this.title = new TranslatedStringDictionary();
            this.message = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] ? TranslatedStringDictionary.fromJS(_data["title"]) : new TranslatedStringDictionary();
            this.message = _data["message"] ? TranslatedStringDictionary.fromJS(_data["message"]) : new TranslatedStringDictionary();
            this.navigationLink = _data["navigationLink"];
            this.eventType = _data["eventType"];
        }
    }

    static fromJS(data: any): BusinessProcessNotificationUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotificationUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["navigationLink"] = this.navigationLink;
        data["eventType"] = this.eventType;
        return data;
    }
}

/** Notification update for a business process. */
export interface IBusinessProcessNotificationUpdate {
    /** The title the message that is shown to the user should have. */
    title: ITranslatedStringDictionary;
    /** The message shown to the user. */
    message: ITranslatedStringDictionary;
    /** An optional navigation link that allows the user to jump to a page giving more information
about the process. */
    navigationLink?: string | undefined;
    /** The event type of the notification. */
    eventType: NotificationEventType;
}

/** A custom dictionary type to distinguish language specific class properties. */
export class TranslatedStringDictionary implements ITranslatedStringDictionary {

    [key: string]: string | any;

    translate(locale: string) {
    const language = locale.split('-')[0];
    return this[language] ? this[language] : this[Object.keys(this)[0]];
  }

    constructor(data?: ITranslatedStringDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): TranslatedStringDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new TranslatedStringDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** A custom dictionary type to distinguish language specific class properties. */
export interface ITranslatedStringDictionary {

    [key: string]: string | any;
}

export enum NotificationEventType {
    Pending = "Pending",
    InProgress = "InProgress",
    Success = "Success",
    Error = "Error",
    Warning = "Warning",
    Information = "Information",
}

/** Transitions the business process to a new state and/or life cycle. */
export class BusinessProcessStateChangeRequest implements IBusinessProcessStateChangeRequest {
    /** The new state of the business process. */
    state!: string;
    /** The new life cycle of the business process. */
    lifeCycle!: BusinessProcessLifeCycle;
    /** An optional notification update to be posted together with the transition. */
    notification?: BusinessProcessNotificationUpdate | undefined;

    constructor(data?: IBusinessProcessStateChangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.notification = data.notification && !(<any>data.notification).toJSON ? new BusinessProcessNotificationUpdate(data.notification) : <BusinessProcessNotificationUpdate>this.notification;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.lifeCycle = _data["lifeCycle"];
            this.notification = _data["notification"] ? BusinessProcessNotificationUpdate.fromJS(_data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessStateChangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessStateChangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["lifeCycle"] = this.lifeCycle;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data;
    }
}

/** Transitions the business process to a new state and/or life cycle. */
export interface IBusinessProcessStateChangeRequest {
    /** The new state of the business process. */
    state: string;
    /** The new life cycle of the business process. */
    lifeCycle: BusinessProcessLifeCycle;
    /** An optional notification update to be posted together with the transition. */
    notification?: IBusinessProcessNotificationUpdate | undefined;
}

/** Updates the notification of a business process without changing the state or the life cycle. */
export class BusinessProcessNotificationUpdateRequest extends BusinessProcessNotificationUpdate implements IBusinessProcessNotificationUpdateRequest {

    constructor(data?: IBusinessProcessNotificationUpdateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessProcessNotificationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessNotificationUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Updates the notification of a business process without changing the state or the life cycle. */
export interface IBusinessProcessNotificationUpdateRequest extends IBusinessProcessNotificationUpdate {
}

/** Result from waiting for state(s) on a business process */
export class BusinessProcessWaitForStateResult implements IBusinessProcessWaitForStateResult {
    /** The state that was hit. */
    stateHit?: string | undefined;
    /** The business process. */
    businessProcess!: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForStateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stateHit = _data["stateHit"];
            this.businessProcess = _data["businessProcess"] ? BusinessProcess.fromJS(_data["businessProcess"]) : new BusinessProcess();
        }
    }

    static fromJS(data: any): BusinessProcessWaitForStateResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForStateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stateHit"] = this.stateHit;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data;
    }
}

/** Result from waiting for state(s) on a business process */
export interface IBusinessProcessWaitForStateResult {
    /** The state that was hit. */
    stateHit?: string | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Result from waiting for life cycle(s) on a business process */
export class BusinessProcessWaitForLifeCycleResult implements IBusinessProcessWaitForLifeCycleResult {
    /** The life cycle that was hit. */
    lifeCycleHit?: BusinessProcessLifeCycle | undefined;
    /** The business process. */
    businessProcess!: BusinessProcess;

    constructor(data?: IBusinessProcessWaitForLifeCycleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.businessProcess = new BusinessProcess();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lifeCycleHit = _data["lifeCycleHit"];
            this.businessProcess = _data["businessProcess"] ? BusinessProcess.fromJS(_data["businessProcess"]) : new BusinessProcess();
        }
    }

    static fromJS(data: any): BusinessProcessWaitForLifeCycleResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessWaitForLifeCycleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lifeCycleHit"] = this.lifeCycleHit;
        data["businessProcess"] = this.businessProcess ? this.businessProcess.toJSON() : <any>undefined;
        return data;
    }
}

/** Result from waiting for life cycle(s) on a business process */
export interface IBusinessProcessWaitForLifeCycleResult {
    /** The life cycle that was hit. */
    lifeCycleHit?: BusinessProcessLifeCycle | undefined;
    /** The business process. */
    businessProcess: BusinessProcess;
}

/** Detailed representation of a business process */
export class BusinessProcessDetails extends BusinessProcess implements IBusinessProcessDetails {
    /** Details for the business process. */
    details?: BusinessProcessDetailsDataBase | undefined;

    constructor(data?: IBusinessProcessDetails) {
        super(data);
        this._discriminator = "BusinessProcessDetails";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.details = _data["details"] ? BusinessProcessDetailsDataBase.fromJS(_data["details"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BusinessProcessDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Detailed representation of a business process */
export interface IBusinessProcessDetails extends IBusinessProcess {
    /** Details for the business process. */
    details?: BusinessProcessDetailsDataBase | undefined;
}

/** Base class for the details of a business process */
export abstract class BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBase {

    protected _discriminator: string;

    constructor(data?: IBusinessProcessDetailsDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessDetailsDataBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BusinessProcessDetailsDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessDetailsDataBatchResponse") {
            let result = new BusinessProcessDetailsDataBatchResponse();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataSchemaImport") {
            let result = new BusinessProcessDetailsDataSchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessDetailsDataContentImport") {
            let result = new BusinessProcessDetailsDataContentImport();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessProcessDetailsDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** Base class for the details of a business process */
export interface IBusinessProcessDetailsDataBase {
}

/** Business process detailed information regarding a batch operation */
export class BusinessProcessDetailsDataBatchResponse extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataBatchResponse {
    /** The DocType on which the operation was performed. */
    docType!: string;
    /** The response of the batch operation. */
    response!: BatchResponse;

    constructor(data?: IBusinessProcessDetailsDataBatchResponse) {
        super(data);
        if (data) {
            this.response = data.response && !(<any>data.response).toJSON ? new BatchResponse(data.response) : <BatchResponse>this.response;
        }
        if (!data) {
            this.response = new BatchResponse();
        }
        this._discriminator = "BusinessProcessDetailsDataBatchResponse";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.docType = _data["docType"];
            this.response = _data["response"] ? BatchResponse.fromJS(_data["response"]) : new BatchResponse();
        }
    }

    static override fromJS(data: any): BusinessProcessDetailsDataBatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataBatchResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Business process detailed information regarding a batch operation */
export interface IBusinessProcessDetailsDataBatchResponse extends IBusinessProcessDetailsDataBase {
    /** The DocType on which the operation was performed. */
    docType: string;
    /** The response of the batch operation. */
    response: IBatchResponse;
}

/** Response from a batch operation */
export class BatchResponse implements IBatchResponse {
    /** Rows in the response. */
    rows!: BatchResponseRow[];

    constructor(data?: IBatchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rows) {
                this.rows = [];
                for (let i = 0; i < data.rows.length; i++) {
                    let item = data.rows[i];
                    this.rows[i] = item && !(<any>item).toJSON ? new BatchResponseRow(item) : <BatchResponseRow>item;
                }
            }
        }
        if (!data) {
            this.rows = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(BatchResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data;
    }
}

/** Response from a batch operation */
export interface IBatchResponse {
    /** Rows in the response. */
    rows: IBatchResponseRow[];
}

/** Row in a batch operation response */
export class BatchResponseRow implements IBatchResponseRow {
    /** Id of the item. */
    id!: string;
    /** Indicates if the operation succeeded. */
    succeeded!: boolean;
    /** Status code of the operation. */
    status!: number;
    /** New version of the item. */
    version!: number;
    /** If the operation did not succeed, this contains error information. */
    error?: ErrorResponse | undefined;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;

    constructor(data?: IBatchResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.succeeded = _data["succeeded"];
            this.status = _data["status"];
            this.version = _data["version"];
            this.error = _data["error"] ? ErrorResponse.fromJS(_data["error"]) : <any>undefined;
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): BatchResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BatchResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["succeeded"] = this.succeeded;
        data["status"] = this.status;
        data["version"] = this.version;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Row in a batch operation response */
export interface IBatchResponseRow {
    /** Id of the item. */
    id: string;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** Status code of the operation. */
    status: number;
    /** New version of the item. */
    version: number;
    /** If the operation did not succeed, this contains error information. */
    error?: IErrorResponse | undefined;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

/** Business process detailed information regarding Schema / ListItems import operation */
export class BusinessProcessDetailsDataSchemaImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataSchemaImport {
    /** Result information of a schema import operation */
    schemaImportResult?: SchemaImportResult | undefined;
    /** Result information of a list item import operation */
    listItemImportResult?: ListItemImportResult | undefined;

    constructor(data?: IBusinessProcessDetailsDataSchemaImport) {
        super(data);
        if (data) {
            this.schemaImportResult = data.schemaImportResult && !(<any>data.schemaImportResult).toJSON ? new SchemaImportResult(data.schemaImportResult) : <SchemaImportResult>this.schemaImportResult;
            this.listItemImportResult = data.listItemImportResult && !(<any>data.listItemImportResult).toJSON ? new ListItemImportResult(data.listItemImportResult) : <ListItemImportResult>this.listItemImportResult;
        }
        this._discriminator = "BusinessProcessDetailsDataSchemaImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaImportResult = _data["schemaImportResult"] ? SchemaImportResult.fromJS(_data["schemaImportResult"]) : <any>undefined;
            this.listItemImportResult = _data["listItemImportResult"] ? ListItemImportResult.fromJS(_data["listItemImportResult"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BusinessProcessDetailsDataSchemaImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataSchemaImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaImportResult"] = this.schemaImportResult ? this.schemaImportResult.toJSON() : <any>undefined;
        data["listItemImportResult"] = this.listItemImportResult ? this.listItemImportResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Business process detailed information regarding Schema / ListItems import operation */
export interface IBusinessProcessDetailsDataSchemaImport extends IBusinessProcessDetailsDataBase {
    /** Result information of a schema import operation */
    schemaImportResult?: ISchemaImportResult | undefined;
    /** Result information of a list item import operation */
    listItemImportResult?: IListItemImportResult | undefined;
}

/** Result information of a schema import operation */
export class SchemaImportResult implements ISchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount!: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount!: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount!: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[] | undefined;
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[] | undefined;

    constructor(data?: ISchemaImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importedSchemaCount = _data["importedSchemaCount"];
            this.skippedSchemaCount = _data["skippedSchemaCount"];
            this.totalSchemaCount = _data["totalSchemaCount"];
            if (Array.isArray(_data["skippedSchemaIds"])) {
                this.skippedSchemaIds = [] as any;
                for (let item of _data["skippedSchemaIds"])
                    this.skippedSchemaIds!.push(item);
            }
            if (Array.isArray(_data["importedSchemaIds"])) {
                this.importedSchemaIds = [] as any;
                for (let item of _data["importedSchemaIds"])
                    this.importedSchemaIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SchemaImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importedSchemaCount"] = this.importedSchemaCount;
        data["skippedSchemaCount"] = this.skippedSchemaCount;
        data["totalSchemaCount"] = this.totalSchemaCount;
        if (Array.isArray(this.skippedSchemaIds)) {
            data["skippedSchemaIds"] = [];
            for (let item of this.skippedSchemaIds)
                data["skippedSchemaIds"].push(item);
        }
        if (Array.isArray(this.importedSchemaIds)) {
            data["importedSchemaIds"] = [];
            for (let item of this.importedSchemaIds)
                data["importedSchemaIds"].push(item);
        }
        return data;
    }
}

/** Result information of a schema import operation */
export interface ISchemaImportResult {
    /** Number of schemas imported */
    importedSchemaCount: number;
    /** Number of schema skipped during import phase because they were already found in the system */
    skippedSchemaCount: number;
    /** Total number of schemas requested to be imported */
    totalSchemaCount: number;
    /** Ids of the schemas that were not imported because already found in the system */
    skippedSchemaIds?: string[] | undefined;
    /** Ids of the schemas that were successfully imported */
    importedSchemaIds?: string[] | undefined;
}

/** Result information of a list item import operation */
export class ListItemImportResult implements IListItemImportResult {
    /** Number of list items imported */
    importedListItemCount!: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount!: number;
    /** Total number of list items requested to be imported */
    totalListItemCount!: number;
    /** Ids of the list items that were not imported because already found in the system or due to errors */
    skippedListItemIds?: string[] | undefined;
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[] | undefined;

    constructor(data?: IListItemImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importedListItemCount = _data["importedListItemCount"];
            this.skippedListItemCount = _data["skippedListItemCount"];
            this.totalListItemCount = _data["totalListItemCount"];
            if (Array.isArray(_data["skippedListItemIds"])) {
                this.skippedListItemIds = [] as any;
                for (let item of _data["skippedListItemIds"])
                    this.skippedListItemIds!.push(item);
            }
            if (Array.isArray(_data["importedListItemIds"])) {
                this.importedListItemIds = [] as any;
                for (let item of _data["importedListItemIds"])
                    this.importedListItemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ListItemImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importedListItemCount"] = this.importedListItemCount;
        data["skippedListItemCount"] = this.skippedListItemCount;
        data["totalListItemCount"] = this.totalListItemCount;
        if (Array.isArray(this.skippedListItemIds)) {
            data["skippedListItemIds"] = [];
            for (let item of this.skippedListItemIds)
                data["skippedListItemIds"].push(item);
        }
        if (Array.isArray(this.importedListItemIds)) {
            data["importedListItemIds"] = [];
            for (let item of this.importedListItemIds)
                data["importedListItemIds"].push(item);
        }
        return data;
    }
}

/** Result information of a list item import operation */
export interface IListItemImportResult {
    /** Number of list items imported */
    importedListItemCount: number;
    /** Number of list items skipped during import phase because they were already found in the system */
    skippedListItemCount: number;
    /** Total number of list items requested to be imported */
    totalListItemCount: number;
    /** Ids of the list items that were not imported because already found in the system or due to errors */
    skippedListItemIds?: string[] | undefined;
    /** Ids of the list items that were successfully imported */
    importedListItemIds?: string[] | undefined;
}

export class BusinessProcessDetailsDataContentImport extends BusinessProcessDetailsDataBase implements IBusinessProcessDetailsDataContentImport {
    /** Items that were imported. */
    items?: ContentImportResult[] | undefined;

    constructor(data?: IBusinessProcessDetailsDataContentImport) {
        super(data);
        if (data) {
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentImportResult(item) : <ContentImportResult>item;
                }
            }
        }
        this._discriminator = "BusinessProcessDetailsDataContentImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentImportResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessProcessDetailsDataContentImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessDetailsDataContentImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessDetailsDataContentImport extends IBusinessProcessDetailsDataBase {
    /** Items that were imported. */
    items?: IContentImportResult[] | undefined;
}

/** Represents an item imported during a content import */
export class ContentImportResult implements IContentImportResult {
    /** ID of the file transfer. */
    fileTransferId!: string;
    /** ID of the resulting content. */
    contentId?: string | undefined;
    /** State of the item. */
    state?: string | undefined;
    /** Indicates if the operation succeeded. */
    succeeded!: boolean;
    /** If the operation did not succeeded, this contains error related information. */
    error?: ErrorResponse | undefined;

    constructor(data?: IContentImportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileTransferId = _data["fileTransferId"];
            this.contentId = _data["contentId"];
            this.state = _data["state"];
            this.succeeded = _data["succeeded"];
            this.error = _data["error"] ? ErrorResponse.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentImportResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentImportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        data["contentId"] = this.contentId;
        data["state"] = this.state;
        data["succeeded"] = this.succeeded;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents an item imported during a content import */
export interface IContentImportResult {
    /** ID of the file transfer. */
    fileTransferId: string;
    /** ID of the resulting content. */
    contentId?: string | undefined;
    /** State of the item. */
    state?: string | undefined;
    /** Indicates if the operation succeeded. */
    succeeded: boolean;
    /** If the operation did not succeeded, this contains error related information. */
    error?: IErrorResponse | undefined;
}

export class BusinessProcessSummaryBase implements IBusinessProcessSummaryBase {

    protected _discriminator: string;

    constructor(data?: IBusinessProcessSummaryBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessSummaryBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BusinessProcessSummaryBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessSummarySchemaImport") {
            let result = new BusinessProcessSummarySchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessSummaryBatchBased") {
            let result = new BusinessProcessSummaryBatchBased();
            result.init(data);
            return result;
        }
        let result = new BusinessProcessSummaryBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface IBusinessProcessSummaryBase {
}

export class BusinessProcessSummarySchemaImport extends BusinessProcessSummaryBase implements IBusinessProcessSummarySchemaImport {
    /** The result of the import schema operation */
    schemaImportResult?: SchemaImportResult | undefined;
    /** The result of the import list item operation */
    listItemImportResult?: ListItemImportResult | undefined;

    constructor(data?: IBusinessProcessSummarySchemaImport) {
        super(data);
        if (data) {
            this.schemaImportResult = data.schemaImportResult && !(<any>data.schemaImportResult).toJSON ? new SchemaImportResult(data.schemaImportResult) : <SchemaImportResult>this.schemaImportResult;
            this.listItemImportResult = data.listItemImportResult && !(<any>data.listItemImportResult).toJSON ? new ListItemImportResult(data.listItemImportResult) : <ListItemImportResult>this.listItemImportResult;
        }
        this._discriminator = "BusinessProcessSummarySchemaImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaImportResult = _data["schemaImportResult"] ? SchemaImportResult.fromJS(_data["schemaImportResult"]) : <any>undefined;
            this.listItemImportResult = _data["listItemImportResult"] ? ListItemImportResult.fromJS(_data["listItemImportResult"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BusinessProcessSummarySchemaImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSummarySchemaImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaImportResult"] = this.schemaImportResult ? this.schemaImportResult.toJSON() : <any>undefined;
        data["listItemImportResult"] = this.listItemImportResult ? this.listItemImportResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessSummarySchemaImport extends IBusinessProcessSummaryBase {
    /** The result of the import schema operation */
    schemaImportResult?: ISchemaImportResult | undefined;
    /** The result of the import list item operation */
    listItemImportResult?: IListItemImportResult | undefined;
}

export class BusinessProcessSummaryBatchBased extends BusinessProcessSummaryBase implements IBusinessProcessSummaryBatchBased {
    /** Succeeded item count. */
    succeededItemCount?: number;
    /** Failed item count. */
    failedItemCount?: number;
    /** Document type that was changed in the business process. */
    docType?: string | undefined;

    constructor(data?: IBusinessProcessSummaryBatchBased) {
        super(data);
        this._discriminator = "BusinessProcessSummaryBatchBased";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.succeededItemCount = _data["succeededItemCount"];
            this.failedItemCount = _data["failedItemCount"];
            this.docType = _data["docType"];
        }
    }

    static override fromJS(data: any): BusinessProcessSummaryBatchBased {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSummaryBatchBased();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeededItemCount"] = this.succeededItemCount;
        data["failedItemCount"] = this.failedItemCount;
        data["docType"] = this.docType;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessSummaryBatchBased extends IBusinessProcessSummaryBase {
    /** Succeeded item count. */
    succeededItemCount?: number;
    /** Failed item count. */
    failedItemCount?: number;
    /** Document type that was changed in the business process. */
    docType?: string | undefined;
}

export class BusinessProcessBatch implements IBusinessProcessBatch {
    pageToken?: string | undefined;
    data?: BusinessProcessBatchItemBase | undefined;

    constructor(data?: IBusinessProcessBatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageToken = _data["pageToken"];
            this.data = _data["data"] ? BusinessProcessBatchItemBase.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessProcessBatch {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessBatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageToken"] = this.pageToken;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBusinessProcessBatch {
    pageToken?: string | undefined;
    data?: BusinessProcessBatchItemBase | undefined;
}

export abstract class BusinessProcessBatchItemBase implements IBusinessProcessBatchItemBase {

    protected _discriminator: string;

    constructor(data?: IBusinessProcessBatchItemBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BusinessProcessBatchItemBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BusinessProcessBatchItemBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessProcessBatchItemBatchResponse") {
            let result = new BusinessProcessBatchItemBatchResponse();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessBatchItemContentImport") {
            let result = new BusinessProcessBatchItemContentImport();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessProcessBatchItemBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface IBusinessProcessBatchItemBase {
}

export class BusinessProcessBatchItemBatchResponse extends BusinessProcessBatchItemBase implements IBusinessProcessBatchItemBatchResponse {
    docType?: string | undefined;
    items?: BatchResponseRow[] | undefined;

    constructor(data?: IBusinessProcessBatchItemBatchResponse) {
        super(data);
        if (data) {
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new BatchResponseRow(item) : <BatchResponseRow>item;
                }
            }
        }
        this._discriminator = "BusinessProcessBatchItemBatchResponse";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.docType = _data["docType"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatchResponseRow.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessProcessBatchItemBatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessBatchItemBatchResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docType"] = this.docType;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessBatchItemBatchResponse extends IBusinessProcessBatchItemBase {
    docType?: string | undefined;
    items?: IBatchResponseRow[] | undefined;
}

export class BusinessProcessBatchItemContentImport extends BusinessProcessBatchItemBase implements IBusinessProcessBatchItemContentImport {
    items?: ContentImportResult[] | undefined;

    constructor(data?: IBusinessProcessBatchItemContentImport) {
        super(data);
        if (data) {
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentImportResult(item) : <ContentImportResult>item;
                }
            }
        }
        this._discriminator = "BusinessProcessBatchItemContentImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentImportResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessProcessBatchItemContentImport {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessBatchItemContentImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessBatchItemContentImport extends IBusinessProcessBatchItemBase {
    items?: IContentImportResult[] | undefined;
}

/** Base class for search results */
export class BaseResultOfBusinessProcess implements IBaseResultOfBusinessProcess {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: BusinessProcess[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfBusinessProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BusinessProcess.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfBusinessProcess {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: BusinessProcess[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfBusinessProcess extends BaseResultOfBusinessProcess implements ISearchBehaviorBaseResultOfBusinessProcess {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfBusinessProcess) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfBusinessProcess extends IBaseResultOfBusinessProcess {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfBusinessProcess extends SearchBehaviorBaseResultOfBusinessProcess implements ISearchBehaviorWithAggregationBaseResultOfBusinessProcess {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfBusinessProcess) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfBusinessProcess();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfBusinessProcess extends ISearchBehaviorBaseResultOfBusinessProcess {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Search result from a search for business processes */
export class BusinessProcessSearchResult extends SearchBehaviorWithAggregationBaseResultOfBusinessProcess implements IBusinessProcessSearchResult {

    constructor(data?: IBusinessProcessSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessProcessSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Search result from a search for business processes */
export interface IBusinessProcessSearchResult extends ISearchBehaviorWithAggregationBaseResultOfBusinessProcess {
}

/** Result of an aggregation */
export class AggregationResult implements IAggregationResult {
    /** Name of the aggregation. */
    name!: string;
    /** When there are lots of unique terms, Elastic Search only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response. */
    sumOtherDocCount?: number | undefined;
    /** Items returned for the aggregation. Each item consists of a bucket with the matched value and the number of matches.
Optionally inner aggregations for further drill down can be available. */
    aggregationResultItems?: AggregationResultItem[] | undefined;

    constructor(data?: IAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResultItems) {
                this.aggregationResultItems = [];
                for (let i = 0; i < data.aggregationResultItems.length; i++) {
                    let item = data.aggregationResultItems[i];
                    this.aggregationResultItems[i] = item && !(<any>item).toJSON ? new AggregationResultItem(item) : <AggregationResultItem>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sumOtherDocCount = _data["sumOtherDocCount"];
            if (Array.isArray(_data["aggregationResultItems"])) {
                this.aggregationResultItems = [] as any;
                for (let item of _data["aggregationResultItems"])
                    this.aggregationResultItems!.push(AggregationResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sumOtherDocCount"] = this.sumOtherDocCount;
        if (Array.isArray(this.aggregationResultItems)) {
            data["aggregationResultItems"] = [];
            for (let item of this.aggregationResultItems)
                data["aggregationResultItems"].push(item.toJSON());
        }
        return data;
    }
}

/** Result of an aggregation */
export interface IAggregationResult {
    /** Name of the aggregation. */
    name: string;
    /** When there are lots of unique terms, Elastic Search only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response. */
    sumOtherDocCount?: number | undefined;
    /** Items returned for the aggregation. Each item consists of a bucket with the matched value and the number of matches.
Optionally inner aggregations for further drill down can be available. */
    aggregationResultItems?: IAggregationResultItem[] | undefined;
}

/** Aggregation result item */
export class AggregationResultItem implements IAggregationResultItem {
    /** Value matched. */
    name!: string;
    /** Number of items matched. */
    count!: number;
    /** Ready to use filter to filter the data based on the aggregation result values.
It can be passed as one of the aggregation filters of an aggregation query: it returns documents meeting the aggregation condition. */
    filter?: AggregationFilter | undefined;
    /** True if the current result item matches on of the aggregation filters sent in the query. */
    active!: boolean;
    /** Inner aggregation results, if inner aggregations were provided in the query. */
    aggregationResults?: AggregationResult[] | undefined;

    getDisplayName(locale: string) {
    let displayName: string | null;

    // remove guid and show only owner name. example: name: "534e5b3763f242629eca53e764d713bf/cp support"
    if (this.filter && this.filter.aggregationName === 'ownerTokenId') {
      displayName = this.name.split('/').pop() || null;
    } else if (
      this.filter &&
      ((this.filter.filter as any).term === 'false' || (this.filter.filter as any).term === 'true')
    ) {
      displayName = (this.filter.filter as any).term;
    } else {
      displayName = this.filter && this.filter.filter ? this.filter.filter.getDisplayName(locale) : null;
    }

    return displayName ?? this.name;
  }

    constructor(data?: IAggregationResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.count = _data["count"];
            this.filter = _data["filter"] ? AggregationFilter.fromJS(_data["filter"]) : <any>undefined;
            this.active = _data["active"];
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AggregationResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["active"] = this.active;
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        return data;
    }
}

/** Aggregation result item */
export interface IAggregationResultItem {
    /** Value matched. */
    name: string;
    /** Number of items matched. */
    count: number;
    /** Ready to use filter to filter the data based on the aggregation result values.
It can be passed as one of the aggregation filters of an aggregation query: it returns documents meeting the aggregation condition. */
    filter?: AggregationFilter | undefined;
    /** True if the current result item matches on of the aggregation filters sent in the query. */
    active: boolean;
    /** Inner aggregation results, if inner aggregations were provided in the query. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** The filters' base class */
export class FilterBase implements IFilterBase {

    protected _discriminator: string;

    getDisplayName(locale: string): string | null {
    return null;
  }

    constructor(data?: IFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FilterBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): FilterBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AndFilter") {
            let result = new AndFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrFilter") {
            let result = new OrFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotFilter") {
            let result = new NotFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateRangeFilter") {
            let result = new DateRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ExistsFilter") {
            let result = new ExistsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoBoundingBoxFilter") {
            let result = new GeoBoundingBoxFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceFilter") {
            let result = new GeoDistanceFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedFilter") {
            let result = new NestedFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeFilter") {
            let result = new NumericRangeFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PrefixFilter") {
            let result = new PrefixFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermFilter") {
            let result = new TermFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsFilter") {
            let result = new TermsFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ChildFilter") {
            let result = new ChildFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ParentFilter") {
            let result = new ParentFilter();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AggregationFilter") {
            let result = new AggregationFilter();
            result.init(data);
            return result;
        }
        let result = new FilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** The filters' base class */
export interface IFilterBase {
}

/** Filters aggregations */
export class AggregationFilter extends FilterBase implements IAggregationFilter {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The filter to be applied. */
    filter?: FilterBase | undefined;
    /** Autogenerated Guid at request time, for precise aggregation result mapping. */
    temporaryAggregatorRequestId?: string | undefined;

    constructor(data?: IAggregationFilter) {
        super(data);
        this._discriminator = "AggregationFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.aggregationName = _data["aggregationName"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.temporaryAggregatorRequestId = _data["temporaryAggregatorRequestId"];
        }
    }

    static override fromJS(data: any): AggregationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationName"] = this.aggregationName;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["temporaryAggregatorRequestId"] = this.temporaryAggregatorRequestId;
        super.toJSON(data);
        return data;
    }
}

/** Filters aggregations */
export interface IAggregationFilter extends IFilterBase {
    /** The name of the aggregation this filter is connected to. */
    aggregationName?: string | undefined;
    /** The filter to be applied. */
    filter?: FilterBase | undefined;
    /** Autogenerated Guid at request time, for precise aggregation result mapping. */
    temporaryAggregatorRequestId?: string | undefined;
}

/** Used to put filters in "and" */
export class AndFilter extends FilterBase implements IAndFilter {
    /** The filters to put in "and". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IAndFilter) {
        super(data);
        this._discriminator = "AndFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AndFilter {
        data = typeof data === 'object' ? data : {};
        let result = new AndFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Used to put filters in "and" */
export interface IAndFilter extends IFilterBase {
    /** The filters to put in "and". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Put filters in "or" */
export class OrFilter extends FilterBase implements IOrFilter {
    /** The filters to put in "or". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;

    constructor(data?: IOrFilter) {
        super(data);
        this._discriminator = "OrFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): OrFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OrFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Put filters in "or" */
export interface IOrFilter extends IFilterBase {
    /** The filters to put in "or". All kinds of filters are accepted. */
    filters?: FilterBase[] | undefined;
}

/** Negates the specified filter */
export class NotFilter extends FilterBase implements INotFilter {
    /** The filter to be negated. */
    filter!: FilterBase;

    constructor(data?: INotFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "NotFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : new FilterBase();
        }
    }

    static override fromJS(data: any): NotFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NotFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Negates the specified filter */
export interface INotFilter extends IFilterBase {
    /** The filter to be negated. */
    filter: FilterBase;
}

/** Filters over a range of date time values */
export class DateRangeFilter extends FilterBase implements IDateRangeFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The date time range. */
    range!: DateRange;

    getDisplayName(locale: string) {
    return this.range && this.range.names ? this.range.names.translate(locale) : 'n/a';
  }

    constructor(data?: IDateRangeFilter) {
        super(data);
        if (data) {
            this.range = data.range && !(<any>data.range).toJSON ? new DateRange(data.range) : <DateRange>this.range;
        }
        if (!data) {
            this.range = new DateRange();
        }
        this._discriminator = "DateRangeFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.range = _data["range"] ? DateRange.fromJS(_data["range"]) : new DateRange();
        }
    }

    static override fromJS(data: any): DateRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters over a range of date time values */
export interface IDateRangeFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The date time range. */
    range: IDateRange;
}

/** The date time range class used in filters */
export class DateRange implements IDateRange {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): DateRange {
        data = typeof data === 'object' ? data : {};
        let result = new DateRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

/** The date time range class used in filters */
export interface IDateRange {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** Filters over the existence of a field's value */
export class ExistsFilter extends FilterBase implements IExistsFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;

    constructor(data?: IExistsFilter) {
        super(data);
        this._discriminator = "ExistsFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
        }
    }

    static override fromJS(data: any): ExistsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ExistsFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        super.toJSON(data);
        return data;
    }
}

/** Filters over the existence of a field's value */
export interface IExistsFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
}

/** Filters geo point values based on a bounding box */
export class GeoBoundingBoxFilter extends FilterBase implements IGeoBoundingBoxFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The top left corner of the bounding box's geo location (latitude and longitude). */
    topLeft!: GeoLocation;
    /** The bottom right corner of the bounding box's geo location (latitude and longitude). */
    bottomRight!: GeoLocation;

    constructor(data?: IGeoBoundingBoxFilter) {
        super(data);
        if (data) {
            this.topLeft = data.topLeft && !(<any>data.topLeft).toJSON ? new GeoLocation(data.topLeft) : <GeoLocation>this.topLeft;
            this.bottomRight = data.bottomRight && !(<any>data.bottomRight).toJSON ? new GeoLocation(data.bottomRight) : <GeoLocation>this.bottomRight;
        }
        if (!data) {
            this.topLeft = new GeoLocation();
            this.bottomRight = new GeoLocation();
        }
        this._discriminator = "GeoBoundingBoxFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.topLeft = _data["topLeft"] ? GeoLocation.fromJS(_data["topLeft"]) : new GeoLocation();
            this.bottomRight = _data["bottomRight"] ? GeoLocation.fromJS(_data["bottomRight"]) : new GeoLocation();
        }
    }

    static override fromJS(data: any): GeoBoundingBoxFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoBoundingBoxFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["topLeft"] = this.topLeft ? this.topLeft.toJSON() : <any>undefined;
        data["bottomRight"] = this.bottomRight ? this.bottomRight.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters geo point values based on a bounding box */
export interface IGeoBoundingBoxFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The top left corner of the bounding box's geo location (latitude and longitude). */
    topLeft: IGeoLocation;
    /** The bottom right corner of the bounding box's geo location (latitude and longitude). */
    bottomRight: IGeoLocation;
}

/** It stores geo location information (latitude and longitude) */
export class GeoLocation implements IGeoLocation {
    /** The latitude */
    lat?: number;
    /** The longitude */
    lon?: number;

    constructor(data?: IGeoLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lon = _data["lon"];
        }
    }

    static fromJS(data: any): GeoLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeoLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data;
    }
}

/** It stores geo location information (latitude and longitude) */
export interface IGeoLocation {
    /** The latitude */
    lat?: number;
    /** The longitude */
    lon?: number;
}

/** Filters within the radius of the distance from a location */
export class GeoDistanceFilter extends FilterBase implements IGeoDistanceFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location!: GeoLocation;
    /** The distance in meters from the point of origin. */
    distance?: number;

    constructor(data?: IGeoDistanceFilter) {
        super(data);
        if (data) {
            this.location = data.location && !(<any>data.location).toJSON ? new GeoLocation(data.location) : <GeoLocation>this.location;
        }
        if (!data) {
            this.location = new GeoLocation();
        }
        this._discriminator = "GeoDistanceFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.location = _data["location"] ? GeoLocation.fromJS(_data["location"]) : new GeoLocation();
            this.distance = _data["distance"];
        }
    }

    static override fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        super.toJSON(data);
        return data;
    }
}

/** Filters within the radius of the distance from a location */
export interface IGeoDistanceFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: IGeoLocation;
    /** The distance in meters from the point of origin. */
    distance?: number;
}

/** Filters on nested documents */
export class NestedFilter extends FilterBase implements INestedFilter {
    /** The path pointing to the nested document (i.e. personLayer.nestedAddress). */
    path!: string;
    /** The filter to be applied on the nested documents. */
    filter!: FilterBase;

    constructor(data?: INestedFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "NestedFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : new FilterBase();
        }
    }

    static override fromJS(data: any): NestedFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NestedFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters on nested documents */
export interface INestedFilter extends IFilterBase {
    /** The path pointing to the nested document (i.e. personLayer.nestedAddress). */
    path: string;
    /** The filter to be applied on the nested documents. */
    filter: FilterBase;
}

/** Filters over a range of numeric values */
export class NumericRangeFilter extends FilterBase implements INumericRangeFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The numeric range on which filtering. */
    range!: NumericRange;

    constructor(data?: INumericRangeFilter) {
        super(data);
        if (data) {
            this.range = data.range && !(<any>data.range).toJSON ? new NumericRange(data.range) : <NumericRange>this.range;
        }
        if (!data) {
            this.range = new NumericRange();
        }
        this._discriminator = "NumericRangeFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.range = _data["range"] ? NumericRange.fromJS(_data["range"]) : new NumericRange();
        }
    }

    static override fromJS(data: any): NumericRangeFilter {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["range"] = this.range ? this.range.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters over a range of numeric values */
export interface INumericRangeFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The numeric range on which filtering. */
    range: INumericRange;
}

/** The numeric range class */
export class NumericRange implements INumericRange {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

/** The numeric range class */
export interface INumericRange {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** Filters field's values based on a prefix */
export class PrefixFilter extends FilterBase implements IPrefixFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The value to be used as prefix. */
    prefix!: string;

    constructor(data?: IPrefixFilter) {
        super(data);
        this._discriminator = "PrefixFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.prefix = _data["prefix"];
        }
    }

    static override fromJS(data: any): PrefixFilter {
        data = typeof data === 'object' ? data : {};
        let result = new PrefixFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["prefix"] = this.prefix;
        super.toJSON(data);
        return data;
    }
}

/** Filters field's values based on a prefix */
export interface IPrefixFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to be used as prefix. */
    prefix: string;
}

/** Filters values exactly containing a term */
export class TermFilter extends FilterBase implements ITermFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The value to use to filter on. */
    term!: string;

    constructor(data?: ITermFilter) {
        super(data);
        this._discriminator = "TermFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.term = _data["term"];
        }
    }

    static override fromJS(data: any): TermFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["term"] = this.term;
        super.toJSON(data);
        return data;
    }
}

/** Filters values exactly containing a term */
export interface ITermFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The value to use to filter on. */
    term: string;
}

/** Filters values containing at least one of the terms */
export class TermsFilter extends FilterBase implements ITermsFilter {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field!: string;
    /** The list of values to be filtered on. At least one must match to return results. */
    terms!: string[];

    constructor(data?: ITermsFilter) {
        super(data);
        if (!data) {
            this.terms = [];
        }
        this._discriminator = "TermsFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
        }
    }

    static override fromJS(data: any): TermsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new TermsFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Filters values containing at least one of the terms */
export interface ITermsFilter extends IFilterBase {
    /** The field's name to execute the filter on. It is composed by the field ids of the hierarchy joined with "."
(i.e. personLayer.address.street). */
    field: string;
    /** The list of values to be filtered on. At least one must match to return results. */
    terms: string[];
}

/** Filters on child documents */
export class ChildFilter extends FilterBase implements IChildFilter {
    /** The type of the child document. */
    childType!: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter!: FilterBase;

    constructor(data?: IChildFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "ChildFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.childType = _data["childType"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : new FilterBase();
        }
    }

    static override fromJS(data: any): ChildFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ChildFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childType"] = this.childType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters on child documents */
export interface IChildFilter extends IFilterBase {
    /** The type of the child document. */
    childType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

/** Filters on parent documents */
export class ParentFilter extends FilterBase implements IParentFilter {
    /** The type of the parent document. */
    parentType!: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter!: FilterBase;

    constructor(data?: IParentFilter) {
        super(data);
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "ParentFilter";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentType = _data["parentType"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : new FilterBase();
        }
    }

    static override fromJS(data: any): ParentFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ParentFilter();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentType"] = this.parentType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Filters on parent documents */
export interface IParentFilter extends IFilterBase {
    /** The type of the parent document. */
    parentType: string;
    /** The filter to be applied on the child document. All kinds of filters are accepted. */
    filter: FilterBase;
}

export class QueryDebugInformation implements IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;

    constructor(data?: IQueryDebugInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"];
            this.auditTrail = _data["auditTrail"];
            this.request = _data["request"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): QueryDebugInformation {
        data = typeof data === 'object' ? data : {};
        let result = new QueryDebugInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general;
        data["auditTrail"] = this.auditTrail;
        data["request"] = this.request;
        data["response"] = this.response;
        return data;
    }
}

export interface IQueryDebugInformation {
    general?: string | undefined;
    auditTrail?: string | undefined;
    request?: any | undefined;
    response?: any | undefined;
}

/** Search request to search for business processes */
export class BusinessProcessSearchRequest implements IBusinessProcessSearchRequest {
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;

    constructor(data?: IBusinessProcessSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessProcessSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        return data;
    }
}

/** Search request to search for business processes */
export interface IBusinessProcessSearchRequest {
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
}

/** Search behaviors */
export enum SearchBehavior {
    DropInvalidCharactersOnFailure = "DropInvalidCharactersOnFailure",
    WildcardOnSingleTerm = "WildcardOnSingleTerm",
    SimplifiedSearch = "SimplifiedSearch",
    WildcardOnEveryTerm = "WildcardOnEveryTerm",
    SimplifiedSearchOr = "SimplifiedSearchOr",
}

/** It is the base class for all aggregators. */
export abstract class AggregatorBase implements IAggregatorBase {
    /** The slug name of the aggregation. It must be unique per aggregation request. */
    name!: string;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional filter to limit the data set the aggregation is operation on. */
    filter?: FilterBase | undefined;
    /** Optional behavior that the UI should keep in regards to the aggregation */
    uiBehavior?: UiAggregatorBehavior | undefined;

    protected _discriminator: string;

    constructor(data?: IAggregatorBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.uiBehavior = data.uiBehavior && !(<any>data.uiBehavior).toJSON ? new UiAggregatorBehavior(data.uiBehavior) : <UiAggregatorBehavior>this.uiBehavior;
        }
        this._discriminator = "AggregatorBase";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.uiBehavior = _data["uiBehavior"] ? UiAggregatorBehavior.fromJS(_data["uiBehavior"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AggregatorBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DateRangeAggregator") {
            let result = new DateRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoDistanceAggregator") {
            let result = new GeoDistanceAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NestedAggregator") {
            let result = new NestedAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumericRangeAggregator") {
            let result = new NumericRangeAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsAggregator") {
            let result = new TermsAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregatorBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["name"] = this.name;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["uiBehavior"] = this.uiBehavior ? this.uiBehavior.toJSON() : <any>undefined;
        return data;
    }
}

/** It is the base class for all aggregators. */
export interface IAggregatorBase {
    /** The slug name of the aggregation. It must be unique per aggregation request. */
    name: string;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary | undefined;
    /** An optional aggregator list for nested aggregations. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional filter to limit the data set the aggregation is operation on. */
    filter?: FilterBase | undefined;
    /** Optional behavior that the UI should keep in regards to the aggregation */
    uiBehavior?: IUiAggregatorBehavior | undefined;
}

/** Behavior that the UI should keep in regards to the aggregation */
export class UiAggregatorBehavior implements IUiAggregatorBehavior {
    /** Filters should be enabled in the UI. */
    enableFilter!: boolean;
    /** Suggestions should be enabled in the UI. */
    enableSuggestions!: boolean;
    /** Search functionality should be enabled in the filters in the UI. */
    enableSearchInFilter!: boolean;

    constructor(data?: IUiAggregatorBehavior) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableFilter = _data["enableFilter"];
            this.enableSuggestions = _data["enableSuggestions"];
            this.enableSearchInFilter = _data["enableSearchInFilter"];
        }
    }

    static fromJS(data: any): UiAggregatorBehavior {
        data = typeof data === 'object' ? data : {};
        let result = new UiAggregatorBehavior();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableFilter"] = this.enableFilter;
        data["enableSuggestions"] = this.enableSuggestions;
        data["enableSearchInFilter"] = this.enableSearchInFilter;
        return data;
    }
}

/** Behavior that the UI should keep in regards to the aggregation */
export interface IUiAggregatorBehavior {
    /** Filters should be enabled in the UI. */
    enableFilter: boolean;
    /** Suggestions should be enabled in the UI. */
    enableSuggestions: boolean;
    /** Search functionality should be enabled in the filters in the UI. */
    enableSearchInFilter: boolean;
}

/** A multi-bucket range aggregator dedicated for date values. */
export class DateRangeAggregator extends AggregatorBase implements IDateRangeAggregator {
    /** The field's ID to execute the aggregation on. */
    field!: string;
    /** A list of date time ranges. */
    ranges!: DateRangeForAggregator[];

    constructor(data?: IDateRangeAggregator) {
        super(data);
        if (data) {
            if (data.ranges) {
                this.ranges = [];
                for (let i = 0; i < data.ranges.length; i++) {
                    let item = data.ranges[i];
                    this.ranges[i] = item && !(<any>item).toJSON ? new DateRangeForAggregator(item) : <DateRangeForAggregator>item;
                }
            }
        }
        if (!data) {
            this.ranges = [];
        }
        this._discriminator = "DateRangeAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(DateRangeForAggregator.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DateRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket range aggregator dedicated for date values. */
export interface IDateRangeAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** A list of date time ranges. */
    ranges: IDateRangeForAggregator[];
}

/** The date range class used in aggregators. */
export class DateRangeForAggregator implements IDateRangeForAggregator {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;

    constructor(data?: IDateRangeForAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): DateRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeForAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

/** The date range class used in aggregators. */
export interface IDateRangeForAggregator {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    from?: string | undefined;
    /** The to value: it can be a datetime string or a pattern now(+-)(int)(YMDHm). */
    to?: string | undefined;
}

/** A multi-bucket range aggregator that works on geo_point fields */
export class GeoDistanceAggregator extends AggregatorBase implements IGeoDistanceAggregator {
    /** The field's ID to execute the aggregation on. */
    field!: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location!: GeoLocation;
    /** A list of distance ranges. */
    ranges!: GeoDistance[];

    constructor(data?: IGeoDistanceAggregator) {
        super(data);
        if (data) {
            this.location = data.location && !(<any>data.location).toJSON ? new GeoLocation(data.location) : <GeoLocation>this.location;
            if (data.ranges) {
                this.ranges = [];
                for (let i = 0; i < data.ranges.length; i++) {
                    let item = data.ranges[i];
                    this.ranges[i] = item && !(<any>item).toJSON ? new GeoDistance(item) : <GeoDistance>item;
                }
            }
        }
        if (!data) {
            this.location = new GeoLocation();
            this.ranges = [];
        }
        this._discriminator = "GeoDistanceAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.location = _data["location"] ? GeoLocation.fromJS(_data["location"]) : new GeoLocation();
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(GeoDistance.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): GeoDistanceAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket range aggregator that works on geo_point fields */
export interface IGeoDistanceAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field: string;
    /** The point of origin to calculate the distance from (latitude/longitude). */
    location: IGeoLocation;
    /** A list of distance ranges. */
    ranges: IGeoDistance[];
}

/** Stores geo distance information for gei distance aggregation */
export class GeoDistance implements IGeoDistance {
    /** Language specific geo distance names. */
    names?: TranslatedStringDictionary | undefined;
    /** The distance in meters. */
    distance!: number;

    constructor(data?: IGeoDistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): GeoDistance {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data;
    }
}

/** Stores geo distance information for gei distance aggregation */
export interface IGeoDistance {
    /** Language specific geo distance names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The distance in meters. */
    distance: number;
}

/** A special single bucket aggregation that enables aggregating on nested documents */
export class NestedAggregator extends AggregatorBase implements INestedAggregator {
    /** The path pointing to the nested object. */
    path!: string;

    constructor(data?: INestedAggregator) {
        super(data);
        this._discriminator = "NestedAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
        }
    }

    static override fromJS(data: any): NestedAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NestedAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        super.toJSON(data);
        return data;
    }
}

/** A special single bucket aggregation that enables aggregating on nested documents */
export interface INestedAggregator extends IAggregatorBase {
    /** The path pointing to the nested object. */
    path: string;
}

/** A multi-bucket range aggregator. */
export class NumericRangeAggregator extends AggregatorBase implements INumericRangeAggregator {
    /** The field's ID to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges on which aggregate. */
    ranges!: NumericRangeForAggregator[];

    constructor(data?: INumericRangeAggregator) {
        super(data);
        if (data) {
            if (data.ranges) {
                this.ranges = [];
                for (let i = 0; i < data.ranges.length; i++) {
                    let item = data.ranges[i];
                    this.ranges[i] = item && !(<any>item).toJSON ? new NumericRangeForAggregator(item) : <NumericRangeForAggregator>item;
                }
            }
        }
        if (!data) {
            this.ranges = [];
        }
        this._discriminator = "NumericRangeAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            if (Array.isArray(_data["ranges"])) {
                this.ranges = [] as any;
                for (let item of _data["ranges"])
                    this.ranges!.push(NumericRangeForAggregator.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): NumericRangeAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        if (Array.isArray(this.ranges)) {
            data["ranges"] = [];
            for (let item of this.ranges)
                data["ranges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket range aggregator. */
export interface INumericRangeAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. */
    field?: string | undefined;
    /** A list of numeric ranges on which aggregate. */
    ranges: INumericRangeForAggregator[];
}

/** The numeric range for aggregator class */
export class NumericRangeForAggregator implements INumericRangeForAggregator {
    /** Language specific range names. */
    names?: TranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;

    constructor(data?: INumericRangeForAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): NumericRangeForAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRangeForAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

/** The numeric range for aggregator class */
export interface INumericRangeForAggregator {
    /** Language specific range names. */
    names?: ITranslatedStringDictionary | undefined;
    /** The from value. */
    from?: number | undefined;
    /** The to value. */
    to?: number | undefined;
}

/** A multi-bucket value aggregator */
export class TermsAggregator extends AggregatorBase implements ITermsAggregator {
    /** The field's ID to execute the aggregation on. Only not analyzed fields are supported. */
    field!: string;
    /** It defines how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
    /** Limits the possible returned aggregation values by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used. */
    searchFields?: string[] | undefined;
    /** Sort settings for the aggregation results. If no sort is specified, aggregation is sorted on the item count. */
    sort?: SortInfo | undefined;

    constructor(data?: ITermsAggregator) {
        super(data);
        if (data) {
            this.sort = data.sort && !(<any>data.sort).toJSON ? new SortInfo(data.sort) : <SortInfo>this.sort;
        }
        this._discriminator = "TermsAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.field = _data["field"];
            this.size = _data["size"];
            if (Array.isArray(_data["includes"])) {
                this.includes = [] as any;
                for (let item of _data["includes"])
                    this.includes!.push(item);
            }
            if (Array.isArray(_data["excludes"])) {
                this.excludes = [] as any;
                for (let item of _data["excludes"])
                    this.excludes!.push(item);
            }
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchFields"])) {
                this.searchFields = [] as any;
                for (let item of _data["searchFields"])
                    this.searchFields!.push(item);
            }
            this.sort = _data["sort"] ? SortInfo.fromJS(_data["sort"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TermsAggregator {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TermsRelationAggregator") {
            let result = new TermsRelationAggregator();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TermsEnumAggregator") {
            let result = new TermsEnumAggregator();
            result.init(data);
            return result;
        }
        let result = new TermsAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["size"] = this.size;
        if (Array.isArray(this.includes)) {
            data["includes"] = [];
            for (let item of this.includes)
                data["includes"].push(item);
        }
        if (Array.isArray(this.excludes)) {
            data["excludes"] = [];
            for (let item of this.excludes)
                data["excludes"].push(item);
        }
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchFields)) {
            data["searchFields"] = [];
            for (let item of this.searchFields)
                data["searchFields"].push(item);
        }
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket value aggregator */
export interface ITermsAggregator extends IAggregatorBase {
    /** The field's ID to execute the aggregation on. Only not analyzed fields are supported. */
    field: string;
    /** It defines how many term buckets should be returned out of the overall terms list. */
    size?: number | undefined;
    /** Includes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    includes?: string[] | undefined;
    /** Excludes values for which buckets will be created. Supports regular expression strings or arrays of exact values. */
    excludes?: string[] | undefined;
    /** Limits the possible returned aggregation values by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Search fields to be used to search the SearchString value into. If no search field is specified, the Field value is used. */
    searchFields?: string[] | undefined;
    /** Sort settings for the aggregation results. If no sort is specified, aggregation is sorted on the item count. */
    sort?: ISortInfo | undefined;
}

/** Sorting information */
export class SortInfo implements ISortInfo {
    /** The field's ID to sort on. */
    field?: string | undefined;
    /** The sort direction (ascending/descending). */
    direction!: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["direction"] = this.direction;
        return data;
    }
}

/** Sorting information */
export interface ISortInfo {
    /** The field's ID to sort on. */
    field?: string | undefined;
    /** The sort direction (ascending/descending). */
    direction: SortDirection;
}

/** The sort direction */
export enum SortDirection {
    Asc = "Asc",
    Desc = "Desc",
}

/** A multi-bucket value aggregator used for aggregations on relation item ids. */
export class TermsRelationAggregator extends TermsAggregator implements ITermsRelationAggregator {
    /** Type of the item target of the relation. It is used to resolve the target ID. */
    documentType?: TermsRelationAggregatorDocumentType;

    constructor(data?: ITermsRelationAggregator) {
        super(data);
        this._discriminator = "TermsRelationAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.documentType = _data["documentType"];
        }
    }

    static override fromJS(data: any): TermsRelationAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsRelationAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket value aggregator used for aggregations on relation item ids. */
export interface ITermsRelationAggregator extends ITermsAggregator {
    /** Type of the item target of the relation. It is used to resolve the target ID. */
    documentType?: TermsRelationAggregatorDocumentType;
}

export enum TermsRelationAggregatorDocumentType {
    Content = "Content",
    ListItem = "ListItem",
    Schema = "Schema",
    User = "User",
    ContentPermissionSet = "ContentPermissionSet",
    Owner = "Owner",
    UserRole = "UserRole",
    SchemaPermissionSet = "SchemaPermissionSet",
    IndexCustomerAlias = "IndexCustomerAlias",
    IndexCustomerId = "IndexCustomerId",
}

/** A multi-bucket value aggregator used for aggregations on indexed enum values. */
export class TermsEnumAggregator extends TermsAggregator implements ITermsEnumAggregator {
    /** Type of the enum target of the relation. It is used to resolve the enum translation. */
    enumType!: string;

    constructor(data?: ITermsEnumAggregator) {
        super(data);
        this._discriminator = "TermsEnumAggregator";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enumType = _data["enumType"];
        }
    }

    static override fromJS(data: any): TermsEnumAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new TermsEnumAggregator();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumType"] = this.enumType;
        super.toJSON(data);
        return data;
    }
}

/** A multi-bucket value aggregator used for aggregations on indexed enum values. */
export interface ITermsEnumAggregator extends ITermsAggregator {
    /** Type of the enum target of the relation. It is used to resolve the enum translation. */
    enumType: string;
}

/** Represents the business rule configuration. */
export class BusinessRuleConfiguration implements IBusinessRuleConfiguration {
    /** Disables the rule engine completely. */
    disableRuleEngine!: boolean;
    /** Rules. */
    rules!: BusinessRule[];
    /** Named caches. */
    caches!: NamedCacheConfigurationBase[];
    /** Notifications. */
    notifications!: BusinessRuleNotification[];
    /** Numbers sequences. */
    numberSequences!: BusinessRuleNumberSequence[];
    /** Schedules. */
    schedules!: BusinessRuleSchedule[];

    constructor(data?: IBusinessRuleConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.notifications) {
                this.notifications = [];
                for (let i = 0; i < data.notifications.length; i++) {
                    let item = data.notifications[i];
                    this.notifications[i] = item && !(<any>item).toJSON ? new BusinessRuleNotification(item) : <BusinessRuleNotification>item;
                }
            }
            if (data.numberSequences) {
                this.numberSequences = [];
                for (let i = 0; i < data.numberSequences.length; i++) {
                    let item = data.numberSequences[i];
                    this.numberSequences[i] = item && !(<any>item).toJSON ? new BusinessRuleNumberSequence(item) : <BusinessRuleNumberSequence>item;
                }
            }
            if (data.schedules) {
                this.schedules = [];
                for (let i = 0; i < data.schedules.length; i++) {
                    let item = data.schedules[i];
                    this.schedules[i] = item && !(<any>item).toJSON ? new BusinessRuleSchedule(item) : <BusinessRuleSchedule>item;
                }
            }
        }
        if (!data) {
            this.rules = [];
            this.caches = [];
            this.notifications = [];
            this.numberSequences = [];
            this.schedules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disableRuleEngine = _data["disableRuleEngine"];
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(BusinessRule.fromJS(item));
            }
            if (Array.isArray(_data["caches"])) {
                this.caches = [] as any;
                for (let item of _data["caches"])
                    this.caches!.push(NamedCacheConfigurationBase.fromJS(item));
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(BusinessRuleNotification.fromJS(item));
            }
            if (Array.isArray(_data["numberSequences"])) {
                this.numberSequences = [] as any;
                for (let item of _data["numberSequences"])
                    this.numberSequences!.push(BusinessRuleNumberSequence.fromJS(item));
            }
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [] as any;
                for (let item of _data["schedules"])
                    this.schedules!.push(BusinessRuleSchedule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessRuleConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disableRuleEngine"] = this.disableRuleEngine;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        if (Array.isArray(this.caches)) {
            data["caches"] = [];
            for (let item of this.caches)
                data["caches"].push(item.toJSON());
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        if (Array.isArray(this.numberSequences)) {
            data["numberSequences"] = [];
            for (let item of this.numberSequences)
                data["numberSequences"].push(item.toJSON());
        }
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents the business rule configuration. */
export interface IBusinessRuleConfiguration {
    /** Disables the rule engine completely. */
    disableRuleEngine: boolean;
    /** Rules. */
    rules: BusinessRule[];
    /** Named caches. */
    caches: NamedCacheConfigurationBase[];
    /** Notifications. */
    notifications: IBusinessRuleNotification[];
    /** Numbers sequences. */
    numberSequences: IBusinessRuleNumberSequence[];
    /** Schedules. */
    schedules: IBusinessRuleSchedule[];
}

/** A business rule */
export abstract class BusinessRule implements IBusinessRule {
    /** User defined ID of the rule. */
    id!: string;
    /** Trigger point. */
    triggerPoints?: BusinessRuleTriggerPoint[] | undefined;
    /** Enable. */
    isEnabled!: boolean;
    /** Language specific rule names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific rule description. */
    description?: TranslatedStringDictionary | undefined;
    /** Enable trace logs for this rule. */
    enableTracing!: boolean;

    protected _discriminator: string;

    constructor(data?: IBusinessRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.triggerPoints) {
                this.triggerPoints = [];
                for (let i = 0; i < data.triggerPoints.length; i++) {
                    let item = data.triggerPoints[i];
                    this.triggerPoints[i] = item && !(<any>item).toJSON ? new BusinessRuleTriggerPoint(item) : <BusinessRuleTriggerPoint>item;
                }
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
        this._discriminator = "BusinessRule";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["triggerPoints"])) {
                this.triggerPoints = [] as any;
                for (let item of _data["triggerPoints"])
                    this.triggerPoints!.push(BusinessRuleTriggerPoint.fromJS(item));
            }
            this.isEnabled = _data["isEnabled"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
            this.enableTracing = _data["enableTracing"];
        }
    }

    static fromJS(data: any): BusinessRule {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BusinessRuleConfigurable") {
            let result = new BusinessRuleConfigurable();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleScript") {
            let result = new BusinessRuleScript();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRule' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        if (Array.isArray(this.triggerPoints)) {
            data["triggerPoints"] = [];
            for (let item of this.triggerPoints)
                data["triggerPoints"].push(item.toJSON());
        }
        data["isEnabled"] = this.isEnabled;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["enableTracing"] = this.enableTracing;
        return data;
    }
}

/** A business rule */
export interface IBusinessRule {
    /** User defined ID of the rule. */
    id: string;
    /** Trigger point. */
    triggerPoints?: IBusinessRuleTriggerPoint[] | undefined;
    /** Enable. */
    isEnabled: boolean;
    /** Language specific rule names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific rule description. */
    description?: ITranslatedStringDictionary | undefined;
    /** Enable trace logs for this rule. */
    enableTracing: boolean;
}

/** Represents a trigger point for a business rule */
export class BusinessRuleTriggerPoint implements IBusinessRuleTriggerPoint {
    /** Execution scope. */
    executionScope!: BusinessRuleExecutionScope;
    /** Document type. */
    documentType!: BusinessRuleTriggerDocType;
    /** Action performed. */
    action!: BusinessRuleTriggerAction;

    constructor(data?: IBusinessRuleTriggerPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.executionScope = _data["executionScope"];
            this.documentType = _data["documentType"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): BusinessRuleTriggerPoint {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTriggerPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["executionScope"] = this.executionScope;
        data["documentType"] = this.documentType;
        data["action"] = this.action;
        return data;
    }
}

/** Represents a trigger point for a business rule */
export interface IBusinessRuleTriggerPoint {
    /** Execution scope. */
    executionScope: BusinessRuleExecutionScope;
    /** Document type. */
    documentType: BusinessRuleTriggerDocType;
    /** Action performed. */
    action: BusinessRuleTriggerAction;
}

export enum BusinessRuleExecutionScope {
    MainDoc = "MainDoc",
    SearchDoc = "SearchDoc",
}

/** A business rule configurable by specific actions and conditions */
export class BusinessRuleConfigurable extends BusinessRule implements IBusinessRuleConfigurable {
    /** The condition that makes this rule trigger. */
    condition?: BusinessRuleCondition | undefined;
    /** Optional transformations to apply. */
    transformationGroups?: BusinessRuleTransformationGroup[] | undefined;
    /** The actions that are performed when this rule triggers. */
    actions?: BusinessRuleAction[] | undefined;

    constructor(data?: IBusinessRuleConfigurable) {
        super(data);
        if (data) {
            if (data.transformationGroups) {
                this.transformationGroups = [];
                for (let i = 0; i < data.transformationGroups.length; i++) {
                    let item = data.transformationGroups[i];
                    this.transformationGroups[i] = item && !(<any>item).toJSON ? new BusinessRuleTransformationGroup(item) : <BusinessRuleTransformationGroup>item;
                }
            }
        }
        this._discriminator = "BusinessRuleConfigurable";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.condition = _data["condition"] ? BusinessRuleCondition.fromJS(_data["condition"]) : <any>undefined;
            if (Array.isArray(_data["transformationGroups"])) {
                this.transformationGroups = [] as any;
                for (let item of _data["transformationGroups"])
                    this.transformationGroups!.push(BusinessRuleTransformationGroup.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(BusinessRuleAction.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessRuleConfigurable {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfigurable();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (Array.isArray(this.transformationGroups)) {
            data["transformationGroups"] = [];
            for (let item of this.transformationGroups)
                data["transformationGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A business rule configurable by specific actions and conditions */
export interface IBusinessRuleConfigurable extends IBusinessRule {
    /** The condition that makes this rule trigger. */
    condition?: BusinessRuleCondition | undefined;
    /** Optional transformations to apply. */
    transformationGroups?: IBusinessRuleTransformationGroup[] | undefined;
    /** The actions that are performed when this rule triggers. */
    actions?: BusinessRuleAction[] | undefined;
}

/** Conditions on which a business rule is executed */
export abstract class BusinessRuleCondition implements IBusinessRuleCondition {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific condition names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific condition description. */
    description?: TranslatedStringDictionary | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessRuleCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
        this._discriminator = "BusinessRuleCondition";
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessRuleCondition {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "BooleanCondition") {
            throw new Error("The abstract class 'BooleanCondition' cannot be instantiated.");
        }
        if (data["kind"] === "AndCondition") {
            let result = new AndCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrCondition") {
            let result = new OrCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerAssignedCondition") {
            let result = new LayerAssignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayerUnassignedCondition") {
            let result = new LayerUnassignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionSetAssignedCondition") {
            let result = new ContentPermissionSetAssignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionSetUnassignedCondition") {
            let result = new ContentPermissionSetUnassignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldValueChangedCondition") {
            let result = new FieldValueChangedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldValueCondition") {
            let result = new FieldValueCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MatchRegexCondition") {
            let result = new MatchRegexCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "StringContainsCondition") {
            let result = new StringContainsCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserInUserRolesCondition") {
            let result = new UserInUserRolesCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TagboxItemAssignedCondition") {
            let result = new TagboxItemAssignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TagboxItemUnassignedCondition") {
            let result = new TagboxItemUnassignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentSchemaCondition") {
            let result = new ContentSchemaCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NumberCompareCondition") {
            let result = new NumberCompareCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentRelationItemAssignedCondition") {
            let result = new ContentRelationItemAssignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentRelationItemUnassignedCondition") {
            let result = new ContentRelationItemUnassignedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GeoPointWithinPolygonCondition") {
            let result = new GeoPointWithinPolygonCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentPermissionSetsChangedCondition") {
            let result = new ContentPermissionSetsChangedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentRelationItemsChangedCondition") {
            let result = new ContentRelationItemsChangedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LayersChangedCondition") {
            let result = new LayersChangedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TagboxItemsChangedCondition") {
            let result = new TagboxItemsChangedCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldEmptyCondition") {
            let result = new FieldEmptyCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotCondition") {
            let result = new NotCondition();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRuleCondition' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["traceRefId"] = this.traceRefId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        return data;
    }
}

/** Conditions on which a business rule is executed */
export interface IBusinessRuleCondition {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific condition names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific condition description. */
    description?: ITranslatedStringDictionary | undefined;
}

/** Links multiple conditions with a boolean operator */
export abstract class BooleanCondition extends BusinessRuleCondition implements IBooleanCondition {
    /** The conditions. */
    conditions?: BusinessRuleCondition[] | undefined;

    constructor(data?: IBooleanCondition) {
        super(data);
        this._discriminator = "BooleanCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(BusinessRuleCondition.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BooleanCondition {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AndCondition") {
            let result = new AndCondition();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OrCondition") {
            let result = new OrCondition();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BooleanCondition' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Links multiple conditions with a boolean operator */
export interface IBooleanCondition extends IBusinessRuleCondition {
    /** The conditions. */
    conditions?: BusinessRuleCondition[] | undefined;
}

/** Links conditions with AND */
export class AndCondition extends BooleanCondition implements IAndCondition {

    constructor(data?: IAndCondition) {
        super(data);
        this._discriminator = "AndCondition";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AndCondition {
        data = typeof data === 'object' ? data : {};
        let result = new AndCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Links conditions with AND */
export interface IAndCondition extends IBooleanCondition {
}

/** Links conditions with OR */
export class OrCondition extends BooleanCondition implements IOrCondition {

    constructor(data?: IOrCondition) {
        super(data);
        this._discriminator = "OrCondition";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OrCondition {
        data = typeof data === 'object' ? data : {};
        let result = new OrCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Links conditions with OR */
export interface IOrCondition extends IBooleanCondition {
}

/** Matches when a layer was assigned */
export class LayerAssignedCondition extends BusinessRuleCondition implements ILayerAssignedCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;

    constructor(data?: ILayerAssignedCondition) {
        super(data);
        this._discriminator = "LayerAssignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
        }
    }

    static override fromJS(data: any): LayerAssignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new LayerAssignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a layer was assigned */
export interface ILayerAssignedCondition extends IBusinessRuleCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;
}

/** Matches when a layer was unassigned */
export class LayerUnassignedCondition extends BusinessRuleCondition implements ILayerUnassignedCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;

    constructor(data?: ILayerUnassignedCondition) {
        super(data);
        this._discriminator = "LayerUnassignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
        }
    }

    static override fromJS(data: any): LayerUnassignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new LayerUnassignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a layer was unassigned */
export interface ILayerUnassignedCondition extends IBusinessRuleCondition {
    /** Layer id to match on. */
    layerId?: string | undefined;
}

/** Matches when a permission set was assigned */
export class ContentPermissionSetAssignedCondition extends BusinessRuleCondition implements IContentPermissionSetAssignedCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;

    constructor(data?: IContentPermissionSetAssignedCondition) {
        super(data);
        this._discriminator = "ContentPermissionSetAssignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): ContentPermissionSetAssignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetAssignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a permission set was assigned */
export interface IContentPermissionSetAssignedCondition extends IBusinessRuleCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;
}

/** Matches when a permission set was unassigned */
export class ContentPermissionSetUnassignedCondition extends BusinessRuleCondition implements IContentPermissionSetUnassignedCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;

    constructor(data?: IContentPermissionSetUnassignedCondition) {
        super(data);
        this._discriminator = "ContentPermissionSetUnassignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): ContentPermissionSetUnassignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUnassignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a permission set was unassigned */
export interface IContentPermissionSetUnassignedCondition extends IBusinessRuleCondition {
    /** Permission set id to match on. */
    permissionSetId?: string | undefined;
}

/** Matches when a field matching the field path string (JSON path) changes to the expected value. */
export class FieldValueChangedCondition extends BusinessRuleCondition implements IFieldValueChangedCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Expected value for the field to have to satisfy the condition */
    expectedValue?: any | undefined;

    constructor(data?: IFieldValueChangedCondition) {
        super(data);
        this._discriminator = "FieldValueChangedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.expectedValue = _data["expectedValue"];
        }
    }

    static override fromJS(data: any): FieldValueChangedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueChangedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["expectedValue"] = this.expectedValue;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a field matching the field path string (JSON path) changes to the expected value. */
export interface IFieldValueChangedCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Expected value for the field to have to satisfy the condition */
    expectedValue?: any | undefined;
}

/** Matches when a field matching the field path string (JSON path) has the expected value. */
export class FieldValueCondition extends BusinessRuleCondition implements IFieldValueCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Expected value for the field to have to satisfy the condition */
    expectedValue?: any | undefined;

    constructor(data?: IFieldValueCondition) {
        super(data);
        this._discriminator = "FieldValueCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.expectedValue = _data["expectedValue"];
        }
    }

    static override fromJS(data: any): FieldValueCondition {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["expectedValue"] = this.expectedValue;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a field matching the field path string (JSON path) has the expected value. */
export interface IFieldValueCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Expected value for the field to have to satisfy the condition */
    expectedValue?: any | undefined;
}

/** Matches when a field matching the field path string (JSON Path) changes and matches the given regular expression. */
export class MatchRegexCondition extends BusinessRuleCondition implements IMatchRegexCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Regular expression */
    regex?: string | undefined;
    /** Optional variable name to store the matched regex groups in */
    storeIn?: string | undefined;

    constructor(data?: IMatchRegexCondition) {
        super(data);
        this._discriminator = "MatchRegexCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.regex = _data["regex"];
            this.storeIn = _data["storeIn"];
        }
    }

    static override fromJS(data: any): MatchRegexCondition {
        data = typeof data === 'object' ? data : {};
        let result = new MatchRegexCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["regex"] = this.regex;
        data["storeIn"] = this.storeIn;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a field matching the field path string (JSON Path) changes and matches the given regular expression. */
export interface IMatchRegexCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Regular expression */
    regex?: string | undefined;
    /** Optional variable name to store the matched regex groups in */
    storeIn?: string | undefined;
}

/** Matches when a field matching the field path string (JSON Path) changes and matches one of the specified values in ValuesToMatch */
export class StringContainsCondition extends BusinessRuleCondition implements IStringContainsCondition {
    /** JSON path to the field. */
    fieldPath?: string | undefined;
    /** A list of string value that will checked if at least one of them is contained in the string value identified by the FieldPath. */
    valuesToMatch?: string[] | undefined;
    /** Optional value to be stored in the variable identified by StoreIn. It can be simple value or a complex object. */
    valueToStore?: any | undefined;
    /** Decide if the StringContains condition should be processed case sensitive. */
    caseSensitive?: boolean;
    /** Optional variable name to store the ValueToStore in */
    storeIn?: string | undefined;

    constructor(data?: IStringContainsCondition) {
        super(data);
        this._discriminator = "StringContainsCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            if (Array.isArray(_data["valuesToMatch"])) {
                this.valuesToMatch = [] as any;
                for (let item of _data["valuesToMatch"])
                    this.valuesToMatch!.push(item);
            }
            this.valueToStore = _data["valueToStore"];
            this.caseSensitive = _data["caseSensitive"];
            this.storeIn = _data["storeIn"];
        }
    }

    static override fromJS(data: any): StringContainsCondition {
        data = typeof data === 'object' ? data : {};
        let result = new StringContainsCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        if (Array.isArray(this.valuesToMatch)) {
            data["valuesToMatch"] = [];
            for (let item of this.valuesToMatch)
                data["valuesToMatch"].push(item);
        }
        data["valueToStore"] = this.valueToStore;
        data["caseSensitive"] = this.caseSensitive;
        data["storeIn"] = this.storeIn;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a field matching the field path string (JSON Path) changes and matches one of the specified values in ValuesToMatch */
export interface IStringContainsCondition extends IBusinessRuleCondition {
    /** JSON path to the field. */
    fieldPath?: string | undefined;
    /** A list of string value that will checked if at least one of them is contained in the string value identified by the FieldPath. */
    valuesToMatch?: string[] | undefined;
    /** Optional value to be stored in the variable identified by StoreIn. It can be simple value or a complex object. */
    valueToStore?: any | undefined;
    /** Decide if the StringContains condition should be processed case sensitive. */
    caseSensitive?: boolean;
    /** Optional variable name to store the ValueToStore in */
    storeIn?: string | undefined;
}

/** Matches when one or all the user roles specified in UserRoleIds are assigned to the user retrieved from the path UserIdPath */
export class UserInUserRolesCondition extends BusinessRuleCondition implements IUserInUserRolesCondition {
    /** JSON path to the field containing the id of the user that needs to be checked. */
    userIdPath?: string | undefined;
    /** A static list of user role ids that will checked: depending on MatchMode all the user roles or only one of them must be assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Decide if all the user roles must be assigned to the user or only one of them. */
    matchMode?: ConditionMatchMode;

    constructor(data?: IUserInUserRolesCondition) {
        super(data);
        this._discriminator = "UserInUserRolesCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userIdPath = _data["userIdPath"];
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
            this.matchMode = _data["matchMode"];
        }
    }

    static override fromJS(data: any): UserInUserRolesCondition {
        data = typeof data === 'object' ? data : {};
        let result = new UserInUserRolesCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userIdPath"] = this.userIdPath;
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["matchMode"] = this.matchMode;
        super.toJSON(data);
        return data;
    }
}

/** Matches when one or all the user roles specified in UserRoleIds are assigned to the user retrieved from the path UserIdPath */
export interface IUserInUserRolesCondition extends IBusinessRuleCondition {
    /** JSON path to the field containing the id of the user that needs to be checked. */
    userIdPath?: string | undefined;
    /** A static list of user role ids that will checked: depending on MatchMode all the user roles or only one of them must be assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Decide if all the user roles must be assigned to the user or only one of them. */
    matchMode?: ConditionMatchMode;
}

/** How a list of values in the condition should be matched during the comparison. */
export enum ConditionMatchMode {
    All = "All",
    Any = "Any",
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is newly assigned. */
export class TagboxItemAssignedCondition extends BusinessRuleCondition implements ITagboxItemAssignedCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was assigned in the tagbox */
    refId?: string | undefined;

    constructor(data?: ITagboxItemAssignedCondition) {
        super(data);
        this._discriminator = "TagboxItemAssignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.refId = _data["refId"];
        }
    }

    static override fromJS(data: any): TagboxItemAssignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TagboxItemAssignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["refId"] = this.refId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is newly assigned. */
export interface ITagboxItemAssignedCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was assigned in the tagbox */
    refId?: string | undefined;
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is removed. */
export class TagboxItemUnassignedCondition extends BusinessRuleCondition implements ITagboxItemUnassignedCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was unassigned from the tagbox */
    refId?: string | undefined;

    constructor(data?: ITagboxItemUnassignedCondition) {
        super(data);
        this._discriminator = "TagboxItemUnassignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.refId = _data["refId"];
        }
    }

    static override fromJS(data: any): TagboxItemUnassignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TagboxItemUnassignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["refId"] = this.refId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a tag in a tagbox matching the field path string (JSON path) is removed. */
export interface ITagboxItemUnassignedCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** Ref Id of the list item that was unassigned from the tagbox */
    refId?: string | undefined;
}

/** Matches when the content schema of a metadata item equals the one set in the condition. */
export class ContentSchemaCondition extends BusinessRuleCondition implements IContentSchemaCondition {
    /** Content schema id to match on. */
    schemaId?: string | undefined;

    constructor(data?: IContentSchemaCondition) {
        super(data);
        this._discriminator = "ContentSchemaCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): ContentSchemaCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSchemaCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

/** Matches when the content schema of a metadata item equals the one set in the condition. */
export interface IContentSchemaCondition extends IBusinessRuleCondition {
    /** Content schema id to match on. */
    schemaId?: string | undefined;
}

export class NumberCompareCondition extends BusinessRuleCondition implements INumberCompareCondition {
    /** JSON path to the field. */
    fieldPath?: string | undefined;
    /** Mode to use for comparison. */
    mode?: BusinessRuleNumberCompareConditionMode;
    /** Value to compare to. */
    value?: number;

    constructor(data?: INumberCompareCondition) {
        super(data);
        this._discriminator = "NumberCompareCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.mode = _data["mode"];
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): NumberCompareCondition {
        data = typeof data === 'object' ? data : {};
        let result = new NumberCompareCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["mode"] = this.mode;
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface INumberCompareCondition extends IBusinessRuleCondition {
    /** JSON path to the field. */
    fieldPath?: string | undefined;
    /** Mode to use for comparison. */
    mode?: BusinessRuleNumberCompareConditionMode;
    /** Value to compare to. */
    value?: number;
}

export enum BusinessRuleNumberCompareConditionMode {
    LessThan = "LessThan",
    LessThanEqual = "LessThanEqual",
    Equal = "Equal",
    GreaterThanEqual = "GreaterThanEqual",
    GreaterThan = "GreaterThan",
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is newly assigned. */
export class ContentRelationItemAssignedCondition extends BusinessRuleCondition implements IContentRelationItemAssignedCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;

    constructor(data?: IContentRelationItemAssignedCondition) {
        super(data);
        this._discriminator = "ContentRelationItemAssignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): ContentRelationItemAssignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRelationItemAssignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is newly assigned. */
export interface IContentRelationItemAssignedCondition extends IBusinessRuleCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is removed. */
export class ContentRelationItemUnassignedCondition extends BusinessRuleCondition implements IContentRelationItemUnassignedCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;

    constructor(data?: IContentRelationItemUnassignedCondition) {
        super(data);
        this._discriminator = "ContentRelationItemUnassignedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): ContentRelationItemUnassignedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRelationItemUnassignedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a relationship entry in a relationship field matching the field path string (JSON path) is removed. */
export interface IContentRelationItemUnassignedCondition extends IBusinessRuleCondition {
    /** Content id that should be matched against. */
    contentId?: string | undefined;
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when the geo point from the field specified by the field path is inside the specified polygon. */
export class GeoPointWithinPolygonCondition extends BusinessRuleCondition implements IGeoPointWithinPolygonCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** List of points that form the polygon for the geo fence.
Must include at least 3 points. */
    polygon?: LatLon[] | undefined;

    constructor(data?: IGeoPointWithinPolygonCondition) {
        super(data);
        if (data) {
            if (data.polygon) {
                this.polygon = [];
                for (let i = 0; i < data.polygon.length; i++) {
                    let item = data.polygon[i];
                    this.polygon[i] = item && !(<any>item).toJSON ? new LatLon(item) : <LatLon>item;
                }
            }
        }
        this._discriminator = "GeoPointWithinPolygonCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            if (Array.isArray(_data["polygon"])) {
                this.polygon = [] as any;
                for (let item of _data["polygon"])
                    this.polygon!.push(LatLon.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): GeoPointWithinPolygonCondition {
        data = typeof data === 'object' ? data : {};
        let result = new GeoPointWithinPolygonCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        if (Array.isArray(this.polygon)) {
            data["polygon"] = [];
            for (let item of this.polygon)
                data["polygon"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Matches when the geo point from the field specified by the field path is inside the specified polygon. */
export interface IGeoPointWithinPolygonCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
    /** List of points that form the polygon for the geo fence.
Must include at least 3 points. */
    polygon?: ILatLon[] | undefined;
}

/** Stores a coordinate */
export class LatLon implements ILatLon {
    /** Latitude */
    lat!: number;
    /** Longitude */
    lon!: number;

    constructor(data?: ILatLon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lon = _data["lon"];
        }
    }

    static fromJS(data: any): LatLon {
        data = typeof data === 'object' ? data : {};
        let result = new LatLon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data;
    }
}

/** Stores a coordinate */
export interface ILatLon {
    /** Latitude */
    lat: number;
    /** Longitude */
    lon: number;
}

/** Matches whenever the assigned content permission sets changed. */
export class ContentPermissionSetsChangedCondition extends BusinessRuleCondition implements IContentPermissionSetsChangedCondition {

    constructor(data?: IContentPermissionSetsChangedCondition) {
        super(data);
        this._discriminator = "ContentPermissionSetsChangedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentPermissionSetsChangedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetsChangedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Matches whenever the assigned content permission sets changed. */
export interface IContentPermissionSetsChangedCondition extends IBusinessRuleCondition {
}

/** Matches whenever the assigned content(s) in a relationship field changed. */
export class ContentRelationItemsChangedCondition extends BusinessRuleCondition implements IContentRelationItemsChangedCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;

    constructor(data?: IContentRelationItemsChangedCondition) {
        super(data);
        this._discriminator = "ContentRelationItemsChangedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): ContentRelationItemsChangedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRelationItemsChangedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Matches whenever the assigned content(s) in a relationship field changed. */
export interface IContentRelationItemsChangedCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches whenever the assigned layers of a content changed. */
export class LayersChangedCondition extends BusinessRuleCondition implements ILayersChangedCondition {
    /** Optional list of layer schema ids that must be added during the current content update operation in order for the condition to match. */
    addedLayerIds?: string[] | undefined;
    /** Optional list of layer schema ids that must be removed during the current content update operation in order for the condition to match. */
    removedLayerIds?: string[] | undefined;

    constructor(data?: ILayersChangedCondition) {
        super(data);
        this._discriminator = "LayersChangedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["addedLayerIds"])) {
                this.addedLayerIds = [] as any;
                for (let item of _data["addedLayerIds"])
                    this.addedLayerIds!.push(item);
            }
            if (Array.isArray(_data["removedLayerIds"])) {
                this.removedLayerIds = [] as any;
                for (let item of _data["removedLayerIds"])
                    this.removedLayerIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): LayersChangedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new LayersChangedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.addedLayerIds)) {
            data["addedLayerIds"] = [];
            for (let item of this.addedLayerIds)
                data["addedLayerIds"].push(item);
        }
        if (Array.isArray(this.removedLayerIds)) {
            data["removedLayerIds"] = [];
            for (let item of this.removedLayerIds)
                data["removedLayerIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Matches whenever the assigned layers of a content changed. */
export interface ILayersChangedCondition extends IBusinessRuleCondition {
    /** Optional list of layer schema ids that must be added during the current content update operation in order for the condition to match. */
    addedLayerIds?: string[] | undefined;
    /** Optional list of layer schema ids that must be removed during the current content update operation in order for the condition to match. */
    removedLayerIds?: string[] | undefined;
}

/** Matches whenever the assigned item(s) in a tagbox changed. */
export class TagboxItemsChangedCondition extends BusinessRuleCondition implements ITagboxItemsChangedCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;

    constructor(data?: ITagboxItemsChangedCondition) {
        super(data);
        this._discriminator = "TagboxItemsChangedCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): TagboxItemsChangedCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TagboxItemsChangedCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Matches whenever the assigned item(s) in a tagbox changed. */
export interface ITagboxItemsChangedCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when a field matching the field path string (JSON path) is empty. */
export class FieldEmptyCondition extends BusinessRuleCondition implements IFieldEmptyCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;

    constructor(data?: IFieldEmptyCondition) {
        super(data);
        this._discriminator = "FieldEmptyCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): FieldEmptyCondition {
        data = typeof data === 'object' ? data : {};
        let result = new FieldEmptyCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Matches when a field matching the field path string (JSON path) is empty. */
export interface IFieldEmptyCondition extends IBusinessRuleCondition {
    /** JSON path to the field */
    fieldPath?: string | undefined;
}

/** Matches when the inner condition is not matching. */
export class NotCondition extends BusinessRuleCondition implements INotCondition {
    /** Inner condition. */
    condition?: BusinessRuleCondition | undefined;

    constructor(data?: INotCondition) {
        super(data);
        this._discriminator = "NotCondition";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.condition = _data["condition"] ? BusinessRuleCondition.fromJS(_data["condition"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): NotCondition {
        data = typeof data === 'object' ? data : {};
        let result = new NotCondition();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Matches when the inner condition is not matching. */
export interface INotCondition extends IBusinessRuleCondition {
    /** Inner condition. */
    condition?: BusinessRuleCondition | undefined;
}

/** Business rule transformation group: A group of transformations to run for the specified inputs */
export class BusinessRuleTransformationGroup implements IBusinessRuleTransformationGroup {
    /** The inputs of the transformation group. */
    inputs?: string[] | undefined;
    /** A list of transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;
    /** Variable name where the final result should be stored in. */
    storeIn?: string | undefined;
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific transformation group names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific transformation group description. */
    description?: TranslatedStringDictionary | undefined;

    constructor(data?: IBusinessRuleTransformationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["inputs"])) {
                this.inputs = [] as any;
                for (let item of _data["inputs"])
                    this.inputs!.push(item);
            }
            if (Array.isArray(_data["transformations"])) {
                this.transformations = [] as any;
                for (let item of _data["transformations"])
                    this.transformations!.push(BusinessRuleTransformation.fromJS(item));
            }
            this.storeIn = _data["storeIn"];
            this.traceRefId = _data["traceRefId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessRuleTransformationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTransformationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.inputs)) {
            data["inputs"] = [];
            for (let item of this.inputs)
                data["inputs"].push(item);
        }
        if (Array.isArray(this.transformations)) {
            data["transformations"] = [];
            for (let item of this.transformations)
                data["transformations"].push(item.toJSON());
        }
        data["storeIn"] = this.storeIn;
        data["traceRefId"] = this.traceRefId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        return data;
    }
}

/** Business rule transformation group: A group of transformations to run for the specified inputs */
export interface IBusinessRuleTransformationGroup {
    /** The inputs of the transformation group. */
    inputs?: string[] | undefined;
    /** A list of transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;
    /** Variable name where the final result should be stored in. */
    storeIn?: string | undefined;
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific transformation group names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific transformation group description. */
    description?: ITranslatedStringDictionary | undefined;
}

/** Business rule transformation */
export abstract class BusinessRuleTransformation implements IBusinessRuleTransformation {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific transformation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific transformation description. */
    description?: TranslatedStringDictionary | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessRuleTransformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
        this._discriminator = "BusinessRuleTransformation";
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessRuleTransformation {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TakeDictionaryValueTransformation") {
            let result = new TakeDictionaryValueTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TakeArrayValueTransformation") {
            let result = new TakeArrayValueTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "JoinByTransformation") {
            let result = new JoinByTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LookupCacheTransformation") {
            let result = new LookupCacheTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramTransformation") {
            let result = new NGramTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ProjectionTransformation") {
            let result = new ProjectionTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SplitTransformation") {
            let result = new SplitTransformation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DateMathTransformation") {
            let result = new DateMathTransformation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRuleTransformation' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["traceRefId"] = this.traceRefId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        return data;
    }
}

/** Business rule transformation */
export interface IBusinessRuleTransformation {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific transformation names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific transformation description. */
    description?: ITranslatedStringDictionary | undefined;
}

/** Takes an item from a dictionary by its key. */
export class TakeDictionaryValueTransformation extends BusinessRuleTransformation implements ITakeDictionaryValueTransformation {
    /** Key of the item. */
    key?: string | undefined;

    constructor(data?: ITakeDictionaryValueTransformation) {
        super(data);
        this._discriminator = "TakeDictionaryValueTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.key = _data["key"];
        }
    }

    static override fromJS(data: any): TakeDictionaryValueTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new TakeDictionaryValueTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        super.toJSON(data);
        return data;
    }
}

/** Takes an item from a dictionary by its key. */
export interface ITakeDictionaryValueTransformation extends IBusinessRuleTransformation {
    /** Key of the item. */
    key?: string | undefined;
}

/** Takes an item from an array by its index. */
export class TakeArrayValueTransformation extends BusinessRuleTransformation implements ITakeArrayValueTransformation {
    /** Index of the item. */
    index?: string | undefined;

    constructor(data?: ITakeArrayValueTransformation) {
        super(data);
        this._discriminator = "TakeArrayValueTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.index = _data["index"];
        }
    }

    static override fromJS(data: any): TakeArrayValueTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new TakeArrayValueTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        super.toJSON(data);
        return data;
    }
}

/** Takes an item from an array by its index. */
export interface ITakeArrayValueTransformation extends IBusinessRuleTransformation {
    /** Index of the item. */
    index?: string | undefined;
}

/** Joins the input by a configurable separator */
export class JoinByTransformation extends BusinessRuleTransformation implements IJoinByTransformation {
    /** Separator to use. */
    separator?: string | undefined;

    constructor(data?: IJoinByTransformation) {
        super(data);
        this._discriminator = "JoinByTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.separator = _data["separator"];
        }
    }

    static override fromJS(data: any): JoinByTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new JoinByTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["separator"] = this.separator;
        super.toJSON(data);
        return data;
    }
}

/** Joins the input by a configurable separator */
export interface IJoinByTransformation extends IBusinessRuleTransformation {
    /** Separator to use. */
    separator?: string | undefined;
}

/** Uses a named cache to lookup a value. */
export class LookupCacheTransformation extends BusinessRuleTransformation implements ILookupCacheTransformation {
    /** Name of the cache to use. */
    namedCache?: string | undefined;
    /** Choose what should be returned.
Found: return the value of the found item in the lookup cache, null if not found.
NotFound: return the input key value of the not found item, null if found.
All: return the value of the found item in the lookup cache or the input key value of the not found item. */
    lookupReturnedItems?: LookupItemsMatch;

    constructor(data?: ILookupCacheTransformation) {
        super(data);
        this._discriminator = "LookupCacheTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.namedCache = _data["namedCache"];
            this.lookupReturnedItems = _data["lookupReturnedItems"];
        }
    }

    static override fromJS(data: any): LookupCacheTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new LookupCacheTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namedCache"] = this.namedCache;
        data["lookupReturnedItems"] = this.lookupReturnedItems;
        super.toJSON(data);
        return data;
    }
}

/** Uses a named cache to lookup a value. */
export interface ILookupCacheTransformation extends IBusinessRuleTransformation {
    /** Name of the cache to use. */
    namedCache?: string | undefined;
    /** Choose what should be returned.
Found: return the value of the found item in the lookup cache, null if not found.
NotFound: return the input key value of the not found item, null if found.
All: return the value of the found item in the lookup cache or the input key value of the not found item. */
    lookupReturnedItems?: LookupItemsMatch;
}

/** How should happen the match on a lookup cache */
export enum LookupItemsMatch {
    Found = "Found",
    NotFound = "NotFound",
    All = "All",
}

/** Produces N-grams based on splitting a text on whitespace characters. Removes punctuation as well. */
export class NGramTransformation extends BusinessRuleTransformation implements INGramTransformation {
    /** Maximum size of n-grams to produce.
Settings this to 3 will produce unigrams, bigrams, trigrams. */
    size?: number;
    /** Minimum length of a word to be considered. */
    minWordLength?: number;
    /** Maximum length of a word to be considered. */
    maxWordLength?: number | undefined;

    constructor(data?: INGramTransformation) {
        super(data);
        this._discriminator = "NGramTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.size = _data["size"];
            this.minWordLength = _data["minWordLength"];
            this.maxWordLength = _data["maxWordLength"];
        }
    }

    static override fromJS(data: any): NGramTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new NGramTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["minWordLength"] = this.minWordLength;
        data["maxWordLength"] = this.maxWordLength;
        super.toJSON(data);
        return data;
    }
}

/** Produces N-grams based on splitting a text on whitespace characters. Removes punctuation as well. */
export interface INGramTransformation extends IBusinessRuleTransformation {
    /** Maximum size of n-grams to produce.
Settings this to 3 will produce unigrams, bigrams, trigrams. */
    size?: number;
    /** Minimum length of a word to be considered. */
    minWordLength?: number;
    /** Maximum length of a word to be considered. */
    maxWordLength?: number | undefined;
}

/** Transforms a list by applying a set of transformation for each item in the list. */
export class ProjectionTransformation extends BusinessRuleTransformation implements IProjectionTransformation {
    /** Transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;

    constructor(data?: IProjectionTransformation) {
        super(data);
        this._discriminator = "ProjectionTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["transformations"])) {
                this.transformations = [] as any;
                for (let item of _data["transformations"])
                    this.transformations!.push(BusinessRuleTransformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ProjectionTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectionTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transformations)) {
            data["transformations"] = [];
            for (let item of this.transformations)
                data["transformations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Transforms a list by applying a set of transformation for each item in the list. */
export interface IProjectionTransformation extends IBusinessRuleTransformation {
    /** Transformations to apply. */
    transformations?: BusinessRuleTransformation[] | undefined;
}

/** Splits the input by separators, optionally trimming the entries afterwards. */
export class SplitTransformation extends BusinessRuleTransformation implements ISplitTransformation {
    /** Separators to use, supports variables, an array of strings including escape sequences or null to split on any white space character. */
    separators?: any | undefined;
    /** Keeps empty items. Empty items will be returned as empty strings. */
    keepEmpty?: boolean;
    /** Trims each entry for punctuation and white space. */
    trim?: boolean;

    constructor(data?: ISplitTransformation) {
        super(data);
        this._discriminator = "SplitTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.separators = _data["separators"];
            this.keepEmpty = _data["keepEmpty"];
            this.trim = _data["trim"];
        }
    }

    static override fromJS(data: any): SplitTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new SplitTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["separators"] = this.separators;
        data["keepEmpty"] = this.keepEmpty;
        data["trim"] = this.trim;
        super.toJSON(data);
        return data;
    }
}

/** Splits the input by separators, optionally trimming the entries afterwards. */
export interface ISplitTransformation extends IBusinessRuleTransformation {
    /** Separators to use, supports variables, an array of strings including escape sequences or null to split on any white space character. */
    separators?: any | undefined;
    /** Keeps empty items. Empty items will be returned as empty strings. */
    keepEmpty?: boolean;
    /** Trims each entry for punctuation and white space. */
    trim?: boolean;
}

/** Add / remove a time span to a date time */
export class DateMathTransformation extends BusinessRuleTransformation implements IDateMathTransformation {
    /** String representation of a time span. */
    timeSpan?: string | undefined;

    constructor(data?: IDateMathTransformation) {
        super(data);
        this._discriminator = "DateMathTransformation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.timeSpan = _data["timeSpan"];
        }
    }

    static override fromJS(data: any): DateMathTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new DateMathTransformation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan;
        super.toJSON(data);
        return data;
    }
}

/** Add / remove a time span to a date time */
export interface IDateMathTransformation extends IBusinessRuleTransformation {
    /** String representation of a time span. */
    timeSpan?: string | undefined;
}

/** Action to be performed by a business rule */
export abstract class BusinessRuleAction implements IBusinessRuleAction {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific action names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific action description. */
    description?: TranslatedStringDictionary | undefined;

    protected _discriminator: string;

    constructor(data?: IBusinessRuleAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
        this._discriminator = "BusinessRuleAction";
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessRuleAction {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AssignLayerAction") {
            let result = new AssignLayerAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnassignLayerAction") {
            let result = new UnassignLayerAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AssignValueAction") {
            let result = new AssignValueAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AssignTagboxItemsAction") {
            let result = new AssignTagboxItemsAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnassignTagboxItemsAction") {
            let result = new UnassignTagboxItemsAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AssignContentPermissionSetsAction") {
            let result = new AssignContentPermissionSetsAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnassignContentPermissionSetsAction") {
            let result = new UnassignContentPermissionSetsAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ProduceMessageAction") {
            let result = new ProduceMessageAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AssignTagboxItemsInLayerAction") {
            let result = new AssignTagboxItemsInLayerAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnqueueTaggingAction") {
            let result = new EnqueueTaggingAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ProduceNotificationAction") {
            let result = new ProduceNotificationAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GetNumberFromNumberSequenceAction") {
            let result = new GetNumberFromNumberSequenceAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnqueueTransferOwnershipAction") {
            let result = new EnqueueTransferOwnershipAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EnqueueCreateEmbedAction") {
            let result = new EnqueueCreateEmbedAction();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BusinessRuleAction' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["traceRefId"] = this.traceRefId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        return data;
    }
}

/** Action to be performed by a business rule */
export interface IBusinessRuleAction {
    /** Optional trace log reference ID set by the system when EnableTracing is set to true on the associated rule. */
    traceRefId?: string | undefined;
    /** Language specific action names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific action description. */
    description?: ITranslatedStringDictionary | undefined;
}

/** Assigns a layer, adding the default values to the data dictionary */
export class AssignLayerAction extends BusinessRuleAction implements IAssignLayerAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
    /** An object containing default values (used for example to populate required fields). */
    defaultValues?: any | undefined;

    constructor(data?: IAssignLayerAction) {
        super(data);
        this._discriminator = "AssignLayerAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
            this.defaultValues = _data["defaultValues"];
        }
    }

    static override fromJS(data: any): AssignLayerAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignLayerAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        data["defaultValues"] = this.defaultValues;
        super.toJSON(data);
        return data;
    }
}

/** Assigns a layer, adding the default values to the data dictionary */
export interface IAssignLayerAction extends IBusinessRuleAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
    /** An object containing default values (used for example to populate required fields). */
    defaultValues?: any | undefined;
}

/** Removes a layer */
export class UnassignLayerAction extends BusinessRuleAction implements IUnassignLayerAction {
    /** The ID of the layer. */
    layerId?: string | undefined;

    constructor(data?: IUnassignLayerAction) {
        super(data);
        this._discriminator = "UnassignLayerAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.layerId = _data["layerId"];
        }
    }

    static override fromJS(data: any): UnassignLayerAction {
        data = typeof data === 'object' ? data : {};
        let result = new UnassignLayerAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        super.toJSON(data);
        return data;
    }
}

/** Removes a layer */
export interface IUnassignLayerAction extends IBusinessRuleAction {
    /** The ID of the layer. */
    layerId?: string | undefined;
}

/** Assign a value to all fields matching the FieldPath (JSON path). */
export class AssignValueAction extends BusinessRuleAction implements IAssignValueAction {
    /** Path to the object the value should be inserted in. */
    path?: string | undefined;
    /** ID of the field, the value should be inserted in. */
    fieldId?: string | undefined;
    /** Value to assign. */
    value?: any | undefined;
    /** Indicates whether existing values should be replaced.
Note: for multi fieldsets and relations, this setting controls, if the value is added
to the already existing values or if the existing values shall be overwritten. */
    replace?: boolean;

    constructor(data?: IAssignValueAction) {
        super(data);
        this._discriminator = "AssignValueAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
            this.fieldId = _data["fieldId"];
            this.value = _data["value"];
            this.replace = _data["replace"];
        }
    }

    static override fromJS(data: any): AssignValueAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignValueAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["fieldId"] = this.fieldId;
        data["value"] = this.value;
        data["replace"] = this.replace;
        super.toJSON(data);
        return data;
    }
}

/** Assign a value to all fields matching the FieldPath (JSON path). */
export interface IAssignValueAction extends IBusinessRuleAction {
    /** Path to the object the value should be inserted in. */
    path?: string | undefined;
    /** ID of the field, the value should be inserted in. */
    fieldId?: string | undefined;
    /** Value to assign. */
    value?: any | undefined;
    /** Indicates whether existing values should be replaced.
Note: for multi fieldsets and relations, this setting controls, if the value is added
to the already existing values or if the existing values shall be overwritten. */
    replace?: boolean;
}

/** Assigns one or multiple tag box items to the multi tagbox identified by the path (JSON path). */
export class AssignTagboxItemsAction extends BusinessRuleAction implements IAssignTagboxItemsAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates whether all the already assigned tags get replaced by the set specified in the action.
If false, the not already assigned tags get added, the rest is left as is. */
    replace?: boolean;

    constructor(data?: IAssignTagboxItemsAction) {
        super(data);
        this._discriminator = "AssignTagboxItemsAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
            this.fieldId = _data["fieldId"];
            this.refIds = _data["refIds"];
            this.replace = _data["replace"];
        }
    }

    static override fromJS(data: any): AssignTagboxItemsAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTagboxItemsAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["fieldId"] = this.fieldId;
        data["refIds"] = this.refIds;
        data["replace"] = this.replace;
        super.toJSON(data);
        return data;
    }
}

/** Assigns one or multiple tag box items to the multi tagbox identified by the path (JSON path). */
export interface IAssignTagboxItemsAction extends IBusinessRuleAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates whether all the already assigned tags get replaced by the set specified in the action.
If false, the not already assigned tags get added, the rest is left as is. */
    replace?: boolean;
}

/** Removes one or multiple tag box items from the multi tagbox identified by the path (JSON path). */
export class UnassignTagboxItemsAction extends BusinessRuleAction implements IUnassignTagboxItemsAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be removed. */
    refIds?: any | undefined;

    constructor(data?: IUnassignTagboxItemsAction) {
        super(data);
        this._discriminator = "UnassignTagboxItemsAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.path = _data["path"];
            this.fieldId = _data["fieldId"];
            this.refIds = _data["refIds"];
        }
    }

    static override fromJS(data: any): UnassignTagboxItemsAction {
        data = typeof data === 'object' ? data : {};
        let result = new UnassignTagboxItemsAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["fieldId"] = this.fieldId;
        data["refIds"] = this.refIds;
        super.toJSON(data);
        return data;
    }
}

/** Removes one or multiple tag box items from the multi tagbox identified by the path (JSON path). */
export interface IUnassignTagboxItemsAction extends IBusinessRuleAction {
    /** Path to the object the tagbox is contained in. */
    path?: string | undefined;
    /** ID of the tagbox field. */
    fieldId?: string | undefined;
    /** List of refIds of the items that should be removed. */
    refIds?: any | undefined;
}

/** Assigns one or more permission sets to a content. */
export class AssignContentPermissionSetsAction extends BusinessRuleAction implements IAssignContentPermissionSetsAction {
    /** IDs of the permission sets to assign. */
    permissionSetIds?: any | undefined;
    /** Indicates whether the already assigned permissions should be replaced or merged. */
    replace?: boolean;

    constructor(data?: IAssignContentPermissionSetsAction) {
        super(data);
        this._discriminator = "AssignContentPermissionSetsAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetIds = _data["permissionSetIds"];
            this.replace = _data["replace"];
        }
    }

    static override fromJS(data: any): AssignContentPermissionSetsAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignContentPermissionSetsAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetIds"] = this.permissionSetIds;
        data["replace"] = this.replace;
        super.toJSON(data);
        return data;
    }
}

/** Assigns one or more permission sets to a content. */
export interface IAssignContentPermissionSetsAction extends IBusinessRuleAction {
    /** IDs of the permission sets to assign. */
    permissionSetIds?: any | undefined;
    /** Indicates whether the already assigned permissions should be replaced or merged. */
    replace?: boolean;
}

/** Removes one or more permission sets from a content. */
export class UnassignContentPermissionSetsAction extends BusinessRuleAction implements IUnassignContentPermissionSetsAction {
    /** IDs of the permission sets to unassign. */
    permissionSetIds?: any | undefined;

    constructor(data?: IUnassignContentPermissionSetsAction) {
        super(data);
        this._discriminator = "UnassignContentPermissionSetsAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetIds = _data["permissionSetIds"];
        }
    }

    static override fromJS(data: any): UnassignContentPermissionSetsAction {
        data = typeof data === 'object' ? data : {};
        let result = new UnassignContentPermissionSetsAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetIds"] = this.permissionSetIds;
        super.toJSON(data);
        return data;
    }
}

/** Removes one or more permission sets from a content. */
export interface IUnassignContentPermissionSetsAction extends IBusinessRuleAction {
    /** IDs of the permission sets to unassign. */
    permissionSetIds?: any | undefined;
}

/** Produces a message that is enqueued to the integration bus for a service provider to consume */
export class ProduceMessageAction extends BusinessRuleAction implements IProduceMessageAction {

    constructor(data?: IProduceMessageAction) {
        super(data);
        this._discriminator = "ProduceMessageAction";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ProduceMessageAction {
        data = typeof data === 'object' ? data : {};
        let result = new ProduceMessageAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Produces a message that is enqueued to the integration bus for a service provider to consume */
export interface IProduceMessageAction extends IBusinessRuleAction {
}

/** Assigns a set of list item ids to all multi tag boxes in a layer where the filter defined on the tagbox does allow assignment of the ID. */
export class AssignTagboxItemsInLayerAction extends BusinessRuleAction implements IAssignTagboxItemsInLayerAction {
    /** Named cache to use for lookup, should be of type SchemaTagboxFilterLookupNamedCacheConfiguration */
    namedCache?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates where the assignment should be additive to the already assigned tags
or if existing tags should be replaced. */
    replace?: boolean;

    constructor(data?: IAssignTagboxItemsInLayerAction) {
        super(data);
        this._discriminator = "AssignTagboxItemsInLayerAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.namedCache = _data["namedCache"];
            this.refIds = _data["refIds"];
            this.replace = _data["replace"];
        }
    }

    static override fromJS(data: any): AssignTagboxItemsInLayerAction {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTagboxItemsInLayerAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namedCache"] = this.namedCache;
        data["refIds"] = this.refIds;
        data["replace"] = this.replace;
        super.toJSON(data);
        return data;
    }
}

/** Assigns a set of list item ids to all multi tag boxes in a layer where the filter defined on the tagbox does allow assignment of the ID. */
export interface IAssignTagboxItemsInLayerAction extends IBusinessRuleAction {
    /** Named cache to use for lookup, should be of type SchemaTagboxFilterLookupNamedCacheConfiguration */
    namedCache?: string | undefined;
    /** List of refIds of the items that should be assigned. */
    refIds?: any | undefined;
    /** Indicates where the assignment should be additive to the already assigned tags
or if existing tags should be replaced. */
    replace?: boolean;
}

/** Enqueue content for tagging */
export class EnqueueTaggingAction extends BusinessRuleAction implements IEnqueueTaggingAction {
    /** Options to use while tagging. */
    options?: TaggingOptionsBase | undefined;

    constructor(data?: IEnqueueTaggingAction) {
        super(data);
        this._discriminator = "EnqueueTaggingAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.options = _data["options"] ? TaggingOptionsBase.fromJS(_data["options"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): EnqueueTaggingAction {
        data = typeof data === 'object' ? data : {};
        let result = new EnqueueTaggingAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Enqueue content for tagging */
export interface IEnqueueTaggingAction extends IBusinessRuleAction {
    /** Options to use while tagging. */
    options?: TaggingOptionsBase | undefined;
}

/** Options for tagging */
export abstract class TaggingOptionsBase implements ITaggingOptionsBase {
    /** Override for the output format ID to tag. */
    tagOutputFormatId?: string | undefined;
    /** Override for the cache to use. */
    keywordLookupCacheName?: string | undefined;
    /** Override for the layer to assign. */
    taggingLayerId?: string | undefined;
    /** Override for the field id where found tags are stored. */
    foundTagsFieldId?: string | undefined;
    /** Override for the field id where not found tags are stored. */
    missingKeywordsFieldId?: string | undefined;

    protected _discriminator: string;

    constructor(data?: ITaggingOptionsBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "TaggingOptionsBase";
    }

    init(_data?: any) {
        if (_data) {
            this.tagOutputFormatId = _data["tagOutputFormatId"];
            this.keywordLookupCacheName = _data["keywordLookupCacheName"];
            this.taggingLayerId = _data["taggingLayerId"];
            this.foundTagsFieldId = _data["foundTagsFieldId"];
            this.missingKeywordsFieldId = _data["missingKeywordsFieldId"];
        }
    }

    static fromJS(data: any): TaggingOptionsBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ClarifaiTaggingOptions") {
            let result = new ClarifaiTaggingOptions();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimulatedTaggingOptions") {
            let result = new SimulatedTaggingOptions();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AzureTaggingOptions") {
            let result = new AzureTaggingOptions();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TaggingOptionsBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["tagOutputFormatId"] = this.tagOutputFormatId;
        data["keywordLookupCacheName"] = this.keywordLookupCacheName;
        data["taggingLayerId"] = this.taggingLayerId;
        data["foundTagsFieldId"] = this.foundTagsFieldId;
        data["missingKeywordsFieldId"] = this.missingKeywordsFieldId;
        return data;
    }
}

/** Options for tagging */
export interface ITaggingOptionsBase {
    /** Override for the output format ID to tag. */
    tagOutputFormatId?: string | undefined;
    /** Override for the cache to use. */
    keywordLookupCacheName?: string | undefined;
    /** Override for the layer to assign. */
    taggingLayerId?: string | undefined;
    /** Override for the field id where found tags are stored. */
    foundTagsFieldId?: string | undefined;
    /** Override for the field id where not found tags are stored. */
    missingKeywordsFieldId?: string | undefined;
}

/** Options for clarifai tagging */
export class ClarifaiTaggingOptions extends TaggingOptionsBase implements IClarifaiTaggingOptions {
    /** Override for the model to use */
    model?: string | undefined;
    /** Override for the language to use */
    language?: string | undefined;
    /** Minimum value a concept must have to be considered */
    minimumValue?: string | undefined;

    constructor(data?: IClarifaiTaggingOptions) {
        super(data);
        this._discriminator = "ClarifaiTaggingOptions";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.model = _data["model"];
            this.language = _data["language"];
            this.minimumValue = _data["minimumValue"];
        }
    }

    static override fromJS(data: any): ClarifaiTaggingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ClarifaiTaggingOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model;
        data["language"] = this.language;
        data["minimumValue"] = this.minimumValue;
        super.toJSON(data);
        return data;
    }
}

/** Options for clarifai tagging */
export interface IClarifaiTaggingOptions extends ITaggingOptionsBase {
    /** Override for the model to use */
    model?: string | undefined;
    /** Override for the language to use */
    language?: string | undefined;
    /** Minimum value a concept must have to be considered */
    minimumValue?: string | undefined;
}

export class SimulatedTaggingOptions extends TaggingOptionsBase implements ISimulatedTaggingOptions {
    /** Number of keywords to assign. */
    numberOfKeywords?: string | undefined;
    /** Enables/disables ocr feature */
    enableOcr?: boolean;

    constructor(data?: ISimulatedTaggingOptions) {
        super(data);
        this._discriminator = "SimulatedTaggingOptions";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.numberOfKeywords = _data["numberOfKeywords"];
            this.enableOcr = _data["enableOcr"];
        }
    }

    static override fromJS(data: any): SimulatedTaggingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new SimulatedTaggingOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfKeywords"] = this.numberOfKeywords;
        data["enableOcr"] = this.enableOcr;
        super.toJSON(data);
        return data;
    }
}

export interface ISimulatedTaggingOptions extends ITaggingOptionsBase {
    /** Number of keywords to assign. */
    numberOfKeywords?: string | undefined;
    /** Enables/disables ocr feature */
    enableOcr?: boolean;
}

/** Options for Azure tagging */
export class AzureTaggingOptions extends TaggingOptionsBase implements IAzureTaggingOptions {
    /** Url to Azure Computer Vision Service */
    apiUrl?: string | undefined;
    /** API Key to Azure Computer Vision Service (needed for connection) */
    apiKey?: string | undefined;
    /** Determines the language, list of supported language codes: https://aka.ms/cv-languages */
    languageCode?: string | undefined;
    /** Minimum value of confidence to accept the service result */
    minimumValue?: string | undefined;
    /** Specifies if tagging feature should be enabled */
    enableTagging?: boolean;
    /** Specifies if object detection feature should be enabled */
    enableObjectDetection?: boolean;
    /** Specifies if OCR feature should be enabled */
    enableOcr?: boolean;

    constructor(data?: IAzureTaggingOptions) {
        super(data);
        this._discriminator = "AzureTaggingOptions";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiUrl = _data["apiUrl"];
            this.apiKey = _data["apiKey"];
            this.languageCode = _data["languageCode"];
            this.minimumValue = _data["minimumValue"];
            this.enableTagging = _data["enableTagging"];
            this.enableObjectDetection = _data["enableObjectDetection"];
            this.enableOcr = _data["enableOcr"];
        }
    }

    static override fromJS(data: any): AzureTaggingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AzureTaggingOptions();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiUrl"] = this.apiUrl;
        data["apiKey"] = this.apiKey;
        data["languageCode"] = this.languageCode;
        data["minimumValue"] = this.minimumValue;
        data["enableTagging"] = this.enableTagging;
        data["enableObjectDetection"] = this.enableObjectDetection;
        data["enableOcr"] = this.enableOcr;
        super.toJSON(data);
        return data;
    }
}

/** Options for Azure tagging */
export interface IAzureTaggingOptions extends ITaggingOptionsBase {
    /** Url to Azure Computer Vision Service */
    apiUrl?: string | undefined;
    /** API Key to Azure Computer Vision Service (needed for connection) */
    apiKey?: string | undefined;
    /** Determines the language, list of supported language codes: https://aka.ms/cv-languages */
    languageCode?: string | undefined;
    /** Minimum value of confidence to accept the service result */
    minimumValue?: string | undefined;
    /** Specifies if tagging feature should be enabled */
    enableTagging?: boolean;
    /** Specifies if object detection feature should be enabled */
    enableObjectDetection?: boolean;
    /** Specifies if OCR feature should be enabled */
    enableOcr?: boolean;
}

/** Produces a notification that is enqueued to users, user groups or owners recipients */
export class ProduceNotificationAction extends BusinessRuleAction implements IProduceNotificationAction {
    /** ID of the notification to produce. */
    notificationId?: string | undefined;
    /** Recipients of the notification. */
    recipients!: NotificationRecipientBase[];

    constructor(data?: IProduceNotificationAction) {
        super(data);
        if (!data) {
            this.recipients = [];
        }
        this._discriminator = "ProduceNotificationAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.notificationId = _data["notificationId"];
            if (Array.isArray(_data["recipients"])) {
                this.recipients = [] as any;
                for (let item of _data["recipients"])
                    this.recipients!.push(NotificationRecipientBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ProduceNotificationAction {
        data = typeof data === 'object' ? data : {};
        let result = new ProduceNotificationAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        if (Array.isArray(this.recipients)) {
            data["recipients"] = [];
            for (let item of this.recipients)
                data["recipients"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Produces a notification that is enqueued to users, user groups or owners recipients */
export interface IProduceNotificationAction extends IBusinessRuleAction {
    /** ID of the notification to produce. */
    notificationId?: string | undefined;
    /** Recipients of the notification. */
    recipients: NotificationRecipientBase[];
}

export abstract class NotificationRecipientBase implements INotificationRecipientBase {

    protected _discriminator: string;

    constructor(data?: INotificationRecipientBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "NotificationRecipientBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): NotificationRecipientBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "UserNotificationRecipient") {
            let result = new UserNotificationRecipient();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRoleNotificationRecipient") {
            let result = new UserRoleNotificationRecipient();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UserRightNotificationRecipient") {
            let result = new UserRightNotificationRecipient();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OwnerNotificationRecipient") {
            let result = new OwnerNotificationRecipient();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationRecipientBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface INotificationRecipientBase {
}

export class UserNotificationRecipient extends NotificationRecipientBase implements IUserNotificationRecipient {
    /** User ID. */
    userId!: string;

    constructor(data?: IUserNotificationRecipient) {
        super(data);
        this._discriminator = "UserNotificationRecipient";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static override fromJS(data: any): UserNotificationRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationRecipient();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserNotificationRecipient extends INotificationRecipientBase {
    /** User ID. */
    userId: string;
}

export class UserRoleNotificationRecipient extends NotificationRecipientBase implements IUserRoleNotificationRecipient {
    /** User role ID. */
    userRoleId!: string;

    constructor(data?: IUserRoleNotificationRecipient) {
        super(data);
        this._discriminator = "UserRoleNotificationRecipient";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userRoleId = _data["userRoleId"];
        }
    }

    static override fromJS(data: any): UserRoleNotificationRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleNotificationRecipient();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRoleNotificationRecipient extends INotificationRecipientBase {
    /** User role ID. */
    userRoleId: string;
}

export class UserRightNotificationRecipient extends NotificationRecipientBase implements IUserRightNotificationRecipient {
    /** User right. */
    userRight!: UserRight;

    constructor(data?: IUserRightNotificationRecipient) {
        super(data);
        this._discriminator = "UserRightNotificationRecipient";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userRight = _data["userRight"];
        }
    }

    static override fromJS(data: any): UserRightNotificationRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new UserRightNotificationRecipient();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRight"] = this.userRight;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRightNotificationRecipient extends INotificationRecipientBase {
    /** User right. */
    userRight: UserRight;
}

export class OwnerNotificationRecipient extends NotificationRecipientBase implements IOwnerNotificationRecipient {

    constructor(data?: IOwnerNotificationRecipient) {
        super(data);
        this._discriminator = "OwnerNotificationRecipient";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OwnerNotificationRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerNotificationRecipient();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOwnerNotificationRecipient extends INotificationRecipientBase {
}

/** Action to get a number from a configured number sequence and store it in a variable. */
export class GetNumberFromNumberSequenceAction extends BusinessRuleAction implements IGetNumberFromNumberSequenceAction {
    /** ID of the sequence number to get number from. */
    numberSequenceId?: string | undefined;
    /** Variable name to store number in. */
    storeIn?: string | undefined;

    constructor(data?: IGetNumberFromNumberSequenceAction) {
        super(data);
        this._discriminator = "GetNumberFromNumberSequenceAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.numberSequenceId = _data["numberSequenceId"];
            this.storeIn = _data["storeIn"];
        }
    }

    static override fromJS(data: any): GetNumberFromNumberSequenceAction {
        data = typeof data === 'object' ? data : {};
        let result = new GetNumberFromNumberSequenceAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberSequenceId"] = this.numberSequenceId;
        data["storeIn"] = this.storeIn;
        super.toJSON(data);
        return data;
    }
}

/** Action to get a number from a configured number sequence and store it in a variable. */
export interface IGetNumberFromNumberSequenceAction extends IBusinessRuleAction {
    /** ID of the sequence number to get number from. */
    numberSequenceId?: string | undefined;
    /** Variable name to store number in. */
    storeIn?: string | undefined;
}

/** Enqueue content for transfer ownership */
export class EnqueueTransferOwnershipAction extends BusinessRuleAction implements IEnqueueTransferOwnershipAction {
    /** Id of the user to whom the ownership should be transferred. */
    transferUserId?: string | undefined;

    constructor(data?: IEnqueueTransferOwnershipAction) {
        super(data);
        this._discriminator = "EnqueueTransferOwnershipAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferUserId = _data["transferUserId"];
        }
    }

    static override fromJS(data: any): EnqueueTransferOwnershipAction {
        data = typeof data === 'object' ? data : {};
        let result = new EnqueueTransferOwnershipAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        super.toJSON(data);
        return data;
    }
}

/** Enqueue content for transfer ownership */
export interface IEnqueueTransferOwnershipAction extends IBusinessRuleAction {
    /** Id of the user to whom the ownership should be transferred. */
    transferUserId?: string | undefined;
}

/** Enqueue creation of an embed */
export class EnqueueCreateEmbedAction extends BusinessRuleAction implements IEnqueueCreateEmbedAction {
    /** Name of the embed. If empty, it will be automatically initialized with the 'Embed_{RuleId}'. */
    embedName?: string | undefined;
    /** Optional description of the embed. */
    embedDescription?: string | undefined;
    /** Output format of the content to be embedded. */
    outputFormatId!: string;
    /** Optional conversion to apply to the output. */
    conversionString?: string | undefined;
    /** Indicates if the conversion is locked and therefore cannot be changed by the caller of the embed URI. */
    lockDeliveryOptions?: boolean;
    /** Optional date when embed expires and cannot be accessed anymore: It must be in ISO format, with or without milliseconds 'yyyy-MM-ddTHH:mm:ss(.fffffff)K'. */
    expirationDate?: string | undefined;
    /** Optional variable name to store in the url of the embed that will be created. */
    storeIn?: string | undefined;

    constructor(data?: IEnqueueCreateEmbedAction) {
        super(data);
        this._discriminator = "EnqueueCreateEmbedAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.embedName = _data["embedName"];
            this.embedDescription = _data["embedDescription"];
            this.outputFormatId = _data["outputFormatId"];
            this.conversionString = _data["conversionString"];
            this.lockDeliveryOptions = _data["lockDeliveryOptions"];
            this.expirationDate = _data["expirationDate"];
            this.storeIn = _data["storeIn"];
        }
    }

    static override fromJS(data: any): EnqueueCreateEmbedAction {
        data = typeof data === 'object' ? data : {};
        let result = new EnqueueCreateEmbedAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["embedName"] = this.embedName;
        data["embedDescription"] = this.embedDescription;
        data["outputFormatId"] = this.outputFormatId;
        data["conversionString"] = this.conversionString;
        data["lockDeliveryOptions"] = this.lockDeliveryOptions;
        data["expirationDate"] = this.expirationDate;
        data["storeIn"] = this.storeIn;
        super.toJSON(data);
        return data;
    }
}

/** Enqueue creation of an embed */
export interface IEnqueueCreateEmbedAction extends IBusinessRuleAction {
    /** Name of the embed. If empty, it will be automatically initialized with the 'Embed_{RuleId}'. */
    embedName?: string | undefined;
    /** Optional description of the embed. */
    embedDescription?: string | undefined;
    /** Output format of the content to be embedded. */
    outputFormatId: string;
    /** Optional conversion to apply to the output. */
    conversionString?: string | undefined;
    /** Indicates if the conversion is locked and therefore cannot be changed by the caller of the embed URI. */
    lockDeliveryOptions?: boolean;
    /** Optional date when embed expires and cannot be accessed anymore: It must be in ISO format, with or without milliseconds 'yyyy-MM-ddTHH:mm:ss(.fffffff)K'. */
    expirationDate?: string | undefined;
    /** Optional variable name to store in the url of the embed that will be created. */
    storeIn?: string | undefined;
}

/** A business rule expressed as a script */
export class BusinessRuleScript extends BusinessRule implements IBusinessRuleScript {
    /** Script */
    script?: string | undefined;

    constructor(data?: IBusinessRuleScript) {
        super(data);
        this._discriminator = "BusinessRuleScript";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.script = _data["script"];
        }
    }

    static override fromJS(data: any): BusinessRuleScript {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleScript();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["script"] = this.script;
        super.toJSON(data);
        return data;
    }
}

/** A business rule expressed as a script */
export interface IBusinessRuleScript extends IBusinessRule {
    /** Script */
    script?: string | undefined;
}

/** Named cache configuration */
export abstract class NamedCacheConfigurationBase implements INamedCacheConfigurationBase {
    /** Name of named cache. */
    name!: string;
    /** Indicates if the lookup should be case sensitive. */
    caseSensitive!: boolean;

    protected _discriminator: string;

    constructor(data?: INamedCacheConfigurationBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "NamedCacheConfigurationBase";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.caseSensitive = _data["caseSensitive"];
        }
    }

    static fromJS(data: any): NamedCacheConfigurationBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ListItemNamedCacheConfiguration") {
            let result = new ListItemNamedCacheConfiguration();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SchemaTagboxFilterLookupNamedCacheConfiguration") {
            let result = new SchemaTagboxFilterLookupNamedCacheConfiguration();
            result.init(data);
            return result;
        }
        if (data["kind"] === "InverseListItemNamedCacheConfiguration") {
            let result = new InverseListItemNamedCacheConfiguration();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NamedCacheConfigurationBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["name"] = this.name;
        data["caseSensitive"] = this.caseSensitive;
        return data;
    }
}

/** Named cache configuration */
export interface INamedCacheConfigurationBase {
    /** Name of named cache. */
    name: string;
    /** Indicates if the lookup should be case sensitive. */
    caseSensitive: boolean;
}

/** List item named cache */
export class ListItemNamedCacheConfiguration extends NamedCacheConfigurationBase implements IListItemNamedCacheConfiguration {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** List of IDs of fields to use as a composite key */
    keyFields?: string[] | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;

    constructor(data?: IListItemNamedCacheConfiguration) {
        super(data);
        this._discriminator = "ListItemNamedCacheConfiguration";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            if (Array.isArray(_data["keyFields"])) {
                this.keyFields = [] as any;
                for (let item of _data["keyFields"])
                    this.keyFields!.push(item);
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = _data["includeAllSchemaChildren"];
        }
    }

    static override fromJS(data: any): ListItemNamedCacheConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemNamedCacheConfiguration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        if (Array.isArray(this.keyFields)) {
            data["keyFields"] = [];
            for (let item of this.keyFields)
                data["keyFields"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        super.toJSON(data);
        return data;
    }
}

/** List item named cache */
export interface IListItemNamedCacheConfiguration extends INamedCacheConfigurationBase {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** List of IDs of fields to use as a composite key */
    keyFields?: string[] | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;
}

/** Creates a cache for all multi tag boxes in a schema Lookup key is then in the format [ fieldId, refId ], returns the refId if matched by the filter */
export class SchemaTagboxFilterLookupNamedCacheConfiguration extends NamedCacheConfigurationBase implements ISchemaTagboxFilterLookupNamedCacheConfiguration {
    /** The layer id. */
    schemaId?: string | undefined;

    constructor(data?: ISchemaTagboxFilterLookupNamedCacheConfiguration) {
        super(data);
        this._discriminator = "SchemaTagboxFilterLookupNamedCacheConfiguration";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static override fromJS(data: any): SchemaTagboxFilterLookupNamedCacheConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaTagboxFilterLookupNamedCacheConfiguration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        super.toJSON(data);
        return data;
    }
}

/** Creates a cache for all multi tag boxes in a schema Lookup key is then in the format [ fieldId, refId ], returns the refId if matched by the filter */
export interface ISchemaTagboxFilterLookupNamedCacheConfiguration extends INamedCacheConfigurationBase {
    /** The layer id. */
    schemaId?: string | undefined;
}

export class InverseListItemNamedCacheConfiguration extends NamedCacheConfigurationBase implements IInverseListItemNamedCacheConfiguration {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** ID of the field that yields the value */
    valueField?: string | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;

    constructor(data?: IInverseListItemNamedCacheConfiguration) {
        super(data);
        this._discriminator = "InverseListItemNamedCacheConfiguration";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.valueField = _data["valueField"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = _data["includeAllSchemaChildren"];
        }
    }

    static override fromJS(data: any): InverseListItemNamedCacheConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new InverseListItemNamedCacheConfiguration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["valueField"] = this.valueField;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        super.toJSON(data);
        return data;
    }
}

export interface IInverseListItemNamedCacheConfiguration extends INamedCacheConfigurationBase {
    /** ID of the schema to cache (should have SchemaType = List) */
    schemaId?: string | undefined;
    /** ID of the field that yields the value */
    valueField?: string | undefined;
    /** An optional filter to narrow down the cached list items */
    filter?: FilterBase | undefined;
    /** Include child schemas when caching list items */
    includeAllSchemaChildren?: boolean;
}

/** Configuration for a notification sent by ProduceNotificationAction. */
export class BusinessRuleNotification implements IBusinessRuleNotification {
    /** ID of the notification. */
    id!: string;
    /** Title of the notification. */
    title?: TranslatedStringDictionary | undefined;
    /** Message of the notification. */
    message?: TranslatedStringDictionary | undefined;
    /** Indicates if a collection of the items affected should be created. */
    createCollection!: boolean;
    /** Name of the template to use when converting the notification to an item in the email notifications. */
    templateName?: string | undefined;

    constructor(data?: IBusinessRuleNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.title = data.title && !(<any>data.title).toJSON ? new TranslatedStringDictionary(data.title) : <TranslatedStringDictionary>this.title;
            this.message = data.message && !(<any>data.message).toJSON ? new TranslatedStringDictionary(data.message) : <TranslatedStringDictionary>this.message;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"] ? TranslatedStringDictionary.fromJS(_data["title"]) : <any>undefined;
            this.message = _data["message"] ? TranslatedStringDictionary.fromJS(_data["message"]) : <any>undefined;
            this.createCollection = _data["createCollection"];
            this.templateName = _data["templateName"];
        }
    }

    static fromJS(data: any): BusinessRuleNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["createCollection"] = this.createCollection;
        data["templateName"] = this.templateName;
        return data;
    }
}

/** Configuration for a notification sent by ProduceNotificationAction. */
export interface IBusinessRuleNotification {
    /** ID of the notification. */
    id: string;
    /** Title of the notification. */
    title?: ITranslatedStringDictionary | undefined;
    /** Message of the notification. */
    message?: ITranslatedStringDictionary | undefined;
    /** Indicates if a collection of the items affected should be created. */
    createCollection: boolean;
    /** Name of the template to use when converting the notification to an item in the email notifications. */
    templateName?: string | undefined;
}

/** Configuration for a number sequence. */
export class BusinessRuleNumberSequence implements IBusinessRuleNumberSequence {
    /** ID of number sequence. */
    id!: string;
    /** Format.
Refer to https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings for guidance.
Note: formatting of numbers use invariant culture. */
    format?: string | undefined;
    /** Starting number of the sequence.
Note: When changing this, existing sequence number will be reset to new starting number and might produce duplicate numbers. */
    start!: number;

    constructor(data?: IBusinessRuleNumberSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.format = _data["format"];
            this.start = _data["start"];
        }
    }

    static fromJS(data: any): BusinessRuleNumberSequence {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleNumberSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["format"] = this.format;
        data["start"] = this.start;
        return data;
    }
}

/** Configuration for a number sequence. */
export interface IBusinessRuleNumberSequence {
    /** ID of number sequence. */
    id: string;
    /** Format.
Refer to https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings for guidance.
Note: formatting of numbers use invariant culture. */
    format?: string | undefined;
    /** Starting number of the sequence.
Note: When changing this, existing sequence number will be reset to new starting number and might produce duplicate numbers. */
    start: number;
}

/** Schedules business rules to run on a regular time frame. Note: If schedules do not complete within 15 minutes, next execution will be skipped */
export class BusinessRuleSchedule implements IBusinessRuleSchedule {
    /** Language specific names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific description. */
    description?: TranslatedStringDictionary | undefined;
    /** Cron expression to specify run time.
Refer to https://github.com/HangfireIO/Cronos#cron-format for reference.
Minimum interval supported is 15 minutes. */
    cronExpression?: string | undefined;
    /** IDs of business rules to run during schedule, regardless of trigger point */
    ruleIds?: string[] | undefined;
    /** Doc type of items that should be loaded. */
    docType!: BusinessRuleTriggerDocType;
    /** Search string to apply when searching for items to load. */
    searchString?: string | undefined;
    /** Filter to apply when searching for items to load. */
    filter?: FilterBase | undefined;
    /** Indicates if schedule is enabled. */
    isEnabled!: boolean;

    constructor(data?: IBusinessRuleSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
            this.cronExpression = _data["cronExpression"];
            if (Array.isArray(_data["ruleIds"])) {
                this.ruleIds = [] as any;
                for (let item of _data["ruleIds"])
                    this.ruleIds!.push(item);
            }
            this.docType = _data["docType"];
            this.searchString = _data["searchString"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): BusinessRuleSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["cronExpression"] = this.cronExpression;
        if (Array.isArray(this.ruleIds)) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["docType"] = this.docType;
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

/** Schedules business rules to run on a regular time frame. Note: If schedules do not complete within 15 minutes, next execution will be skipped */
export interface IBusinessRuleSchedule {
    /** Language specific names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific description. */
    description?: ITranslatedStringDictionary | undefined;
    /** Cron expression to specify run time.
Refer to https://github.com/HangfireIO/Cronos#cron-format for reference.
Minimum interval supported is 15 minutes. */
    cronExpression?: string | undefined;
    /** IDs of business rules to run during schedule, regardless of trigger point */
    ruleIds?: string[] | undefined;
    /** Doc type of items that should be loaded. */
    docType: BusinessRuleTriggerDocType;
    /** Search string to apply when searching for items to load. */
    searchString?: string | undefined;
    /** Filter to apply when searching for items to load. */
    filter?: FilterBase | undefined;
    /** Indicates if schedule is enabled. */
    isEnabled: boolean;
}

/** Update request for changing business rule configuration */
export class BusinessRuleConfigurationUpdateRequest extends BusinessRuleConfiguration implements IBusinessRuleConfigurationUpdateRequest {

    constructor(data?: IBusinessRuleConfigurationUpdateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleConfigurationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleConfigurationUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Update request for changing business rule configuration */
export interface IBusinessRuleConfigurationUpdateRequest extends IBusinessRuleConfiguration {
}

/** Base class for search results */
export class BaseResultOfBusinessRuleTraceLog implements IBaseResultOfBusinessRuleTraceLog {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: BusinessRuleTraceLog[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfBusinessRuleTraceLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new BusinessRuleTraceLog(item) : <BusinessRuleTraceLog>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BusinessRuleTraceLog.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfBusinessRuleTraceLog {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfBusinessRuleTraceLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfBusinessRuleTraceLog {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IBusinessRuleTraceLog[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfBusinessRuleTraceLog extends BaseResultOfBusinessRuleTraceLog implements ISearchBehaviorBaseResultOfBusinessRuleTraceLog {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfBusinessRuleTraceLog) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfBusinessRuleTraceLog {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfBusinessRuleTraceLog();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfBusinessRuleTraceLog extends IBaseResultOfBusinessRuleTraceLog {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog extends SearchBehaviorBaseResultOfBusinessRuleTraceLog implements ISearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog extends ISearchBehaviorBaseResultOfBusinessRuleTraceLog {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Holds results of trace log search. */
export class BusinessRuleTraceLogSearchResult extends SearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog implements IBusinessRuleTraceLogSearchResult {

    constructor(data?: IBusinessRuleTraceLogSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): BusinessRuleTraceLogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTraceLogSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of trace log search. */
export interface IBusinessRuleTraceLogSearchResult extends ISearchBehaviorWithAggregationBaseResultOfBusinessRuleTraceLog {
}

/** Contains a trace for a single document affected by potentially multiple business rules being evaluated and executed. */
export class BusinessRuleTraceLog implements IBusinessRuleTraceLog {
    /** ID of the trace. */
    id?: string | undefined;
    /** ID of the document. */
    documentId?: string | undefined;
    /** Type of the document. */
    documentType!: BusinessRuleTriggerDocType;
    /** IDs of rules that were traced for this document. */
    ruleIds?: string[] | undefined;
    /** Detailed information about rules traced. */
    rules?: BusinessRuleTracedRule[] | undefined;
    /** Validation errors occuring after all rules have ran. */
    validationErrors?: ErrorResponse[] | undefined;
    /** General errors occuring when saving the document. */
    generalErrors?: ErrorResponse[] | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;

    constructor(data?: IBusinessRuleTraceLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rules) {
                this.rules = [];
                for (let i = 0; i < data.rules.length; i++) {
                    let item = data.rules[i];
                    this.rules[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedRule(item) : <BusinessRuleTracedRule>item;
                }
            }
            if (data.validationErrors) {
                this.validationErrors = [];
                for (let i = 0; i < data.validationErrors.length; i++) {
                    let item = data.validationErrors[i];
                    this.validationErrors[i] = item && !(<any>item).toJSON ? new ErrorResponse(item) : <ErrorResponse>item;
                }
            }
            if (data.generalErrors) {
                this.generalErrors = [];
                for (let i = 0; i < data.generalErrors.length; i++) {
                    let item = data.generalErrors[i];
                    this.generalErrors[i] = item && !(<any>item).toJSON ? new ErrorResponse(item) : <ErrorResponse>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentId = _data["documentId"];
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["ruleIds"])) {
                this.ruleIds = [] as any;
                for (let item of _data["ruleIds"])
                    this.ruleIds!.push(item);
            }
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(BusinessRuleTracedRule.fromJS(item));
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(ErrorResponse.fromJS(item));
            }
            if (Array.isArray(_data["generalErrors"])) {
                this.generalErrors = [] as any;
                for (let item of _data["generalErrors"])
                    this.generalErrors!.push(ErrorResponse.fromJS(item));
            }
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessRuleTraceLog {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTraceLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        if (Array.isArray(this.ruleIds)) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        if (Array.isArray(this.generalErrors)) {
            data["generalErrors"] = [];
            for (let item of this.generalErrors)
                data["generalErrors"].push(item.toJSON());
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains a trace for a single document affected by potentially multiple business rules being evaluated and executed. */
export interface IBusinessRuleTraceLog {
    /** ID of the trace. */
    id?: string | undefined;
    /** ID of the document. */
    documentId?: string | undefined;
    /** Type of the document. */
    documentType: BusinessRuleTriggerDocType;
    /** IDs of rules that were traced for this document. */
    ruleIds?: string[] | undefined;
    /** Detailed information about rules traced. */
    rules?: IBusinessRuleTracedRule[] | undefined;
    /** Validation errors occuring after all rules have ran. */
    validationErrors?: IErrorResponse[] | undefined;
    /** General errors occuring when saving the document. */
    generalErrors?: IErrorResponse[] | undefined;
    /** Audit information. */
    audit?: IUserAudit | undefined;
}

/** Traced Business rule */
export class BusinessRuleTracedRule implements IBusinessRuleTracedRule {
    /** Configuration of the rule as it was running. Enriched with trace ref IDs. */
    configuration?: BusinessRule | undefined;
    /** Evaluations performed for this rule. */
    evaluations?: BusinessRuleTracedEvaluation[] | undefined;

    constructor(data?: IBusinessRuleTracedRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.evaluations) {
                this.evaluations = [];
                for (let i = 0; i < data.evaluations.length; i++) {
                    let item = data.evaluations[i];
                    this.evaluations[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedEvaluation(item) : <BusinessRuleTracedEvaluation>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["configuration"] ? BusinessRule.fromJS(_data["configuration"]) : <any>undefined;
            if (Array.isArray(_data["evaluations"])) {
                this.evaluations = [] as any;
                for (let item of _data["evaluations"])
                    this.evaluations!.push(BusinessRuleTracedEvaluation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessRuleTracedRule {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        if (Array.isArray(this.evaluations)) {
            data["evaluations"] = [];
            for (let item of this.evaluations)
                data["evaluations"].push(item.toJSON());
        }
        return data;
    }
}

/** Traced Business rule */
export interface IBusinessRuleTracedRule {
    /** Configuration of the rule as it was running. Enriched with trace ref IDs. */
    configuration?: BusinessRule | undefined;
    /** Evaluations performed for this rule. */
    evaluations?: IBusinessRuleTracedEvaluation[] | undefined;
}

/** Evaluation trace of a business rule */
export class BusinessRuleTracedEvaluation implements IBusinessRuleTracedEvaluation {
    /** Indicates if the rule was found to be executable. */
    conditionSatisfied!: boolean;
    /** Detailed evaluation results for each condition. */
    conditions?: BusinessRuleTracedEvaluationCondition[] | undefined;
    /** Detailed results for transformation groups. */
    transformationGroups?: BusinessRuleTracedTransformationGroup[] | undefined;
    /** Detailed steps performed by actions. */
    actions?: BusinessRuleTracedAction[] | undefined;
    /** State of variables after all transformation groups were ran. */
    variables?: { [key: string]: string; } | undefined;

    constructor(data?: IBusinessRuleTracedEvaluation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.conditions) {
                this.conditions = [];
                for (let i = 0; i < data.conditions.length; i++) {
                    let item = data.conditions[i];
                    this.conditions[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedEvaluationCondition(item) : <BusinessRuleTracedEvaluationCondition>item;
                }
            }
            if (data.transformationGroups) {
                this.transformationGroups = [];
                for (let i = 0; i < data.transformationGroups.length; i++) {
                    let item = data.transformationGroups[i];
                    this.transformationGroups[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedTransformationGroup(item) : <BusinessRuleTracedTransformationGroup>item;
                }
            }
            if (data.actions) {
                this.actions = [];
                for (let i = 0; i < data.actions.length; i++) {
                    let item = data.actions[i];
                    this.actions[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedAction(item) : <BusinessRuleTracedAction>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionSatisfied = _data["conditionSatisfied"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(BusinessRuleTracedEvaluationCondition.fromJS(item));
            }
            if (Array.isArray(_data["transformationGroups"])) {
                this.transformationGroups = [] as any;
                for (let item of _data["transformationGroups"])
                    this.transformationGroups!.push(BusinessRuleTracedTransformationGroup.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(BusinessRuleTracedAction.fromJS(item));
            }
            if (_data["variables"]) {
                this.variables = {} as any;
                for (let key in _data["variables"]) {
                    if (_data["variables"].hasOwnProperty(key))
                        (<any>this.variables)![key] = _data["variables"][key];
                }
            }
        }
    }

    static fromJS(data: any): BusinessRuleTracedEvaluation {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedEvaluation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionSatisfied"] = this.conditionSatisfied;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.transformationGroups)) {
            data["transformationGroups"] = [];
            for (let item of this.transformationGroups)
                data["transformationGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        if (this.variables) {
            data["variables"] = {};
            for (let key in this.variables) {
                if (this.variables.hasOwnProperty(key))
                    (<any>data["variables"])[key] = (<any>this.variables)[key];
            }
        }
        return data;
    }
}

/** Evaluation trace of a business rule */
export interface IBusinessRuleTracedEvaluation {
    /** Indicates if the rule was found to be executable. */
    conditionSatisfied: boolean;
    /** Detailed evaluation results for each condition. */
    conditions?: IBusinessRuleTracedEvaluationCondition[] | undefined;
    /** Detailed results for transformation groups. */
    transformationGroups?: IBusinessRuleTracedTransformationGroup[] | undefined;
    /** Detailed steps performed by actions. */
    actions?: IBusinessRuleTracedAction[] | undefined;
    /** State of variables after all transformation groups were ran. */
    variables?: { [key: string]: string; } | undefined;
}

/** Detail trace for business rule condition */
export class BusinessRuleTracedEvaluationCondition implements IBusinessRuleTracedEvaluationCondition {
    /** Trace reference ID of condition. */
    traceRefId?: string | undefined;
    /** Indicates if this condition evaluated to true. */
    satisfied!: boolean;
    /** Additional reason why condition evaluated to given result. */
    reason?: string | undefined;

    constructor(data?: IBusinessRuleTracedEvaluationCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.satisfied = _data["satisfied"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): BusinessRuleTracedEvaluationCondition {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedEvaluationCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceRefId"] = this.traceRefId;
        data["satisfied"] = this.satisfied;
        data["reason"] = this.reason;
        return data;
    }
}

/** Detail trace for business rule condition */
export interface IBusinessRuleTracedEvaluationCondition {
    /** Trace reference ID of condition. */
    traceRefId?: string | undefined;
    /** Indicates if this condition evaluated to true. */
    satisfied: boolean;
    /** Additional reason why condition evaluated to given result. */
    reason?: string | undefined;
}

/** Trace of transformation group */
export class BusinessRuleTracedTransformationGroup implements IBusinessRuleTracedTransformationGroup {
    /** Trace reference ID of transformation group. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input for group */
    input?: string | undefined;
    /** Serialized JSON of output for group */
    output?: string | undefined;
    /** Detailed traces for each step performed by transformations in group. */
    transformations?: BusinessRuleTracedTransformation[] | undefined;

    constructor(data?: IBusinessRuleTracedTransformationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.transformations) {
                this.transformations = [];
                for (let i = 0; i < data.transformations.length; i++) {
                    let item = data.transformations[i];
                    this.transformations[i] = item && !(<any>item).toJSON ? new BusinessRuleTracedTransformation(item) : <BusinessRuleTracedTransformation>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.input = _data["input"];
            this.output = _data["output"];
            if (Array.isArray(_data["transformations"])) {
                this.transformations = [] as any;
                for (let item of _data["transformations"])
                    this.transformations!.push(BusinessRuleTracedTransformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessRuleTracedTransformationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedTransformationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceRefId"] = this.traceRefId;
        data["input"] = this.input;
        data["output"] = this.output;
        if (Array.isArray(this.transformations)) {
            data["transformations"] = [];
            for (let item of this.transformations)
                data["transformations"].push(item.toJSON());
        }
        return data;
    }
}

/** Trace of transformation group */
export interface IBusinessRuleTracedTransformationGroup {
    /** Trace reference ID of transformation group. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input for group */
    input?: string | undefined;
    /** Serialized JSON of output for group */
    output?: string | undefined;
    /** Detailed traces for each step performed by transformations in group. */
    transformations?: IBusinessRuleTracedTransformation[] | undefined;
}

/** Trace of single transformation step */
export class BusinessRuleTracedTransformation implements IBusinessRuleTracedTransformation {
    /** Trace reference ID of transformation. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input of transformation */
    input?: string | undefined;
    /** Serialized JSON of output of transformation */
    output?: string | undefined;

    constructor(data?: IBusinessRuleTracedTransformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.input = _data["input"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): BusinessRuleTracedTransformation {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedTransformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceRefId"] = this.traceRefId;
        data["input"] = this.input;
        data["output"] = this.output;
        return data;
    }
}

/** Trace of single transformation step */
export interface IBusinessRuleTracedTransformation {
    /** Trace reference ID of transformation. */
    traceRefId?: string | undefined;
    /** Serialized JSON of input of transformation */
    input?: string | undefined;
    /** Serialized JSON of output of transformation */
    output?: string | undefined;
}

/** Detailed trace for business rule action */
export class BusinessRuleTracedAction implements IBusinessRuleTracedAction {
    /** Trace reference ID of action */
    traceRefId?: string | undefined;
    /** Indicates if the action modified the document */
    documentModified!: boolean;
    /** Additional information provided by the trace */
    text?: string | undefined;

    constructor(data?: IBusinessRuleTracedAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceRefId = _data["traceRefId"];
            this.documentModified = _data["documentModified"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): BusinessRuleTracedAction {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTracedAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceRefId"] = this.traceRefId;
        data["documentModified"] = this.documentModified;
        data["text"] = this.text;
        return data;
    }
}

/** Detailed trace for business rule action */
export interface IBusinessRuleTracedAction {
    /** Trace reference ID of action */
    traceRefId?: string | undefined;
    /** Indicates if the action modified the document */
    documentModified: boolean;
    /** Additional information provided by the trace */
    text?: string | undefined;
}

/** Audit information */
export class UserAudit implements IUserAudit {
    /** The date on which the document was created. */
    creationDate!: Date;
    /** The last date on which the document was modified. */
    modificationDate!: Date;
    /** ID of the user who created the document. */
    createdByUser?: string | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.createdByUser = _data["createdByUser"];
            this.modifiedByUser = _data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAudit {
        data = typeof data === 'object' ? data : {};
        let result = new UserAudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser;
        data["modifiedByUser"] = this.modifiedByUser;
        return data;
    }
}

/** Audit information */
export interface IUserAudit {
    /** The date on which the document was created. */
    creationDate: Date;
    /** The last date on which the document was modified. */
    modificationDate: Date;
    /** ID of the user who created the document. */
    createdByUser?: string | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: string | undefined;
}

export class BusinessRuleTraceLogSearchRequest implements IBusinessRuleTraceLogSearchRequest {
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode!: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;

    constructor(data?: IBusinessRuleTraceLogSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BusinessRuleTraceLogSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleTraceLogSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBusinessRuleTraceLogSearchRequest {
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
}

export class Channel implements IChannel {
    /** ID of channel. */
    id!: string;
    /** Numeric sort order of the channel. Channels are returned ordered by this field. */
    sortOrder!: number;
    /** The search index ID where the channel requests the content from. Only RootContentSearchIndex is supported. */
    searchIndexId!: string;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names!: TranslatedStringDictionary;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort!: SortInfo[];
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields!: SortField[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations!: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields!: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds!: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns!: TranslatedStringDictionary;
    /** Audit information. */
    audit!: UserAudit;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            if (data.sortFields) {
                this.sortFields = [];
                for (let i = 0; i < data.sortFields.length; i++) {
                    let item = data.sortFields[i];
                    this.sortFields[i] = item && !(<any>item).toJSON ? new SortField(item) : <SortField>item;
                }
            }
            this.missingResultsDisplayPatterns = data.missingResultsDisplayPatterns && !(<any>data.missingResultsDisplayPatterns).toJSON ? new TranslatedStringDictionary(data.missingResultsDisplayPatterns) : <TranslatedStringDictionary>this.missingResultsDisplayPatterns;
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.sort = [];
            this.sortFields = [];
            this.aggregations = [];
            this.extendedSimpleSearchFields = [];
            this.grantedUserRoleIds = [];
            this.missingResultsDisplayPatterns = new TranslatedStringDictionary();
            this.audit = new UserAudit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sortOrder = _data["sortOrder"];
            this.searchIndexId = _data["searchIndexId"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            if (Array.isArray(_data["sortFields"])) {
                this.sortFields = [] as any;
                for (let item of _data["sortFields"])
                    this.sortFields!.push(SortField.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["extendedSimpleSearchFields"])) {
                this.extendedSimpleSearchFields = [] as any;
                for (let item of _data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields!.push(item);
            }
            if (Array.isArray(_data["grantedUserRoleIds"])) {
                this.grantedUserRoleIds = [] as any;
                for (let item of _data["grantedUserRoleIds"])
                    this.grantedUserRoleIds!.push(item);
            }
            this.missingResultsDisplayPatterns = _data["missingResultsDisplayPatterns"] ? TranslatedStringDictionary.fromJS(_data["missingResultsDisplayPatterns"]) : new TranslatedStringDictionary();
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : new UserAudit();
            this.viewForAll = _data["viewForAll"];
        }
    }

    static fromJS(data: any): Channel {
        data = typeof data === 'object' ? data : {};
        let result = new Channel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["searchIndexId"] = this.searchIndexId;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (Array.isArray(this.sortFields)) {
            data["sortFields"] = [];
            for (let item of this.sortFields)
                data["sortFields"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (Array.isArray(this.extendedSimpleSearchFields)) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        if (Array.isArray(this.grantedUserRoleIds)) {
            data["grantedUserRoleIds"] = [];
            for (let item of this.grantedUserRoleIds)
                data["grantedUserRoleIds"].push(item);
        }
        data["missingResultsDisplayPatterns"] = this.missingResultsDisplayPatterns ? this.missingResultsDisplayPatterns.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["viewForAll"] = this.viewForAll;
        return data;
    }
}

export interface IChannel {
    /** ID of channel. */
    id: string;
    /** Numeric sort order of the channel. Channels are returned ordered by this field. */
    sortOrder: number;
    /** The search index ID where the channel requests the content from. Only RootContentSearchIndex is supported. */
    searchIndexId: string;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** Language specific names. */
    names: ITranslatedStringDictionary;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort: ISortInfo[];
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields: ISortField[];
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations: AggregatorBase[];
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields: string[];
    /** User roles granted access to the channel. */
    grantedUserRoleIds: string[];
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns: ITranslatedStringDictionary;
    /** Audit information. */
    audit: IUserAudit;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export class SortField implements ISortField {
    /** The path of the field ({schemaId}.{fieldId}) */
    path!: string;
    /** The translated name of the field to be shown in the UI. */
    names!: TranslatedStringDictionary;

    constructor(data?: ISortField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
        }
    }

    static fromJS(data: any): SortField {
        data = typeof data === 'object' ? data : {};
        let result = new SortField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISortField {
    /** The path of the field ({schemaId}.{fieldId}) */
    path: string;
    /** The translated name of the field to be shown in the UI. */
    names: ITranslatedStringDictionary;
}

export class ChannelCreateRequest implements IChannelCreateRequest {
    /** ID of the channel. */
    id?: string | undefined;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort?: SortInfo[] | undefined;
    /** Order in which the channels should be displayed. */
    sortOrder!: number;
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields!: SortField[];
    /** Language specific channel names. */
    names!: TranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannelCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            if (data.sortFields) {
                this.sortFields = [];
                for (let i = 0; i < data.sortFields.length; i++) {
                    let item = data.sortFields[i];
                    this.sortFields[i] = item && !(<any>item).toJSON ? new SortField(item) : <SortField>item;
                }
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.missingResultsDisplayPatterns = data.missingResultsDisplayPatterns && !(<any>data.missingResultsDisplayPatterns).toJSON ? new TranslatedStringDictionary(data.missingResultsDisplayPatterns) : <TranslatedStringDictionary>this.missingResultsDisplayPatterns;
        }
        if (!data) {
            this.sortFields = [];
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["sortFields"])) {
                this.sortFields = [] as any;
                for (let item of _data["sortFields"])
                    this.sortFields!.push(SortField.fromJS(item));
            }
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            this.searchIndexId = _data["searchIndexId"];
            if (Array.isArray(_data["grantedUserRoleIds"])) {
                this.grantedUserRoleIds = [] as any;
                for (let item of _data["grantedUserRoleIds"])
                    this.grantedUserRoleIds!.push(item);
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["extendedSimpleSearchFields"])) {
                this.extendedSimpleSearchFields = [] as any;
                for (let item of _data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields!.push(item);
            }
            this.missingResultsDisplayPatterns = _data["missingResultsDisplayPatterns"] ? TranslatedStringDictionary.fromJS(_data["missingResultsDisplayPatterns"]) : <any>undefined;
            this.viewForAll = _data["viewForAll"];
        }
    }

    static fromJS(data: any): ChannelCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.sortFields)) {
            data["sortFields"] = [];
            for (let item of this.sortFields)
                data["sortFields"].push(item.toJSON());
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["searchIndexId"] = this.searchIndexId;
        if (Array.isArray(this.grantedUserRoleIds)) {
            data["grantedUserRoleIds"] = [];
            for (let item of this.grantedUserRoleIds)
                data["grantedUserRoleIds"].push(item);
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.extendedSimpleSearchFields)) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        data["missingResultsDisplayPatterns"] = this.missingResultsDisplayPatterns ? this.missingResultsDisplayPatterns.toJSON() : <any>undefined;
        data["viewForAll"] = this.viewForAll;
        return data;
    }
}

export interface IChannelCreateRequest {
    /** ID of the channel. */
    id?: string | undefined;
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort?: ISortInfo[] | undefined;
    /** Order in which the channels should be displayed. */
    sortOrder: number;
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields: ISortField[];
    /** Language specific channel names. */
    names: ITranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export class ChannelUpdateRequest implements IChannelUpdateRequest {
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort?: SortInfo[] | undefined;
    /** Order in which the channels should be displayed. */
    sortOrder!: number;
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields!: SortField[];
    names!: TranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: TranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll!: boolean;

    constructor(data?: IChannelUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            if (data.sortFields) {
                this.sortFields = [];
                for (let i = 0; i < data.sortFields.length; i++) {
                    let item = data.sortFields[i];
                    this.sortFields[i] = item && !(<any>item).toJSON ? new SortField(item) : <SortField>item;
                }
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.missingResultsDisplayPatterns = data.missingResultsDisplayPatterns && !(<any>data.missingResultsDisplayPatterns).toJSON ? new TranslatedStringDictionary(data.missingResultsDisplayPatterns) : <TranslatedStringDictionary>this.missingResultsDisplayPatterns;
        }
        if (!data) {
            this.sortFields = [];
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["sortFields"])) {
                this.sortFields = [] as any;
                for (let item of _data["sortFields"])
                    this.sortFields!.push(SortField.fromJS(item));
            }
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            this.searchIndexId = _data["searchIndexId"];
            if (Array.isArray(_data["grantedUserRoleIds"])) {
                this.grantedUserRoleIds = [] as any;
                for (let item of _data["grantedUserRoleIds"])
                    this.grantedUserRoleIds!.push(item);
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["extendedSimpleSearchFields"])) {
                this.extendedSimpleSearchFields = [] as any;
                for (let item of _data["extendedSimpleSearchFields"])
                    this.extendedSimpleSearchFields!.push(item);
            }
            this.missingResultsDisplayPatterns = _data["missingResultsDisplayPatterns"] ? TranslatedStringDictionary.fromJS(_data["missingResultsDisplayPatterns"]) : <any>undefined;
            this.viewForAll = _data["viewForAll"];
        }
    }

    static fromJS(data: any): ChannelUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.sortFields)) {
            data["sortFields"] = [];
            for (let item of this.sortFields)
                data["sortFields"].push(item.toJSON());
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["searchIndexId"] = this.searchIndexId;
        if (Array.isArray(this.grantedUserRoleIds)) {
            data["grantedUserRoleIds"] = [];
            for (let item of this.grantedUserRoleIds)
                data["grantedUserRoleIds"].push(item);
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.extendedSimpleSearchFields)) {
            data["extendedSimpleSearchFields"] = [];
            for (let item of this.extendedSimpleSearchFields)
                data["extendedSimpleSearchFields"].push(item);
        }
        data["missingResultsDisplayPatterns"] = this.missingResultsDisplayPatterns ? this.missingResultsDisplayPatterns.toJSON() : <any>undefined;
        data["viewForAll"] = this.viewForAll;
        return data;
    }
}

export interface IChannelUpdateRequest {
    /** Default sort order specified for the channel to sort the results of a content search. */
    sort?: ISortInfo[] | undefined;
    /** Order in which the channels should be displayed. */
    sortOrder: number;
    /** Fields to be used for sorting in content browser when displaying the channel. The information is only set and consumed by the client, not by the server. */
    sortFields: ISortField[];
    names: ITranslatedStringDictionary;
    /** Language specific names. */
    searchIndexId?: string | undefined;
    /** User roles granted access to the channel. */
    grantedUserRoleIds?: string[] | undefined;
    /** An optional list of aggregators. These aggregations are added by default on each aggregation requests. */
    aggregations?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the content document result set on each search and aggregation request. */
    filter?: FilterBase | undefined;
    /** An Optional list of fields. These fields extend the list of simple search fields outside the bounds of any schema field configuration. */
    extendedSimpleSearchFields?: string[] | undefined;
    /** Display pattern to use for rendering details when 0 results are returned */
    missingResultsDisplayPatterns?: ITranslatedStringDictionary | undefined;
    /** Grants rights to all the users to view the channel. */
    viewForAll: boolean;
}

export class FieldInfo implements IFieldInfo {
    /** The path of the field ({schemaId}.{fieldId}) */
    path?: string | undefined;
    /** The ID of the field. */
    fieldId?: string | undefined;
    /** The type of the field. */
    type?: string | undefined;
    /** Flag indicating if the search when aggregating the field is supported or not. */
    allowSearch!: boolean;
    /** Identifies a static field not retrieved from the dynamic metadata fields. */
    static!: boolean;
    /** Path of the nested object, if the current field is part of a nested object */
    nestedPath?: string | undefined;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.fieldId = _data["fieldId"];
            this.type = _data["type"];
            this.allowSearch = _data["allowSearch"];
            this.static = _data["static"];
            this.nestedPath = _data["nestedPath"];
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["fieldId"] = this.fieldId;
        data["type"] = this.type;
        data["allowSearch"] = this.allowSearch;
        data["static"] = this.static;
        data["nestedPath"] = this.nestedPath;
        return data;
    }
}

export interface IFieldInfo {
    /** The path of the field ({schemaId}.{fieldId}) */
    path?: string | undefined;
    /** The ID of the field. */
    fieldId?: string | undefined;
    /** The type of the field. */
    type?: string | undefined;
    /** Flag indicating if the search when aggregating the field is supported or not. */
    allowSearch: boolean;
    /** Identifies a static field not retrieved from the dynamic metadata fields. */
    static: boolean;
    /** Path of the nested object, if the current field is part of a nested object */
    nestedPath?: string | undefined;
}

export class SortFieldInfo implements ISortFieldInfo {
    /** The path of the field ({schemaId}.{fieldId}) */
    path!: string;
    /** Identifies a static field not retrieved from the dynamic metadata fields. */
    static!: boolean;

    constructor(data?: ISortFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.static = _data["static"];
        }
    }

    static fromJS(data: any): SortFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["static"] = this.static;
        return data;
    }
}

export interface ISortFieldInfo {
    /** The path of the field ({schemaId}.{fieldId}) */
    path: string;
    /** Identifies a static field not retrieved from the dynamic metadata fields. */
    static: boolean;
}

/** Base class for detail of permission sets */
export abstract class PermissionSetDetailOfContentRight implements IPermissionSetDetailOfContentRight {
    /** The permission set ID. */
    id!: string;
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: PermissionUserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on the Content Item or List Item. */
    exclusive!: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId!: string;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IPermissionSetDetailOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfContentRight(item) : <PermissionUserRoleRightsOfContentRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(PermissionUserRoleRightsOfContentRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = _data["exclusive"];
            this.ownerTokenId = _data["ownerTokenId"];
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSetDetailOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfContentRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["ownerTokenId"] = this.ownerTokenId;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data;
    }
}

/** Base class for detail of permission sets */
export interface IPermissionSetDetailOfContentRight {
    /** The permission set ID. */
    id: string;
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IPermissionUserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on the Content Item or List Item. */
    exclusive: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId: string;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

/** Detail of a content permission set */
export class ContentPermissionSetDetail extends PermissionSetDetailOfContentRight implements IContentPermissionSetDetail {

    constructor(data?: IContentPermissionSetDetail) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Detail of a content permission set */
export interface IContentPermissionSetDetail extends IPermissionSetDetailOfContentRight {
}

/** Rights assigned to a user role. */
export class PermissionUserRoleRightsOfContentRight implements IPermissionUserRoleRightsOfContentRight {
    /** The user role ID. */
    userRoleId!: string;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: ContentRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfContentRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

/** Rights assigned to a user role. */
export interface IPermissionUserRoleRightsOfContentRight {
    /** The user role ID. */
    userRoleId: string;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: ContentRight[] | undefined;
}

/** Rights assigned to a user role. */
export class PermissionUserRoleRightsOfPermissionSetRight implements IPermissionUserRoleRightsOfPermissionSetRight {
    /** The user role ID. */
    userRoleId!: string;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfPermissionSetRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

/** Rights assigned to a user role. */
export interface IPermissionUserRoleRightsOfPermissionSetRight {
    /** The user role ID. */
    userRoleId: string;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: PermissionSetRight[] | undefined;
}

/** Permission set rights */
export enum PermissionSetRight {
    Apply = "Apply",
    Manage = "Manage",
}

/** Audit information */
export class UserAuditDetail implements IUserAuditDetail {
    /** The date on which the document was created. */
    creationDate!: Date;
    /** The last date on which the document was modified. */
    modificationDate!: Date;
    /** ID of the user who created the document. */
    createdByUser?: User | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: User | undefined;

    constructor(data?: IUserAuditDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.createdByUser = data.createdByUser && !(<any>data.createdByUser).toJSON ? new User(data.createdByUser) : <User>this.createdByUser;
            this.modifiedByUser = data.modifiedByUser && !(<any>data.modifiedByUser).toJSON ? new User(data.modifiedByUser) : <User>this.modifiedByUser;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : <any>undefined;
            this.modifiedByUser = _data["modifiedByUser"] ? User.fromJS(_data["modifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAuditDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuditDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser ? this.modifiedByUser.toJSON() : <any>undefined;
        return data;
    }
}

/** Audit information */
export interface IUserAuditDetail {
    /** The date on which the document was created. */
    creationDate: Date;
    /** The last date on which the document was modified. */
    modificationDate: Date;
    /** ID of the user who created the document. */
    createdByUser?: IUser | undefined;
    /** ID of the last user who modified the document. */
    modifiedByUser?: IUser | undefined;
}

export class User implements IUser {
    /** User's Picturepark ID. */
    id!: string;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;
    /** Marks a user that was deleted from the system. */
    isDeleted!: boolean;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUser {
    /** User's Picturepark ID. */
    id: string;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Marks a user that was deleted from the system. */
    isDeleted: boolean;
}

export abstract class PermissionSetCreateRequestOfContentRight implements IPermissionSetCreateRequestOfContentRight {
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on Content Items or List Items. */
    exclusive!: boolean;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IPermissionSetCreateRequestOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfContentRight(item) : <UserRoleRightsOfContentRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfPermissionSetRight(item) : <UserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(UserRoleRightsOfContentRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(UserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = _data["exclusive"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): PermissionSetCreateRequestOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetCreateRequestOfContentRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["requestId"] = this.requestId;
        return data;
    }
}

export interface IPermissionSetCreateRequestOfContentRight {
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IUserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on Content Items or List Items. */
    exclusive: boolean;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to create a content permission set */
export class ContentPermissionSetCreateRequest extends PermissionSetCreateRequestOfContentRight implements IContentPermissionSetCreateRequest {

    constructor(data?: IContentPermissionSetCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentPermissionSetCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to create a content permission set */
export interface IContentPermissionSetCreateRequest extends IPermissionSetCreateRequestOfContentRight {
}

export class UserRoleRightsOfContentRight implements IUserRoleRightsOfContentRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: ContentRight[] | undefined;

    constructor(data?: IUserRoleRightsOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsOfContentRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfContentRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

export interface IUserRoleRightsOfContentRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: ContentRight[] | undefined;
}

export class UserRoleRightsOfPermissionSetRight implements IUserRoleRightsOfPermissionSetRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: PermissionSetRight[] | undefined;

    constructor(data?: IUserRoleRightsOfPermissionSetRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsOfPermissionSetRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfPermissionSetRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

export interface IUserRoleRightsOfPermissionSetRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: PermissionSetRight[] | undefined;
}

/** Base class for permission set update requests */
export abstract class PermissionSetUpdateRequestOfContentRight implements IPermissionSetUpdateRequestOfContentRight {
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: UserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUpdateRequestOfContentRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfContentRight(item) : <UserRoleRightsOfContentRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfPermissionSetRight(item) : <UserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(UserRoleRightsOfContentRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(UserRoleRightsOfPermissionSetRight.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionSetUpdateRequestOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestOfContentRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        return data;
    }
}

/** Base class for permission set update requests */
export interface IPermissionSetUpdateRequestOfContentRight {
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IUserRoleRightsOfContentRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a content permission set */
export class ContentPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfContentRight implements IContentPermissionSetUpdateRequest {

    constructor(data?: IContentPermissionSetUpdateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentPermissionSetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to update a content permission set */
export interface IContentPermissionSetUpdateRequest extends IPermissionSetUpdateRequestOfContentRight {
}

/** Request to transfer the ownership of a permission set */
export class PermissionSetOwnershipTransferRequest implements IPermissionSetOwnershipTransferRequest {
    /** The ID of the user to whom the permission set ownership should be transferred to. */
    transferUserId!: string;

    constructor(data?: IPermissionSetOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferUserId = _data["transferUserId"];
        }
    }

    static fromJS(data: any): PermissionSetOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        return data;
    }
}

/** Request to transfer the ownership of a permission set */
export interface IPermissionSetOwnershipTransferRequest {
    /** The ID of the user to whom the permission set ownership should be transferred to. */
    transferUserId: string;
}

/** Response to a bulk operation */
export class BulkResponse implements IBulkResponse {
    /** Rows of the bulk response. */
    rows?: BulkResponseRow[] | undefined;

    constructor(data?: IBulkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.rows) {
                this.rows = [];
                for (let i = 0; i < data.rows.length; i++) {
                    let item = data.rows[i];
                    this.rows[i] = item && !(<any>item).toJSON ? new BulkResponseRow(item) : <BulkResponseRow>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(BulkResponseRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data;
    }
}

/** Response to a bulk operation */
export interface IBulkResponse {
    /** Rows of the bulk response. */
    rows?: IBulkResponseRow[] | undefined;
}

/** Row information of a bulk response */
export class BulkResponseRow implements IBulkResponseRow {
    /** ID of the document. */
    id!: string;
    /** Version of the document. */
    version!: number;
    /** Eventual error. */
    error?: string | undefined;
    /** True if item successfully saved. False otherwise. */
    succeeded!: boolean;
    /** Returned status code. */
    status!: number;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;

    constructor(data?: IBulkResponseRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.error = _data["error"];
            this.succeeded = _data["succeeded"];
            this.status = _data["status"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): BulkResponseRow {
        data = typeof data === 'object' ? data : {};
        let result = new BulkResponseRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["error"] = this.error;
        data["succeeded"] = this.succeeded;
        data["status"] = this.status;
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Row information of a bulk response */
export interface IBulkResponseRow {
    /** ID of the document. */
    id: string;
    /** Version of the document. */
    version: number;
    /** Eventual error. */
    error?: string | undefined;
    /** True if item successfully saved. False otherwise. */
    succeeded: boolean;
    /** Returned status code. */
    status: number;
    /** The identifier provided by user in the corresponding request (or null if none was provided). Used only in bulk creation. */
    requestId?: string | undefined;
}

/** Request to create multiple content permission sets */
export class ContentPermissionSetCreateManyRequest implements IContentPermissionSetCreateManyRequest {
    /** Content permission set update requests. */
    items?: ContentPermissionSetCreateRequest[] | undefined;

    constructor(data?: IContentPermissionSetCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentPermissionSetCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentPermissionSetCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to create multiple content permission sets */
export interface IContentPermissionSetCreateManyRequest {
    /** Content permission set update requests. */
    items?: ContentPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple content permission sets */
export class ContentPermissionSetUpdateManyRequest implements IContentPermissionSetUpdateManyRequest {
    /** Content permission sets update requests. */
    items?: ContentPermissionSetUpdateRequestItem[] | undefined;

    constructor(data?: IContentPermissionSetUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentPermissionSetUpdateRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentPermissionSetUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple content permission sets */
export interface IContentPermissionSetUpdateManyRequest {
    /** Content permission sets update requests. */
    items?: ContentPermissionSetUpdateRequestItem[] | undefined;
}

/** Base class for permission set update requests */
export abstract class PermissionSetUpdateRequestItemOfContentRight extends PermissionSetUpdateRequestOfContentRight implements IPermissionSetUpdateRequestItemOfContentRight {
    /** The permission set ID. */
    id!: string;

    constructor(data?: IPermissionSetUpdateRequestItemOfContentRight) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): PermissionSetUpdateRequestItemOfContentRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestItemOfContentRight' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Base class for permission set update requests */
export interface IPermissionSetUpdateRequestItemOfContentRight extends IPermissionSetUpdateRequestOfContentRight {
    /** The permission set ID. */
    id: string;
}

/** Request to update a content permission set */
export class ContentPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfContentRight implements IContentPermissionSetUpdateRequestItem {

    constructor(data?: IContentPermissionSetUpdateRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentPermissionSetUpdateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionSetUpdateRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to update a content permission set */
export interface IContentPermissionSetUpdateRequestItem extends IPermissionSetUpdateRequestItemOfContentRight {
}

/** Request to delete multiple permission sets */
export class PermissionSetDeleteManyRequest implements IPermissionSetDeleteManyRequest {
    /** Permission set IDs. */
    permissionSetIds?: string[] | undefined;

    constructor(data?: IPermissionSetDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissionSetIds"])) {
                this.permissionSetIds = [] as any;
                for (let item of _data["permissionSetIds"])
                    this.permissionSetIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionSetDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissionSetIds)) {
            data["permissionSetIds"] = [];
            for (let item of this.permissionSetIds)
                data["permissionSetIds"].push(item);
        }
        return data;
    }
}

/** Request to delete multiple permission sets */
export interface IPermissionSetDeleteManyRequest {
    /** Permission set IDs. */
    permissionSetIds?: string[] | undefined;
}

/** Request to transfer the ownership of multiple permission sets */
export class PermissionSetOwnershipTransferManyRequest implements IPermissionSetOwnershipTransferManyRequest {
    /** Permission set ownership transfer requests. */
    items?: PermissionSetOwnershipTransferItem[] | undefined;

    constructor(data?: IPermissionSetOwnershipTransferManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionSetOwnershipTransferItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionSetOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to transfer the ownership of multiple permission sets */
export interface IPermissionSetOwnershipTransferManyRequest {
    /** Permission set ownership transfer requests. */
    items?: PermissionSetOwnershipTransferItem[] | undefined;
}

export class PermissionSetOwnershipTransferItem extends PermissionSetOwnershipTransferRequest implements IPermissionSetOwnershipTransferItem {
    /** The permission set ID. */
    permissionSetId?: string | undefined;

    constructor(data?: IPermissionSetOwnershipTransferItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
        }
    }

    static override fromJS(data: any): PermissionSetOwnershipTransferItem {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetOwnershipTransferItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        super.toJSON(data);
        return data;
    }
}

export interface IPermissionSetOwnershipTransferItem extends IPermissionSetOwnershipTransferRequest {
    /** The permission set ID. */
    permissionSetId?: string | undefined;
}

/** Rights that the current user has on a permission set */
export class PermissionSetUserPermissionRights implements IPermissionSetUserPermissionRights {
    /** Permission set ID. */
    permissionSetId?: string | undefined;
    /** List of rights on the permission set specified by PermissionSetId */
    permissionSetRights?: PermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUserPermissionRights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionSetId = _data["permissionSetId"];
            if (Array.isArray(_data["permissionSetRights"])) {
                this.permissionSetRights = [] as any;
                for (let item of _data["permissionSetRights"])
                    this.permissionSetRights!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionSetUserPermissionRights {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetUserPermissionRights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionSetId"] = this.permissionSetId;
        if (Array.isArray(this.permissionSetRights)) {
            data["permissionSetRights"] = [];
            for (let item of this.permissionSetRights)
                data["permissionSetRights"].push(item);
        }
        return data;
    }
}

/** Rights that the current user has on a permission set */
export interface IPermissionSetUserPermissionRights {
    /** Permission set ID. */
    permissionSetId?: string | undefined;
    /** List of rights on the permission set specified by PermissionSetId */
    permissionSetRights?: PermissionSetRight[] | undefined;
}

/** Base class for search results */
export class BaseResultOfPermissionSet implements IBaseResultOfPermissionSet {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: PermissionSet[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new PermissionSet(item) : <PermissionSet>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PermissionSet.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfPermissionSet {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IPermissionSet[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfPermissionSet extends BaseResultOfPermissionSet implements ISearchBehaviorBaseResultOfPermissionSet {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfPermissionSet) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfPermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfPermissionSet();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfPermissionSet extends IBaseResultOfPermissionSet {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Result of a permission set search operation */
export class PermissionSetSearchResult extends SearchBehaviorBaseResultOfPermissionSet implements IPermissionSetSearchResult {

    constructor(data?: IPermissionSetSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PermissionSetSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result of a permission set search operation */
export interface IPermissionSetSearchResult extends ISearchBehaviorBaseResultOfPermissionSet {
}

/** Permission set */
export class PermissionSet implements IPermissionSet {
    /** The permission set ID. */
    id!: string;
    /** When true this permission set will derogate all other configured permission sets.
Cannot be changed after creation. */
    exclusive!: boolean;
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;

    constructor(data?: IPermissionSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exclusive = _data["exclusive"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
        }
    }

    static fromJS(data: any): PermissionSet {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exclusive"] = this.exclusive;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        return data;
    }
}

/** Permission set */
export interface IPermissionSet {
    /** The permission set ID. */
    id: string;
    /** When true this permission set will derogate all other configured permission sets.
Cannot be changed after creation. */
    exclusive: boolean;
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
}

/** Request to search permission sets */
export class PermissionSetSearchRequest implements IPermissionSetSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    filter?: FilterBase | undefined;
    /** Filters based on the PermissionSetRight of the user. */
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the result.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IPermissionSetSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.rightFilter = _data["rightFilter"];
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionSetSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSetSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["rightFilter"] = this.rightFilter;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data;
    }
}

/** Request to search permission sets */
export interface IPermissionSetSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    filter?: FilterBase | undefined;
    /** Filters based on the PermissionSetRight of the user. */
    rightFilter?: PermissionSetRight | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the result.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
}

/** Content detail */
export class ContentDetail implements IContentDetail {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId!: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified.
by the ContentSchemaId property. */
    content?: any | undefined;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** The content ID. */
    id!: string;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** The Outputs generated from the content. They identifies the rendered files generated by the system.
They are available only for file base contents, and they depends on the output formats configured in the system. */
    outputs?: Output[] | undefined;
    /** The id of related DisplayContent */
    displayContentId?: string | undefined;
    /** The Outputs generated from the display content. */
    displayContentOutputs?: Output[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** The owner token ID. Defines the content owner. */
    ownerTokenId!: string;
    /** The resolved owner. */
    owner?: User | undefined;
    /** Content type. */
    contentType!: ContentType;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The actual lifecycle value of the content. Becomes Inactive when the content is deleted. */
    lifeCycle!: LifeCycle;
    /** List of content rights the user has on this content */
    contentRights?: ContentRight[] | undefined;
    /** Activity information: dynamically mapped from configured metadata fields or from audit information if no mapping is configured. */
    activity?: Activity | undefined;
    /** The number of historized versions of the content. Contains null if
(i) not requested by using HistoricVersionCount resolve behavior,
(ii) user lacks ManageHistoricVersions right on the content,
(iii) user lacks ManageContent user right,
(iv) historic versioning is disabled or
(v) content is a virtual item (ContentType is Virtual). */
    historicVersionCount?: number | undefined;

    isVirtual() {
    return !NON_VIRTUAL_CONTENT_SCHEMAS_IDS.includes(this.contentSchemaId);
  }

    constructor(data?: IContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
            this.owner = data.owner && !(<any>data.owner).toJSON ? new User(data.owner) : <User>this.owner;
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues;
            this.activity = data.activity && !(<any>data.activity).toJSON ? new Activity(data.activity) : <Activity>this.activity;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentSchemaId = _data["contentSchemaId"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["brokenReferenceIds"])) {
                this.brokenReferenceIds = [] as any;
                for (let item of _data["brokenReferenceIds"])
                    this.brokenReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenIndirectReferenceIds"])) {
                this.brokenIndirectReferenceIds = [] as any;
                for (let item of _data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenRelationTargetIds"])) {
                this.brokenRelationTargetIds = [] as any;
                for (let item of _data["brokenRelationTargetIds"])
                    this.brokenRelationTargetIds!.push(item);
            }
            this.content = _data["content"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.id = _data["id"];
            if (Array.isArray(_data["contentPermissionSetIds"])) {
                this.contentPermissionSetIds = [] as any;
                for (let item of _data["contentPermissionSetIds"])
                    this.contentPermissionSetIds!.push(item);
            }
            if (Array.isArray(_data["outputs"])) {
                this.outputs = [] as any;
                for (let item of _data["outputs"])
                    this.outputs!.push(Output.fromJS(item));
            }
            this.displayContentId = _data["displayContentId"];
            if (Array.isArray(_data["displayContentOutputs"])) {
                this.displayContentOutputs = [] as any;
                for (let item of _data["displayContentOutputs"])
                    this.displayContentOutputs!.push(Output.fromJS(item));
            }
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
            this.ownerTokenId = _data["ownerTokenId"];
            this.owner = _data["owner"] ? User.fromJS(_data["owner"]) : <any>undefined;
            this.contentType = _data["contentType"];
            this.displayValues = _data["displayValues"] ? DisplayValueDictionary.fromJS(_data["displayValues"]) : <any>undefined;
            this.lifeCycle = _data["lifeCycle"];
            if (Array.isArray(_data["contentRights"])) {
                this.contentRights = [] as any;
                for (let item of _data["contentRights"])
                    this.contentRights!.push(item);
            }
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
            this.historicVersionCount = _data["historicVersionCount"];
        }
    }

    static fromJS(data: any): ContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (Array.isArray(this.brokenReferenceIds)) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenIndirectReferenceIds)) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenRelationTargetIds)) {
            data["brokenRelationTargetIds"] = [];
            for (let item of this.brokenRelationTargetIds)
                data["brokenRelationTargetIds"].push(item);
        }
        data["content"] = this.content;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["id"] = this.id;
        if (Array.isArray(this.contentPermissionSetIds)) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        if (Array.isArray(this.outputs)) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["displayContentId"] = this.displayContentId;
        if (Array.isArray(this.displayContentOutputs)) {
            data["displayContentOutputs"] = [];
            for (let item of this.displayContentOutputs)
                data["displayContentOutputs"].push(item.toJSON());
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["ownerTokenId"] = this.ownerTokenId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["lifeCycle"] = this.lifeCycle;
        if (Array.isArray(this.contentRights)) {
            data["contentRights"] = [];
            for (let item of this.contentRights)
                data["contentRights"].push(item);
        }
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["historicVersionCount"] = this.historicVersionCount;
        return data;
    }
}

/** Content detail */
export interface IContentDetail {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified.
by the ContentSchemaId property. */
    content?: any | undefined;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** The content ID. */
    id: string;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** The Outputs generated from the content. They identifies the rendered files generated by the system.
They are available only for file base contents, and they depends on the output formats configured in the system. */
    outputs?: Output[] | undefined;
    /** The id of related DisplayContent */
    displayContentId?: string | undefined;
    /** The Outputs generated from the display content. */
    displayContentOutputs?: Output[] | undefined;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
    /** The owner token ID. Defines the content owner. */
    ownerTokenId: string;
    /** The resolved owner. */
    owner?: IUser | undefined;
    /** Content type. */
    contentType: ContentType;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The actual lifecycle value of the content. Becomes Inactive when the content is deleted. */
    lifeCycle: LifeCycle;
    /** List of content rights the user has on this content */
    contentRights?: ContentRight[] | undefined;
    /** Activity information: dynamically mapped from configured metadata fields or from audit information if no mapping is configured. */
    activity?: IActivity | undefined;
    /** The number of historized versions of the content. Contains null if
(i) not requested by using HistoricVersionCount resolve behavior,
(ii) user lacks ManageHistoricVersions right on the content,
(iii) user lacks ManageContent user right,
(iv) historic versioning is disabled or
(v) content is a virtual item (ContentType is Virtual). */
    historicVersionCount?: number | undefined;
}

/** Output */
export class Output implements IOutput {
    /** The ID of the output. Can be null for dynamic outputs which are not rendered yet. */
    id?: string | undefined;
    /** The ID of the output format this output represents. */
    outputFormatId!: string;
    /** The ID of the content for which this output has been created. */
    contentId!: string;
    /** The rendering state of the output file. */
    renderingState!: OutputRenderingState;
    /** Detail of the output that are format dependent. */
    detail?: OutputDataBase | undefined;
    /** Date and time of the backup of the output file. */
    backupTimestamp?: Date | undefined;
    /** Number of rendering retry attempts left. */
    attemptsLeft!: number;
    /** Version counter incremented every time this output is rendered (or in case of Original when new original is uploaded). */
    fileVersion!: number;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering!: boolean;

    protected _discriminator: string;

    constructor(data?: IOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Output";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outputFormatId = _data["outputFormatId"];
            this.contentId = _data["contentId"];
            this.renderingState = _data["renderingState"];
            this.detail = _data["detail"] ? OutputDataBase.fromJS(_data["detail"]) : <any>undefined;
            this.backupTimestamp = _data["backupTimestamp"] ? new Date(_data["backupTimestamp"].toString()) : <any>undefined;
            this.attemptsLeft = _data["attemptsLeft"];
            this.fileVersion = _data["fileVersion"];
            this.dynamicRendering = _data["dynamicRendering"];
        }
    }

    static fromJS(data: any): Output {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDetail") {
            let result = new OutputDetail();
            result.init(data);
            return result;
        }
        let result = new Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        data["contentId"] = this.contentId;
        data["renderingState"] = this.renderingState;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        data["backupTimestamp"] = this.backupTimestamp ? this.backupTimestamp.toISOString() : <any>undefined;
        data["attemptsLeft"] = this.attemptsLeft;
        data["fileVersion"] = this.fileVersion;
        data["dynamicRendering"] = this.dynamicRendering;
        return data;
    }
}

/** Output */
export interface IOutput {
    /** The ID of the output. Can be null for dynamic outputs which are not rendered yet. */
    id?: string | undefined;
    /** The ID of the output format this output represents. */
    outputFormatId: string;
    /** The ID of the content for which this output has been created. */
    contentId: string;
    /** The rendering state of the output file. */
    renderingState: OutputRenderingState;
    /** Detail of the output that are format dependent. */
    detail?: OutputDataBase | undefined;
    /** Date and time of the backup of the output file. */
    backupTimestamp?: Date | undefined;
    /** Number of rendering retry attempts left. */
    attemptsLeft: number;
    /** Version counter incremented every time this output is rendered (or in case of Original when new original is uploaded). */
    fileVersion: number;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering: boolean;
}

export enum OutputRenderingState {
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
    Skipped = "Skipped",
    NoLicense = "NoLicense",
    RerenderRequested = "RerenderRequested",
}

/** Base class for the output detail dependent on the file format. */
export abstract class OutputDataBase implements IOutputDataBase {
    /** The extension of the file. */
    fileExtension?: string | undefined;
    /** The path where the file is stored. */
    filePath?: string | undefined;
    /** The size of the file in bytes. */
    fileSizeInBytes?: number | undefined;
    /** The SHA-1 hash of the file. */
    sha1Hash?: string | undefined;
    /** The original filename of the file. */
    originalFileName?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IOutputDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "OutputDataBase";
    }

    init(_data?: any) {
        if (_data) {
            this.fileExtension = _data["fileExtension"];
            this.filePath = _data["filePath"];
            this.fileSizeInBytes = _data["fileSizeInBytes"];
            this.sha1Hash = _data["sha1Hash"];
            this.originalFileName = _data["originalFileName"];
        }
    }

    static fromJS(data: any): OutputDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "OutputDataImage") {
            let result = new OutputDataImage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataAudio") {
            let result = new OutputDataAudio();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataVideo") {
            let result = new OutputDataVideo();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDocument") {
            let result = new OutputDataDocument();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataVector") {
            let result = new OutputDataVector();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputDataDefault") {
            let result = new OutputDataDefault();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OutputDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["fileExtension"] = this.fileExtension;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        data["originalFileName"] = this.originalFileName;
        return data;
    }
}

/** Base class for the output detail dependent on the file format. */
export interface IOutputDataBase {
    /** The extension of the file. */
    fileExtension?: string | undefined;
    /** The path where the file is stored. */
    filePath?: string | undefined;
    /** The size of the file in bytes. */
    fileSizeInBytes?: number | undefined;
    /** The SHA-1 hash of the file. */
    sha1Hash?: string | undefined;
    /** The original filename of the file. */
    originalFileName?: string | undefined;
}

/** Output information for an image file. */
export class OutputDataImage extends OutputDataBase implements IOutputDataImage {
    /** The width of the image. */
    width?: number;
    /** The height of the image. */
    height?: number;

    constructor(data?: IOutputDataImage) {
        super(data);
        this._discriminator = "OutputDataImage";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static override fromJS(data: any): OutputDataImage {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataImage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data;
    }
}

/** Output information for an image file. */
export interface IOutputDataImage extends IOutputDataBase {
    /** The width of the image. */
    width?: number;
    /** The height of the image. */
    height?: number;
}

/** Output information for an audio file. */
export class OutputDataAudio extends OutputDataBase implements IOutputDataAudio {
    /** Duration of the audio stream in seconds. */
    durationInSeconds?: number | undefined;

    constructor(data?: IOutputDataAudio) {
        super(data);
        this._discriminator = "OutputDataAudio";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.durationInSeconds = _data["durationInSeconds"];
        }
    }

    static override fromJS(data: any): OutputDataAudio {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataAudio();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        super.toJSON(data);
        return data;
    }
}

/** Output information for an audio file. */
export interface IOutputDataAudio extends IOutputDataBase {
    /** Duration of the audio stream in seconds. */
    durationInSeconds?: number | undefined;
}

/** Output information for a video file. */
export class OutputDataVideo extends OutputDataBase implements IOutputDataVideo {
    /** Duration of the video in seconds. */
    durationInSeconds?: number;
    /** With of the video. */
    width?: number;
    /** Height of the video. */
    height?: number;
    /** The sprites making up the key frames of the video. */
    sprites?: Sprite[] | undefined;

    constructor(data?: IOutputDataVideo) {
        super(data);
        if (data) {
            if (data.sprites) {
                this.sprites = [];
                for (let i = 0; i < data.sprites.length; i++) {
                    let item = data.sprites[i];
                    this.sprites[i] = item && !(<any>item).toJSON ? new Sprite(item) : <Sprite>item;
                }
            }
        }
        this._discriminator = "OutputDataVideo";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.durationInSeconds = _data["durationInSeconds"];
            this.width = _data["width"];
            this.height = _data["height"];
            if (Array.isArray(_data["sprites"])) {
                this.sprites = [] as any;
                for (let item of _data["sprites"])
                    this.sprites!.push(Sprite.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): OutputDataVideo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataVideo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationInSeconds"] = this.durationInSeconds;
        data["width"] = this.width;
        data["height"] = this.height;
        if (Array.isArray(this.sprites)) {
            data["sprites"] = [];
            for (let item of this.sprites)
                data["sprites"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Output information for a video file. */
export interface IOutputDataVideo extends IOutputDataBase {
    /** Duration of the video in seconds. */
    durationInSeconds?: number;
    /** With of the video. */
    width?: number;
    /** Height of the video. */
    height?: number;
    /** The sprites making up the key frames of the video. */
    sprites?: ISprite[] | undefined;
}

/** The sprite of a video sprite */
export class Sprite implements ISprite {
    /** The width of the sprite. */
    width!: number;
    /** The height of the sprite. */
    height!: number;
    /** Y coordinate of the sprite in the saved file. */
    y!: number;
    /** X coordinate of the sprite in the saved file. */
    x!: number;
    /** The starting point in time of the sprite in the video. */
    start!: string;
    /** The ending point in time of the sprite in the video. */
    end!: string;

    constructor(data?: ISprite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.y = _data["y"];
            this.x = _data["x"];
            this.start = _data["start"];
            this.end = _data["end"];
        }
    }

    static fromJS(data: any): Sprite {
        data = typeof data === 'object' ? data : {};
        let result = new Sprite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["y"] = this.y;
        data["x"] = this.x;
        data["start"] = this.start;
        data["end"] = this.end;
        return data;
    }
}

/** The sprite of a video sprite */
export interface ISprite {
    /** The width of the sprite. */
    width: number;
    /** The height of the sprite. */
    height: number;
    /** Y coordinate of the sprite in the saved file. */
    y: number;
    /** X coordinate of the sprite in the saved file. */
    x: number;
    /** The starting point in time of the sprite in the video. */
    start: string;
    /** The ending point in time of the sprite in the video. */
    end: string;
}

/** Output information for a document file. */
export class OutputDataDocument extends OutputDataBase implements IOutputDataDocument {
    /** Number of document's pages. */
    pageCount?: number;

    constructor(data?: IOutputDataDocument) {
        super(data);
        this._discriminator = "OutputDataDocument";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageCount = _data["pageCount"];
        }
    }

    static override fromJS(data: any): OutputDataDocument {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDocument();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data;
    }
}

/** Output information for a document file. */
export interface IOutputDataDocument extends IOutputDataBase {
    /** Number of document's pages. */
    pageCount?: number;
}

/** Output information for a vector file. */
export class OutputDataVector extends OutputDataBase implements IOutputDataVector {

    constructor(data?: IOutputDataVector) {
        super(data);
        this._discriminator = "OutputDataVector";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputDataVector {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataVector();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Output information for a vector file. */
export interface IOutputDataVector extends IOutputDataBase {
}

/** Default output information */
export class OutputDataDefault extends OutputDataBase implements IOutputDataDefault {

    constructor(data?: IOutputDataDefault) {
        super(data);
        this._discriminator = "OutputDataDefault";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputDataDefault {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDataDefault();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Default output information */
export interface IOutputDataDefault extends IOutputDataBase {
}

/** Output detail */
export class OutputDetail extends Output implements IOutputDetail {

    constructor(data?: IOutputDetail) {
        super(data);
        this._discriminator = "OutputDetail";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OutputDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Output detail */
export interface IOutputDetail extends IOutput {
}

export class DisplayValueDictionary implements IDisplayValueDictionary {

    [key: string]: string | any;

    constructor(data?: IDisplayValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): DisplayValueDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IDisplayValueDictionary {

    [key: string]: string | any;
}

/** Lifecycle */
export enum LifeCycle {
    Draft = "Draft",
    Active = "Active",
    Inactive = "Inactive",
    Deleted = "Deleted",
}

export class Activity implements IActivity {
    creationDate?: Date | undefined;
    modificationDate?: Date | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    creationDate?: Date | undefined;
    modificationDate?: Date | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions!: { [key: string]: any; };

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensions = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = (<any>this.extensions)[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions: { [key: string]: any; };
}

/** Values that represent thumbnail sizes. */
export enum ThumbnailSize {
    Small = "Small",
    Medium = "Medium",
    Large = "Large",
    Preview = "Preview",
    ExtraLarge = "ExtraLarge",
}

/** Request to create a content */
export class ContentCreateRequest implements IContentCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId!: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by the ContentSchemaId property. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IContentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentSchemaId = _data["contentSchemaId"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.content = _data["content"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["contentPermissionSetIds"])) {
                this.contentPermissionSetIds = [] as any;
                for (let item of _data["contentPermissionSetIds"])
                    this.contentPermissionSetIds!.push(item);
            }
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): ContentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.contentPermissionSetIds)) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Request to create a content */
export interface IContentCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be Content.
The schema specifies the structure of the Content dictionary. */
    contentSchemaId: string;
    /** An optional list of IDs of the schemas that form the layers of the content.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by the ContentSchemaId property. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional list of content permission set IDs which control content permissions. These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds?: string[] | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to update content metadata */
export class ContentMetadataUpdateRequest implements IContentMetadataUpdateRequest {
    /** An optional list of IDs of the schemas that should be updated/replaced based on the options below and Metadata provided.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by
the ContentSchemaId property. Updating the Content property is only possible for virtual items (contents
whose ContentType is Virtual).
Update of content data will be done only if this attribute has any data, i.e. if it's not null or empty. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property.
If there are no data for a specified LayerSchemaId, it is treated as empty. */
    metadata?: { [key: string]: any; } | undefined;
    /** Options to modify the behavior for updating the layers.
Merge: the content is updated so that the assigned layers to the content will be a merge of the ones specified in the LayerSchemaIds property
and the ones already existing; existing assigned layers not specified in the property are kept and missing layers are assigned.
Replace: the content is updated so that only the layers specified in the LayerSchemaIds property are assigned to the content;
existing assigned layers not specified in the property are removed and missing layers are assigned.
Defaults to Merge. */
    layerSchemasUpdateOptions!: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas.
Merge: the values specified in the Metadata dictionary are merged to the existing values of the corresponding schema on the content.
Replace: the values specified in the Metadata dictionary entirely replace any existing value of the corresponding schema on the content.
Defaults to Merge. */
    layerFieldsUpdateOptions!: UpdateOption;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace the content.
Defaults to Merge. */
    contentFieldsUpdateOptions!: UpdateOption;

    constructor(data?: IContentMetadataUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.content = _data["content"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.layerSchemasUpdateOptions = _data["layerSchemasUpdateOptions"];
            this.layerFieldsUpdateOptions = _data["layerFieldsUpdateOptions"];
            this.contentFieldsUpdateOptions = _data["contentFieldsUpdateOptions"];
        }
    }

    static fromJS(data: any): ContentMetadataUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["layerSchemasUpdateOptions"] = this.layerSchemasUpdateOptions;
        data["layerFieldsUpdateOptions"] = this.layerFieldsUpdateOptions;
        data["contentFieldsUpdateOptions"] = this.contentFieldsUpdateOptions;
        return data;
    }
}

/** Request to update content metadata */
export interface IContentMetadataUpdateRequest {
    /** An optional list of IDs of the schemas that should be updated/replaced based on the options below and Metadata provided.
The SchemaType of the specified schemas must be Layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data of the content. It's an object of dynamic metadata whose structure is defined in the Content schema identified by
the ContentSchemaId property. Updating the Content property is only possible for virtual items (contents
whose ContentType is Virtual).
Update of content data will be done only if this attribute has any data, i.e. if it's not null or empty. */
    content?: any | undefined;
    /** The dynamic data structure matching the field schematics of the schemas with type layer (LayerSchemaIds).
The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property.
If there are no data for a specified LayerSchemaId, it is treated as empty. */
    metadata?: { [key: string]: any; } | undefined;
    /** Options to modify the behavior for updating the layers.
Merge: the content is updated so that the assigned layers to the content will be a merge of the ones specified in the LayerSchemaIds property
and the ones already existing; existing assigned layers not specified in the property are kept and missing layers are assigned.
Replace: the content is updated so that only the layers specified in the LayerSchemaIds property are assigned to the content;
existing assigned layers not specified in the property are removed and missing layers are assigned.
Defaults to Merge. */
    layerSchemasUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the values of schemas.
Merge: the values specified in the Metadata dictionary are merged to the existing values of the corresponding schema on the content.
Replace: the values specified in the Metadata dictionary entirely replace any existing value of the corresponding schema on the content.
Defaults to Merge. */
    layerFieldsUpdateOptions: UpdateOption;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace the content.
Defaults to Merge. */
    contentFieldsUpdateOptions: UpdateOption;
}

/** Controls the update of metadata */
export enum UpdateOption {
    Merge = "Merge",
    Replace = "Replace",
}

/** Request to update the permissions of a content */
export class ContentPermissionsUpdateRequest implements IContentPermissionsUpdateRequest {
    /** A list of content permission set IDs which control content permissions that will be updated on the content.
These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds!: string[];

    constructor(data?: IContentPermissionsUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentPermissionSetIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentPermissionSetIds"])) {
                this.contentPermissionSetIds = [] as any;
                for (let item of _data["contentPermissionSetIds"])
                    this.contentPermissionSetIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentPermissionSetIds)) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data;
    }
}

/** Request to update the permissions of a content */
export interface IContentPermissionsUpdateRequest {
    /** A list of content permission set IDs which control content permissions that will be updated on the content.
These permissions control content accessibility for the users that do not own the content. */
    contentPermissionSetIds: string[];
}

/** Request to transfer the content ownership */
export class ContentOwnershipTransferRequest implements IContentOwnershipTransferRequest {
    /** The ID of the user to whom the content ownership has to be transferred to. */
    transferUserId!: string;

    constructor(data?: IContentOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferUserId = _data["transferUserId"];
        }
    }

    static fromJS(data: any): ContentOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        return data;
    }
}

/** Request to transfer the content ownership */
export interface IContentOwnershipTransferRequest {
    /** The ID of the user to whom the content ownership has to be transferred to. */
    transferUserId: string;
}

/** Result for CheckContentSchemaIdChangeRequest */
export class CheckContentSchemaIdChangeResult implements ICheckContentSchemaIdChangeResult {
    /** List of operations which incur loss of data if carried out */
    problematicChanges?: ContentSchemaChangeException[] | undefined;
    /** List of errors preventing validation of ContentSchema change */
    errors?: CheckContentSchemaIdChangeResultErrorItem[] | undefined;

    constructor(data?: ICheckContentSchemaIdChangeResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.errors) {
                this.errors = [];
                for (let i = 0; i < data.errors.length; i++) {
                    let item = data.errors[i];
                    this.errors[i] = item && !(<any>item).toJSON ? new CheckContentSchemaIdChangeResultErrorItem(item) : <CheckContentSchemaIdChangeResultErrorItem>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["problematicChanges"])) {
                this.problematicChanges = [] as any;
                for (let item of _data["problematicChanges"])
                    this.problematicChanges!.push(ContentSchemaChangeException.fromJS(item));
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(CheckContentSchemaIdChangeResultErrorItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckContentSchemaIdChangeResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckContentSchemaIdChangeResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.problematicChanges)) {
            data["problematicChanges"] = [];
            for (let item of this.problematicChanges)
                data["problematicChanges"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

/** Result for CheckContentSchemaIdChangeRequest */
export interface ICheckContentSchemaIdChangeResult {
    /** List of operations which incur loss of data if carried out */
    problematicChanges?: ContentSchemaChangeException[] | undefined;
    /** List of errors preventing validation of ContentSchema change */
    errors?: ICheckContentSchemaIdChangeResultErrorItem[] | undefined;
}

export class CheckContentSchemaIdChangeResultErrorItem implements ICheckContentSchemaIdChangeResultErrorItem {
    /** Request for which this error occured */
    request?: CheckContentSchemaIdChangeRequestItem | undefined;
    /** Error which occured when trying to check ContentSchema change (e.g. ContentNotFoundException or ContentPermissionException) */
    exception?: PictureparkException | undefined;

    constructor(data?: ICheckContentSchemaIdChangeResultErrorItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.request = data.request && !(<any>data.request).toJSON ? new CheckContentSchemaIdChangeRequestItem(data.request) : <CheckContentSchemaIdChangeRequestItem>this.request;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request = _data["request"] ? CheckContentSchemaIdChangeRequestItem.fromJS(_data["request"]) : <any>undefined;
            this.exception = _data["exception"] ? PictureparkException.fromJS(_data["exception"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckContentSchemaIdChangeResultErrorItem {
        data = typeof data === 'object' ? data : {};
        let result = new CheckContentSchemaIdChangeResultErrorItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["exception"] = this.exception ? this.exception.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICheckContentSchemaIdChangeResultErrorItem {
    /** Request for which this error occured */
    request?: ICheckContentSchemaIdChangeRequestItem | undefined;
    /** Error which occured when trying to check ContentSchema change (e.g. ContentNotFoundException or ContentPermissionException) */
    exception?: PictureparkException | undefined;
}

/** Change of ContentSchemaId to check */
export class CheckContentSchemaIdChangeRequestItem implements ICheckContentSchemaIdChangeRequestItem {
    /** Content for which to check a ContentSchemaId change */
    contentId?: string | undefined;
    /** ContentSchemaId to change to */
    newContentSchemaId?: string | undefined;

    constructor(data?: ICheckContentSchemaIdChangeRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.newContentSchemaId = _data["newContentSchemaId"];
        }
    }

    static fromJS(data: any): CheckContentSchemaIdChangeRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new CheckContentSchemaIdChangeRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["newContentSchemaId"] = this.newContentSchemaId;
        return data;
    }
}

/** Change of ContentSchemaId to check */
export interface ICheckContentSchemaIdChangeRequestItem {
    /** Content for which to check a ContentSchemaId change */
    contentId?: string | undefined;
    /** ContentSchemaId to change to */
    newContentSchemaId?: string | undefined;
}

/** Request to check if given changes to ContentSchemaId are possible without data loss due to restrictions (LayerSchemaIds) on assigned metadata */
export class CheckContentSchemaIdChangeRequest implements ICheckContentSchemaIdChangeRequest {
    /** Operations which should be checked */
    requests?: CheckContentSchemaIdChangeRequestItem[] | undefined;

    constructor(data?: ICheckContentSchemaIdChangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.requests) {
                this.requests = [];
                for (let i = 0; i < data.requests.length; i++) {
                    let item = data.requests[i];
                    this.requests[i] = item && !(<any>item).toJSON ? new CheckContentSchemaIdChangeRequestItem(item) : <CheckContentSchemaIdChangeRequestItem>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(CheckContentSchemaIdChangeRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckContentSchemaIdChangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckContentSchemaIdChangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to check if given changes to ContentSchemaId are possible without data loss due to restrictions (LayerSchemaIds) on assigned metadata */
export interface ICheckContentSchemaIdChangeRequest {
    /** Operations which should be checked */
    requests?: ICheckContentSchemaIdChangeRequestItem[] | undefined;
}

export abstract class ContentFileUpdateRequestBase implements IContentFileUpdateRequestBase {
    /** ID of the file transfer to use to replace the content file. */
    fileTransferId!: string;

    constructor(data?: IContentFileUpdateRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileTransferId = _data["fileTransferId"];
        }
    }

    static fromJS(data: any): ContentFileUpdateRequestBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContentFileUpdateRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        return data;
    }
}

export interface IContentFileUpdateRequestBase {
    /** ID of the file transfer to use to replace the content file. */
    fileTransferId: string;
}

/** Request to check if update of a content file incurs data loss */
export class ContentFileUpdateCheckRequest extends ContentFileUpdateRequestBase implements IContentFileUpdateCheckRequest {

    constructor(data?: IContentFileUpdateCheckRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentFileUpdateCheckRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileUpdateCheckRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to check if update of a content file incurs data loss */
export interface IContentFileUpdateCheckRequest extends IContentFileUpdateRequestBase {
}

/** Request to update a content file */
export class ContentFileUpdateRequest extends ContentFileUpdateRequestBase implements IContentFileUpdateRequest {
    /** Whether ContentType is allowed to change. This is needed if the newly uploaded file is of a different type (e.g. ".jpg" is replaced by ".svg") */
    allowContentTypeChange?: boolean;
    /** When enabled, content file update will take place regardless of any layers that are not compatible with updated ContentSchemaId.
For better safety, consider using AcceptableLayerUnassignments instead. */
    allowAnyLayerUnassignment?: boolean;
    /** Allow removal of given Layers from Content if needed. Ignored when AllowAnyLayerUnassignment is enabled. */
    acceptableLayerUnassignments?: string[] | undefined;

    constructor(data?: IContentFileUpdateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.allowContentTypeChange = _data["allowContentTypeChange"];
            this.allowAnyLayerUnassignment = _data["allowAnyLayerUnassignment"];
            if (Array.isArray(_data["acceptableLayerUnassignments"])) {
                this.acceptableLayerUnassignments = [] as any;
                for (let item of _data["acceptableLayerUnassignments"])
                    this.acceptableLayerUnassignments!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentFileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFileUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowContentTypeChange"] = this.allowContentTypeChange;
        data["allowAnyLayerUnassignment"] = this.allowAnyLayerUnassignment;
        if (Array.isArray(this.acceptableLayerUnassignments)) {
            data["acceptableLayerUnassignments"] = [];
            for (let item of this.acceptableLayerUnassignments)
                data["acceptableLayerUnassignments"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to update a content file */
export interface IContentFileUpdateRequest extends IContentFileUpdateRequestBase {
    /** Whether ContentType is allowed to change. This is needed if the newly uploaded file is of a different type (e.g. ".jpg" is replaced by ".svg") */
    allowContentTypeChange?: boolean;
    /** When enabled, content file update will take place regardless of any layers that are not compatible with updated ContentSchemaId.
For better safety, consider using AcceptableLayerUnassignments instead. */
    allowAnyLayerUnassignment?: boolean;
    /** Allow removal of given Layers from Content if needed. Ignored when AllowAnyLayerUnassignment is enabled. */
    acceptableLayerUnassignments?: string[] | undefined;
}

/** Result to a get content references operation */
export class ContentReferencesResult implements IContentReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;
    /** List of share references */
    shareReferences?: ContentShareReferenceResult | undefined;
    /** List of usages as the display content */
    displayContentUsagesReferences?: DisplayContentUsagesReferenceResult | undefined;

    constructor(data?: IContentReferencesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadataReferences = data.metadataReferences && !(<any>data.metadataReferences).toJSON ? new MetadataReferenceResult(data.metadataReferences) : <MetadataReferenceResult>this.metadataReferences;
            this.shareReferences = data.shareReferences && !(<any>data.shareReferences).toJSON ? new ContentShareReferenceResult(data.shareReferences) : <ContentShareReferenceResult>this.shareReferences;
            this.displayContentUsagesReferences = data.displayContentUsagesReferences && !(<any>data.displayContentUsagesReferences).toJSON ? new DisplayContentUsagesReferenceResult(data.displayContentUsagesReferences) : <DisplayContentUsagesReferenceResult>this.displayContentUsagesReferences;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metadataReferences = _data["metadataReferences"] ? MetadataReferenceResult.fromJS(_data["metadataReferences"]) : <any>undefined;
            this.shareReferences = _data["shareReferences"] ? ContentShareReferenceResult.fromJS(_data["shareReferences"]) : <any>undefined;
            this.displayContentUsagesReferences = _data["displayContentUsagesReferences"] ? DisplayContentUsagesReferenceResult.fromJS(_data["displayContentUsagesReferences"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentReferencesResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metadataReferences"] = this.metadataReferences ? this.metadataReferences.toJSON() : <any>undefined;
        data["shareReferences"] = this.shareReferences ? this.shareReferences.toJSON() : <any>undefined;
        data["displayContentUsagesReferences"] = this.displayContentUsagesReferences ? this.displayContentUsagesReferences.toJSON() : <any>undefined;
        return data;
    }
}

/** Result to a get content references operation */
export interface IContentReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: IMetadataReferenceResult | undefined;
    /** List of share references */
    shareReferences?: IContentShareReferenceResult | undefined;
    /** List of usages as the display content */
    displayContentUsagesReferences?: IDisplayContentUsagesReferenceResult | undefined;
}

/** Base class for search results */
export class BaseResultOfMetadataReference implements IBaseResultOfMetadataReference {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: MetadataReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfMetadataReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new MetadataReference(item) : <MetadataReference>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MetadataReference.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfMetadataReference {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfMetadataReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfMetadataReference {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IMetadataReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Result for getting references. */
export class MetadataReferenceResult extends BaseResultOfMetadataReference implements IMetadataReferenceResult {
    /** Indicates if any reference is originating from an item that the current user does not have access to. */
    isReferencedByRestrictedItem?: boolean | undefined;

    constructor(data?: IMetadataReferenceResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isReferencedByRestrictedItem = _data["isReferencedByRestrictedItem"];
        }
    }

    static override fromJS(data: any): MetadataReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReferenceResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReferencedByRestrictedItem"] = this.isReferencedByRestrictedItem;
        super.toJSON(data);
        return data;
    }
}

/** Result for getting references. */
export interface IMetadataReferenceResult extends IBaseResultOfMetadataReference {
    /** Indicates if any reference is originating from an item that the current user does not have access to. */
    isReferencedByRestrictedItem?: boolean | undefined;
}

/** Reference to a metadata item */
export class MetadataReference implements IMetadataReference {
    /** Target ID of reference. */
    targetMetadataItemId!: string;
    /** Indicates if the source of the reference is restricted because of permissions.
If this is true and the SourceMetadataItemId property is filled, the user does not have the
edit permission on the source metadata item. If the SourceMetadataItemId is null, the user also
does not have the view permission on that item. */
    isRestricted!: boolean;
    /** ID of the source of the reference. */
    sourceMetadataItemId?: string | undefined;
    /** DocType of the source of the reference. */
    sourceDocType?: string | undefined;

    constructor(data?: IMetadataReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetMetadataItemId = _data["targetMetadataItemId"];
            this.isRestricted = _data["isRestricted"];
            this.sourceMetadataItemId = _data["sourceMetadataItemId"];
            this.sourceDocType = _data["sourceDocType"];
        }
    }

    static fromJS(data: any): MetadataReference {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetMetadataItemId"] = this.targetMetadataItemId;
        data["isRestricted"] = this.isRestricted;
        data["sourceMetadataItemId"] = this.sourceMetadataItemId;
        data["sourceDocType"] = this.sourceDocType;
        return data;
    }
}

/** Reference to a metadata item */
export interface IMetadataReference {
    /** Target ID of reference. */
    targetMetadataItemId: string;
    /** Indicates if the source of the reference is restricted because of permissions.
If this is true and the SourceMetadataItemId property is filled, the user does not have the
edit permission on the source metadata item. If the SourceMetadataItemId is null, the user also
does not have the view permission on that item. */
    isRestricted: boolean;
    /** ID of the source of the reference. */
    sourceMetadataItemId?: string | undefined;
    /** DocType of the source of the reference. */
    sourceDocType?: string | undefined;
}

/** Base class for search results */
export class BaseResultOfContentShareReference implements IBaseResultOfContentShareReference {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: ContentShareReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContentShareReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ContentShareReference(item) : <ContentShareReference>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ContentShareReference.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContentShareReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfContentShareReference {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IContentShareReference[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Result class for share reference search */
export class ContentShareReferenceResult extends BaseResultOfContentShareReference implements IContentShareReferenceResult {

    constructor(data?: IContentShareReferenceResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ContentShareReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReferenceResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result class for share reference search */
export interface IContentShareReferenceResult extends IBaseResultOfContentShareReference {
}

/** Share information for a share referencing a content */
export class ContentShareReference implements IContentShareReference {
    /** ID of the share. */
    id?: string | undefined;
    /** Name of the share. */
    name?: string | undefined;
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** Type of the share. */
    shareType!: ShareType;
    /** The email address of the user who created the share. */
    emailAddress?: string | undefined;

    constructor(data?: IContentShareReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
            this.shareType = _data["shareType"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): ContentShareReference {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["shareType"] = this.shareType;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

/** Share information for a share referencing a content */
export interface IContentShareReference {
    /** ID of the share. */
    id?: string | undefined;
    /** Name of the share. */
    name?: string | undefined;
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** Type of the share. */
    shareType: ShareType;
    /** The email address of the user who created the share. */
    emailAddress?: string | undefined;
}

export enum ShareType {
    Basic = "Basic",
    Embed = "Embed",
}

/** Base class for search results */
export class BaseResultOfString implements IBaseResultOfString {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: string[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfString {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: string[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Result class for display content reference search */
export class DisplayContentUsagesReferenceResult extends BaseResultOfString implements IDisplayContentUsagesReferenceResult {

    constructor(data?: IDisplayContentUsagesReferenceResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DisplayContentUsagesReferenceResult {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayContentUsagesReferenceResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result class for display content reference search */
export interface IDisplayContentUsagesReferenceResult extends IBaseResultOfString {
}

/** Request to get the references to a content */
export class ContentReferencesRequest implements IContentReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;
    /** Limits the number of the returned display content usages by setting paging information. */
    displayContentUsages?: PagingRequest | undefined;

    constructor(data?: IContentReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.references = data.references && !(<any>data.references).toJSON ? new MetadataReferencesPagingRequest(data.references) : <MetadataReferencesPagingRequest>this.references;
            this.shares = data.shares && !(<any>data.shares).toJSON ? new PagingRequest(data.shares) : <PagingRequest>this.shares;
            this.displayContentUsages = data.displayContentUsages && !(<any>data.displayContentUsages).toJSON ? new PagingRequest(data.displayContentUsages) : <PagingRequest>this.displayContentUsages;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.references = _data["references"] ? MetadataReferencesPagingRequest.fromJS(_data["references"]) : <any>undefined;
            this.shares = _data["shares"] ? PagingRequest.fromJS(_data["shares"]) : <any>undefined;
            this.displayContentUsages = _data["displayContentUsages"] ? PagingRequest.fromJS(_data["displayContentUsages"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["references"] = this.references ? this.references.toJSON() : <any>undefined;
        data["shares"] = this.shares ? this.shares.toJSON() : <any>undefined;
        data["displayContentUsages"] = this.displayContentUsages ? this.displayContentUsages.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to get the references to a content */
export interface IContentReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: IPagingRequest | undefined;
    /** Limits the number of the returned display content usages by setting paging information. */
    displayContentUsages?: IPagingRequest | undefined;
}

/** Request to page data */
export class PagingRequest implements IPagingRequest {
    /** Limits the number of the returned schemas. Defaults to 0. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;

    constructor(data?: IPagingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): PagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Request to page data */
export interface IPagingRequest {
    /** Limits the number of the returned schemas. Defaults to 0. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
}

/** Request to get paginated metadata references */
export class MetadataReferencesPagingRequest extends PagingRequest implements IMetadataReferencesPagingRequest {
    /** Set to true to check if any incoming references are originating from an item the current user does not have full access to. */
    fetchReferencedByRestrictedItem?: boolean;

    constructor(data?: IMetadataReferencesPagingRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fetchReferencedByRestrictedItem = _data["fetchReferencedByRestrictedItem"];
        }
    }

    static override fromJS(data: any): MetadataReferencesPagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataReferencesPagingRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fetchReferencedByRestrictedItem"] = this.fetchReferencedByRestrictedItem;
        super.toJSON(data);
        return data;
    }
}

/** Request to get paginated metadata references */
export interface IMetadataReferencesPagingRequest extends IPagingRequest {
    /** Set to true to check if any incoming references are originating from an item the current user does not have full access to. */
    fetchReferencedByRestrictedItem?: boolean;
}

/** Result of output resolution. */
export class OutputResolveResult implements IOutputResolveResult {
    /** ID of output. */
    id?: string | undefined;
    /** ID of output format. */
    outputFormatId!: string;
    /** ID of content. */
    contentId!: string;
    /** Rendering state of output. */
    renderingState!: OutputRenderingState;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering!: boolean;
    /** Size of file, if already known */
    fileSize?: number | undefined;

    constructor(data?: IOutputResolveResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outputFormatId = _data["outputFormatId"];
            this.contentId = _data["contentId"];
            this.renderingState = _data["renderingState"];
            this.dynamicRendering = _data["dynamicRendering"];
            this.fileSize = _data["fileSize"];
        }
    }

    static fromJS(data: any): OutputResolveResult {
        data = typeof data === 'object' ? data : {};
        let result = new OutputResolveResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        data["contentId"] = this.contentId;
        data["renderingState"] = this.renderingState;
        data["dynamicRendering"] = this.dynamicRendering;
        data["fileSize"] = this.fileSize;
        return data;
    }
}

/** Result of output resolution. */
export interface IOutputResolveResult {
    /** ID of output. */
    id?: string | undefined;
    /** ID of output format. */
    outputFormatId: string;
    /** ID of content. */
    contentId: string;
    /** Rendering state of output. */
    renderingState: OutputRenderingState;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering: boolean;
    /** Size of file, if already known */
    fileSize?: number | undefined;
}

/** Request to create a content download link */
export class ContentDownloadLinkCreateRequest implements IContentDownloadLinkCreateRequest {
    /** List of content information to generate the download link */
    contents!: ContentDownloadRequestItem[];
    /** Indicates if a progress message shall be shown to the user, notifying once the download is completed. */
    notifyProgress!: boolean;

    constructor(data?: IContentDownloadLinkCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contents) {
                this.contents = [];
                for (let i = 0; i < data.contents.length; i++) {
                    let item = data.contents[i];
                    this.contents[i] = item && !(<any>item).toJSON ? new ContentDownloadRequestItem(item) : <ContentDownloadRequestItem>item;
                }
            }
        }
        if (!data) {
            this.contents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ContentDownloadRequestItem.fromJS(item));
            }
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ContentDownloadLinkCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadLinkCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to create a content download link */
export interface IContentDownloadLinkCreateRequest {
    /** List of content information to generate the download link */
    contents: IContentDownloadRequestItem[];
    /** Indicates if a progress message shall be shown to the user, notifying once the download is completed. */
    notifyProgress: boolean;
}

/** Information needed to generate a content download link */
export class ContentDownloadRequestItem implements IContentDownloadRequestItem {
    /** ID of the content that is going to be downloaded. */
    contentId!: string;
    /** ID of the output format that is going to be downloaded. */
    outputFormatId!: string;

    constructor(data?: IContentDownloadRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static fromJS(data: any): ContentDownloadRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        return data;
    }
}

/** Information needed to generate a content download link */
export interface IContentDownloadRequestItem {
    /** ID of the content that is going to be downloaded. */
    contentId: string;
    /** ID of the output format that is going to be downloaded. */
    outputFormatId: string;
}

/** Download link information */
export class DownloadLink implements IDownloadLink {
    /** Token of the download, used to generate the url. */
    downloadToken!: string;
    /** Url of the download link. */
    downloadUrl!: string;

    constructor(data?: IDownloadLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadToken = _data["downloadToken"];
            this.downloadUrl = _data["downloadUrl"];
        }
    }

    static fromJS(data: any): DownloadLink {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadToken"] = this.downloadToken;
        data["downloadUrl"] = this.downloadUrl;
        return data;
    }
}

/** Download link information */
export interface IDownloadLink {
    /** Token of the download, used to generate the url. */
    downloadToken: string;
    /** Url of the download link. */
    downloadUrl: string;
}

/** Request to create multiple contents */
export class ContentCreateManyRequest implements IContentCreateManyRequest {
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Items to be created. */
    items!: ContentCreateRequest[];

    constructor(data?: IContentCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentCreateRequest(item) : <ContentCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to create multiple contents */
export interface IContentCreateManyRequest {
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be created. */
    items: IContentCreateRequest[];
}

/** Request to update many contents metadata */
export class ContentMetadataUpdateManyRequest implements IContentMetadataUpdateManyRequest {
    /** Allows storing references to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Update items */
    items!: ContentMetadataUpdateItem[];

    constructor(data?: IContentMetadataUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentMetadataUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentMetadataUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update many contents metadata */
export interface IContentMetadataUpdateManyRequest {
    /** Allows storing references to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Update items */
    items: ContentMetadataUpdateItem[];
}

/** Item to update content metadata */
export class ContentMetadataUpdateItem extends ContentMetadataUpdateRequest implements IContentMetadataUpdateItem {
    /** The ID of the content. */
    id!: string;

    constructor(data?: IContentMetadataUpdateItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): ContentMetadataUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentMetadataUpdateItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Item to update content metadata */
export interface IContentMetadataUpdateItem extends IContentMetadataUpdateRequest {
    /** The ID of the content. */
    id: string;
}

/** Request to update multiple contents permissions */
export class ContentPermissionsUpdateManyRequest implements IContentPermissionsUpdateManyRequest {
    /** Content permissions update items */
    items!: ContentPermissionsUpdateItem[];

    constructor(data?: IContentPermissionsUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentPermissionsUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentPermissionsUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple contents permissions */
export interface IContentPermissionsUpdateManyRequest {
    /** Content permissions update items */
    items: ContentPermissionsUpdateItem[];
}

/** Content permissions update item */
export class ContentPermissionsUpdateItem extends ContentPermissionsUpdateRequest implements IContentPermissionsUpdateItem {
    /** ID of the content. */
    contentId!: string;

    constructor(data?: IContentPermissionsUpdateItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
        }
    }

    static override fromJS(data: any): ContentPermissionsUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentPermissionsUpdateItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data;
    }
}

/** Content permissions update item */
export interface IContentPermissionsUpdateItem extends IContentPermissionsUpdateRequest {
    /** ID of the content. */
    contentId: string;
}

/** Request to transfer multiple contents ownerships */
export class ContentOwnershipTransferManyRequest implements IContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer items. */
    items!: ContentOwnershipTransferItem[];

    constructor(data?: IContentOwnershipTransferManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentOwnershipTransferItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to transfer multiple contents ownerships */
export interface IContentOwnershipTransferManyRequest {
    /** List of Content Permissions ownership transfer items. */
    items: ContentOwnershipTransferItem[];
}

/** Content ownership transfer item */
export class ContentOwnershipTransferItem extends ContentOwnershipTransferRequest implements IContentOwnershipTransferItem {
    /** The content ID. */
    contentId!: string;

    constructor(data?: IContentOwnershipTransferItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
        }
    }

    static override fromJS(data: any): ContentOwnershipTransferItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentOwnershipTransferItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data;
    }
}

/** Content ownership transfer item */
export interface IContentOwnershipTransferItem extends IContentOwnershipTransferRequest {
    /** The content ID. */
    contentId: string;
}

/** Request to delete multiple contents. */
export class ContentDeleteManyRequest implements IContentDeleteManyRequest {
    /** IDs of the contents to delete. */
    contentIds!: string[];
    /** A value indicating whether references to the contents should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IContentDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            this.forceReferenceRemoval = _data["forceReferenceRemoval"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ContentDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to delete multiple contents. */
export interface IContentDeleteManyRequest {
    /** IDs of the contents to delete. */
    contentIds: string[];
    /** A value indicating whether references to the contents should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple contents based on a provided filter */
export class ContentDeleteManyFilterRequest implements IContentDeleteManyFilterRequest {
    /** Filters the contents that need to be deleted. */
    filterRequest!: ContentFilterRequest;
    /** A value indicating whether references to the content items should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IContentDeleteManyFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.filterRequest = data.filterRequest && !(<any>data.filterRequest).toJSON ? new ContentFilterRequest(data.filterRequest) : <ContentFilterRequest>this.filterRequest;
        }
        if (!data) {
            this.filterRequest = new ContentFilterRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterRequest = _data["filterRequest"] ? ContentFilterRequest.fromJS(_data["filterRequest"]) : new ContentFilterRequest();
            this.forceReferenceRemoval = _data["forceReferenceRemoval"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ContentDeleteManyFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDeleteManyFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to delete multiple contents based on a provided filter */
export interface IContentDeleteManyFilterRequest {
    /** Filters the contents that need to be deleted. */
    filterRequest: IContentFilterRequest;
    /** A value indicating whether references to the content items should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

export class ContentFilterRequest implements IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType!: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;

    constructor(data?: IContentFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.channelId = _data["channelId"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            this.searchString = _data["searchString"];
            this.searchType = _data["searchType"];
            this.collectionId = _data["collectionId"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.lifeCycleFilter = _data["lifeCycleFilter"];
            this.brokenDependenciesFilter = _data["brokenDependenciesFilter"];
            if (Array.isArray(_data["rightsFilter"])) {
                this.rightsFilter = [] as any;
                for (let item of _data["rightsFilter"])
                    this.rightsFilter!.push(item);
            }
        }
    }

    static fromJS(data: any): ContentFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channelId"] = this.channelId;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["searchString"] = this.searchString;
        data["searchType"] = this.searchType;
        data["collectionId"] = this.collectionId;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (Array.isArray(this.rightsFilter)) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        return data;
    }
}

export interface IContentFilterRequest {
    /** Limits the simple search fields to the fields available in the specified channel. */
    channelId?: string | undefined;
    /** Only searches the specified language values. Defaults to all metadata languages of the language configuration. */
    searchLanguages?: string[] | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** Type of search to be performed: against metadata, extracted fulltext from documents or both. Default to Metadata. */
    searchType: ContentSearchType;
    /** The collection id. */
    collectionId?: string | undefined;
    /** An optional search filter. Limits the content document result set. */
    filter?: FilterBase | undefined;
    /** Limits the content document result set to that life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Filter the content document result set to those that have or not have broken references */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the content document result set to specific ContentRights the user has */
    rightsFilter?: ContentRight[] | undefined;
}

export enum ContentSearchType {
    Metadata = "Metadata",
    FullText = "FullText",
    MetadataAndFullText = "MetadataAndFullText",
}

export enum LifeCycleFilter {
    ActiveOnly = "ActiveOnly",
    All = "All",
    InactiveOnly = "InactiveOnly",
    ActiveInactiveOnly = "ActiveInactiveOnly",
}

/** Filter items with broken or not broken dependencies */
export enum BrokenDependenciesFilter {
    All = "All",
    NotBrokenOnly = "NotBrokenOnly",
    BrokenOnly = "BrokenOnly",
}

/** Request to restore multiple contents */
export class ContentRestoreManyRequest implements IContentRestoreManyRequest {
    /** IDs of the contents to restore. */
    contentIds!: string[];
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;

    constructor(data?: IContentRestoreManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            this.allowMissingDependencies = _data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ContentRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRestoreManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data;
    }
}

/** Request to restore multiple contents */
export interface IContentRestoreManyRequest {
    /** IDs of the contents to restore. */
    contentIds: string[];
    /** Allows creating contents that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to get multiple contents' references */
export class ContentManyReferencesRequest implements IContentManyReferencesRequest {
    /** The IDs of the contents whose references need to be retrieved. */
    contentIds!: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: PagingRequest | undefined;
    /** Limits the number of the returned contentIds referencing as DisplayContent by setting paging information. */
    displayContentUsages?: PagingRequest | undefined;

    constructor(data?: IContentManyReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.references = data.references && !(<any>data.references).toJSON ? new MetadataReferencesPagingRequest(data.references) : <MetadataReferencesPagingRequest>this.references;
            this.shares = data.shares && !(<any>data.shares).toJSON ? new PagingRequest(data.shares) : <PagingRequest>this.shares;
            this.displayContentUsages = data.displayContentUsages && !(<any>data.displayContentUsages).toJSON ? new PagingRequest(data.displayContentUsages) : <PagingRequest>this.displayContentUsages;
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            this.references = _data["references"] ? MetadataReferencesPagingRequest.fromJS(_data["references"]) : <any>undefined;
            this.shares = _data["shares"] ? PagingRequest.fromJS(_data["shares"]) : <any>undefined;
            this.displayContentUsages = _data["displayContentUsages"] ? PagingRequest.fromJS(_data["displayContentUsages"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentManyReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentManyReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["references"] = this.references ? this.references.toJSON() : <any>undefined;
        data["shares"] = this.shares ? this.shares.toJSON() : <any>undefined;
        data["displayContentUsages"] = this.displayContentUsages ? this.displayContentUsages.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to get multiple contents' references */
export interface IContentManyReferencesRequest {
    /** The IDs of the contents whose references need to be retrieved. */
    contentIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
    /** Limits the number of the returned share references by setting paging information. */
    shares?: IPagingRequest | undefined;
    /** Limits the number of the returned contentIds referencing as DisplayContent by setting paging information. */
    displayContentUsages?: IPagingRequest | undefined;
}

/** Resolves outputs available for given content ids. */
export class OutputResolveManyRequest implements IOutputResolveManyRequest {
    /** The IDs of the contents whose outputs should to be retrieved. */
    contentIds!: string[];

    constructor(data?: IOutputResolveManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contentIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OutputResolveManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputResolveManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        return data;
    }
}

/** Resolves outputs available for given content ids. */
export interface IOutputResolveManyRequest {
    /** The IDs of the contents whose outputs should to be retrieved. */
    contentIds: string[];
}

export abstract class ContentRepairRequestBase implements IContentRepairRequestBase {
    /** Settings to use if no specific settings for a requested Content were specified */
    defaultSettings?: ContentRepairSettings | undefined;

    protected _discriminator: string;

    constructor(data?: IContentRepairRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.defaultSettings = data.defaultSettings && !(<any>data.defaultSettings).toJSON ? new ContentRepairSettings(data.defaultSettings) : <ContentRepairSettings>this.defaultSettings;
        }
        this._discriminator = "ContentRepairRequestBase";
    }

    init(_data?: any) {
        if (_data) {
            this.defaultSettings = _data["defaultSettings"] ? ContentRepairSettings.fromJS(_data["defaultSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentRepairRequestBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ContentRepairByFilterRequest") {
            let result = new ContentRepairByFilterRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentRepairBatchRequest") {
            let result = new ContentRepairBatchRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ContentRepairRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["defaultSettings"] = this.defaultSettings ? this.defaultSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContentRepairRequestBase {
    /** Settings to use if no specific settings for a requested Content were specified */
    defaultSettings?: IContentRepairSettings | undefined;
}

export class ContentRepairByFilterRequest extends ContentRepairRequestBase implements IContentRepairByFilterRequest {
    /** Filter used to enumerate Contents to repair */
    filter!: ContentFilterRequest;
    /** Settings for specific contents (overwrites DefaultSettings) */
    repairSettingOverrides?: ContentRepairRequestItem[] | undefined;

    constructor(data?: IContentRepairByFilterRequest) {
        super(data);
        if (data) {
            this.filter = data.filter && !(<any>data.filter).toJSON ? new ContentFilterRequest(data.filter) : <ContentFilterRequest>this.filter;
            if (data.repairSettingOverrides) {
                this.repairSettingOverrides = [];
                for (let i = 0; i < data.repairSettingOverrides.length; i++) {
                    let item = data.repairSettingOverrides[i];
                    this.repairSettingOverrides[i] = item && !(<any>item).toJSON ? new ContentRepairRequestItem(item) : <ContentRepairRequestItem>item;
                }
            }
        }
        if (!data) {
            this.filter = new ContentFilterRequest();
        }
        this._discriminator = "ContentRepairByFilterRequest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filter = _data["filter"] ? ContentFilterRequest.fromJS(_data["filter"]) : new ContentFilterRequest();
            if (Array.isArray(_data["repairSettingOverrides"])) {
                this.repairSettingOverrides = [] as any;
                for (let item of _data["repairSettingOverrides"])
                    this.repairSettingOverrides!.push(ContentRepairRequestItem.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentRepairByFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRepairByFilterRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.repairSettingOverrides)) {
            data["repairSettingOverrides"] = [];
            for (let item of this.repairSettingOverrides)
                data["repairSettingOverrides"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentRepairByFilterRequest extends IContentRepairRequestBase {
    /** Filter used to enumerate Contents to repair */
    filter: IContentFilterRequest;
    /** Settings for specific contents (overwrites DefaultSettings) */
    repairSettingOverrides?: IContentRepairRequestItem[] | undefined;
}

export class ContentRepairRequestItem implements IContentRepairRequestItem {
    /** Content to repair */
    contentId!: string;
    /** Options for this repair */
    settings?: ContentRepairSettings | undefined;

    constructor(data?: IContentRepairRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.settings = data.settings && !(<any>data.settings).toJSON ? new ContentRepairSettings(data.settings) : <ContentRepairSettings>this.settings;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.settings = _data["settings"] ? ContentRepairSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentRepairRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRepairRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContentRepairRequestItem {
    /** Content to repair */
    contentId: string;
    /** Options for this repair */
    settings?: IContentRepairSettings | undefined;
}

export class ContentRepairSettings implements IContentRepairSettings {
    /** List of layers that can be unassigned (due to change of ContentSchemaId and LayerSchemaIds) */
    acceptableLayerUnassignments?: string[] | undefined;
    /** Whether to enforce XmpWriteback for Outputs of Content (ignored if repair was not performed) */
    forceInvalidateXmpWriteback!: boolean;

    constructor(data?: IContentRepairSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["acceptableLayerUnassignments"])) {
                this.acceptableLayerUnassignments = [] as any;
                for (let item of _data["acceptableLayerUnassignments"])
                    this.acceptableLayerUnassignments!.push(item);
            }
            this.forceInvalidateXmpWriteback = _data["forceInvalidateXmpWriteback"];
        }
    }

    static fromJS(data: any): ContentRepairSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRepairSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.acceptableLayerUnassignments)) {
            data["acceptableLayerUnassignments"] = [];
            for (let item of this.acceptableLayerUnassignments)
                data["acceptableLayerUnassignments"].push(item);
        }
        data["forceInvalidateXmpWriteback"] = this.forceInvalidateXmpWriteback;
        return data;
    }
}

export interface IContentRepairSettings {
    /** List of layers that can be unassigned (due to change of ContentSchemaId and LayerSchemaIds) */
    acceptableLayerUnassignments?: string[] | undefined;
    /** Whether to enforce XmpWriteback for Outputs of Content (ignored if repair was not performed) */
    forceInvalidateXmpWriteback: boolean;
}

export class ContentRepairBatchRequest extends ContentRepairRequestBase implements IContentRepairBatchRequest {
    /** List of contents and options for repair */
    items?: ContentRepairRequestItem[] | undefined;

    constructor(data?: IContentRepairBatchRequest) {
        super(data);
        if (data) {
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentRepairRequestItem(item) : <ContentRepairRequestItem>item;
                }
            }
        }
        this._discriminator = "ContentRepairBatchRequest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentRepairRequestItem.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentRepairBatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRepairBatchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentRepairBatchRequest extends IContentRepairRequestBase {
    /** List of contents and options for repair */
    items?: IContentRepairRequestItem[] | undefined;
}

/** Base class for the content metadata batch requests. */
export abstract class MetadataValuesChangeRequestBase implements IMetadataValuesChangeRequestBase {
    /** Changes that need to be applied to the existing content metadata. The same set of changes is applied to all contents. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allows updating contents with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.changeCommands = [];
        }
        this._discriminator = "MetadataValuesChangeRequestBase";
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["changeCommands"])) {
                this.changeCommands = [] as any;
                for (let item of _data["changeCommands"])
                    this.changeCommands!.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeRequestBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ContentFieldsBatchUpdateRequest") {
            let result = new ContentFieldsBatchUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentFieldsBatchUpdateFilterRequest") {
            let result = new ContentFieldsBatchUpdateFilterRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        if (Array.isArray(this.changeCommands)) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Base class for the content metadata batch requests. */
export interface IMetadataValuesChangeRequestBase {
    /** Changes that need to be applied to the existing content metadata. The same set of changes is applied to all contents. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating contents with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update contents' fields based on content IDs */
export class ContentFieldsBatchUpdateRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateRequest {
    /** The IDs of the contents whose fields need to be updated. */
    contentIds!: string[];

    constructor(data?: IContentFieldsBatchUpdateRequest) {
        super(data);
        if (!data) {
            this.contentIds = [];
        }
        this._discriminator = "ContentFieldsBatchUpdateRequest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to batch update contents' fields based on content IDs */
export interface IContentFieldsBatchUpdateRequest extends IMetadataValuesChangeRequestBase {
    /** The IDs of the contents whose fields need to be updated. */
    contentIds: string[];
}

/** The base class for metadata value change commands. */
export abstract class MetadataValuesChangeCommandBase implements IMetadataValuesChangeCommandBase {
    /** The ID of the schema to which the operation scope is addressed. */
    schemaId!: string;

    protected _discriminator: string;

    constructor(data?: IMetadataValuesChangeCommandBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "MetadataValuesChangeCommandBase";
    }

    init(_data?: any) {
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static fromJS(data: any): MetadataValuesChangeCommandBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "MetadataValuesSchemaUpdateCommand") {
            let result = new MetadataValuesSchemaUpdateCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaUpsertCommand") {
            let result = new MetadataValuesSchemaUpsertCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaRemoveCommand") {
            let result = new MetadataValuesSchemaRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaReplaceCommand") {
            let result = new MetadataValuesSchemaReplaceCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesFieldRemoveCommand") {
            let result = new MetadataValuesFieldRemoveCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemAddCommand") {
            let result = new MetadataValuesSchemaItemAddCommand();
            result.init(data);
            return result;
        }
        if (data["kind"] === "MetadataValuesSchemaItemRemoveCommand") {
            let result = new MetadataValuesSchemaItemRemoveCommand();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'MetadataValuesChangeCommandBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["schemaId"] = this.schemaId;
        return data;
    }
}

/** The base class for metadata value change commands. */
export interface IMetadataValuesChangeCommandBase {
    /** The ID of the schema to which the operation scope is addressed. */
    schemaId: string;
}

/** Updates schema values */
export class MetadataValuesSchemaUpdateCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpdateCommand {
    /** An object containing the metadata values to add / update. */
    value!: any;

    constructor(data?: IMetadataValuesSchemaUpdateCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpdateCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): MetadataValuesSchemaUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpdateCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** Updates schema values */
export interface IMetadataValuesSchemaUpdateCommand extends IMetadataValuesChangeCommandBase {
    /** An object containing the metadata values to add / update. */
    value: any;
}

/** Adds or updates schema values */
export class MetadataValuesSchemaUpsertCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaUpsertCommand {
    /** An object containing the metadata values to add / update. */
    value!: any;

    constructor(data?: IMetadataValuesSchemaUpsertCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaUpsertCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): MetadataValuesSchemaUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaUpsertCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** Adds or updates schema values */
export interface IMetadataValuesSchemaUpsertCommand extends IMetadataValuesChangeCommandBase {
    /** An object containing the metadata values to add / update. */
    value: any;
}

/** Removes schema and all its values */
export class MetadataValuesSchemaRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaRemoveCommand {

    constructor(data?: IMetadataValuesSchemaRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaRemoveCommand";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): MetadataValuesSchemaRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaRemoveCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Removes schema and all its values */
export interface IMetadataValuesSchemaRemoveCommand extends IMetadataValuesChangeCommandBase {
}

/** Replaces schema values */
export class MetadataValuesSchemaReplaceCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaReplaceCommand {
    /** An object containing the metadata values for the schema. The existing dictionary will be entirely overwritten. */
    value!: any;

    constructor(data?: IMetadataValuesSchemaReplaceCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaReplaceCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): MetadataValuesSchemaReplaceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaReplaceCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** Replaces schema values */
export interface IMetadataValuesSchemaReplaceCommand extends IMetadataValuesChangeCommandBase {
    /** An object containing the metadata values for the schema. The existing dictionary will be entirely overwritten. */
    value: any;
}

/** Removes a field and its value from the values of the specified schema */
export class MetadataValuesFieldRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesFieldRemoveCommand {
    /** The path of the field to be removed within the specified schema (i.e. remove the street from the address of a person: fieldPath = "address.streetName", schemaId = "PersonLayer") */
    fieldPath!: string;

    constructor(data?: IMetadataValuesFieldRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesFieldRemoveCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
        }
    }

    static override fromJS(data: any): MetadataValuesFieldRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesFieldRemoveCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        super.toJSON(data);
        return data;
    }
}

/** Removes a field and its value from the values of the specified schema */
export interface IMetadataValuesFieldRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field to be removed within the specified schema (i.e. remove the street from the address of a person: fieldPath = "address.streetName", schemaId = "PersonLayer") */
    fieldPath: string;
}

/** Adds a list item to a FieldMultiTagbox field */
export class MetadataValuesSchemaItemAddCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemAddCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath!: string;
    /** The field namespace */
    fieldNamespace!: string;
    /** The ID of the list item to be added. */
    referenceId!: string;

    constructor(data?: IMetadataValuesSchemaItemAddCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemAddCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.fieldNamespace = _data["fieldNamespace"];
            this.referenceId = _data["referenceId"];
        }
    }

    static override fromJS(data: any): MetadataValuesSchemaItemAddCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemAddCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data;
    }
}

/** Adds a list item to a FieldMultiTagbox field */
export interface IMetadataValuesSchemaItemAddCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace */
    fieldNamespace: string;
    /** The ID of the list item to be added. */
    referenceId: string;
}

/** Removes a list item from a FieldMultiTagbox field */
export class MetadataValuesSchemaItemRemoveCommand extends MetadataValuesChangeCommandBase implements IMetadataValuesSchemaItemRemoveCommand {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath!: string;
    /** The field namespace. */
    fieldNamespace!: string;
    /** The ID of the list item to be removed. */
    referenceId!: string;

    constructor(data?: IMetadataValuesSchemaItemRemoveCommand) {
        super(data);
        this._discriminator = "MetadataValuesSchemaItemRemoveCommand";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fieldPath = _data["fieldPath"];
            this.fieldNamespace = _data["fieldNamespace"];
            this.referenceId = _data["referenceId"];
        }
    }

    static override fromJS(data: any): MetadataValuesSchemaItemRemoveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataValuesSchemaItemRemoveCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldPath"] = this.fieldPath;
        data["fieldNamespace"] = this.fieldNamespace;
        data["referenceId"] = this.referenceId;
        super.toJSON(data);
        return data;
    }
}

/** Removes a list item from a FieldMultiTagbox field */
export interface IMetadataValuesSchemaItemRemoveCommand extends IMetadataValuesChangeCommandBase {
    /** The path of the field relative to the Content or Layer schema values defined by the schemaId property.
(i.e. add a team (existing list item) to the work information of a person: fieldPath = "workInfo.teams", schemaId = "PersonLayer"). */
    fieldPath: string;
    /** The field namespace. */
    fieldNamespace: string;
    /** The ID of the list item to be removed. */
    referenceId: string;
}

/** Request to batch update contents' fields based on a filter */
export class ContentFieldsBatchUpdateFilterRequest extends MetadataValuesChangeRequestBase implements IContentFieldsBatchUpdateFilterRequest {
    /** Filters the contents on which the change commands must be applied. */
    filterRequest!: ContentFilterRequest;

    constructor(data?: IContentFieldsBatchUpdateFilterRequest) {
        super(data);
        if (data) {
            this.filterRequest = data.filterRequest && !(<any>data.filterRequest).toJSON ? new ContentFilterRequest(data.filterRequest) : <ContentFilterRequest>this.filterRequest;
        }
        if (!data) {
            this.filterRequest = new ContentFilterRequest();
        }
        this._discriminator = "ContentFieldsBatchUpdateFilterRequest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filterRequest = _data["filterRequest"] ? ContentFilterRequest.fromJS(_data["filterRequest"]) : new ContentFilterRequest();
        }
    }

    static override fromJS(data: any): ContentFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Request to batch update contents' fields based on a filter */
export interface IContentFieldsBatchUpdateFilterRequest extends IMetadataValuesChangeRequestBase {
    /** Filters the contents on which the change commands must be applied. */
    filterRequest: IContentFilterRequest;
}

/** Base class for search results */
export class BaseResultOfContent implements IBaseResultOfContent {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Content[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Content(item) : <Content>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Content.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfContent {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IContent[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfContent extends BaseResultOfContent implements ISearchBehaviorBaseResultOfContent {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfContent) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfContent extends IBaseResultOfContent {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfContent extends SearchBehaviorBaseResultOfContent implements ISearchBehaviorWithAggregationBaseResultOfContent {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfContent) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfContent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfContent extends ISearchBehaviorBaseResultOfContent {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Result for content search operation */
export class ContentSearchResult extends SearchBehaviorWithAggregationBaseResultOfContent implements IContentSearchResult {
    /** Result of rights aggregation count requested in rightsAggregations in the ContentSearchRequest. */
    rightsAggregationsCounts?: ContentRightAggregationCount[] | undefined;

    constructor(data?: IContentSearchResult) {
        super(data);
        if (data) {
            if (data.rightsAggregationsCounts) {
                this.rightsAggregationsCounts = [];
                for (let i = 0; i < data.rightsAggregationsCounts.length; i++) {
                    let item = data.rightsAggregationsCounts[i];
                    this.rightsAggregationsCounts[i] = item && !(<any>item).toJSON ? new ContentRightAggregationCount(item) : <ContentRightAggregationCount>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["rightsAggregationsCounts"])) {
                this.rightsAggregationsCounts = [] as any;
                for (let item of _data["rightsAggregationsCounts"])
                    this.rightsAggregationsCounts!.push(ContentRightAggregationCount.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rightsAggregationsCounts)) {
            data["rightsAggregationsCounts"] = [];
            for (let item of this.rightsAggregationsCounts)
                data["rightsAggregationsCounts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Result for content search operation */
export interface IContentSearchResult extends ISearchBehaviorWithAggregationBaseResultOfContent {
    /** Result of rights aggregation count requested in rightsAggregations in the ContentSearchRequest. */
    rightsAggregationsCounts?: IContentRightAggregationCount[] | undefined;
}

/** Combination of ContentRight and found document count */
export class ContentRightAggregationCount implements IContentRightAggregationCount {
    /** ContentRight. */
    contentRight!: ContentRight;
    /** Found document count. */
    count!: number;

    constructor(data?: IContentRightAggregationCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentRight = _data["contentRight"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContentRightAggregationCount {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRightAggregationCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentRight"] = this.contentRight;
        data["count"] = this.count;
        return data;
    }
}

/** Combination of ContentRight and found document count */
export interface IContentRightAggregationCount {
    /** ContentRight. */
    contentRight: ContentRight;
    /** Found document count. */
    count: number;
}

export class Content implements IContent {
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId!: string;
    /** The content type of this content. All except Virtual are binary files. */
    contentType!: ContentType;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues!: { [key: string]: string; };
    id!: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** Life cycle of content */
    lifeCycle!: LifeCycle;
    /** List of content rights the user has on this content. Values are returned only if related resolve behavior is requested in the search request. */
    contentRights?: ContentRight[] | undefined;
    /** Id of the related display content */
    displayContentId?: string | undefined;

    isVirtual() {
    return !NON_VIRTUAL_CONTENT_SCHEMAS_IDS.includes(this.contentSchemaId);
  }

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
        if (!data) {
            this.displayValues = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
            this.contentSchemaId = _data["contentSchemaId"];
            this.contentType = _data["contentType"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (_data["displayValues"]) {
                this.displayValues = {} as any;
                for (let key in _data["displayValues"]) {
                    if (_data["displayValues"].hasOwnProperty(key))
                        (<any>this.displayValues)![key] = _data["displayValues"][key];
                }
            }
            this.id = _data["id"];
            if (Array.isArray(_data["brokenReferenceIds"])) {
                this.brokenReferenceIds = [] as any;
                for (let item of _data["brokenReferenceIds"])
                    this.brokenReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenIndirectReferenceIds"])) {
                this.brokenIndirectReferenceIds = [] as any;
                for (let item of _data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenRelationTargetIds"])) {
                this.brokenRelationTargetIds = [] as any;
                for (let item of _data["brokenRelationTargetIds"])
                    this.brokenRelationTargetIds!.push(item);
            }
            this.lifeCycle = _data["lifeCycle"];
            if (Array.isArray(_data["contentRights"])) {
                this.contentRights = [] as any;
                for (let item of _data["contentRights"])
                    this.contentRights!.push(item);
            }
            this.displayContentId = _data["displayContentId"];
        }
    }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["contentSchemaId"] = this.contentSchemaId;
        data["contentType"] = this.contentType;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.displayValues) {
            data["displayValues"] = {};
            for (let key in this.displayValues) {
                if (this.displayValues.hasOwnProperty(key))
                    (<any>data["displayValues"])[key] = (<any>this.displayValues)[key];
            }
        }
        data["id"] = this.id;
        if (Array.isArray(this.brokenReferenceIds)) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenIndirectReferenceIds)) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenRelationTargetIds)) {
            data["brokenRelationTargetIds"] = [];
            for (let item of this.brokenRelationTargetIds)
                data["brokenRelationTargetIds"].push(item);
        }
        data["lifeCycle"] = this.lifeCycle;
        if (Array.isArray(this.contentRights)) {
            data["contentRights"] = [];
            for (let item of this.contentRights)
                data["contentRights"].push(item);
        }
        data["displayContentId"] = this.displayContentId;
        return data;
    }
}

export interface IContent {
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** The id of the schema with schema type content. */
    contentSchemaId: string;
    /** The content type of this content. All except Virtual are binary files. */
    contentType: ContentType;
    /** An optional id list of schemas with schema type layer. */
    layerSchemaIds?: string[] | undefined;
    /** Contains display values of the specified language, rendered according to the content schema's display pattern configuration. */
    displayValues: { [key: string]: string; };
    id: string;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** Life cycle of content */
    lifeCycle: LifeCycle;
    /** List of content rights the user has on this content. Values are returned only if related resolve behavior is requested in the search request. */
    contentRights?: ContentRight[] | undefined;
    /** Id of the related display content */
    displayContentId?: string | undefined;
}

/** Request to aggregate contents based on the aggregators defined on a channel */
export class ContentAggregationOnChannelRequest implements IContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. Defaults to RootChannel.
For the ContentAggregationOnChannelRequest only, the existing aggregation saved on the channel are retrieved and used to perform the aggregation. */
    channelId?: string | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limit the search to the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** Limits the aggregation to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;
    /** Limits the aggregation to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType!: ContentSearchType;

    constructor(data?: IContentAggregationOnChannelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
            this.channelId = _data["channelId"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            this.collectionId = _data["collectionId"];
            this.lifeCycleFilter = _data["lifeCycleFilter"];
            this.brokenDependenciesFilter = _data["brokenDependenciesFilter"];
            this.searchType = _data["searchType"];
        }
    }

    static fromJS(data: any): ContentAggregationOnChannelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationOnChannelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        data["channelId"] = this.channelId;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["collectionId"] = this.collectionId;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        data["searchType"] = this.searchType;
        return data;
    }
}

/** Request to aggregate contents based on the aggregators defined on a channel */
export interface IContentAggregationOnChannelRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Limits the simple search fields to the fields available in the specified channel. Defaults to RootChannel.
For the ContentAggregationOnChannelRequest only, the existing aggregation saved on the channel are retrieved and used to perform the aggregation. */
    channelId?: string | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limit the search to the contents belonging to the specified collection. */
    collectionId?: string | undefined;
    /** Limits the aggregation to the contents that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
    /** Limits the aggregation to the contents that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Type of search to be performed: search only in metadata, only in the extracted fulltext from the file or both. Default to Metadata. */
    searchType: ContentSearchType;
}

/** Request to search contents */
export class ContentSearchRequest extends ContentAggregationOnChannelRequest implements IContentSearchRequest {
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the contents to the ones the user has the specified ContentRights. */
    rightsFilter?: ContentRight[] | undefined;
    /** Returns the aggregated document counts to the ones the user has the specified ContentRights.
Produces the rightsAggregationCounts on the ContentSearchResult. View will be ignored as the totalResults already gives this information. */
    rightsAggregations?: ContentRight[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ContentSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** List of enums that allow additional resolutions on top of the standard Content result */
    resolveBehaviors?: ContentSearchResolveBehavior[] | undefined;

    constructor(data?: IContentSearchRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["displayPatternIds"])) {
                this.displayPatternIds = [] as any;
                for (let item of _data["displayPatternIds"])
                    this.displayPatternIds!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            if (Array.isArray(_data["rightsFilter"])) {
                this.rightsFilter = [] as any;
                for (let item of _data["rightsFilter"])
                    this.rightsFilter!.push(item);
            }
            if (Array.isArray(_data["rightsAggregations"])) {
                this.rightsAggregations = [] as any;
                for (let item of _data["rightsAggregations"])
                    this.rightsAggregations!.push(item);
            }
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["resolveBehaviors"])) {
                this.resolveBehaviors = [] as any;
                for (let item of _data["resolveBehaviors"])
                    this.resolveBehaviors!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSearchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.displayPatternIds)) {
            data["displayPatternIds"] = [];
            for (let item of this.displayPatternIds)
                data["displayPatternIds"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        if (Array.isArray(this.rightsFilter)) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        if (Array.isArray(this.rightsAggregations)) {
            data["rightsAggregations"] = [];
            for (let item of this.rightsAggregations)
                data["rightsAggregations"].push(item);
        }
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        if (Array.isArray(this.resolveBehaviors)) {
            data["resolveBehaviors"] = [];
            for (let item of this.resolveBehaviors)
                data["resolveBehaviors"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to search contents */
export interface IContentSearchRequest extends IContentAggregationOnChannelRequest {
    /** Limits the display values included in the search response. Defaults to all display values. */
    displayPatternIds?: string[] | undefined;
    /** Sorts the search results. Sorting on a field not marked as Sortable in the Content schema will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the contents to the ones the user has the specified ContentRights. */
    rightsFilter?: ContentRight[] | undefined;
    /** Returns the aggregated document counts to the ones the user has the specified ContentRights.
Produces the rightsAggregationCounts on the ContentSearchResult. View will be ignored as the totalResults already gives this information. */
    rightsAggregations?: ContentRight[] | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ContentSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** List of enums that allow additional resolutions on top of the standard Content result */
    resolveBehaviors?: ContentSearchResolveBehavior[] | undefined;
}

/** Enum that allow additional resolutions on top of the standard Content result */
export enum ContentSearchResolveBehavior {
    Permissions = "Permissions",
}

/** Result for an aggregation operation */
export class ObjectAggregationResult implements IObjectAggregationResult {
    /** How long did the search and aggregation took. */
    elapsedMilliseconds!: number;
    /** Results of the aggregation. */
    aggregationResults!: AggregationResult[];
    /** Search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten!: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: IObjectAggregationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
        if (!data) {
            this.aggregationResults = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ObjectAggregationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectAggregationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        return data;
    }
}

/** Result for an aggregation operation */
export interface IObjectAggregationResult {
    /** How long did the search and aggregation took. */
    elapsedMilliseconds: number;
    /** Results of the aggregation. */
    aggregationResults: IAggregationResult[];
    /** Search string used to query the data */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Request to aggregate contents based on the specified aggregators */
export class ContentAggregationRequest extends ContentAggregationOnChannelRequest implements IContentAggregationRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: IContentAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ContentAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContentAggregationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to aggregate contents based on the specified aggregators */
export interface IContentAggregationRequest extends IContentAggregationOnChannelRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Base class for search results */
export class BaseResultOfHistoricVersion implements IBaseResultOfHistoricVersion {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: HistoricVersion[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfHistoricVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new HistoricVersion(item) : <HistoricVersion>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(HistoricVersion.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfHistoricVersion {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfHistoricVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfHistoricVersion {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IHistoricVersion[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class HistoricVersionSearchResult extends BaseResultOfHistoricVersion implements IHistoricVersionSearchResult {
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: IHistoricVersionSearchResult) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): HistoricVersionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new HistoricVersionSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHistoricVersionSearchResult extends IBaseResultOfHistoricVersion {
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

export class HistoricVersion implements IHistoricVersion {
    /** Sequential version number. */
    versionNumber!: number;
    /** Content ID. */
    contentId?: string | undefined;
    /** The datetime when this version was replaced. */
    replaced!: Date;
    /** User who replaced this version. */
    user?: User | undefined;
    /** File name for this version. */
    fileName?: string | undefined;
    /** True if this version was created by XMP writeback (as the version without the mutation). */
    createdByXmpWriteback!: boolean;
    /** ID of the original output associated with this version. */
    originalOutputId?: string | undefined;

    constructor(data?: IHistoricVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new User(data.user) : <User>this.user;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionNumber = _data["versionNumber"];
            this.contentId = _data["contentId"];
            this.replaced = _data["replaced"] ? new Date(_data["replaced"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.fileName = _data["fileName"];
            this.createdByXmpWriteback = _data["createdByXmpWriteback"];
            this.originalOutputId = _data["originalOutputId"];
        }
    }

    static fromJS(data: any): HistoricVersion {
        data = typeof data === 'object' ? data : {};
        let result = new HistoricVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionNumber"] = this.versionNumber;
        data["contentId"] = this.contentId;
        data["replaced"] = this.replaced ? this.replaced.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["fileName"] = this.fileName;
        data["createdByXmpWriteback"] = this.createdByXmpWriteback;
        data["originalOutputId"] = this.originalOutputId;
        return data;
    }
}

export interface IHistoricVersion {
    /** Sequential version number. */
    versionNumber: number;
    /** Content ID. */
    contentId?: string | undefined;
    /** The datetime when this version was replaced. */
    replaced: Date;
    /** User who replaced this version. */
    user?: IUser | undefined;
    /** File name for this version. */
    fileName?: string | undefined;
    /** True if this version was created by XMP writeback (as the version without the mutation). */
    createdByXmpWriteback: boolean;
    /** ID of the original output associated with this version. */
    originalOutputId?: string | undefined;
}

export class HistoricVersionSearchRequest implements IHistoricVersionSearchRequest {
    /** Will exclude the historic versions that were created by XMP writeback */
    excludeXmpWritebackGenerated!: boolean;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: IHistoricVersionSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.excludeXmpWritebackGenerated = _data["excludeXmpWritebackGenerated"];
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.debugMode = _data["debugMode"];
        }
    }

    static fromJS(data: any): HistoricVersionSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HistoricVersionSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["excludeXmpWritebackGenerated"] = this.excludeXmpWritebackGenerated;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["debugMode"] = this.debugMode;
        return data;
    }
}

export interface IHistoricVersionSearchRequest {
    /** Will exclude the historic versions that were created by XMP writeback */
    excludeXmpWritebackGenerated: boolean;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the BusinessProcessSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

export class CommentEditable implements ICommentEditable {
    /** Text of the comment message. */
    message!: string;

    constructor(data?: ICommentEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CommentEditable {
        data = typeof data === 'object' ? data : {};
        let result = new CommentEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface ICommentEditable {
    /** Text of the comment message. */
    message: string;
}

/** Represents a comment */
export class Comment extends CommentEditable implements IComment {
    /** Comment ID. */
    id!: string;
    /** ID of the content this comment is on. */
    contentId!: string;
    /** ID of the parent comment, in case this comment is a reply. */
    parentId?: string | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IComment) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.contentId = _data["contentId"];
            this.parentId = _data["parentId"];
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentId"] = this.contentId;
        data["parentId"] = this.parentId;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents a comment */
export interface IComment extends ICommentEditable {
    /** Comment ID. */
    id: string;
    /** ID of the content this comment is on. */
    contentId: string;
    /** ID of the parent comment, in case this comment is a reply. */
    parentId?: string | undefined;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

export class CommentCreateRequest extends CommentEditable implements ICommentCreateRequest {
    /** ID of the parent comment, in case the comment should be a reply. */
    parentId?: string | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: ICommentCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentId = _data["parentId"];
            this.requestId = _data["requestId"];
        }
    }

    static override fromJS(data: any): CommentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data;
    }
}

export interface ICommentCreateRequest extends ICommentEditable {
    /** ID of the parent comment, in case the comment should be a reply. */
    parentId?: string | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Base class for search results */
export class BaseResultOfComment implements IBaseResultOfComment {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Comment[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Comment.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfComment {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfComment {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Comment[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class CommentSearchResult extends BaseResultOfComment implements ICommentSearchResult {
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ICommentSearchResult) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CommentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommentSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICommentSearchResult extends IBaseResultOfComment {
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

export class CommentSearchRequest implements ICommentSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** If set to true, the result set will be sorted in an ascending order based on time of when which comment was originally created, replies will be always in descending order.
If false, the result set will be sorted in a descending order of when which comment was originally created. */
    ascending!: boolean;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the CommentSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: ICommentSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.ascending = _data["ascending"];
            this.pageToken = _data["pageToken"];
            this.debugMode = _data["debugMode"];
        }
    }

    static fromJS(data: any): CommentSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommentSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["ascending"] = this.ascending;
        data["pageToken"] = this.pageToken;
        data["debugMode"] = this.debugMode;
        return data;
    }
}

export interface ICommentSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** If set to true, the result set will be sorted in an ascending order based on time of when which comment was originally created, replies will be always in descending order.
If false, the result set will be sorted in a descending order of when which comment was originally created. */
    ascending: boolean;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the CommentSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

export class SetDisplayContentRequest implements ISetDisplayContentRequest {
    /** Id of the content which is supposed to be a DisplayContent. Intentionally nullable, null on the the property means the 'unset' operation */
    displayContentId?: string | undefined;

    constructor(data?: ISetDisplayContentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayContentId = _data["displayContentId"];
        }
    }

    static fromJS(data: any): SetDisplayContentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetDisplayContentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayContentId"] = this.displayContentId;
        return data;
    }
}

export interface ISetDisplayContentRequest {
    /** Id of the content which is supposed to be a DisplayContent. Intentionally nullable, null on the the property means the 'unset' operation */
    displayContentId?: string | undefined;
}

export class SetDisplayContentsManyRequest implements ISetDisplayContentsManyRequest {
    /** List of set display content items */
    items!: SetDisplayContentItem[];

    constructor(data?: ISetDisplayContentsManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SetDisplayContentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetDisplayContentsManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetDisplayContentsManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISetDisplayContentsManyRequest {
    /** List of set display content items */
    items: SetDisplayContentItem[];
}

/** Set display content item */
export class SetDisplayContentItem extends SetDisplayContentRequest implements ISetDisplayContentItem {
    /** The content ID. */
    contentId!: string;

    constructor(data?: ISetDisplayContentItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentId = _data["contentId"];
        }
    }

    static override fromJS(data: any): SetDisplayContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new SetDisplayContentItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        super.toJSON(data);
        return data;
    }
}

/** Set display content item */
export interface ISetDisplayContentItem extends ISetDisplayContentRequest {
    /** The content ID. */
    contentId: string;
}

/** Base class for search results */
export class BaseResultOfConversionPresetTemplate implements IBaseResultOfConversionPresetTemplate {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: ConversionPresetTemplate[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfConversionPresetTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ConversionPresetTemplate.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfConversionPresetTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfConversionPresetTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfConversionPresetTemplate {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ConversionPresetTemplate[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfConversionPresetTemplate extends BaseResultOfConversionPresetTemplate implements ISearchBehaviorBaseResultOfConversionPresetTemplate {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfConversionPresetTemplate) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfConversionPresetTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfConversionPresetTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfConversionPresetTemplate extends IBaseResultOfConversionPresetTemplate {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Holds results of the conversion preset template search */
export class ConversionPresetTemplateSearchResult extends SearchBehaviorBaseResultOfConversionPresetTemplate implements IConversionPresetTemplateSearchResult {

    constructor(data?: IConversionPresetTemplateSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ConversionPresetTemplateSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of the conversion preset template search */
export interface IConversionPresetTemplateSearchResult extends ISearchBehaviorBaseResultOfConversionPresetTemplate {
}

/** Holds information needed for conversion preset template update. */
export class ConversionPresetTemplateUpdateRequest implements IConversionPresetTemplateUpdateRequest {
    /** Language specific names. */
    names!: TranslatedStringDictionary;
    /** Language specific descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** The template for the conversion. */
    template?: string | undefined;

    constructor(data?: IConversionPresetTemplateUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): ConversionPresetTemplateUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["template"] = this.template;
        return data;
    }
}

/** Holds information needed for conversion preset template update. */
export interface IConversionPresetTemplateUpdateRequest {
    /** Language specific names. */
    names: ITranslatedStringDictionary;
    /** Language specific descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** The template for the conversion. */
    template?: string | undefined;
}

/** Represents a conversion preset template */
export class ConversionPresetTemplate extends ConversionPresetTemplateUpdateRequest implements IConversionPresetTemplate {
    /** Conversion preset template ID. */
    id!: string;
    /** The output format ID to which the conversion preset template is associated. */
    outputFormatId!: string;

    constructor(data?: IConversionPresetTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): ConversionPresetTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

/** Represents a conversion preset template */
export interface IConversionPresetTemplate extends IConversionPresetTemplateUpdateRequest {
    /** Conversion preset template ID. */
    id: string;
    /** The output format ID to which the conversion preset template is associated. */
    outputFormatId: string;
}

/** Conversion preset templates search request */
export class ConversionPresetTemplateSearchRequest implements IConversionPresetTemplateSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode!: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;

    constructor(data?: IConversionPresetTemplateSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
        }
    }

    static fromJS(data: any): ConversionPresetTemplateSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        return data;
    }
}

/** Conversion preset templates search request */
export interface IConversionPresetTemplateSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
}

/** Represents the detail of a conversion preset template */
export class ConversionPresetTemplateDetail extends ConversionPresetTemplate implements IConversionPresetTemplateDetail {
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IConversionPresetTemplateDetail) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ConversionPresetTemplateDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents the detail of a conversion preset template */
export interface IConversionPresetTemplateDetail extends IConversionPresetTemplate {
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

/** Holds information needed for conversion preset template creation */
export class ConversionPresetTemplateCreateRequest extends ConversionPresetTemplateUpdateRequest implements IConversionPresetTemplateCreateRequest {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
    /** The output format ID to which the conversion preset template is associated */
    outputFormatId!: string;

    constructor(data?: IConversionPresetTemplateCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestId = _data["requestId"];
            this.outputFormatId = _data["outputFormatId"];
        }
    }

    static override fromJS(data: any): ConversionPresetTemplateCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["outputFormatId"] = this.outputFormatId;
        super.toJSON(data);
        return data;
    }
}

/** Holds information needed for conversion preset template creation */
export interface IConversionPresetTemplateCreateRequest extends IConversionPresetTemplateUpdateRequest {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
    /** The output format ID to which the conversion preset template is associated */
    outputFormatId: string;
}

/** Used to create multiple new conversion preset templates at once. */
export class ConversionPresetTemplateCreateManyRequest implements IConversionPresetTemplateCreateManyRequest {
    /** Conversion preset templates items to be created. */
    items?: ConversionPresetTemplateCreateRequest[] | undefined;

    constructor(data?: IConversionPresetTemplateCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConversionPresetTemplateCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConversionPresetTemplateCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to create multiple new conversion preset templates at once. */
export interface IConversionPresetTemplateCreateManyRequest {
    /** Conversion preset templates items to be created. */
    items?: ConversionPresetTemplateCreateRequest[] | undefined;
}

/** Used to modify multiple conversion preset templates at once. */
export class ConversionPresetTemplateUpdateManyRequest implements IConversionPresetTemplateUpdateManyRequest {
    /** Conversion preset templates items to be modified. */
    items?: ConversionPresetTemplateUpdateManyRequestItem[] | undefined;

    constructor(data?: IConversionPresetTemplateUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConversionPresetTemplateUpdateManyRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConversionPresetTemplateUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to modify multiple conversion preset templates at once. */
export interface IConversionPresetTemplateUpdateManyRequest {
    /** Conversion preset templates items to be modified. */
    items?: ConversionPresetTemplateUpdateManyRequestItem[] | undefined;
}

/** Represents one item to be modified in a bulk update operation on conversion preset templates. */
export class ConversionPresetTemplateUpdateManyRequestItem extends ConversionPresetTemplateUpdateRequest implements IConversionPresetTemplateUpdateManyRequestItem {
    /** ID of the conversion preset templates to modify. */
    id?: string | undefined;

    constructor(data?: IConversionPresetTemplateUpdateManyRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): ConversionPresetTemplateUpdateManyRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateUpdateManyRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Represents one item to be modified in a bulk update operation on conversion preset templates. */
export interface IConversionPresetTemplateUpdateManyRequestItem extends IConversionPresetTemplateUpdateRequest {
    /** ID of the conversion preset templates to modify. */
    id?: string | undefined;
}

/** Used to remove multiple conversion preset templates at once. */
export class ConversionPresetTemplateDeleteManyRequest implements IConversionPresetTemplateDeleteManyRequest {
    /** List of IDs of conversion preset templates to remove. */
    ids?: string[] | undefined;

    constructor(data?: IConversionPresetTemplateDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): ConversionPresetTemplateDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPresetTemplateDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

/** Used to remove multiple conversion preset templates at once. */
export interface IConversionPresetTemplateDeleteManyRequest {
    /** List of IDs of conversion preset templates to remove. */
    ids?: string[] | undefined;
}

export class DisplayValueStatus implements IDisplayValueStatus {
    /** The schema ids (of type Content or Layer) for which the re-rendering of the display values is needed. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the re-rendering of the display values is needed. */
    listSchemaIds?: string[] | undefined;
    /** The state of the display values compared to the schema structure (UpToDate = ok, Outdated = re-rendering needed). */
    state!: DisplayValuesState;

    constructor(data?: IDisplayValueStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentOrLayerSchemaIds"])) {
                this.contentOrLayerSchemaIds = [] as any;
                for (let item of _data["contentOrLayerSchemaIds"])
                    this.contentOrLayerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["listSchemaIds"])) {
                this.listSchemaIds = [] as any;
                for (let item of _data["listSchemaIds"])
                    this.listSchemaIds!.push(item);
            }
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): DisplayValueStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayValueStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentOrLayerSchemaIds)) {
            data["contentOrLayerSchemaIds"] = [];
            for (let item of this.contentOrLayerSchemaIds)
                data["contentOrLayerSchemaIds"].push(item);
        }
        if (Array.isArray(this.listSchemaIds)) {
            data["listSchemaIds"] = [];
            for (let item of this.listSchemaIds)
                data["listSchemaIds"].push(item);
        }
        data["state"] = this.state;
        return data;
    }
}

export interface IDisplayValueStatus {
    /** The schema ids (of type Content or Layer) for which the re-rendering of the display values is needed. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the re-rendering of the display values is needed. */
    listSchemaIds?: string[] | undefined;
    /** The state of the display values compared to the schema structure (UpToDate = ok, Outdated = re-rendering needed). */
    state: DisplayValuesState;
}

export enum DisplayValuesState {
    UpToDate = "UpToDate",
    Outdated = "Outdated",
    RerenderingInProgress = "RerenderingInProgress",
}

export class DocumentHistory implements IDocumentHistory {
    documentId?: string | undefined;
    documentVersion!: number;
    documentType?: string | undefined;
    documentDate!: Date;
    document?: string | undefined;
    timestamp!: Date;
    audit?: UserAuditHistory | undefined;
    deleted!: boolean;
    action!: DocumentChangeAction;

    constructor(data?: IDocumentHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditHistory(data.audit) : <UserAuditHistory>this.audit;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentVersion = _data["documentVersion"];
            this.documentType = _data["documentType"];
            this.documentDate = _data["documentDate"] ? new Date(_data["documentDate"].toString()) : <any>undefined;
            this.document = _data["document"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.audit = _data["audit"] ? UserAuditHistory.fromJS(_data["audit"]) : <any>undefined;
            this.deleted = _data["deleted"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): DocumentHistory {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["document"] = this.document;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["deleted"] = this.deleted;
        data["action"] = this.action;
        return data;
    }
}

export interface IDocumentHistory {
    documentId?: string | undefined;
    documentVersion: number;
    documentType?: string | undefined;
    documentDate: Date;
    document?: string | undefined;
    timestamp: Date;
    audit?: IUserAuditHistory | undefined;
    deleted: boolean;
    action: DocumentChangeAction;
}

export class UserAuditHistory implements IUserAuditHistory {
    modificationDate!: Date;
    modifiedByUser?: string | undefined;

    constructor(data?: IUserAuditHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.modifiedByUser = _data["modifiedByUser"];
        }
    }

    static fromJS(data: any): UserAuditHistory {
        data = typeof data === 'object' ? data : {};
        let result = new UserAuditHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["modifiedByUser"] = this.modifiedByUser;
        return data;
    }
}

export interface IUserAuditHistory {
    modificationDate: Date;
    modifiedByUser?: string | undefined;
}

export enum DocumentChangeAction {
    Create = "Create",
    Update = "Update",
    Delete = "Delete",
    Activate = "Activate",
    Deactivate = "Deactivate",
}

export class DocumentHistoryDifference implements IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion!: number;
    newDocumentVersion!: number;
    /** Contains an RFC 6902 compatible patch that can be applied on the old document to get the new document.
Use a library like jsondiffpatch.net (https://github.com/wbish/jsondiffpatch.net)
or jsondiffpatch (https://github.com/benjamine/jsondiffpatch) to process this. */
    patch?: any | undefined;

    constructor(data?: IDocumentHistoryDifference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.oldDocumentVersion = _data["oldDocumentVersion"];
            this.newDocumentVersion = _data["newDocumentVersion"];
            this.patch = _data["patch"];
        }
    }

    static fromJS(data: any): DocumentHistoryDifference {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistoryDifference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["oldDocumentVersion"] = this.oldDocumentVersion;
        data["newDocumentVersion"] = this.newDocumentVersion;
        data["patch"] = this.patch;
        return data;
    }
}

export interface IDocumentHistoryDifference {
    documentId?: string | undefined;
    oldDocumentVersion: number;
    newDocumentVersion: number;
    /** Contains an RFC 6902 compatible patch that can be applied on the old document to get the new document.
Use a library like jsondiffpatch.net (https://github.com/wbish/jsondiffpatch.net)
or jsondiffpatch (https://github.com/benjamine/jsondiffpatch) to process this. */
    patch?: any | undefined;
}

export class DocumentHistorySearchResult implements IDocumentHistorySearchResult {
    /** The upper bound of the total number of matching documents. */
    maxResults!: number;
    /** The matched documents. */
    results!: DocumentHistory[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IDocumentHistorySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new DocumentHistory(item) : <DocumentHistory>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DocumentHistory.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): DocumentHistorySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

export interface IDocumentHistorySearchResult {
    /** The upper bound of the total number of matching documents. */
    maxResults: number;
    /** The matched documents. */
    results: IDocumentHistory[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class DocumentHistorySearchRequest implements IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. By default no limitation set. */
    from!: Date;
    /** Limits the end date of the search request. By default no limitation set. */
    to!: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document ID. E.g. contentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion!: number;
    /** Limits the search to a specific document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;

    constructor(data?: IDocumentHistorySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.documentId = _data["documentId"];
            this.documentVersion = _data["documentVersion"];
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentHistorySearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentHistorySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["documentId"] = this.documentId;
        data["documentVersion"] = this.documentVersion;
        data["documentType"] = this.documentType;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocumentHistorySearchRequest {
    /** Limits the start date of the search request. By default no limitation set. */
    from: Date;
    /** Limits the end date of the search request. By default no limitation set. */
    to: Date;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
    /** Limits the search to a specific document ID. E.g. contentId */
    documentId?: string | undefined;
    /** The document version to search. Default to -1 to not limit to a specific document version. */
    documentVersion: number;
    /** Limits the search to a specific document type. */
    documentType?: string | undefined;
    /** Sorts the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
}

export class IdentityProviderEditable implements IIdentityProviderEditable {
    /** Mapping of identity provider claims to user attributes */
    claimMapping?: IdpClaimToUserAttributeMapping[] | undefined;
    /** Name of the identity provider claim that holds group membership information */
    groupClaimType?: string | undefined;
    /** IdP (AD) group to user role ID mapping */
    groupMapping?: IdpGroupToUserRoleMapping[] | undefined;
    /** Optional user role ID that will be assigned to a user is none of the group mappings produce a match */
    fallbackUserRoleId?: string | undefined;

    constructor(data?: IIdentityProviderEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.claimMapping) {
                this.claimMapping = [];
                for (let i = 0; i < data.claimMapping.length; i++) {
                    let item = data.claimMapping[i];
                    this.claimMapping[i] = item && !(<any>item).toJSON ? new IdpClaimToUserAttributeMapping(item) : <IdpClaimToUserAttributeMapping>item;
                }
            }
            if (data.groupMapping) {
                this.groupMapping = [];
                for (let i = 0; i < data.groupMapping.length; i++) {
                    let item = data.groupMapping[i];
                    this.groupMapping[i] = item && !(<any>item).toJSON ? new IdpGroupToUserRoleMapping(item) : <IdpGroupToUserRoleMapping>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claimMapping"])) {
                this.claimMapping = [] as any;
                for (let item of _data["claimMapping"])
                    this.claimMapping!.push(IdpClaimToUserAttributeMapping.fromJS(item));
            }
            this.groupClaimType = _data["groupClaimType"];
            if (Array.isArray(_data["groupMapping"])) {
                this.groupMapping = [] as any;
                for (let item of _data["groupMapping"])
                    this.groupMapping!.push(IdpGroupToUserRoleMapping.fromJS(item));
            }
            this.fallbackUserRoleId = _data["fallbackUserRoleId"];
        }
    }

    static fromJS(data: any): IdentityProviderEditable {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProviderEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claimMapping)) {
            data["claimMapping"] = [];
            for (let item of this.claimMapping)
                data["claimMapping"].push(item.toJSON());
        }
        data["groupClaimType"] = this.groupClaimType;
        if (Array.isArray(this.groupMapping)) {
            data["groupMapping"] = [];
            for (let item of this.groupMapping)
                data["groupMapping"].push(item.toJSON());
        }
        data["fallbackUserRoleId"] = this.fallbackUserRoleId;
        return data;
    }
}

export interface IIdentityProviderEditable {
    /** Mapping of identity provider claims to user attributes */
    claimMapping?: IIdpClaimToUserAttributeMapping[] | undefined;
    /** Name of the identity provider claim that holds group membership information */
    groupClaimType?: string | undefined;
    /** IdP (AD) group to user role ID mapping */
    groupMapping?: IIdpGroupToUserRoleMapping[] | undefined;
    /** Optional user role ID that will be assigned to a user is none of the group mappings produce a match */
    fallbackUserRoleId?: string | undefined;
}

/** Represents an identity provider defined in IdentityServer and its Picturepark configuration */
export class IdentityProvider extends IdentityProviderEditable implements IIdentityProvider {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id!: string;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;

    constructor(data?: IIdentityProvider) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static override fromJS(data: any): IdentityProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProvider();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        super.toJSON(data);
        return data;
    }
}

/** Represents an identity provider defined in IdentityServer and its Picturepark configuration */
export interface IIdentityProvider extends IIdentityProviderEditable {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id: string;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;
}

export class IdpClaimToUserAttributeMapping implements IIdpClaimToUserAttributeMapping {
    /** Claim type name coming from external identity provider */
    claimType?: string | undefined;
    /** Path to a user attribute to synchronize */
    userAttributePath?: string | undefined;

    constructor(data?: IIdpClaimToUserAttributeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimType = _data["claimType"];
            this.userAttributePath = _data["userAttributePath"];
        }
    }

    static fromJS(data: any): IdpClaimToUserAttributeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IdpClaimToUserAttributeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimType"] = this.claimType;
        data["userAttributePath"] = this.userAttributePath;
        return data;
    }
}

export interface IIdpClaimToUserAttributeMapping {
    /** Claim type name coming from external identity provider */
    claimType?: string | undefined;
    /** Path to a user attribute to synchronize */
    userAttributePath?: string | undefined;
}

export class IdpGroupToUserRoleMapping implements IIdpGroupToUserRoleMapping {
    /** Name of the group on external identity provider */
    group?: string | undefined;
    /** User role ID as defined in CP */
    userRoleId?: string | undefined;

    constructor(data?: IIdpGroupToUserRoleMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.userRoleId = _data["userRoleId"];
        }
    }

    static fromJS(data: any): IdpGroupToUserRoleMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IdpGroupToUserRoleMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["userRoleId"] = this.userRoleId;
        return data;
    }
}

export interface IIdpGroupToUserRoleMapping {
    /** Name of the group on external identity provider */
    group?: string | undefined;
    /** User role ID as defined in CP */
    userRoleId?: string | undefined;
}

/** Basic information about an identity provider */
export class IdentityProviderBasicInfo implements IIdentityProviderBasicInfo {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id?: string | undefined;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;

    constructor(data?: IIdentityProviderBasicInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): IdentityProviderBasicInfo {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProviderBasicInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }
}

/** Basic information about an identity provider */
export interface IIdentityProviderBasicInfo {
    /** Identity provider ID (has to match an existing IdP defined in IdentityServer) */
    id?: string | undefined;
    /** Name of the identity provider as defined in IdentityServer */
    name?: string | undefined;
    /** Display name of the identity provider as defined in IdentityServer */
    displayName?: string | undefined;
}

/** The version view item for the environment. */
export class VersionInfo implements IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The release version. */
    release?: string | undefined;
    /** Cloud name. */
    cloudName?: string | undefined;

    constructor(data?: IVersionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileVersion = _data["fileVersion"];
            this.fileProductVersion = _data["fileProductVersion"];
            this.contractVersion = _data["contractVersion"];
            this.release = _data["release"];
            this.cloudName = _data["cloudName"];
        }
    }

    static fromJS(data: any): VersionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VersionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileVersion"] = this.fileVersion;
        data["fileProductVersion"] = this.fileProductVersion;
        data["contractVersion"] = this.contractVersion;
        data["release"] = this.release;
        data["cloudName"] = this.cloudName;
        return data;
    }
}

/** The version view item for the environment. */
export interface IVersionInfo {
    /** The manual file version of Picturepark.Contract.dll. */
    fileVersion?: string | undefined;
    /** The GitVersionTask generated file product version of Picturepark.Configuration.dll. */
    fileProductVersion?: string | undefined;
    /** The current contract version stored in CustomerDoc / EnvironmentDoc. */
    contractVersion?: string | undefined;
    /** The release version. */
    release?: string | undefined;
    /** Cloud name. */
    cloudName?: string | undefined;
}

/** Customer configuration information */
export class CustomerInfo implements ICustomerInfo {
    /** The customer ID. */
    customerId!: string;
    /** The name of the customer instance. */
    name!: string;
    /** Alias of the customer instance. */
    customerAlias!: string;
    /** The base URL of identity server to authenticate the user using OpenID Connect. */
    identityServerUrl!: string;
    /** The base API URL. */
    apiUrl!: string;
    /** Host for integrations (Service Providers) */
    integrationHost!: string;
    /** Information if the query details can be enabled when searching. For debug purposes only. */
    enableQueryDetails!: boolean;
    /** Configured languages of customer instance (system, metadata, share, default). */
    languageConfiguration!: LanguageConfigurationInfo;
    /** Languages including translations for the configured system and metadata and share languages. */
    languages!: Language[];
    /** Configured rendering outputs including translations for the customer instance. */
    outputFormats!: OutputFormatInfo[];
    /** Boost levels that can be applied to a metadata field to boost the the significance of the field in a search operation. */
    boostValues!: number[];
    /** Apps registered for this customer */
    apps?: CustomerApp[] | undefined;
    modificationDate!: Date;
    /** Url to access Frontend service */
    baseUrl!: string;
    /** Base bath to access logos of customer (including trailing slash), available images: name, full, small, background */
    logosUrl!: string;
    /** License options and states */
    licenseInformation!: LicenseInfo;
    /** Customer settings */
    settings!: CustomerInfoSettings;
    /** True if a dashboard overview template is available. */
    hasDashboard!: boolean;
    /** Cloud name customer is located in. */
    cloudName!: string;

    constructor(data?: ICustomerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.languageConfiguration = data.languageConfiguration && !(<any>data.languageConfiguration).toJSON ? new LanguageConfigurationInfo(data.languageConfiguration) : <LanguageConfigurationInfo>this.languageConfiguration;
            if (data.languages) {
                this.languages = [];
                for (let i = 0; i < data.languages.length; i++) {
                    let item = data.languages[i];
                    this.languages[i] = item && !(<any>item).toJSON ? new Language(item) : <Language>item;
                }
            }
            if (data.outputFormats) {
                this.outputFormats = [];
                for (let i = 0; i < data.outputFormats.length; i++) {
                    let item = data.outputFormats[i];
                    this.outputFormats[i] = item && !(<any>item).toJSON ? new OutputFormatInfo(item) : <OutputFormatInfo>item;
                }
            }
            if (data.apps) {
                this.apps = [];
                for (let i = 0; i < data.apps.length; i++) {
                    let item = data.apps[i];
                    this.apps[i] = item && !(<any>item).toJSON ? new CustomerApp(item) : <CustomerApp>item;
                }
            }
            this.licenseInformation = data.licenseInformation && !(<any>data.licenseInformation).toJSON ? new LicenseInfo(data.licenseInformation) : <LicenseInfo>this.licenseInformation;
            this.settings = data.settings && !(<any>data.settings).toJSON ? new CustomerInfoSettings(data.settings) : <CustomerInfoSettings>this.settings;
        }
        if (!data) {
            this.languageConfiguration = new LanguageConfigurationInfo();
            this.languages = [];
            this.outputFormats = [];
            this.boostValues = [];
            this.licenseInformation = new LicenseInfo();
            this.settings = new CustomerInfoSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.name = _data["name"];
            this.customerAlias = _data["customerAlias"];
            this.identityServerUrl = _data["identityServerUrl"];
            this.apiUrl = _data["apiUrl"];
            this.integrationHost = _data["integrationHost"];
            this.enableQueryDetails = _data["enableQueryDetails"];
            this.languageConfiguration = _data["languageConfiguration"] ? LanguageConfigurationInfo.fromJS(_data["languageConfiguration"]) : new LanguageConfigurationInfo();
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(Language.fromJS(item));
            }
            if (Array.isArray(_data["outputFormats"])) {
                this.outputFormats = [] as any;
                for (let item of _data["outputFormats"])
                    this.outputFormats!.push(OutputFormatInfo.fromJS(item));
            }
            if (Array.isArray(_data["boostValues"])) {
                this.boostValues = [] as any;
                for (let item of _data["boostValues"])
                    this.boostValues!.push(item);
            }
            if (Array.isArray(_data["apps"])) {
                this.apps = [] as any;
                for (let item of _data["apps"])
                    this.apps!.push(CustomerApp.fromJS(item));
            }
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.logosUrl = _data["logosUrl"];
            this.licenseInformation = _data["licenseInformation"] ? LicenseInfo.fromJS(_data["licenseInformation"]) : new LicenseInfo();
            this.settings = _data["settings"] ? CustomerInfoSettings.fromJS(_data["settings"]) : new CustomerInfoSettings();
            this.hasDashboard = _data["hasDashboard"];
            this.cloudName = _data["cloudName"];
        }
    }

    static fromJS(data: any): CustomerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["customerAlias"] = this.customerAlias;
        data["identityServerUrl"] = this.identityServerUrl;
        data["apiUrl"] = this.apiUrl;
        data["integrationHost"] = this.integrationHost;
        data["enableQueryDetails"] = this.enableQueryDetails;
        data["languageConfiguration"] = this.languageConfiguration ? this.languageConfiguration.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.outputFormats)) {
            data["outputFormats"] = [];
            for (let item of this.outputFormats)
                data["outputFormats"].push(item.toJSON());
        }
        if (Array.isArray(this.boostValues)) {
            data["boostValues"] = [];
            for (let item of this.boostValues)
                data["boostValues"].push(item);
        }
        if (Array.isArray(this.apps)) {
            data["apps"] = [];
            for (let item of this.apps)
                data["apps"].push(item.toJSON());
        }
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["logosUrl"] = this.logosUrl;
        data["licenseInformation"] = this.licenseInformation ? this.licenseInformation.toJSON() : <any>undefined;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        data["hasDashboard"] = this.hasDashboard;
        data["cloudName"] = this.cloudName;
        return data;
    }
}

/** Customer configuration information */
export interface ICustomerInfo {
    /** The customer ID. */
    customerId: string;
    /** The name of the customer instance. */
    name: string;
    /** Alias of the customer instance. */
    customerAlias: string;
    /** The base URL of identity server to authenticate the user using OpenID Connect. */
    identityServerUrl: string;
    /** The base API URL. */
    apiUrl: string;
    /** Host for integrations (Service Providers) */
    integrationHost: string;
    /** Information if the query details can be enabled when searching. For debug purposes only. */
    enableQueryDetails: boolean;
    /** Configured languages of customer instance (system, metadata, share, default). */
    languageConfiguration: ILanguageConfigurationInfo;
    /** Languages including translations for the configured system and metadata and share languages. */
    languages: ILanguage[];
    /** Configured rendering outputs including translations for the customer instance. */
    outputFormats: IOutputFormatInfo[];
    /** Boost levels that can be applied to a metadata field to boost the the significance of the field in a search operation. */
    boostValues: number[];
    /** Apps registered for this customer */
    apps?: ICustomerApp[] | undefined;
    modificationDate: Date;
    /** Url to access Frontend service */
    baseUrl: string;
    /** Base bath to access logos of customer (including trailing slash), available images: name, full, small, background */
    logosUrl: string;
    /** License options and states */
    licenseInformation: ILicenseInfo;
    /** Customer settings */
    settings: ICustomerInfoSettings;
    /** True if a dashboard overview template is available. */
    hasDashboard: boolean;
    /** Cloud name customer is located in. */
    cloudName: string;
}

export class LanguageConfiguration implements ILanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages!: string[];
    /** A list of languages serving as metadata languages. */
    metadataLanguages!: string[];
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage!: string;

    constructor(data?: ILanguageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.systemLanguages = [];
            this.metadataLanguages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["systemLanguages"])) {
                this.systemLanguages = [] as any;
                for (let item of _data["systemLanguages"])
                    this.systemLanguages!.push(item);
            }
            if (Array.isArray(_data["metadataLanguages"])) {
                this.metadataLanguages = [] as any;
                for (let item of _data["metadataLanguages"])
                    this.metadataLanguages!.push(item);
            }
            this.defaultLanguage = _data["defaultLanguage"];
        }
    }

    static fromJS(data: any): LanguageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.systemLanguages)) {
            data["systemLanguages"] = [];
            for (let item of this.systemLanguages)
                data["systemLanguages"].push(item);
        }
        if (Array.isArray(this.metadataLanguages)) {
            data["metadataLanguages"] = [];
            for (let item of this.metadataLanguages)
                data["metadataLanguages"].push(item);
        }
        data["defaultLanguage"] = this.defaultLanguage;
        return data;
    }
}

export interface ILanguageConfiguration {
    /** A list of languages serving as system languages. */
    systemLanguages: string[];
    /** A list of languages serving as metadata languages. */
    metadataLanguages: string[];
    /** The default language. Not the be confused with the metadata fallback language x-default. */
    defaultLanguage: string;
}

export class LanguageConfigurationInfo extends LanguageConfiguration implements ILanguageConfigurationInfo {
    /** Share languages based on defined ShareMail templates. */
    shareLanguages!: string[];

    constructor(data?: ILanguageConfigurationInfo) {
        super(data);
        if (!data) {
            this.shareLanguages = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["shareLanguages"])) {
                this.shareLanguages = [] as any;
                for (let item of _data["shareLanguages"])
                    this.shareLanguages!.push(item);
            }
        }
    }

    static override fromJS(data: any): LanguageConfigurationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageConfigurationInfo();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.shareLanguages)) {
            data["shareLanguages"] = [];
            for (let item of this.shareLanguages)
                data["shareLanguages"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILanguageConfigurationInfo extends ILanguageConfiguration {
    /** Share languages based on defined ShareMail templates. */
    shareLanguages: string[];
}

export class Language implements ILanguage {
    /** Language translations. */
    name!: TranslatedStringDictionary;
    /** IETF language tag. E.g en, en-US, de. */
    ietf!: string;
    /** Two letter ISO language code. E.g. en, de. */
    twoLetterISOLanguageName?: string | undefined;
    /** Three letter ISO language code. E.g. eng, deu. */
    threeLetterISOLanguageName?: string | undefined;
    /** Region code of the language. E.g. US, DE, CH. */
    regionCode?: string | undefined;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.name = data.name && !(<any>data.name).toJSON ? new TranslatedStringDictionary(data.name) : <TranslatedStringDictionary>this.name;
        }
        if (!data) {
            this.name = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? TranslatedStringDictionary.fromJS(_data["name"]) : new TranslatedStringDictionary();
            this.ietf = _data["ietf"];
            this.twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            this.threeLetterISOLanguageName = _data["threeLetterISOLanguageName"];
            this.regionCode = _data["regionCode"];
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["ietf"] = this.ietf;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["threeLetterISOLanguageName"] = this.threeLetterISOLanguageName;
        data["regionCode"] = this.regionCode;
        return data;
    }
}

export interface ILanguage {
    /** Language translations. */
    name: ITranslatedStringDictionary;
    /** IETF language tag. E.g en, en-US, de. */
    ietf: string;
    /** Two letter ISO language code. E.g. en, de. */
    twoLetterISOLanguageName?: string | undefined;
    /** Three letter ISO language code. E.g. eng, deu. */
    threeLetterISOLanguageName?: string | undefined;
    /** Region code of the language. E.g. US, DE, CH. */
    regionCode?: string | undefined;
}

export class OutputFormatInfo implements IOutputFormatInfo {
    /** Output ID. */
    id!: string;
    /** Output translations. */
    names!: TranslatedStringDictionary;
    /** Format behaviors. */
    behaviors?: OutputFormatBehaviors | undefined;

    constructor(data?: IOutputFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.behaviors = data.behaviors && !(<any>data.behaviors).toJSON ? new OutputFormatBehaviors(data.behaviors) : <OutputFormatBehaviors>this.behaviors;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            this.behaviors = _data["behaviors"] ? OutputFormatBehaviors.fromJS(_data["behaviors"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OutputFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["behaviors"] = this.behaviors ? this.behaviors.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOutputFormatInfo {
    /** Output ID. */
    id: string;
    /** Output translations. */
    names: ITranslatedStringDictionary;
    /** Format behaviors. */
    behaviors?: IOutputFormatBehaviors | undefined;
}

/** Behaviors of OutputFormat */
export class OutputFormatBehaviors implements IOutputFormatBehaviors {
    /** Behavior for DownloadDialog. */
    downloadDialogBehavior!: DownloadDialogBehavior;
    /** Behavior when sharing. */
    shareOutputAccessBehaviors?: OutputFormatShareOutputAccessBehaviors | undefined;
    /** Behavior for media editor. */
    mediaEditorBehavior!: MediaEditorBehavior;

    constructor(data?: IOutputFormatBehaviors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.shareOutputAccessBehaviors = data.shareOutputAccessBehaviors && !(<any>data.shareOutputAccessBehaviors).toJSON ? new OutputFormatShareOutputAccessBehaviors(data.shareOutputAccessBehaviors) : <OutputFormatShareOutputAccessBehaviors>this.shareOutputAccessBehaviors;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadDialogBehavior = _data["downloadDialogBehavior"];
            this.shareOutputAccessBehaviors = _data["shareOutputAccessBehaviors"] ? OutputFormatShareOutputAccessBehaviors.fromJS(_data["shareOutputAccessBehaviors"]) : <any>undefined;
            this.mediaEditorBehavior = _data["mediaEditorBehavior"];
        }
    }

    static fromJS(data: any): OutputFormatBehaviors {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatBehaviors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadDialogBehavior"] = this.downloadDialogBehavior;
        data["shareOutputAccessBehaviors"] = this.shareOutputAccessBehaviors ? this.shareOutputAccessBehaviors.toJSON() : <any>undefined;
        data["mediaEditorBehavior"] = this.mediaEditorBehavior;
        return data;
    }
}

/** Behaviors of OutputFormat */
export interface IOutputFormatBehaviors {
    /** Behavior for DownloadDialog. */
    downloadDialogBehavior: DownloadDialogBehavior;
    /** Behavior when sharing. */
    shareOutputAccessBehaviors?: IOutputFormatShareOutputAccessBehaviors | undefined;
    /** Behavior for media editor. */
    mediaEditorBehavior: MediaEditorBehavior;
}

/** Defines behavior of an OutputFormat in DownloadDialog */
export enum DownloadDialogBehavior {
    ShowAlways = "ShowAlways",
    ShowMoreFormats = "ShowMoreFormats",
    Hide = "Hide",
}

/** Behavior when sharing for OutputFormat */
export class OutputFormatShareOutputAccessBehaviors implements IOutputFormatShareOutputAccessBehaviors {
    /** Behavior when sharing with Full. */
    full!: OutputAccessBehavior;
    /** Behavior when sharing with Preview. */
    preview!: OutputAccessBehavior;

    constructor(data?: IOutputFormatShareOutputAccessBehaviors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.full = _data["full"];
            this.preview = _data["preview"];
        }
    }

    static fromJS(data: any): OutputFormatShareOutputAccessBehaviors {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatShareOutputAccessBehaviors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["full"] = this.full;
        data["preview"] = this.preview;
        return data;
    }
}

/** Behavior when sharing for OutputFormat */
export interface IOutputFormatShareOutputAccessBehaviors {
    /** Behavior when sharing with Full. */
    full: OutputAccessBehavior;
    /** Behavior when sharing with Preview. */
    preview: OutputAccessBehavior;
}

/** Defines behavior of OutputFormat in ShareAccess */
export enum OutputAccessBehavior {
    Include = "Include",
    Exclude = "Exclude",
}

/** Defines behavior of OutputFormat in Media editor */
export enum MediaEditorBehavior {
    Show = "Show",
    Hide = "Hide",
}

export class CustomerApp implements ICustomerApp {
    appId?: string | undefined;
    name?: TranslatedStringDictionary | undefined;
    description?: TranslatedStringDictionary | undefined;
    icon?: string | undefined;

    constructor(data?: ICustomerApp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.name = data.name && !(<any>data.name).toJSON ? new TranslatedStringDictionary(data.name) : <TranslatedStringDictionary>this.name;
            this.description = data.description && !(<any>data.description).toJSON ? new TranslatedStringDictionary(data.description) : <TranslatedStringDictionary>this.description;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.name = _data["name"] ? TranslatedStringDictionary.fromJS(_data["name"]) : <any>undefined;
            this.description = _data["description"] ? TranslatedStringDictionary.fromJS(_data["description"]) : <any>undefined;
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): CustomerApp {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["icon"] = this.icon;
        return data;
    }
}

export interface ICustomerApp {
    appId?: string | undefined;
    name?: ITranslatedStringDictionary | undefined;
    description?: ITranslatedStringDictionary | undefined;
    icon?: string | undefined;
}

/** Customer license information */
export class LicenseInfo implements ILicenseInfo {
    /** State of content historic versioning */
    historicVersioningState!: HistoricVersioningState;
    /** State of statistics features for Content */
    contentStatistics!: StatisticsLicenseState;
    /** Licensing options for image optimization. */
    imageOptimization!: ImageOptimizationLicenseState;

    constructor(data?: ILicenseInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.contentStatistics = data.contentStatistics && !(<any>data.contentStatistics).toJSON ? new StatisticsLicenseState(data.contentStatistics) : <StatisticsLicenseState>this.contentStatistics;
            this.imageOptimization = data.imageOptimization && !(<any>data.imageOptimization).toJSON ? new ImageOptimizationLicenseState(data.imageOptimization) : <ImageOptimizationLicenseState>this.imageOptimization;
        }
        if (!data) {
            this.contentStatistics = new StatisticsLicenseState();
            this.imageOptimization = new ImageOptimizationLicenseState();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.historicVersioningState = _data["historicVersioningState"];
            this.contentStatistics = _data["contentStatistics"] ? StatisticsLicenseState.fromJS(_data["contentStatistics"]) : new StatisticsLicenseState();
            this.imageOptimization = _data["imageOptimization"] ? ImageOptimizationLicenseState.fromJS(_data["imageOptimization"]) : new ImageOptimizationLicenseState();
        }
    }

    static fromJS(data: any): LicenseInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["historicVersioningState"] = this.historicVersioningState;
        data["contentStatistics"] = this.contentStatistics ? this.contentStatistics.toJSON() : <any>undefined;
        data["imageOptimization"] = this.imageOptimization ? this.imageOptimization.toJSON() : <any>undefined;
        return data;
    }
}

/** Customer license information */
export interface ILicenseInfo {
    /** State of content historic versioning */
    historicVersioningState: HistoricVersioningState;
    /** State of statistics features for Content */
    contentStatistics: IStatisticsLicenseState;
    /** Licensing options for image optimization. */
    imageOptimization: IImageOptimizationLicenseState;
}

export enum HistoricVersioningState {
    Disabled = "Disabled",
    Suspended = "Suspended",
    Enabled = "Enabled",
}

export class StatisticsLicenseState implements IStatisticsLicenseState {
    /** Defines whether the respective statistics are gathered periodically */
    collection!: boolean;
    /** Allows or prevents access to read endpoints */
    read!: boolean;
    /** Allows or prevents access to write endpoints */
    write!: boolean;
    /** Allows or prevents export of the respective statistics */
    export!: boolean;

    constructor(data?: IStatisticsLicenseState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collection = _data["collection"];
            this.read = _data["read"];
            this.write = _data["write"];
            this.export = _data["export"];
        }
    }

    static fromJS(data: any): StatisticsLicenseState {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsLicenseState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collection"] = this.collection;
        data["read"] = this.read;
        data["write"] = this.write;
        data["export"] = this.export;
        return data;
    }
}

export interface IStatisticsLicenseState {
    /** Defines whether the respective statistics are gathered periodically */
    collection: boolean;
    /** Allows or prevents access to read endpoints */
    read: boolean;
    /** Allows or prevents access to write endpoints */
    write: boolean;
    /** Allows or prevents export of the respective statistics */
    export: boolean;
}

export class ImageOptimizationLicenseState implements IImageOptimizationLicenseState {
    /** Whether image optimization can be used when delivering embeds. */
    embedDelivery!: boolean;
    /** Whether edit output endpoint is available in API. */
    apiOutputEditing!: boolean;

    constructor(data?: IImageOptimizationLicenseState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.embedDelivery = _data["embedDelivery"];
            this.apiOutputEditing = _data["apiOutputEditing"];
        }
    }

    static fromJS(data: any): ImageOptimizationLicenseState {
        data = typeof data === 'object' ? data : {};
        let result = new ImageOptimizationLicenseState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["embedDelivery"] = this.embedDelivery;
        data["apiOutputEditing"] = this.apiOutputEditing;
        return data;
    }
}

export interface IImageOptimizationLicenseState {
    /** Whether image optimization can be used when delivering embeds. */
    embedDelivery: boolean;
    /** Whether edit output endpoint is available in API. */
    apiOutputEditing: boolean;
}

/** Customer settings within customer information */
export class CustomerInfoSettings implements ICustomerInfoSettings {
    /** Default expiration time span as number of milliseconds that will be applied as default by the UI when creating a new Share */
    uiDefaultShareExpirationTime?: number | undefined;
    /** Prefix to be used for the zip file created when downloading multiple contents */
    downloadPrefixName!: string;

    constructor(data?: ICustomerInfoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uiDefaultShareExpirationTime = _data["uiDefaultShareExpirationTime"];
            this.downloadPrefixName = _data["downloadPrefixName"];
        }
    }

    static fromJS(data: any): CustomerInfoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInfoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uiDefaultShareExpirationTime"] = this.uiDefaultShareExpirationTime;
        data["downloadPrefixName"] = this.downloadPrefixName;
        return data;
    }
}

/** Customer settings within customer information */
export interface ICustomerInfoSettings {
    /** Default expiration time span as number of milliseconds that will be applied as default by the UI when creating a new Share */
    uiDefaultShareExpirationTime?: number | undefined;
    /** Prefix to be used for the zip file created when downloading multiple contents */
    downloadPrefixName: string;
}

export class SystemStatus implements ISystemStatus {
    /** The status of the search indices. */
    searchIndicesStatus?: StatusOfSearchIndexState[] | undefined;
    /** The status of the display values. */
    displayValuesStatus?: StatusOfDisplayValuesState[] | undefined;
    /** The status of the contents and list items. */
    metadataStatus?: StatusOfMetadataState[] | undefined;

    constructor(data?: ISystemStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.searchIndicesStatus) {
                this.searchIndicesStatus = [];
                for (let i = 0; i < data.searchIndicesStatus.length; i++) {
                    let item = data.searchIndicesStatus[i];
                    this.searchIndicesStatus[i] = item && !(<any>item).toJSON ? new StatusOfSearchIndexState(item) : <StatusOfSearchIndexState>item;
                }
            }
            if (data.displayValuesStatus) {
                this.displayValuesStatus = [];
                for (let i = 0; i < data.displayValuesStatus.length; i++) {
                    let item = data.displayValuesStatus[i];
                    this.displayValuesStatus[i] = item && !(<any>item).toJSON ? new StatusOfDisplayValuesState(item) : <StatusOfDisplayValuesState>item;
                }
            }
            if (data.metadataStatus) {
                this.metadataStatus = [];
                for (let i = 0; i < data.metadataStatus.length; i++) {
                    let item = data.metadataStatus[i];
                    this.metadataStatus[i] = item && !(<any>item).toJSON ? new StatusOfMetadataState(item) : <StatusOfMetadataState>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["searchIndicesStatus"])) {
                this.searchIndicesStatus = [] as any;
                for (let item of _data["searchIndicesStatus"])
                    this.searchIndicesStatus!.push(StatusOfSearchIndexState.fromJS(item));
            }
            if (Array.isArray(_data["displayValuesStatus"])) {
                this.displayValuesStatus = [] as any;
                for (let item of _data["displayValuesStatus"])
                    this.displayValuesStatus!.push(StatusOfDisplayValuesState.fromJS(item));
            }
            if (Array.isArray(_data["metadataStatus"])) {
                this.metadataStatus = [] as any;
                for (let item of _data["metadataStatus"])
                    this.metadataStatus!.push(StatusOfMetadataState.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SystemStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.searchIndicesStatus)) {
            data["searchIndicesStatus"] = [];
            for (let item of this.searchIndicesStatus)
                data["searchIndicesStatus"].push(item.toJSON());
        }
        if (Array.isArray(this.displayValuesStatus)) {
            data["displayValuesStatus"] = [];
            for (let item of this.displayValuesStatus)
                data["displayValuesStatus"].push(item.toJSON());
        }
        if (Array.isArray(this.metadataStatus)) {
            data["metadataStatus"] = [];
            for (let item of this.metadataStatus)
                data["metadataStatus"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISystemStatus {
    /** The status of the search indices. */
    searchIndicesStatus?: IStatusOfSearchIndexState[] | undefined;
    /** The status of the display values. */
    displayValuesStatus?: IStatusOfDisplayValuesState[] | undefined;
    /** The status of the contents and list items. */
    metadataStatus?: IStatusOfMetadataState[] | undefined;
}

export class StatusOfSearchIndexState implements IStatusOfSearchIndexState {
    id?: string | undefined;
    state!: SearchIndexState;

    constructor(data?: IStatusOfSearchIndexState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): StatusOfSearchIndexState {
        data = typeof data === 'object' ? data : {};
        let result = new StatusOfSearchIndexState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        return data;
    }
}

export interface IStatusOfSearchIndexState {
    id?: string | undefined;
    state: SearchIndexState;
}

export enum SearchIndexState {
    Green = "Green",
    Yellow = "Yellow",
    Red = "Red",
}

export class StatusOfDisplayValuesState implements IStatusOfDisplayValuesState {
    id?: string | undefined;
    state!: DisplayValuesState;

    constructor(data?: IStatusOfDisplayValuesState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): StatusOfDisplayValuesState {
        data = typeof data === 'object' ? data : {};
        let result = new StatusOfDisplayValuesState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        return data;
    }
}

export interface IStatusOfDisplayValuesState {
    id?: string | undefined;
    state: DisplayValuesState;
}

export class StatusOfMetadataState implements IStatusOfMetadataState {
    id?: string | undefined;
    state!: MetadataState;

    constructor(data?: IStatusOfMetadataState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): StatusOfMetadataState {
        data = typeof data === 'object' ? data : {};
        let result = new StatusOfMetadataState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        return data;
    }
}

export interface IStatusOfMetadataState {
    id?: string | undefined;
    state: MetadataState;
}

/** The state of the contents and list items */
export enum MetadataState {
    UpToDate = "UpToDate",
    Outdated = "Outdated",
    UpdateInProgress = "UpdateInProgress",
}

/** List item detail */
export class ListItemDetail implements IListItemDetail {
    /** The list item ID. */
    id!: string;
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId!: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content?: any | undefined;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: DisplayValueDictionary | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** Activity information: dynamically mapped from configured metadata fields or from audit information if no mapping is configured. */
    activity?: Activity | undefined;

    constructor(data?: IListItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues;
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
            this.activity = data.activity && !(<any>data.activity).toJSON ? new Activity(data.activity) : <Activity>this.activity;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contentSchemaId = _data["contentSchemaId"];
            this.content = _data["content"];
            this.displayValues = _data["displayValues"] ? DisplayValueDictionary.fromJS(_data["displayValues"]) : <any>undefined;
            if (Array.isArray(_data["brokenReferenceIds"])) {
                this.brokenReferenceIds = [] as any;
                for (let item of _data["brokenReferenceIds"])
                    this.brokenReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenRelationTargetIds"])) {
                this.brokenRelationTargetIds = [] as any;
                for (let item of _data["brokenRelationTargetIds"])
                    this.brokenRelationTargetIds!.push(item);
            }
            if (Array.isArray(_data["brokenIndirectReferenceIds"])) {
                this.brokenIndirectReferenceIds = [] as any;
                for (let item of _data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds!.push(item);
            }
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentSchemaId"] = this.contentSchemaId;
        data["content"] = this.content;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        if (Array.isArray(this.brokenReferenceIds)) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenRelationTargetIds)) {
            data["brokenRelationTargetIds"] = [];
            for (let item of this.brokenRelationTargetIds)
                data["brokenRelationTargetIds"].push(item);
        }
        if (Array.isArray(this.brokenIndirectReferenceIds)) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

/** List item detail */
export interface IListItemDetail {
    /** The list item ID. */
    id: string;
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content?: any | undefined;
    /** Contains language specific display values. They are calculated values based on the template stored in the Content schema DisplayPatterns property. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** All the IDs of the referenced list items (tagboxes) that do not exist in the system. */
    brokenReferenceIds?: string[] | undefined;
    /** All the IDs of the contents or list items target of a relation that do not exist in the system. */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the IDs of the indirectly referenced list items (tagboxes) that do not exist in the system.
They are referenced list items that reference at least a list item that do not exist in the system. */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
    /** Activity information: dynamically mapped from configured metadata fields or from audit information if no mapping is configured. */
    activity?: IActivity | undefined;
}

/** Request to update an existing list item */
export class ListItemUpdateRequest implements IListItemUpdateRequest {
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema of the list item. */
    content?: any | undefined;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace any existing content.
Defaults to Merge. */
    contentFieldsUpdateOptions!: UpdateOption;

    constructor(data?: IListItemUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.contentFieldsUpdateOptions = _data["contentFieldsUpdateOptions"];
        }
    }

    static fromJS(data: any): ListItemUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["contentFieldsUpdateOptions"] = this.contentFieldsUpdateOptions;
        return data;
    }
}

/** Request to update an existing list item */
export interface IListItemUpdateRequest {
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema of the list item. */
    content?: any | undefined;
    /** Options to modify the behavior for updating the content.
Merge: the values specified in the Content object are merged to the existing content.
Replace: the values specified in the Content object entirely replace any existing content.
Defaults to Merge. */
    contentFieldsUpdateOptions: UpdateOption;
}

/** Result from getting references to list items. */
export class ListItemReferencesResult implements IListItemReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: MetadataReferenceResult | undefined;

    constructor(data?: IListItemReferencesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.metadataReferences = data.metadataReferences && !(<any>data.metadataReferences).toJSON ? new MetadataReferenceResult(data.metadataReferences) : <MetadataReferenceResult>this.metadataReferences;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metadataReferences = _data["metadataReferences"] ? MetadataReferenceResult.fromJS(_data["metadataReferences"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListItemReferencesResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemReferencesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metadataReferences"] = this.metadataReferences ? this.metadataReferences.toJSON() : <any>undefined;
        return data;
    }
}

/** Result from getting references to list items. */
export interface IListItemReferencesResult {
    /** List of references. Only available when requested in the request. */
    metadataReferences?: IMetadataReferenceResult | undefined;
}

/** Request to get the references to a list item */
export class ListItemReferencesRequest implements IListItemReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;

    constructor(data?: IListItemReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.references = data.references && !(<any>data.references).toJSON ? new MetadataReferencesPagingRequest(data.references) : <MetadataReferencesPagingRequest>this.references;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.references = _data["references"] ? MetadataReferencesPagingRequest.fromJS(_data["references"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListItemReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["references"] = this.references ? this.references.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to get the references to a list item */
export interface IListItemReferencesRequest {
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
}

/** Request to create a list item */
export class ListItemCreateRequest implements IListItemCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId!: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema. */
    content?: any | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IListItemCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentSchemaId = _data["contentSchemaId"];
            this.content = _data["content"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): ListItemCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        data["content"] = this.content;
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Request to create a list item */
export interface IListItemCreateRequest {
    /** The ID of the content schema. The SchemaType of the specified schema must be List. */
    contentSchemaId: string;
    /** The content data of the list item. It's an object of dynamic metadata whose structure is defined in the Content schema. */
    content?: any | undefined;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to create multiple list items */
export class ListItemCreateManyRequest implements IListItemCreateManyRequest {
    /** Allows creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Items to be created. */
    items!: ListItemCreateRequest[];

    constructor(data?: IListItemCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ListItemCreateRequest(item) : <ListItemCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListItemCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to create multiple list items */
export interface IListItemCreateManyRequest {
    /** Allows creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be created. */
    items: IListItemCreateRequest[];
}

/** Request to update multiple list items */
export class ListItemUpdateManyRequest implements IListItemUpdateManyRequest {
    /** Allows updating list items with references to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Items to be updated. */
    items!: ListItemUpdateItem[];

    constructor(data?: IListItemUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListItemUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple list items */
export interface IListItemUpdateManyRequest {
    /** Allows updating list items with references to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Items to be updated. */
    items: ListItemUpdateItem[];
}

export class ListItemUpdateItem extends ListItemUpdateRequest implements IListItemUpdateItem {
    /** The list item id. */
    id!: string;

    constructor(data?: IListItemUpdateItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): ListItemUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemUpdateItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IListItemUpdateItem extends IListItemUpdateRequest {
    /** The list item id. */
    id: string;
}

/** Request to delete multiple list items */
export class ListItemDeleteManyRequest implements IListItemDeleteManyRequest {
    /** IDs of the list items to delete. */
    listItemIds!: string[];
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IListItemDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
            this.forceReferenceRemoval = _data["forceReferenceRemoval"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to delete multiple list items */
export interface IListItemDeleteManyRequest {
    /** IDs of the list items to delete. */
    listItemIds: string[];
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to delete multiple list items based on a provided filter */
export class ListItemDeleteManyFilterRequest implements IListItemDeleteManyFilterRequest {
    /** Filters the list items that need to be deleted. */
    filterRequest!: ListItemFilterRequest;
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress!: boolean;

    constructor(data?: IListItemDeleteManyFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.filterRequest = data.filterRequest && !(<any>data.filterRequest).toJSON ? new ListItemFilterRequest(data.filterRequest) : <ListItemFilterRequest>this.filterRequest;
        }
        if (!data) {
            this.filterRequest = new ListItemFilterRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterRequest = _data["filterRequest"] ? ListItemFilterRequest.fromJS(_data["filterRequest"]) : new ListItemFilterRequest();
            this.forceReferenceRemoval = _data["forceReferenceRemoval"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemDeleteManyFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemDeleteManyFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        data["forceReferenceRemoval"] = this.forceReferenceRemoval;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to delete multiple list items based on a provided filter */
export interface IListItemDeleteManyFilterRequest {
    /** Filters the list items that need to be deleted. */
    filterRequest: IListItemFilterRequest;
    /** A value indicating whether references to the list item should be removed. */
    forceReferenceRemoval: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the delete request. */
    notifyProgress: boolean;
}

/** Request to filter list items */
export class ListItemFilterRequest implements IListItemFilterRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren!: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;

    constructor(data?: IListItemFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.includeAllSchemaChildren = _data["includeAllSchemaChildren"];
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            this.brokenDependenciesFilter = _data["brokenDependenciesFilter"];
        }
    }

    static fromJS(data: any): ListItemFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        return data;
    }
}

/** Request to filter list items */
export interface IListItemFilterRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the search to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
}

/** Request to restore multiple deleted list items */
export class ListItemRestoreManyRequest implements IListItemRestoreManyRequest {
    /** The IDs of the list items to restore. */
    listItemIds!: string[];
    /** Allows restoring list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;

    constructor(data?: IListItemRestoreManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
            this.allowMissingDependencies = _data["allowMissingDependencies"];
        }
    }

    static fromJS(data: any): ListItemRestoreManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemRestoreManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        return data;
    }
}

/** Request to restore multiple deleted list items */
export interface IListItemRestoreManyRequest {
    /** The IDs of the list items to restore. */
    listItemIds: string[];
    /** Allows restoring list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
}

/** Request to get the references to multiple list items */
export class ListItemManyReferencesRequest implements IListItemManyReferencesRequest {
    /** The IDs of the list items whose references need to be retrieved. */
    listItemIds!: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: MetadataReferencesPagingRequest | undefined;

    constructor(data?: IListItemManyReferencesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.references = data.references && !(<any>data.references).toJSON ? new MetadataReferencesPagingRequest(data.references) : <MetadataReferencesPagingRequest>this.references;
        }
        if (!data) {
            this.listItemIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
            this.references = _data["references"] ? MetadataReferencesPagingRequest.fromJS(_data["references"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListItemManyReferencesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemManyReferencesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        data["references"] = this.references ? this.references.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to get the references to multiple list items */
export interface IListItemManyReferencesRequest {
    /** The IDs of the list items whose references need to be retrieved. */
    listItemIds: string[];
    /** Limits the number of the returned metadata references by setting paging information. */
    references?: IMetadataReferencesPagingRequest | undefined;
}

/** Request to batch update list items' fields based on list item IDs */
export class ListItemFieldsBatchUpdateRequest implements IListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated. */
    listItemIds!: string[];
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allows updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    constructor(data?: IListItemFieldsBatchUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.listItemIds = [];
            this.changeCommands = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listItemIds"])) {
                this.listItemIds = [] as any;
                for (let item of _data["listItemIds"])
                    this.listItemIds!.push(item);
            }
            if (Array.isArray(_data["changeCommands"])) {
                this.changeCommands = [] as any;
                for (let item of _data["changeCommands"])
                    this.changeCommands!.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemFieldsBatchUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listItemIds)) {
            data["listItemIds"] = [];
            for (let item of this.listItemIds)
                data["listItemIds"].push(item);
        }
        if (Array.isArray(this.changeCommands)) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to batch update list items' fields based on list item IDs */
export interface IListItemFieldsBatchUpdateRequest {
    /** The ids of the list items whose fields need to be updated. */
    listItemIds: string[];
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allows updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Request to batch update list items' fields based on a filter */
export class ListItemFieldsBatchUpdateFilterRequest implements IListItemFieldsBatchUpdateFilterRequest {
    /** Filters the list items on which the change commands must be applied. */
    filterRequest!: ListItemFilterRequest;
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands!: MetadataValuesChangeCommandBase[];
    /** Allow updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies!: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress!: boolean;

    constructor(data?: IListItemFieldsBatchUpdateFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.filterRequest = data.filterRequest && !(<any>data.filterRequest).toJSON ? new ListItemFilterRequest(data.filterRequest) : <ListItemFilterRequest>this.filterRequest;
        }
        if (!data) {
            this.filterRequest = new ListItemFilterRequest();
            this.changeCommands = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterRequest = _data["filterRequest"] ? ListItemFilterRequest.fromJS(_data["filterRequest"]) : new ListItemFilterRequest();
            if (Array.isArray(_data["changeCommands"])) {
                this.changeCommands = [] as any;
                for (let item of _data["changeCommands"])
                    this.changeCommands!.push(MetadataValuesChangeCommandBase.fromJS(item));
            }
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ListItemFieldsBatchUpdateFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemFieldsBatchUpdateFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterRequest"] = this.filterRequest ? this.filterRequest.toJSON() : <any>undefined;
        if (Array.isArray(this.changeCommands)) {
            data["changeCommands"] = [];
            for (let item of this.changeCommands)
                data["changeCommands"].push(item.toJSON());
        }
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

/** Request to batch update list items' fields based on a filter */
export interface IListItemFieldsBatchUpdateFilterRequest {
    /** Filters the list items on which the change commands must be applied. */
    filterRequest: IListItemFilterRequest;
    /** Changes that need to be applied to the existing list items. The same set of changes is applied to all list items. */
    changeCommands: MetadataValuesChangeCommandBase[];
    /** Allow updating list items with references to list items or contents that do not exist in the system. */
    allowMissingDependencies: boolean;
    /** Create a progress notification and notify on progress. Notifications are shown in the UI only to the same use who triggered the batch update. */
    notifyProgress: boolean;
}

/** Base class for search results */
export class BaseResultOfListItem implements IBaseResultOfListItem {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: ListItem[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ListItem(item) : <ListItem>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ListItem.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfListItem {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfListItem {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IListItem[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfListItem extends BaseResultOfListItem implements ISearchBehaviorBaseResultOfListItem {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfListItem) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfListItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfListItem extends IBaseResultOfListItem {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfListItem extends SearchBehaviorBaseResultOfListItem implements ISearchBehaviorWithAggregationBaseResultOfListItem {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfListItem) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfListItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfListItem extends ISearchBehaviorBaseResultOfListItem {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Result for list item search operation */
export class ListItemSearchResult extends SearchBehaviorWithAggregationBaseResultOfListItem implements IListItemSearchResult {

    constructor(data?: IListItemSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ListItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result for list item search operation */
export interface IListItemSearchResult extends ISearchBehaviorWithAggregationBaseResultOfListItem {
}

export class ListItem implements IListItem {
    /** Audit information. */
    audit?: UserAudit | undefined;
    /** The list item id. */
    id!: string;
    /** The id of the schema with schema type list. */
    contentSchemaId!: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: DisplayValueDictionary | undefined;
    /** The content data of the list item. */
    content?: any | undefined;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** LifeCycle of list item */
    lifeCycle!: LifeCycle;

    constructor(data?: IListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
            this.id = _data["id"];
            this.contentSchemaId = _data["contentSchemaId"];
            this.displayValues = _data["displayValues"] ? DisplayValueDictionary.fromJS(_data["displayValues"]) : <any>undefined;
            this.content = _data["content"];
            if (Array.isArray(_data["brokenReferenceIds"])) {
                this.brokenReferenceIds = [] as any;
                for (let item of _data["brokenReferenceIds"])
                    this.brokenReferenceIds!.push(item);
            }
            if (Array.isArray(_data["brokenRelationTargetIds"])) {
                this.brokenRelationTargetIds = [] as any;
                for (let item of _data["brokenRelationTargetIds"])
                    this.brokenRelationTargetIds!.push(item);
            }
            if (Array.isArray(_data["brokenIndirectReferenceIds"])) {
                this.brokenIndirectReferenceIds = [] as any;
                for (let item of _data["brokenIndirectReferenceIds"])
                    this.brokenIndirectReferenceIds!.push(item);
            }
            this.lifeCycle = _data["lifeCycle"];
        }
    }

    static fromJS(data: any): ListItem {
        data = typeof data === 'object' ? data : {};
        let result = new ListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["contentSchemaId"] = this.contentSchemaId;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["content"] = this.content;
        if (Array.isArray(this.brokenReferenceIds)) {
            data["brokenReferenceIds"] = [];
            for (let item of this.brokenReferenceIds)
                data["brokenReferenceIds"].push(item);
        }
        if (Array.isArray(this.brokenRelationTargetIds)) {
            data["brokenRelationTargetIds"] = [];
            for (let item of this.brokenRelationTargetIds)
                data["brokenRelationTargetIds"].push(item);
        }
        if (Array.isArray(this.brokenIndirectReferenceIds)) {
            data["brokenIndirectReferenceIds"] = [];
            for (let item of this.brokenIndirectReferenceIds)
                data["brokenIndirectReferenceIds"].push(item);
        }
        data["lifeCycle"] = this.lifeCycle;
        return data;
    }
}

export interface IListItem {
    /** Audit information. */
    audit?: IUserAudit | undefined;
    /** The list item id. */
    id: string;
    /** The id of the schema with schema type list. */
    contentSchemaId: string;
    /** Contains language specific display values, rendered according to the list schema's display pattern configuration. */
    displayValues?: IDisplayValueDictionary | undefined;
    /** The content data of the list item. */
    content?: any | undefined;
    /** All the ids of the broken references (tagboxes) */
    brokenReferenceIds?: string[] | undefined;
    /** All the target ids of the broken relations */
    brokenRelationTargetIds?: string[] | undefined;
    /** All the ids of the broken indirect references (tagbox that has a property that reference a broken tagbox) */
    brokenIndirectReferenceIds?: string[] | undefined;
    /** LifeCycle of list item */
    lifeCycle: LifeCycle;
}

/** Request to aggregate list items */
export abstract class ListItemSearchAndAggregationBaseRequest implements IListItemSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren!: boolean;
    /** Limits the aggregation to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter!: BrokenDependenciesFilter;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the aggregation to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter!: LifeCycleFilter;

    constructor(data?: IListItemSearchAndAggregationBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
            this.includeAllSchemaChildren = _data["includeAllSchemaChildren"];
            this.brokenDependenciesFilter = _data["brokenDependenciesFilter"];
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            this.lifeCycleFilter = _data["lifeCycleFilter"];
        }
    }

    static fromJS(data: any): ListItemSearchAndAggregationBaseRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ListItemSearchAndAggregationBaseRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        data["brokenDependenciesFilter"] = this.brokenDependenciesFilter;
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        return data;
    }
}

/** Request to aggregate list items */
export interface IListItemSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** Broadens the search to include all schema descendant list items. */
    includeAllSchemaChildren: boolean;
    /** Limits the aggregation to the list items that have or not have broken references. By default it includes both. */
    brokenDependenciesFilter: BrokenDependenciesFilter;
    /** Limits the search among the list items of the provided schemas. */
    schemaIds?: string[] | undefined;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages defined in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the aggregation to the list items that have the specified life cycle state. Defaults to ActiveOnly. */
    lifeCycleFilter: LifeCycleFilter;
}

/** Request to search list items */
export class ListItemSearchRequest extends ListItemSearchAndAggregationBaseRequest implements IListItemSearchRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ListItemSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of enums that control which parts of the list item are resolved and returned. */
    resolveBehaviors?: ListItemResolveBehavior[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: IListItemSearchRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["resolveBehaviors"])) {
                this.resolveBehaviors = [] as any;
                for (let item of _data["resolveBehaviors"])
                    this.resolveBehaviors!.push(item);
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ListItemSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemSearchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.resolveBehaviors)) {
            data["resolveBehaviors"] = [];
            for (let item of this.resolveBehaviors)
                data["resolveBehaviors"].push(item);
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to search list items */
export interface IListItemSearchRequest extends IListItemSearchAndAggregationBaseRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the ListItemSearchResult.
Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of enums that control which parts of the list item are resolved and returned. */
    resolveBehaviors?: ListItemResolveBehavior[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Request to aggregate list items */
export class ListItemAggregationRequest extends ListItemSearchAndAggregationBaseRequest implements IListItemAggregationRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: IListItemAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ListItemAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemAggregationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to aggregate list items */
export interface IListItemAggregationRequest extends IListItemSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Base class for search results */
export class BaseResultOfLiveStream implements IBaseResultOfLiveStream {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: LiveStream[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfLiveStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new LiveStream(item) : <LiveStream>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LiveStream.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfLiveStream {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfLiveStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfLiveStream {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ILiveStream[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Results of live stream search. */
export class LiveStreamSearchResult extends BaseResultOfLiveStream implements ILiveStreamSearchResult {

    constructor(data?: ILiveStreamSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): LiveStreamSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Results of live stream search. */
export interface ILiveStreamSearchResult extends IBaseResultOfLiveStream {
}

export class LiveStream implements ILiveStream {
    id!: string;
    document?: string | undefined;
    scopeType?: string | undefined;
    timestamp!: Date;
    traceJob?: LiveStreamTraceJob | undefined;
    audit?: UserAudit | undefined;

    constructor(data?: ILiveStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.traceJob = data.traceJob && !(<any>data.traceJob).toJSON ? new LiveStreamTraceJob(data.traceJob) : <LiveStreamTraceJob>this.traceJob;
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.document = _data["document"];
            this.scopeType = _data["scopeType"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.traceJob = _data["traceJob"] ? LiveStreamTraceJob.fromJS(_data["traceJob"]) : <any>undefined;
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LiveStream {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["document"] = this.document;
        data["scopeType"] = this.scopeType;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["traceJob"] = this.traceJob ? this.traceJob.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILiveStream {
    id: string;
    document?: string | undefined;
    scopeType?: string | undefined;
    timestamp: Date;
    traceJob?: ILiveStreamTraceJob | undefined;
    audit?: IUserAudit | undefined;
}

export class LiveStreamTraceJob implements ILiveStreamTraceJob {
    traceJobId?: string | undefined;
    ipAddress?: string | undefined;
    userId?: string | undefined;
    apiClientId?: string | undefined;

    constructor(data?: ILiveStreamTraceJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.traceJobId = _data["traceJobId"];
            this.ipAddress = _data["ipAddress"];
            this.userId = _data["userId"];
            this.apiClientId = _data["apiClientId"];
        }
    }

    static fromJS(data: any): LiveStreamTraceJob {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamTraceJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceJobId"] = this.traceJobId;
        data["ipAddress"] = this.ipAddress;
        data["userId"] = this.userId;
        data["apiClientId"] = this.apiClientId;
        return data;
    }
}

export interface ILiveStreamTraceJob {
    traceJobId?: string | undefined;
    ipAddress?: string | undefined;
    userId?: string | undefined;
    apiClientId?: string | undefined;
}

export class LiveStreamSearchRequest implements ILiveStreamSearchRequest {
    /** Sets the start date and time for results based on Timestamp attribute. */
    from!: Date;
    /** Sets the end date and time for results based on Timestamp attribute. */
    to!: Date;
    /** Optionally limits the result to only the specified scope type. */
    scopeType?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;

    constructor(data?: ILiveStreamSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.scopeType = _data["scopeType"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): LiveStreamSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["scopeType"] = this.scopeType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

export interface ILiveStreamSearchRequest {
    /** Sets the start date and time for results based on Timestamp attribute. */
    from: Date;
    /** Sets the end date and time for results based on Timestamp attribute. */
    to: Date;
    /** Optionally limits the result to only the specified scope type. */
    scopeType?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** To get a large amount of data, page token returned from the response can be used to get all data. */
    pageToken?: string | undefined;
}

/** The overall status of the contents and list items in comparison to the actual schemas' structure */
export class MetadataStatus implements IMetadataStatus {
    /** The schema ids (of type Content or Layer) for which the contents are outdated and need to be updated. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the the list items are outdated and need to be updated. */
    listSchemaIds?: string[] | undefined;
    /** The global state of the Contents and ListItems compared to the schema structure (Green = ok, Red = update needed). */
    state!: MetadataState;
    /** The field ids that that cannot be used and needs to be cleaned up after updating the outdated contents and list items. */
    fieldIdsToCleanup?: { [key: string]: string[]; } | undefined;

    constructor(data?: IMetadataStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contentOrLayerSchemaIds"])) {
                this.contentOrLayerSchemaIds = [] as any;
                for (let item of _data["contentOrLayerSchemaIds"])
                    this.contentOrLayerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["listSchemaIds"])) {
                this.listSchemaIds = [] as any;
                for (let item of _data["listSchemaIds"])
                    this.listSchemaIds!.push(item);
            }
            this.state = _data["state"];
            if (_data["fieldIdsToCleanup"]) {
                this.fieldIdsToCleanup = {} as any;
                for (let key in _data["fieldIdsToCleanup"]) {
                    if (_data["fieldIdsToCleanup"].hasOwnProperty(key))
                        (<any>this.fieldIdsToCleanup)![key] = _data["fieldIdsToCleanup"][key] !== undefined ? _data["fieldIdsToCleanup"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): MetadataStatus {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentOrLayerSchemaIds)) {
            data["contentOrLayerSchemaIds"] = [];
            for (let item of this.contentOrLayerSchemaIds)
                data["contentOrLayerSchemaIds"].push(item);
        }
        if (Array.isArray(this.listSchemaIds)) {
            data["listSchemaIds"] = [];
            for (let item of this.listSchemaIds)
                data["listSchemaIds"].push(item);
        }
        data["state"] = this.state;
        if (this.fieldIdsToCleanup) {
            data["fieldIdsToCleanup"] = {};
            for (let key in this.fieldIdsToCleanup) {
                if (this.fieldIdsToCleanup.hasOwnProperty(key))
                    (<any>data["fieldIdsToCleanup"])[key] = (<any>this.fieldIdsToCleanup)[key];
            }
        }
        return data;
    }
}

/** The overall status of the contents and list items in comparison to the actual schemas' structure */
export interface IMetadataStatus {
    /** The schema ids (of type Content or Layer) for which the contents are outdated and need to be updated. */
    contentOrLayerSchemaIds?: string[] | undefined;
    /** The schema ids (of type List) for which the the list items are outdated and need to be updated. */
    listSchemaIds?: string[] | undefined;
    /** The global state of the Contents and ListItems compared to the schema structure (Green = ok, Red = update needed). */
    state: MetadataState;
    /** The field ids that that cannot be used and needs to be cleaned up after updating the outdated contents and list items. */
    fieldIdsToCleanup?: { [key: string]: string[]; } | undefined;
}

export class Notification implements INotification {
    id!: string;
    recipientUserId?: string | undefined;
    referenceDocType?: string | undefined;
    referenceId?: string | undefined;
    audit?: UserAudit | undefined;
    titleCode!: TitleCode;
    messageCode!: MessageCode;
    detail?: NotificationDetailBase | undefined;
    state!: NotificationState;
    eventType!: NotificationEventType;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recipientUserId = _data["recipientUserId"];
            this.referenceDocType = _data["referenceDocType"];
            this.referenceId = _data["referenceId"];
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : <any>undefined;
            this.titleCode = _data["titleCode"];
            this.messageCode = _data["messageCode"];
            this.detail = _data["detail"] ? NotificationDetailBase.fromJS(_data["detail"]) : <any>undefined;
            this.state = _data["state"];
            this.eventType = _data["eventType"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recipientUserId"] = this.recipientUserId;
        data["referenceDocType"] = this.referenceDocType;
        data["referenceId"] = this.referenceId;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["titleCode"] = this.titleCode;
        data["messageCode"] = this.messageCode;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["eventType"] = this.eventType;
        return data;
    }
}

export interface INotification {
    id: string;
    recipientUserId?: string | undefined;
    referenceDocType?: string | undefined;
    referenceId?: string | undefined;
    audit?: IUserAudit | undefined;
    titleCode: TitleCode;
    messageCode: MessageCode;
    detail?: NotificationDetailBase | undefined;
    state: NotificationState;
    eventType: NotificationEventType;
}

export enum TitleCode {
    TransferInProgressTitle = "TransferInProgressTitle",
    TransferCompletedTitle = "TransferCompletedTitle",
    ImportInProgressTitle = "ImportInProgressTitle",
    ImportCompletedTitle = "ImportCompletedTitle",
    ShareNewShareTitle = "ShareNewShareTitle",
    TransferCancelledTitle = "TransferCancelledTitle",
    ImportCancelledTitle = "ImportCancelledTitle",
    ImportCompletedWithErrors = "ImportCompletedWithErrors",
    SchemaImportInProgressTitle = "SchemaImportInProgressTitle",
    SchemaImportCompletedTitle = "SchemaImportCompletedTitle",
    SchemaImportFailedTitle = "SchemaImportFailedTitle",
    UserRegisteredTitle = "UserRegisteredTitle",
    NewUserRegisteredEmailSubject = "NewUserRegisteredEmailSubject",
    UserLockedEmailSubject = "UserLockedEmailSubject",
    UserUnlockedEmailSubject = "UserUnlockedEmailSubject",
    UserReviewedEmailSubject = "UserReviewedEmailSubject",
    UserInvitationEmailSubject = "UserInvitationEmailSubject",
    UserTriggeredDeactivationRequest = "UserTriggeredDeactivationRequest",
    UserTriggeredDeactivationRequestMailSubject = "UserTriggeredDeactivationRequestMailSubject",
    IndexDraft = "IndexDraft",
    IndexCreate = "IndexCreate",
    IndexInactive = "IndexInactive",
    IndexActive = "IndexActive",
    IndexClosed = "IndexClosed",
    IndexReindexInProgress = "IndexReindexInProgress",
    IndexCancelled = "IndexCancelled",
    ReindexProgressDraft = "ReindexProgressDraft",
    ReindexProgressInProgress = "ReindexProgressInProgress",
    ReindexProgressCompleted = "ReindexProgressCompleted",
    ReindexProgressCancelled = "ReindexProgressCancelled",
    ReindexProgressFailed = "ReindexProgressFailed",
    ReindexProgressCompletedWithErrors = "ReindexProgressCompletedWithErrors",
    ContentBatchEditInProgress = "ContentBatchEditInProgress",
    ContentBatchEditCompleted = "ContentBatchEditCompleted",
    ContentBatchEditProgressFailed = "ContentBatchEditProgressFailed",
    ContentBatchEditProgressCompletedWithErrors = "ContentBatchEditProgressCompletedWithErrors",
    ListItemBatchEditInProgress = "ListItemBatchEditInProgress",
    ListItemBatchEditCompleted = "ListItemBatchEditCompleted",
    ListItemBatchEditProgressFailed = "ListItemBatchEditProgressFailed",
    ListItemBatchEditProgressCompletedWithErrors = "ListItemBatchEditProgressCompletedWithErrors",
    ContentBackupRecoveryDraft = "ContentBackupRecoveryDraft",
    ContentBackupRecoveryInProgress = "ContentBackupRecoveryInProgress",
    ContentBackupRecoveryCompleted = "ContentBackupRecoveryCompleted",
    ContentBackupRecoveryForcefullyCompleted = "ContentBackupRecoveryForcefullyCompleted",
    ContentBackupRecoveryCancelled = "ContentBackupRecoveryCancelled",
    ContentBackupRecoveryFailed = "ContentBackupRecoveryFailed",
    ContentOwnershipBatchEditInProgress = "ContentOwnershipBatchEditInProgress",
    ContentOwnershipBatchEditCompleted = "ContentOwnershipBatchEditCompleted",
    ContentOwnershipBatchEditProgressFailed = "ContentOwnershipBatchEditProgressFailed",
    ContentOwnershipBatchEditProgressCompletedWithErrors = "ContentOwnershipBatchEditProgressCompletedWithErrors",
    ContentPermissionsBatchEditInProgress = "ContentPermissionsBatchEditInProgress",
    ContentPermissionsBatchEditCompleted = "ContentPermissionsBatchEditCompleted",
    ContentPermissionsBatchEditProgressFailed = "ContentPermissionsBatchEditProgressFailed",
    ContentPermissionsBatchEditProgressCompletedWithErrors = "ContentPermissionsBatchEditProgressCompletedWithErrors",
    ListItemDeactivateManyInProgress = "ListItemDeactivateManyInProgress",
    ListItemDeactivateManyCompleted = "ListItemDeactivateManyCompleted",
    ListItemDeactivateManyProgressFailed = "ListItemDeactivateManyProgressFailed",
    ListItemDeactivateManyProgressCompletedWithErrors = "ListItemDeactivateManyProgressCompletedWithErrors",
    ContentDeactivateManyInProgress = "ContentDeactivateManyInProgress",
    ContentDeactivateManyCompleted = "ContentDeactivateManyCompleted",
    ContentDeactivateManyProgressFailed = "ContentDeactivateManyProgressFailed",
    ContentDeactivateManyProgressCompletedWithErrors = "ContentDeactivateManyProgressCompletedWithErrors",
    ExternalBusinessProcessTitle = "ExternalBusinessProcessTitle",
    MetadataRelatedItemsInProgress = "MetadataRelatedItemsInProgress",
    MetadataRelatedItemsProgressFailed = "MetadataRelatedItemsProgressFailed",
    MetadataRelatedItemsProgressCompletedWithErrors = "MetadataRelatedItemsProgressCompletedWithErrors",
    MetadataRelatedItemsCompleted = "MetadataRelatedItemsCompleted",
    AutoTaggingInProgress = "AutoTaggingInProgress",
    AutoTaggingSucceeded = "AutoTaggingSucceeded",
    AutoTaggingSucceededWithErrors = "AutoTaggingSucceededWithErrors",
    AutoTaggingFailed = "AutoTaggingFailed",
    AutoTaggingCancelled = "AutoTaggingCancelled",
    ContentUpdateManyInProgress = "ContentUpdateManyInProgress",
    ContentUpdateManyCompleted = "ContentUpdateManyCompleted",
    ContentUpdateManyCompletedWithErrors = "ContentUpdateManyCompletedWithErrors",
    ContentUpdateManyFailed = "ContentUpdateManyFailed",
    MetadataRelatedItemsBySchemaInProgress = "MetadataRelatedItemsBySchemaInProgress",
    MetadataRelatedItemsBySchemaFailed = "MetadataRelatedItemsBySchemaFailed",
    MetadataRelatedItemsBySchemaCompletedWithErrors = "MetadataRelatedItemsBySchemaCompletedWithErrors",
    MetadataRelatedItemsBySchemaCompleted = "MetadataRelatedItemsBySchemaCompleted",
    MetadataOutdatedItemsUpdateInProgress = "MetadataOutdatedItemsUpdateInProgress",
    MetadataOutdatedItemsUpdateCompleted = "MetadataOutdatedItemsUpdateCompleted",
    MetadataOutdatedItemsUpdateCompletedWithErrors = "MetadataOutdatedItemsUpdateCompletedWithErrors",
    MetadataOutdatedItemsUpdateFailed = "MetadataOutdatedItemsUpdateFailed",
    BatchRenderingInProgress = "BatchRenderingInProgress",
    BatchRenderingCompleted = "BatchRenderingCompleted",
    BatchRenderingCompletedWithErrors = "BatchRenderingCompletedWithErrors",
    BatchRenderingFailed = "BatchRenderingFailed",
    BusinessRuleTitle = "BusinessRuleTitle",
    StatisticsExportDraft = "StatisticsExportDraft",
    StatisticsExportInProgress = "StatisticsExportInProgress",
    StatisticsExportCompleted = "StatisticsExportCompleted",
    StatisticsExportFailed = "StatisticsExportFailed",
    StatisticsExportCancelled = "StatisticsExportCancelled",
    NewComment = "NewComment",
    UserEmailConflictSolved = "UserEmailConflictSolved",
    UserEmailConflictSolvedSubject = "UserEmailConflictSolvedSubject",
    SupportUserDeactivation = "SupportUserDeactivation",
    ImportFailedTitle = "ImportFailedTitle",
}

export enum MessageCode {
    TransferInProgressMessage = "TransferInProgressMessage",
    TransferCompletedMessage = "TransferCompletedMessage",
    ImportInProgressMessage = "ImportInProgressMessage",
    ImportCompletedMessage = "ImportCompletedMessage",
    ShareNewShareMessage = "ShareNewShareMessage",
    TransferCancelledMessage = "TransferCancelledMessage",
    ImportCancelledMessage = "ImportCancelledMessage",
    ImportFailedMessage = "ImportFailedMessage",
    TransferInProgressWithFailedMessage = "TransferInProgressWithFailedMessage",
    TransferCompletedWithFailedMessage = "TransferCompletedWithFailedMessage",
    TransferCancelledWithFailedMessage = "TransferCancelledWithFailedMessage",
    ImportInProgressWithFailedMessage = "ImportInProgressWithFailedMessage",
    ImportCompletedWithFailedMessage = "ImportCompletedWithFailedMessage",
    ImportCancelledWithFailedMessage = "ImportCancelledWithFailedMessage",
    SchemaImportInProgressMessage = "SchemaImportInProgressMessage",
    SchemaImportCompletedMessage = "SchemaImportCompletedMessage",
    SchemaImportFailedMessage = "SchemaImportFailedMessage",
    UserRegisteredMessage = "UserRegisteredMessage",
    UserLockedMessage = "UserLockedMessage",
    UserReviewedMessage = "UserReviewedMessage",
    IndexDraft = "IndexDraft",
    IndexCreate = "IndexCreate",
    IndexInactive = "IndexInactive",
    IndexActive = "IndexActive",
    IndexClosed = "IndexClosed",
    IndexReindexInProgress = "IndexReindexInProgress",
    IndexCancelled = "IndexCancelled",
    ReindexProgressDraft = "ReindexProgressDraft",
    ReindexProgressInProgress = "ReindexProgressInProgress",
    ReindexProgressCompleted = "ReindexProgressCompleted",
    ReindexProgressCancelled = "ReindexProgressCancelled",
    ReindexProgressFailed = "ReindexProgressFailed",
    ReindexProgressCompletedWithErrors = "ReindexProgressCompletedWithErrors",
    ContentBatchEditInProgress = "ContentBatchEditInProgress",
    ContentBatchEditCompleted = "ContentBatchEditCompleted",
    ContentBatchEditProgressFailed = "ContentBatchEditProgressFailed",
    ContentBatchEditProgressCompletedWithErrors = "ContentBatchEditProgressCompletedWithErrors",
    ListItemBatchEditInProgress = "ListItemBatchEditInProgress",
    ListItemBatchEditCompleted = "ListItemBatchEditCompleted",
    ListItemBatchEditProgressFailed = "ListItemBatchEditProgressFailed",
    ListItemBatchEditProgressCompletedWithErrors = "ListItemBatchEditProgressCompletedWithErrors",
    ContentBackupRecoveryDraft = "ContentBackupRecoveryDraft",
    ContentBackupRecoveryInProgress = "ContentBackupRecoveryInProgress",
    ContentBackupRecoveryCompleted = "ContentBackupRecoveryCompleted",
    ContentBackupRecoveryForcefullyCompleted = "ContentBackupRecoveryForcefullyCompleted",
    ContentBackupRecoveryCancelled = "ContentBackupRecoveryCancelled",
    ContentBackupRecoveryFailed = "ContentBackupRecoveryFailed",
    ContentOwnershipBatchEditInProgress = "ContentOwnershipBatchEditInProgress",
    ContentOwnershipBatchEditCompleted = "ContentOwnershipBatchEditCompleted",
    ContentOwnershipBatchEditProgressFailed = "ContentOwnershipBatchEditProgressFailed",
    ContentOwnershipBatchEditProgressCompletedWithErrors = "ContentOwnershipBatchEditProgressCompletedWithErrors",
    ContentPermissionsBatchEditInProgress = "ContentPermissionsBatchEditInProgress",
    ContentPermissionsBatchEditCompleted = "ContentPermissionsBatchEditCompleted",
    ContentPermissionsBatchEditProgressFailed = "ContentPermissionsBatchEditProgressFailed",
    ContentPermissionsBatchEditProgressCompletedWithErrors = "ContentPermissionsBatchEditProgressCompletedWithErrors",
    UserTriggeredDeactivationRequestMessage = "UserTriggeredDeactivationRequestMessage",
    UserEmailConflictSolved = "UserEmailConflictSolved",
    ListItemDeactivateManyInProgress = "ListItemDeactivateManyInProgress",
    ListItemDeactivateManyCompleted = "ListItemDeactivateManyCompleted",
    ListItemDeactivateManyProgressFailed = "ListItemDeactivateManyProgressFailed",
    ListItemDeactivateManyProgressCompletedWithErrors = "ListItemDeactivateManyProgressCompletedWithErrors",
    ContentDeactivateManyInProgress = "ContentDeactivateManyInProgress",
    ContentDeactivateManyCompleted = "ContentDeactivateManyCompleted",
    ContentDeactivateManyProgressFailed = "ContentDeactivateManyProgressFailed",
    ContentDeactivateManyProgressCompletedWithErrors = "ContentDeactivateManyProgressCompletedWithErrors",
    ExternalBusinessProcessMessage = "ExternalBusinessProcessMessage",
    MetadataRelatedItemsInProgress = "MetadataRelatedItemsInProgress",
    MetadataRelatedItemsProgressFailed = "MetadataRelatedItemsProgressFailed",
    MetadataRelatedItemsProgressCompletedWithErrors = "MetadataRelatedItemsProgressCompletedWithErrors",
    MetadataRelatedItemsCompleted = "MetadataRelatedItemsCompleted",
    AutoTaggingInProgress = "AutoTaggingInProgress",
    AutoTaggingSucceeded = "AutoTaggingSucceeded",
    AutoTaggingSucceededWithErrors = "AutoTaggingSucceededWithErrors",
    AutoTaggingFailed = "AutoTaggingFailed",
    AutoTaggingCancelled = "AutoTaggingCancelled",
    ContentUpdateManyInProgress = "ContentUpdateManyInProgress",
    ContentUpdateManyCompleted = "ContentUpdateManyCompleted",
    ContentUpdateManyCompletedWithErrors = "ContentUpdateManyCompletedWithErrors",
    ContentUpdateManyFailed = "ContentUpdateManyFailed",
    MetadataRelatedItemsBySchemaInProgress = "MetadataRelatedItemsBySchemaInProgress",
    MetadataRelatedItemsBySchemaFailed = "MetadataRelatedItemsBySchemaFailed",
    MetadataRelatedItemsBySchemaCompletedWithErrors = "MetadataRelatedItemsBySchemaCompletedWithErrors",
    MetadataRelatedItemsBySchemaCompleted = "MetadataRelatedItemsBySchemaCompleted",
    MetadataOutdatedItemsUpdateInProgress = "MetadataOutdatedItemsUpdateInProgress",
    MetadataOutdatedItemsUpdateCompleted = "MetadataOutdatedItemsUpdateCompleted",
    MetadataOutdatedItemsUpdateCompletedWithErrors = "MetadataOutdatedItemsUpdateCompletedWithErrors",
    MetadataOutdatedItemsUpdateFailed = "MetadataOutdatedItemsUpdateFailed",
    BatchRenderingInProgress = "BatchRenderingInProgress",
    BatchRenderingCompleted = "BatchRenderingCompleted",
    BatchRenderingCompletedWithErrors = "BatchRenderingCompletedWithErrors",
    BatchRenderingFailed = "BatchRenderingFailed",
    BusinessRuleMessage = "BusinessRuleMessage",
    StatisticsExportDraft = "StatisticsExportDraft",
    StatisticsExportInProgress = "StatisticsExportInProgress",
    StatisticsExportCompleted = "StatisticsExportCompleted",
    StatisticsExportFailed = "StatisticsExportFailed",
    StatisticsExportCancelled = "StatisticsExportCancelled",
    NewComment = "NewComment",
}

export abstract class NotificationDetailBase implements INotificationDetailBase {

    protected _discriminator: string;

    constructor(data?: INotificationDetailBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "NotificationDetailBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): NotificationDetailBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailBusinessProcessBase") {
            throw new Error("The abstract class 'NotificationDetailBusinessProcessBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailTransferBase") {
            throw new Error("The abstract class 'NotificationDetailTransferBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailTransfer") {
            let result = new NotificationDetailTransfer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailTransferImport") {
            let result = new NotificationDetailTransferImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailShare") {
            let result = new NotificationDetailShare();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailSchemaImport") {
            let result = new NotificationDetailSchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailIndexReindexProgress") {
            let result = new NotificationDetailIndexReindexProgress();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailUserRegistered") {
            let result = new NotificationDetailUserRegistered();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentBackupRecovery") {
            let result = new NotificationDetailContentBackupRecovery();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailExternalBusinessProcess") {
            let result = new NotificationDetailExternalBusinessProcess();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailBusinessRule") {
            let result = new NotificationDetailBusinessRule();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailProgressBase") {
            throw new Error("The abstract class 'NotificationDetailProgressBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailTagging") {
            let result = new NotificationDetailTagging();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailBatchRendering") {
            let result = new NotificationDetailBatchRendering();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailStatisticsExport") {
            let result = new NotificationDetailStatisticsExport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailProgressWithRelatedItemsBase") {
            throw new Error("The abstract class 'NotificationDetailProgressWithRelatedItemsBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItems") {
            let result = new NotificationDetailMetadataItemCreateRelatedItems();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItemsBySchema") {
            let result = new NotificationDetailMetadataItemCreateRelatedItemsBySchema();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemUpdateOutdated") {
            let result = new NotificationDetailMetadataItemUpdateOutdated();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentBatchEditBase") {
            throw new Error("The abstract class 'NotificationDetailContentBatchEditBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentMetadataBatchEdit") {
            let result = new NotificationDetailContentMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentOwnershipBatchEdit") {
            let result = new NotificationDetailContentOwnershipBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentPermissionsBatchEdit") {
            let result = new NotificationDetailContentPermissionsBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemDeactivationBase") {
            throw new Error("The abstract class 'NotificationDetailMetadataItemDeactivationBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentDeactivation") {
            let result = new NotificationDetailContentDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemMetadataBatchEdit") {
            let result = new NotificationDetailListItemMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemDeactivation") {
            let result = new NotificationDetailListItemDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailComment") {
            let result = new NotificationDetailComment();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface INotificationDetailBase {
}

export abstract class NotificationDetailBusinessProcessBase extends NotificationDetailBase implements INotificationDetailBusinessProcessBase {
    businessProcessId!: string;
    businessProcessLifeCycle?: BusinessProcessLifeCycle;
    supportsCancellation!: boolean;

    constructor(data?: INotificationDetailBusinessProcessBase) {
        super(data);
        this._discriminator = "NotificationDetailBusinessProcessBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
            this.businessProcessLifeCycle = _data["businessProcessLifeCycle"];
            this.supportsCancellation = _data["supportsCancellation"];
        }
    }

    static override fromJS(data: any): NotificationDetailBusinessProcessBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailTransferBase") {
            throw new Error("The abstract class 'NotificationDetailTransferBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailTransfer") {
            let result = new NotificationDetailTransfer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailTransferImport") {
            let result = new NotificationDetailTransferImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailSchemaImport") {
            let result = new NotificationDetailSchemaImport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailIndexReindexProgress") {
            let result = new NotificationDetailIndexReindexProgress();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentBackupRecovery") {
            let result = new NotificationDetailContentBackupRecovery();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailExternalBusinessProcess") {
            let result = new NotificationDetailExternalBusinessProcess();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailProgressBase") {
            throw new Error("The abstract class 'NotificationDetailProgressBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailTagging") {
            let result = new NotificationDetailTagging();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailBatchRendering") {
            let result = new NotificationDetailBatchRendering();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailStatisticsExport") {
            let result = new NotificationDetailStatisticsExport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailProgressWithRelatedItemsBase") {
            throw new Error("The abstract class 'NotificationDetailProgressWithRelatedItemsBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItems") {
            let result = new NotificationDetailMetadataItemCreateRelatedItems();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItemsBySchema") {
            let result = new NotificationDetailMetadataItemCreateRelatedItemsBySchema();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemUpdateOutdated") {
            let result = new NotificationDetailMetadataItemUpdateOutdated();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentBatchEditBase") {
            throw new Error("The abstract class 'NotificationDetailContentBatchEditBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentMetadataBatchEdit") {
            let result = new NotificationDetailContentMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentOwnershipBatchEdit") {
            let result = new NotificationDetailContentOwnershipBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentPermissionsBatchEdit") {
            let result = new NotificationDetailContentPermissionsBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemDeactivationBase") {
            throw new Error("The abstract class 'NotificationDetailMetadataItemDeactivationBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentDeactivation") {
            let result = new NotificationDetailContentDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemMetadataBatchEdit") {
            let result = new NotificationDetailListItemMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemDeactivation") {
            let result = new NotificationDetailListItemDeactivation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailBusinessProcessBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        data["businessProcessLifeCycle"] = this.businessProcessLifeCycle;
        data["supportsCancellation"] = this.supportsCancellation;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailBusinessProcessBase extends INotificationDetailBase {
    businessProcessId: string;
    businessProcessLifeCycle?: BusinessProcessLifeCycle;
    supportsCancellation: boolean;
}

export abstract class NotificationDetailTransferBase extends NotificationDetailBusinessProcessBase implements INotificationDetailTransferBase {
    fileProgress?: number;
    fileCount?: number;
    failedCount?: number;
    cancelledCount?: number;
    name?: string | undefined;
    transferId!: string;

    constructor(data?: INotificationDetailTransferBase) {
        super(data);
        this._discriminator = "NotificationDetailTransferBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileProgress = _data["fileProgress"];
            this.fileCount = _data["fileCount"];
            this.failedCount = _data["failedCount"];
            this.cancelledCount = _data["cancelledCount"];
            this.name = _data["name"];
            this.transferId = _data["transferId"];
        }
    }

    static override fromJS(data: any): NotificationDetailTransferBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailTransfer") {
            let result = new NotificationDetailTransfer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailTransferImport") {
            let result = new NotificationDetailTransferImport();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailTransferBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileProgress"] = this.fileProgress;
        data["fileCount"] = this.fileCount;
        data["failedCount"] = this.failedCount;
        data["cancelledCount"] = this.cancelledCount;
        data["name"] = this.name;
        data["transferId"] = this.transferId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailTransferBase extends INotificationDetailBusinessProcessBase {
    fileProgress?: number;
    fileCount?: number;
    failedCount?: number;
    cancelledCount?: number;
    name?: string | undefined;
    transferId: string;
}

export class NotificationDetailTransfer extends NotificationDetailTransferBase implements INotificationDetailTransfer {

    constructor(data?: INotificationDetailTransfer) {
        super(data);
        this._discriminator = "NotificationDetailTransfer";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailTransfer extends INotificationDetailTransferBase {
}

export class NotificationDetailTransferImport extends NotificationDetailTransferBase implements INotificationDetailTransferImport {
    collectionId?: string | undefined;

    constructor(data?: INotificationDetailTransferImport) {
        super(data);
        this._discriminator = "NotificationDetailTransferImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collectionId = _data["collectionId"];
        }
    }

    static override fromJS(data: any): NotificationDetailTransferImport {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailTransferImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionId"] = this.collectionId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailTransferImport extends INotificationDetailTransferBase {
    collectionId?: string | undefined;
}

export class NotificationDetailShare extends NotificationDetailBase implements INotificationDetailShare {
    token?: string | undefined;
    shareId!: string;

    constructor(data?: INotificationDetailShare) {
        super(data);
        this._discriminator = "NotificationDetailShare";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
            this.shareId = _data["shareId"];
        }
    }

    static override fromJS(data: any): NotificationDetailShare {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailShare();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["shareId"] = this.shareId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailShare extends INotificationDetailBase {
    token?: string | undefined;
    shareId: string;
}

export class NotificationDetailSchemaImport extends NotificationDetailBusinessProcessBase implements INotificationDetailSchemaImport {
    schemaCount?: number;
    schemaProgress?: number;
    listItemCount?: number;
    listItemProgress?: number;
    name?: string | undefined;
    transferId!: string;
    importedSchemaCount?: number;
    skippedSchemaCount?: number;
    importedListItemCount?: number;
    skippedListItemCount?: number;
    relatedItemCount?: number;
    relatedItemProgress?: number;

    constructor(data?: INotificationDetailSchemaImport) {
        super(data);
        this._discriminator = "NotificationDetailSchemaImport";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaCount = _data["schemaCount"];
            this.schemaProgress = _data["schemaProgress"];
            this.listItemCount = _data["listItemCount"];
            this.listItemProgress = _data["listItemProgress"];
            this.name = _data["name"];
            this.transferId = _data["transferId"];
            this.importedSchemaCount = _data["importedSchemaCount"];
            this.skippedSchemaCount = _data["skippedSchemaCount"];
            this.importedListItemCount = _data["importedListItemCount"];
            this.skippedListItemCount = _data["skippedListItemCount"];
            this.relatedItemCount = _data["relatedItemCount"];
            this.relatedItemProgress = _data["relatedItemProgress"];
        }
    }

    static override fromJS(data: any): NotificationDetailSchemaImport {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailSchemaImport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaCount"] = this.schemaCount;
        data["schemaProgress"] = this.schemaProgress;
        data["listItemCount"] = this.listItemCount;
        data["listItemProgress"] = this.listItemProgress;
        data["name"] = this.name;
        data["transferId"] = this.transferId;
        data["importedSchemaCount"] = this.importedSchemaCount;
        data["skippedSchemaCount"] = this.skippedSchemaCount;
        data["importedListItemCount"] = this.importedListItemCount;
        data["skippedListItemCount"] = this.skippedListItemCount;
        data["relatedItemCount"] = this.relatedItemCount;
        data["relatedItemProgress"] = this.relatedItemProgress;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailSchemaImport extends INotificationDetailBusinessProcessBase {
    schemaCount?: number;
    schemaProgress?: number;
    listItemCount?: number;
    listItemProgress?: number;
    name?: string | undefined;
    transferId: string;
    importedSchemaCount?: number;
    skippedSchemaCount?: number;
    importedListItemCount?: number;
    skippedListItemCount?: number;
    relatedItemCount?: number;
    relatedItemProgress?: number;
}

export class NotificationDetailIndexReindexProgress extends NotificationDetailBusinessProcessBase implements INotificationDetailIndexReindexProgress {
    indexId!: string;
    expected?: number;
    current?: number;

    constructor(data?: INotificationDetailIndexReindexProgress) {
        super(data);
        this._discriminator = "NotificationDetailIndexReindexProgress";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexId = _data["indexId"];
            this.expected = _data["expected"];
            this.current = _data["current"];
        }
    }

    static override fromJS(data: any): NotificationDetailIndexReindexProgress {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailIndexReindexProgress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexId"] = this.indexId;
        data["expected"] = this.expected;
        data["current"] = this.current;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailIndexReindexProgress extends INotificationDetailBusinessProcessBase {
    indexId: string;
    expected?: number;
    current?: number;
}

export class NotificationDetailUserRegistered extends NotificationDetailBase implements INotificationDetailUserRegistered {
    displayName?: string | undefined;
    userId!: string;

    constructor(data?: INotificationDetailUserRegistered) {
        super(data);
        this._discriminator = "NotificationDetailUserRegistered";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayName = _data["displayName"];
            this.userId = _data["userId"];
        }
    }

    static override fromJS(data: any): NotificationDetailUserRegistered {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailUserRegistered();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailUserRegistered extends INotificationDetailBase {
    displayName?: string | undefined;
    userId: string;
}

export class NotificationDetailContentBackupRecovery extends NotificationDetailBusinessProcessBase implements INotificationDetailContentBackupRecovery {
    contentTotalCount?: number;
    contentProgressCount?: number;

    constructor(data?: INotificationDetailContentBackupRecovery) {
        super(data);
        this._discriminator = "NotificationDetailContentBackupRecovery";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentTotalCount = _data["contentTotalCount"];
            this.contentProgressCount = _data["contentProgressCount"];
        }
    }

    static override fromJS(data: any): NotificationDetailContentBackupRecovery {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailContentBackupRecovery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentTotalCount"] = this.contentTotalCount;
        data["contentProgressCount"] = this.contentProgressCount;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentBackupRecovery extends INotificationDetailBusinessProcessBase {
    contentTotalCount?: number;
    contentProgressCount?: number;
}

export class NotificationDetailExternalBusinessProcess extends NotificationDetailBusinessProcessBase implements INotificationDetailExternalBusinessProcess {
    title?: TranslatedStringDictionary | undefined;
    message?: TranslatedStringDictionary | undefined;
    navigationLink?: string | undefined;

    constructor(data?: INotificationDetailExternalBusinessProcess) {
        super(data);
        if (data) {
            this.title = data.title && !(<any>data.title).toJSON ? new TranslatedStringDictionary(data.title) : <TranslatedStringDictionary>this.title;
            this.message = data.message && !(<any>data.message).toJSON ? new TranslatedStringDictionary(data.message) : <TranslatedStringDictionary>this.message;
        }
        this._discriminator = "NotificationDetailExternalBusinessProcess";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"] ? TranslatedStringDictionary.fromJS(_data["title"]) : <any>undefined;
            this.message = _data["message"] ? TranslatedStringDictionary.fromJS(_data["message"]) : <any>undefined;
            this.navigationLink = _data["navigationLink"];
        }
    }

    static override fromJS(data: any): NotificationDetailExternalBusinessProcess {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailExternalBusinessProcess();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["navigationLink"] = this.navigationLink;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailExternalBusinessProcess extends INotificationDetailBusinessProcessBase {
    title?: ITranslatedStringDictionary | undefined;
    message?: ITranslatedStringDictionary | undefined;
    navigationLink?: string | undefined;
}

export class NotificationDetailBusinessRule extends NotificationDetailBase implements INotificationDetailBusinessRule {
    /** Title of the notification */
    title?: TranslatedStringDictionary | undefined;
    /** Message of the notification */
    message?: TranslatedStringDictionary | undefined;
    /** Id of collection, if created */
    collectionId?: string | undefined;
    /** Id of BusinessRule notification configuration */
    notificationId!: string;

    constructor(data?: INotificationDetailBusinessRule) {
        super(data);
        if (data) {
            this.title = data.title && !(<any>data.title).toJSON ? new TranslatedStringDictionary(data.title) : <TranslatedStringDictionary>this.title;
            this.message = data.message && !(<any>data.message).toJSON ? new TranslatedStringDictionary(data.message) : <TranslatedStringDictionary>this.message;
        }
        this._discriminator = "NotificationDetailBusinessRule";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"] ? TranslatedStringDictionary.fromJS(_data["title"]) : <any>undefined;
            this.message = _data["message"] ? TranslatedStringDictionary.fromJS(_data["message"]) : <any>undefined;
            this.collectionId = _data["collectionId"];
            this.notificationId = _data["notificationId"];
        }
    }

    static override fromJS(data: any): NotificationDetailBusinessRule {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailBusinessRule();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["collectionId"] = this.collectionId;
        data["notificationId"] = this.notificationId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailBusinessRule extends INotificationDetailBase {
    /** Title of the notification */
    title?: ITranslatedStringDictionary | undefined;
    /** Message of the notification */
    message?: ITranslatedStringDictionary | undefined;
    /** Id of collection, if created */
    collectionId?: string | undefined;
    /** Id of BusinessRule notification configuration */
    notificationId: string;
}

export abstract class NotificationDetailProgressBase extends NotificationDetailBusinessProcessBase implements INotificationDetailProgressBase {
    total?: number;
    succeeded?: number;
    failed?: number;

    constructor(data?: INotificationDetailProgressBase) {
        super(data);
        this._discriminator = "NotificationDetailProgressBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.total = _data["total"];
            this.succeeded = _data["succeeded"];
            this.failed = _data["failed"];
        }
    }

    static override fromJS(data: any): NotificationDetailProgressBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailTagging") {
            let result = new NotificationDetailTagging();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailBatchRendering") {
            let result = new NotificationDetailBatchRendering();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailStatisticsExport") {
            let result = new NotificationDetailStatisticsExport();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailProgressWithRelatedItemsBase") {
            throw new Error("The abstract class 'NotificationDetailProgressWithRelatedItemsBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItems") {
            let result = new NotificationDetailMetadataItemCreateRelatedItems();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItemsBySchema") {
            let result = new NotificationDetailMetadataItemCreateRelatedItemsBySchema();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemUpdateOutdated") {
            let result = new NotificationDetailMetadataItemUpdateOutdated();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentBatchEditBase") {
            throw new Error("The abstract class 'NotificationDetailContentBatchEditBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentMetadataBatchEdit") {
            let result = new NotificationDetailContentMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentOwnershipBatchEdit") {
            let result = new NotificationDetailContentOwnershipBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentPermissionsBatchEdit") {
            let result = new NotificationDetailContentPermissionsBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemDeactivationBase") {
            throw new Error("The abstract class 'NotificationDetailMetadataItemDeactivationBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentDeactivation") {
            let result = new NotificationDetailContentDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemMetadataBatchEdit") {
            let result = new NotificationDetailListItemMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemDeactivation") {
            let result = new NotificationDetailListItemDeactivation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailProgressBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["succeeded"] = this.succeeded;
        data["failed"] = this.failed;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailProgressBase extends INotificationDetailBusinessProcessBase {
    total?: number;
    succeeded?: number;
    failed?: number;
}

export class NotificationDetailTagging extends NotificationDetailProgressBase implements INotificationDetailTagging {

    constructor(data?: INotificationDetailTagging) {
        super(data);
        this._discriminator = "NotificationDetailTagging";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailTagging {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailTagging();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailTagging extends INotificationDetailProgressBase {
}

export class NotificationDetailBatchRendering extends NotificationDetailProgressBase implements INotificationDetailBatchRendering {

    constructor(data?: INotificationDetailBatchRendering) {
        super(data);
        this._discriminator = "NotificationDetailBatchRendering";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailBatchRendering {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailBatchRendering();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailBatchRendering extends INotificationDetailProgressBase {
}

export class NotificationDetailStatisticsExport extends NotificationDetailProgressBase implements INotificationDetailStatisticsExport {

    constructor(data?: INotificationDetailStatisticsExport) {
        super(data);
        this._discriminator = "NotificationDetailStatisticsExport";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailStatisticsExport {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailStatisticsExport();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailStatisticsExport extends INotificationDetailProgressBase {
}

export abstract class NotificationDetailProgressWithRelatedItemsBase extends NotificationDetailProgressBase implements INotificationDetailProgressWithRelatedItemsBase {
    relatedItemCount?: number;
    relatedItemProgress?: number;

    constructor(data?: INotificationDetailProgressWithRelatedItemsBase) {
        super(data);
        this._discriminator = "NotificationDetailProgressWithRelatedItemsBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.relatedItemCount = _data["relatedItemCount"];
            this.relatedItemProgress = _data["relatedItemProgress"];
        }
    }

    static override fromJS(data: any): NotificationDetailProgressWithRelatedItemsBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItems") {
            let result = new NotificationDetailMetadataItemCreateRelatedItems();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemCreateRelatedItemsBySchema") {
            let result = new NotificationDetailMetadataItemCreateRelatedItemsBySchema();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemUpdateOutdated") {
            let result = new NotificationDetailMetadataItemUpdateOutdated();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailMetadataItemDeactivationBase") {
            throw new Error("The abstract class 'NotificationDetailMetadataItemDeactivationBase' cannot be instantiated.");
        }
        if (data["kind"] === "NotificationDetailContentDeactivation") {
            let result = new NotificationDetailContentDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemMetadataBatchEdit") {
            let result = new NotificationDetailListItemMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemDeactivation") {
            let result = new NotificationDetailListItemDeactivation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailProgressWithRelatedItemsBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedItemCount"] = this.relatedItemCount;
        data["relatedItemProgress"] = this.relatedItemProgress;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailProgressWithRelatedItemsBase extends INotificationDetailProgressBase {
    relatedItemCount?: number;
    relatedItemProgress?: number;
}

export class NotificationDetailMetadataItemCreateRelatedItems extends NotificationDetailProgressWithRelatedItemsBase implements INotificationDetailMetadataItemCreateRelatedItems {

    constructor(data?: INotificationDetailMetadataItemCreateRelatedItems) {
        super(data);
        this._discriminator = "NotificationDetailMetadataItemCreateRelatedItems";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailMetadataItemCreateRelatedItems {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailMetadataItemCreateRelatedItems();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailMetadataItemCreateRelatedItems extends INotificationDetailProgressWithRelatedItemsBase {
}

export class NotificationDetailMetadataItemCreateRelatedItemsBySchema extends NotificationDetailProgressWithRelatedItemsBase implements INotificationDetailMetadataItemCreateRelatedItemsBySchema {

    constructor(data?: INotificationDetailMetadataItemCreateRelatedItemsBySchema) {
        super(data);
        this._discriminator = "NotificationDetailMetadataItemCreateRelatedItemsBySchema";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailMetadataItemCreateRelatedItemsBySchema {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailMetadataItemCreateRelatedItemsBySchema();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailMetadataItemCreateRelatedItemsBySchema extends INotificationDetailProgressWithRelatedItemsBase {
}

export class NotificationDetailMetadataItemUpdateOutdated extends NotificationDetailProgressWithRelatedItemsBase implements INotificationDetailMetadataItemUpdateOutdated {

    constructor(data?: INotificationDetailMetadataItemUpdateOutdated) {
        super(data);
        this._discriminator = "NotificationDetailMetadataItemUpdateOutdated";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailMetadataItemUpdateOutdated {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailMetadataItemUpdateOutdated();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailMetadataItemUpdateOutdated extends INotificationDetailProgressWithRelatedItemsBase {
}

export abstract class NotificationDetailContentBatchEditBase extends NotificationDetailProgressBase implements INotificationDetailContentBatchEditBase {
    collectionId?: string | undefined;

    constructor(data?: INotificationDetailContentBatchEditBase) {
        super(data);
        this._discriminator = "NotificationDetailContentBatchEditBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collectionId = _data["collectionId"];
        }
    }

    static override fromJS(data: any): NotificationDetailContentBatchEditBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailContentMetadataBatchEdit") {
            let result = new NotificationDetailContentMetadataBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentOwnershipBatchEdit") {
            let result = new NotificationDetailContentOwnershipBatchEdit();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailContentPermissionsBatchEdit") {
            let result = new NotificationDetailContentPermissionsBatchEdit();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailContentBatchEditBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionId"] = this.collectionId;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentBatchEditBase extends INotificationDetailProgressBase {
    collectionId?: string | undefined;
}

export class NotificationDetailContentMetadataBatchEdit extends NotificationDetailContentBatchEditBase implements INotificationDetailContentMetadataBatchEdit {

    constructor(data?: INotificationDetailContentMetadataBatchEdit) {
        super(data);
        this._discriminator = "NotificationDetailContentMetadataBatchEdit";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailContentMetadataBatchEdit {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailContentMetadataBatchEdit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentMetadataBatchEdit extends INotificationDetailContentBatchEditBase {
}

export class NotificationDetailContentOwnershipBatchEdit extends NotificationDetailContentBatchEditBase implements INotificationDetailContentOwnershipBatchEdit {

    constructor(data?: INotificationDetailContentOwnershipBatchEdit) {
        super(data);
        this._discriminator = "NotificationDetailContentOwnershipBatchEdit";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailContentOwnershipBatchEdit {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailContentOwnershipBatchEdit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentOwnershipBatchEdit extends INotificationDetailContentBatchEditBase {
}

export class NotificationDetailContentPermissionsBatchEdit extends NotificationDetailContentBatchEditBase implements INotificationDetailContentPermissionsBatchEdit {

    constructor(data?: INotificationDetailContentPermissionsBatchEdit) {
        super(data);
        this._discriminator = "NotificationDetailContentPermissionsBatchEdit";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailContentPermissionsBatchEdit {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailContentPermissionsBatchEdit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentPermissionsBatchEdit extends INotificationDetailContentBatchEditBase {
}

export abstract class NotificationDetailMetadataItemDeactivationBase extends NotificationDetailProgressWithRelatedItemsBase implements INotificationDetailMetadataItemDeactivationBase {
    referencingItemsCount?: number;
    referencingItemsProgress?: number;

    constructor(data?: INotificationDetailMetadataItemDeactivationBase) {
        super(data);
        this._discriminator = "NotificationDetailMetadataItemDeactivationBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.referencingItemsCount = _data["referencingItemsCount"];
            this.referencingItemsProgress = _data["referencingItemsProgress"];
        }
    }

    static override fromJS(data: any): NotificationDetailMetadataItemDeactivationBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "NotificationDetailContentDeactivation") {
            let result = new NotificationDetailContentDeactivation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NotificationDetailListItemDeactivation") {
            let result = new NotificationDetailListItemDeactivation();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'NotificationDetailMetadataItemDeactivationBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referencingItemsCount"] = this.referencingItemsCount;
        data["referencingItemsProgress"] = this.referencingItemsProgress;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailMetadataItemDeactivationBase extends INotificationDetailProgressWithRelatedItemsBase {
    referencingItemsCount?: number;
    referencingItemsProgress?: number;
}

export class NotificationDetailContentDeactivation extends NotificationDetailMetadataItemDeactivationBase implements INotificationDetailContentDeactivation {

    constructor(data?: INotificationDetailContentDeactivation) {
        super(data);
        this._discriminator = "NotificationDetailContentDeactivation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailContentDeactivation {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailContentDeactivation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailContentDeactivation extends INotificationDetailMetadataItemDeactivationBase {
}

export class NotificationDetailListItemMetadataBatchEdit extends NotificationDetailProgressWithRelatedItemsBase implements INotificationDetailListItemMetadataBatchEdit {

    constructor(data?: INotificationDetailListItemMetadataBatchEdit) {
        super(data);
        this._discriminator = "NotificationDetailListItemMetadataBatchEdit";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailListItemMetadataBatchEdit {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailListItemMetadataBatchEdit();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailListItemMetadataBatchEdit extends INotificationDetailProgressWithRelatedItemsBase {
}

export class NotificationDetailListItemDeactivation extends NotificationDetailMetadataItemDeactivationBase implements INotificationDetailListItemDeactivation {

    constructor(data?: INotificationDetailListItemDeactivation) {
        super(data);
        this._discriminator = "NotificationDetailListItemDeactivation";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): NotificationDetailListItemDeactivation {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailListItemDeactivation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailListItemDeactivation extends INotificationDetailMetadataItemDeactivationBase {
}

export class NotificationDetailComment extends NotificationDetailBase implements INotificationDetailComment {
    reason?: CommentNotificationReason;
    contentId?: string | undefined;
    commenterName?: string | undefined;
    commentMessage?: string | undefined;
    count?: number;

    constructor(data?: INotificationDetailComment) {
        super(data);
        this._discriminator = "NotificationDetailComment";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reason = _data["reason"];
            this.contentId = _data["contentId"];
            this.commenterName = _data["commenterName"];
            this.commentMessage = _data["commentMessage"];
            this.count = _data["count"];
        }
    }

    static override fromJS(data: any): NotificationDetailComment {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailComment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["contentId"] = this.contentId;
        data["commenterName"] = this.commenterName;
        data["commentMessage"] = this.commentMessage;
        data["count"] = this.count;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationDetailComment extends INotificationDetailBase {
    reason?: CommentNotificationReason;
    contentId?: string | undefined;
    commenterName?: string | undefined;
    commentMessage?: string | undefined;
    count?: number;
}

/** Reason for a comment notification. */
export enum CommentNotificationReason {
    Owned = "Owned",
    Replied = "Replied",
    Mentioned = "Mentioned",
}

export enum NotificationState {
    Draft = "Draft",
    Unread = "Unread",
    Read = "Read",
    Deleted = "Deleted",
    Null = "Null",
}

/** Base class for search results */
export class BaseResultOfNotification implements IBaseResultOfNotification {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Notification[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Notification(item) : <Notification>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Notification.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfNotification {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: INotification[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class NotificationCompactResult extends BaseResultOfNotification implements INotificationCompactResult {
    dataFetchStamp?: Date;
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: INotificationCompactResult) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dataFetchStamp = _data["dataFetchStamp"] ? new Date(_data["dataFetchStamp"].toString()) : <any>undefined;
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): NotificationCompactResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationCompactResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataFetchStamp"] = this.dataFetchStamp ? this.dataFetchStamp.toISOString() : <any>undefined;
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INotificationCompactResult extends IBaseResultOfNotification {
    dataFetchStamp?: Date;
    aggregationResults?: IAggregationResult[] | undefined;
}

export abstract class NotificationSearchAndAggregationBaseRequest implements INotificationSearchAndAggregationBaseRequest {
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;

    constructor(data?: INotificationSearchAndAggregationBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSearchAndAggregationBaseRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'NotificationSearchAndAggregationBaseRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationSearchAndAggregationBaseRequest {
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
}

export class NotificationSearchRequest extends NotificationSearchAndAggregationBaseRequest implements INotificationSearchRequest {
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: INotificationSearchRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): NotificationSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSearchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INotificationSearchRequest extends INotificationSearchAndAggregationBaseRequest {
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

export class NotificationAggregationRequest extends NotificationSearchAndAggregationBaseRequest implements INotificationAggregationRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: INotificationAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): NotificationAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationAggregationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INotificationAggregationRequest extends INotificationSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Email notification settings */
export class EmailNotificationsSettings implements IEmailNotificationsSettings {
    /** Settings for notification sources */
    sources?: { [key: string]: EmailNotificationsSourceSettings; } | undefined;

    constructor(data?: IEmailNotificationsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sources) {
                this.sources = {};
                for (let key in data.sources) {
                    if (data.sources.hasOwnProperty(key)) {
                        let item = data.sources[key];
                        this.sources[key] = item && !(<any>item).toJSON ? new EmailNotificationsSourceSettings(item) : <EmailNotificationsSourceSettings>item;
                    }
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["sources"]) {
                this.sources = {} as any;
                for (let key in _data["sources"]) {
                    if (_data["sources"].hasOwnProperty(key))
                        (<any>this.sources)![key] = _data["sources"][key] ? EmailNotificationsSourceSettings.fromJS(_data["sources"][key]) : new EmailNotificationsSourceSettings();
                }
            }
        }
    }

    static fromJS(data: any): EmailNotificationsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailNotificationsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sources) {
            data["sources"] = {};
            for (let key in this.sources) {
                if (this.sources.hasOwnProperty(key))
                    (<any>data["sources"])[key] = this.sources[key] ? this.sources[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Email notification settings */
export interface IEmailNotificationsSettings {
    /** Settings for notification sources */
    sources?: { [key: string]: IEmailNotificationsSourceSettings; } | undefined;
}

/** Email notification settings for a specific notification source */
export class EmailNotificationsSourceSettings implements IEmailNotificationsSourceSettings {
    /** Interval. */
    interval!: EmailNotificationsInterval;
    /** Exclusions from the default set by DisableAll property.
List of notification IDs which are excluded or included from the email, depending on the DisableAll property. */
    exclusions?: string[] | undefined;
    /** Receive all
            
When set to false, Exclusions property acts as a blacklist (all items are included by default).
When set to true, Exclusions property acts as a whitelist (no items are included by default). */
    disableAll!: boolean;

    constructor(data?: IEmailNotificationsSourceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interval = _data["interval"];
            if (Array.isArray(_data["exclusions"])) {
                this.exclusions = [] as any;
                for (let item of _data["exclusions"])
                    this.exclusions!.push(item);
            }
            this.disableAll = _data["disableAll"];
        }
    }

    static fromJS(data: any): EmailNotificationsSourceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailNotificationsSourceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interval"] = this.interval;
        if (Array.isArray(this.exclusions)) {
            data["exclusions"] = [];
            for (let item of this.exclusions)
                data["exclusions"].push(item);
        }
        data["disableAll"] = this.disableAll;
        return data;
    }
}

/** Email notification settings for a specific notification source */
export interface IEmailNotificationsSourceSettings {
    /** Interval. */
    interval: EmailNotificationsInterval;
    /** Exclusions from the default set by DisableAll property.
List of notification IDs which are excluded or included from the email, depending on the DisableAll property. */
    exclusions?: string[] | undefined;
    /** Receive all
            
When set to false, Exclusions property acts as a blacklist (all items are included by default).
When set to true, Exclusions property acts as a whitelist (no items are included by default). */
    disableAll: boolean;
}

/** Interval for email notifications */
export enum EmailNotificationsInterval {
    Daily = "Daily",
    Hourly = "Hourly",
    QuarterHourly = "QuarterHourly",
    EveryFiveMinutes = "EveryFiveMinutes",
    Off = "Off",
}

/** Notification that is available for email settings. */
export class NotificationType implements INotificationType {
    /** ID of the notification. */
    id?: string | undefined;
    /** Title of the notification. */
    title?: TranslatedStringDictionary | undefined;

    constructor(data?: INotificationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.title = data.title && !(<any>data.title).toJSON ? new TranslatedStringDictionary(data.title) : <TranslatedStringDictionary>this.title;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"] ? TranslatedStringDictionary.fromJS(_data["title"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationType {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
        return data;
    }
}

/** Notification that is available for email settings. */
export interface INotificationType {
    /** ID of the notification. */
    id?: string | undefined;
    /** Title of the notification. */
    title?: ITranslatedStringDictionary | undefined;
}

/** Used to change the download file name pattern for multiple formats at once. */
export class OutputFormatDownloadFileNamePatternUpdateManyRequest implements IOutputFormatDownloadFileNamePatternUpdateManyRequest {
    /** Download file name update requests to be processed. */
    items!: OutputFormatDownloadFileNamePatternUpdateRequestItem[];

    constructor(data?: IOutputFormatDownloadFileNamePatternUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new OutputFormatDownloadFileNamePatternUpdateRequestItem(item) : <OutputFormatDownloadFileNamePatternUpdateRequestItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutputFormatDownloadFileNamePatternUpdateRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputFormatDownloadFileNamePatternUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatDownloadFileNamePatternUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to change the download file name pattern for multiple formats at once. */
export interface IOutputFormatDownloadFileNamePatternUpdateManyRequest {
    /** Download file name update requests to be processed. */
    items: IOutputFormatDownloadFileNamePatternUpdateRequestItem[];
}

/** Represents a change to the download file name pattern to one output format. */
export class OutputFormatDownloadFileNamePatternUpdateRequestItem implements IOutputFormatDownloadFileNamePatternUpdateRequestItem {
    /** ID of the output format to set pattern for. */
    id!: string;
    /** The patterns to use per metadata language.
The customer's default language is required. */
    patterns?: TranslatedStringDictionary | undefined;

    constructor(data?: IOutputFormatDownloadFileNamePatternUpdateRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.patterns = data.patterns && !(<any>data.patterns).toJSON ? new TranslatedStringDictionary(data.patterns) : <TranslatedStringDictionary>this.patterns;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.patterns = _data["patterns"] ? TranslatedStringDictionary.fromJS(_data["patterns"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OutputFormatDownloadFileNamePatternUpdateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatDownloadFileNamePatternUpdateRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["patterns"] = this.patterns ? this.patterns.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a change to the download file name pattern to one output format. */
export interface IOutputFormatDownloadFileNamePatternUpdateRequestItem {
    /** ID of the output format to set pattern for. */
    id: string;
    /** The patterns to use per metadata language.
The customer's default language is required. */
    patterns?: ITranslatedStringDictionary | undefined;
}

/** Defines additional settings for XmpWriteback */
export class XmpWritebackOptions implements IXmpWritebackOptions {
    /** Defines how data from XmpMappings interacts with unaltered Xmp data contained in originally uploaded file */
    mergeMode!: XmpWritebackMergeMode;

    constructor(data?: IXmpWritebackOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mergeMode = _data["mergeMode"];
        }
    }

    static fromJS(data: any): XmpWritebackOptions {
        data = typeof data === 'object' ? data : {};
        let result = new XmpWritebackOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mergeMode"] = this.mergeMode;
        return data;
    }
}

/** Defines additional settings for XmpWriteback */
export interface IXmpWritebackOptions {
    /** Defines how data from XmpMappings interacts with unaltered Xmp data contained in originally uploaded file */
    mergeMode: XmpWritebackMergeMode;
}

export class OutputFormatSetXmpWritebackStateRequest extends XmpWritebackOptions implements IOutputFormatSetXmpWritebackStateRequest {
    /** Indicates if XMP writeback shall be enabled for the format. */
    enabled?: boolean;

    constructor(data?: IOutputFormatSetXmpWritebackStateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enabled = _data["enabled"];
        }
    }

    static override fromJS(data: any): OutputFormatSetXmpWritebackStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetXmpWritebackStateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputFormatSetXmpWritebackStateRequest extends IXmpWritebackOptions {
    /** Indicates if XMP writeback shall be enabled for the format. */
    enabled?: boolean;
}

/** Defines how data from XmpMappings interacts with unaltered Xmp data */
export enum XmpWritebackMergeMode {
    MappingOnly = "MappingOnly",
    MergeWithOriginal = "MergeWithOriginal",
}

/** Used to change the state of XMP writeback for multiple output formats at once. */
export class OutputFormatSetXmpWritebackStateManyRequest implements IOutputFormatSetXmpWritebackStateManyRequest {
    /** XMP writeback state changes to be processed. */
    items?: OutputFormatSetXmpWritebackStateRequestItem[] | undefined;

    constructor(data?: IOutputFormatSetXmpWritebackStateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutputFormatSetXmpWritebackStateRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputFormatSetXmpWritebackStateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetXmpWritebackStateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to change the state of XMP writeback for multiple output formats at once. */
export interface IOutputFormatSetXmpWritebackStateManyRequest {
    /** XMP writeback state changes to be processed. */
    items?: OutputFormatSetXmpWritebackStateRequestItem[] | undefined;
}

/** Represents a change to the XMP writeback state to one output format. */
export class OutputFormatSetXmpWritebackStateRequestItem extends OutputFormatSetXmpWritebackStateRequest implements IOutputFormatSetXmpWritebackStateRequestItem {
    /** ID of the output format to set XMP writeback state for. */
    id!: string;

    constructor(data?: IOutputFormatSetXmpWritebackStateRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): OutputFormatSetXmpWritebackStateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetXmpWritebackStateRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Represents a change to the XMP writeback state to one output format. */
export interface IOutputFormatSetXmpWritebackStateRequestItem extends IOutputFormatSetXmpWritebackStateRequest {
    /** ID of the output format to set XMP writeback state for. */
    id: string;
}

/** Request to change permission-related settings on an OutputFormat */
export class OutputFormatSetPermissionRequest implements IOutputFormatSetPermissionRequest {
    /** Indicates if outputs of this format should be accessible for users not having AccessOriginal permission on the content. */
    viewForAll!: boolean;

    constructor(data?: IOutputFormatSetPermissionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewForAll = _data["viewForAll"];
        }
    }

    static fromJS(data: any): OutputFormatSetPermissionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetPermissionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewForAll"] = this.viewForAll;
        return data;
    }
}

/** Request to change permission-related settings on an OutputFormat */
export interface IOutputFormatSetPermissionRequest {
    /** Indicates if outputs of this format should be accessible for users not having AccessOriginal permission on the content. */
    viewForAll: boolean;
}

/** Used to change permission-related settings on multiple OutputFormat */
export class OutputFormatSetPermissionManyRequest implements IOutputFormatSetPermissionManyRequest {
    /** Permission changes to be processed. */
    items?: OutputFormatSetPermissionRequestItem[] | undefined;

    constructor(data?: IOutputFormatSetPermissionManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutputFormatSetPermissionRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputFormatSetPermissionManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetPermissionManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to change permission-related settings on multiple OutputFormat */
export interface IOutputFormatSetPermissionManyRequest {
    /** Permission changes to be processed. */
    items?: OutputFormatSetPermissionRequestItem[] | undefined;
}

/** Represents a change to permission-related settings of an OutputFormat> */
export class OutputFormatSetPermissionRequestItem extends OutputFormatSetPermissionRequest implements IOutputFormatSetPermissionRequestItem {
    /** ID of the output format to set permission for. */
    id!: string;

    constructor(data?: IOutputFormatSetPermissionRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): OutputFormatSetPermissionRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatSetPermissionRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Represents a change to permission-related settings of an OutputFormat> */
export interface IOutputFormatSetPermissionRequestItem extends IOutputFormatSetPermissionRequest {
    /** ID of the output format to set permission for. */
    id: string;
}

/** Specifies for which content a given format should be rendered */
export class OutputFormatRenderPreviewRequest implements IOutputFormatRenderPreviewRequest {
    /** The content for which the format should be rendered */
    contentId?: string | undefined;
    /** The format which should be rendered. */
    outputFormat?: OutputFormatRenderingSpecification | undefined;

    constructor(data?: IOutputFormatRenderPreviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.outputFormat = data.outputFormat && !(<any>data.outputFormat).toJSON ? new OutputFormatRenderingSpecification(data.outputFormat) : <OutputFormatRenderingSpecification>this.outputFormat;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormat = _data["outputFormat"] ? OutputFormatRenderingSpecification.fromJS(_data["outputFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OutputFormatRenderPreviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatRenderPreviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormat"] = this.outputFormat ? this.outputFormat.toJSON() : <any>undefined;
        return data;
    }
}

/** Specifies for which content a given format should be rendered */
export interface IOutputFormatRenderPreviewRequest {
    /** The content for which the format should be rendered */
    contentId?: string | undefined;
    /** The format which should be rendered. */
    outputFormat?: IOutputFormatRenderingSpecification | undefined;
}

/** Used to specify how to render derived outputs */
export class OutputFormatRenderingSpecification implements IOutputFormatRenderingSpecification {
    /** Which output format should be used as a source of data. */
    sourceOutputFormats?: SourceOutputFormats | undefined;
    /** Information about the technical format of the data, e.g. JPEG, AAC or video still. */
    format?: FormatBase | undefined;

    constructor(data?: IOutputFormatRenderingSpecification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.sourceOutputFormats = data.sourceOutputFormats && !(<any>data.sourceOutputFormats).toJSON ? new SourceOutputFormats(data.sourceOutputFormats) : <SourceOutputFormats>this.sourceOutputFormats;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceOutputFormats = _data["sourceOutputFormats"] ? SourceOutputFormats.fromJS(_data["sourceOutputFormats"]) : <any>undefined;
            this.format = _data["format"] ? FormatBase.fromJS(_data["format"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OutputFormatRenderingSpecification {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatRenderingSpecification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceOutputFormats"] = this.sourceOutputFormats ? this.sourceOutputFormats.toJSON() : <any>undefined;
        data["format"] = this.format ? this.format.toJSON() : <any>undefined;
        return data;
    }
}

/** Used to specify how to render derived outputs */
export interface IOutputFormatRenderingSpecification {
    /** Which output format should be used as a source of data. */
    sourceOutputFormats?: ISourceOutputFormats | undefined;
    /** Information about the technical format of the data, e.g. JPEG, AAC or video still. */
    format?: FormatBase | undefined;
}

/** Defines the source used for rendering an OutputFormat depending on the type of content */
export class SourceOutputFormats implements ISourceOutputFormats {
    /** The source to be used for content of type Image */
    image?: string | undefined;
    /** The source to be used for content of type Video */
    video?: string | undefined;
    /** The source to be used for content of type Document */
    document?: string | undefined;
    /** The source to be used for content of type Audio */
    audio?: string | undefined;
    /** The source to be used for content of type Vector */
    vector?: string | undefined;

    constructor(data?: ISourceOutputFormats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.video = _data["video"];
            this.document = _data["document"];
            this.audio = _data["audio"];
            this.vector = _data["vector"];
        }
    }

    static fromJS(data: any): SourceOutputFormats {
        data = typeof data === 'object' ? data : {};
        let result = new SourceOutputFormats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["video"] = this.video;
        data["document"] = this.document;
        data["audio"] = this.audio;
        data["vector"] = this.vector;
        return data;
    }
}

/** Defines the source used for rendering an OutputFormat depending on the type of content */
export interface ISourceOutputFormats {
    /** The source to be used for content of type Image */
    image?: string | undefined;
    /** The source to be used for content of type Video */
    video?: string | undefined;
    /** The source to be used for content of type Document */
    document?: string | undefined;
    /** The source to be used for content of type Audio */
    audio?: string | undefined;
    /** The source to be used for content of type Vector */
    vector?: string | undefined;
}

export abstract class FormatBase implements IFormatBase {

    protected _discriminator: string;

    constructor(data?: IFormatBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FormatBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): FormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FormatWithFixedExtensionBase") {
            throw new Error("The abstract class 'FormatWithFixedExtensionBase' cannot be instantiated.");
        }
        if (data["kind"] === "OriginalFormat") {
            let result = new OriginalFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CopyFormat") {
            let result = new CopyFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ImageFormatBase") {
            throw new Error("The abstract class 'ImageFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "JpegFormat") {
            let result = new JpegFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PngFormat") {
            let result = new PngFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TiffFormat") {
            let result = new TiffFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WebPFormat") {
            let result = new WebPFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AvifFormat") {
            let result = new AvifFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoFormatBase") {
            throw new Error("The abstract class 'VideoFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "AudioFormatBase") {
            throw new Error("The abstract class 'AudioFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "Mp4VideoFormat") {
            let result = new Mp4VideoFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoSpriteFormat") {
            let result = new VideoSpriteFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoStillFormat") {
            let result = new VideoStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AacAudioFormat") {
            let result = new AacAudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AudioStillFormat") {
            let result = new AudioStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "Mp3AudioFormat") {
            let result = new Mp3AudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentFormatBase") {
            throw new Error("The abstract class 'DocumentFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "DocumentStillFormat") {
            let result = new DocumentStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PdfFormat") {
            let result = new PdfFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VectorFormatBase") {
            throw new Error("The abstract class 'VectorFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "SvgFormat") {
            let result = new SvgFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VectorStillFormat") {
            let result = new VectorStillFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FormatBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface IFormatBase {
}

export abstract class FormatWithFixedExtensionBase extends FormatBase implements IFormatWithFixedExtensionBase {
    /** The filename extension of the file produced by this Format. */
    extension?: string | undefined;

    constructor(data?: IFormatWithFixedExtensionBase) {
        super(data);
        this._discriminator = "FormatWithFixedExtensionBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.extension = _data["extension"];
        }
    }

    static override fromJS(data: any): FormatWithFixedExtensionBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ImageFormatBase") {
            throw new Error("The abstract class 'ImageFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "JpegFormat") {
            let result = new JpegFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PngFormat") {
            let result = new PngFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TiffFormat") {
            let result = new TiffFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WebPFormat") {
            let result = new WebPFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AvifFormat") {
            let result = new AvifFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoFormatBase") {
            throw new Error("The abstract class 'VideoFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "AudioFormatBase") {
            throw new Error("The abstract class 'AudioFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "Mp4VideoFormat") {
            let result = new Mp4VideoFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoSpriteFormat") {
            let result = new VideoSpriteFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoStillFormat") {
            let result = new VideoStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AacAudioFormat") {
            let result = new AacAudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AudioStillFormat") {
            let result = new AudioStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "Mp3AudioFormat") {
            let result = new Mp3AudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DocumentFormatBase") {
            throw new Error("The abstract class 'DocumentFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "DocumentStillFormat") {
            let result = new DocumentStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PdfFormat") {
            let result = new PdfFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VectorFormatBase") {
            throw new Error("The abstract class 'VectorFormatBase' cannot be instantiated.");
        }
        if (data["kind"] === "SvgFormat") {
            let result = new SvgFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VectorStillFormat") {
            let result = new VectorStillFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FormatWithFixedExtensionBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        super.toJSON(data);
        return data;
    }
}

export interface IFormatWithFixedExtensionBase extends IFormatBase {
    /** The filename extension of the file produced by this Format. */
    extension?: string | undefined;
}

/** Special format that represents the original. */
export class OriginalFormat extends FormatBase implements IOriginalFormat {

    constructor(data?: IOriginalFormat) {
        super(data);
        this._discriminator = "OriginalFormat";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OriginalFormat {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Special format that represents the original. */
export interface IOriginalFormat extends IFormatBase {
}

/** A format that, when rendered, simply copies the source file. Primarily intended for use with XmpWriteback. */
export class CopyFormat extends FormatBase implements ICopyFormat {

    constructor(data?: ICopyFormat) {
        super(data);
        this._discriminator = "CopyFormat";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CopyFormat {
        data = typeof data === 'object' ? data : {};
        let result = new CopyFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** A format that, when rendered, simply copies the source file. Primarily intended for use with XmpWriteback. */
export interface ICopyFormat extends IFormatBase {
}

/** Base class for ImageFormats such as JPEG, PNG, TIFF, ... */
export abstract class ImageFormatBase extends FormatWithFixedExtensionBase implements IImageFormatBase {
    /** Color profile to use. Colorspace is derived from the chosen profile. */
    colorProfile?: ColorProfile | undefined;
    /** The method of conversion for color spaces (e.g. CMYK to RGB). Further information can be found here: http://www.colourphil.co.uk/rendering_intents.shtml */
    colorTransformationIntent?: ColorTransformationIntent;
    /** Horizontal resolution in dpi (dots per inch) */
    horizontalResolution?: number | undefined;
    /** Vertical resolution in dpi (dots per inch) */
    verticalResolution?: number | undefined;
    /** Copy clipping paths from input. */
    keepClippingPath?: boolean;
    /** Allows resizing of the image. */
    resizeAction?: ResizeAction | undefined;
    /** A collection of actions to be applied during rendering. */
    actions?: ImageActionBase[] | undefined;

    constructor(data?: IImageFormatBase) {
        super(data);
        if (data) {
            this.resizeAction = data.resizeAction && !(<any>data.resizeAction).toJSON ? new ResizeAction(data.resizeAction) : <ResizeAction>this.resizeAction;
        }
        this._discriminator = "ImageFormatBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.colorProfile = _data["colorProfile"];
            this.colorTransformationIntent = _data["colorTransformationIntent"];
            this.horizontalResolution = _data["horizontalResolution"];
            this.verticalResolution = _data["verticalResolution"];
            this.keepClippingPath = _data["keepClippingPath"];
            this.resizeAction = _data["resizeAction"] ? ResizeAction.fromJS(_data["resizeAction"]) : <any>undefined;
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ImageActionBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ImageFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "JpegFormat") {
            let result = new JpegFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PngFormat") {
            let result = new PngFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TiffFormat") {
            let result = new TiffFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WebPFormat") {
            let result = new WebPFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AvifFormat") {
            let result = new AvifFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ImageFormatBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colorProfile"] = this.colorProfile;
        data["colorTransformationIntent"] = this.colorTransformationIntent;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["keepClippingPath"] = this.keepClippingPath;
        data["resizeAction"] = this.resizeAction ? this.resizeAction.toJSON() : <any>undefined;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for ImageFormats such as JPEG, PNG, TIFF, ... */
export interface IImageFormatBase extends IFormatWithFixedExtensionBase {
    /** Color profile to use. Colorspace is derived from the chosen profile. */
    colorProfile?: ColorProfile | undefined;
    /** The method of conversion for color spaces (e.g. CMYK to RGB). Further information can be found here: http://www.colourphil.co.uk/rendering_intents.shtml */
    colorTransformationIntent?: ColorTransformationIntent;
    /** Horizontal resolution in dpi (dots per inch) */
    horizontalResolution?: number | undefined;
    /** Vertical resolution in dpi (dots per inch) */
    verticalResolution?: number | undefined;
    /** Copy clipping paths from input. */
    keepClippingPath?: boolean;
    /** Allows resizing of the image. */
    resizeAction?: IResizeAction | undefined;
    /** A collection of actions to be applied during rendering. */
    actions?: ImageActionBase[] | undefined;
}

/** Available color profiles */
export enum ColorProfile {
    AdobeRgb1998 = "AdobeRgb1998",
    AppleRgb = "AppleRgb",
    ColorMatchRgb = "ColorMatchRgb",
    EciRgbV1 = "EciRgbV1",
    EciRgbV2 = "EciRgbV2",
    Srgb = "Srgb",
    SrgbColorSpaceProfile = "SrgbColorSpaceProfile",
    EuropeIsoCoatedFogra27 = "EuropeIsoCoatedFogra27",
    EuroscaleCoated = "EuroscaleCoated",
    EuroscaleUncoated = "EuroscaleUncoated",
    IsoCoated = "IsoCoated",
    IsoCoatedEciV2 = "IsoCoatedEciV2",
    JapanColor2001Coated = "JapanColor2001Coated",
    JapanColor2001Uncoated = "JapanColor2001Uncoated",
    JapanColor2002Newspaper = "JapanColor2002Newspaper",
    JapanWebCoated = "JapanWebCoated",
    UsSheetfedCoated = "UsSheetfedCoated",
    UsSheetfedUncoated = "UsSheetfedUncoated",
    UsWebCoatedSwop = "UsWebCoatedSwop",
    UsWebUncoated = "UsWebUncoated",
    IsoCoatedV2Grey1cBas = "IsoCoatedV2Grey1cBas",
    IsoCoated300EciV2 = "IsoCoated300EciV2",
    CoatedFogra27 = "CoatedFogra27",
    CoatedFogra39 = "CoatedFogra39",
    UncoatedFogra29 = "UncoatedFogra29",
    WebCoatedFogra28 = "WebCoatedFogra28",
    WebCoatedSwop2006Grade3 = "WebCoatedSwop2006Grade3",
    WebCoatedSwop2006Grade5 = "WebCoatedSwop2006Grade5",
    Isonewspaper26v4 = "Isonewspaper26v4",
    Isonewspaper26v4Grey = "Isonewspaper26v4Grey",
}

/** http://www.colourphil.co.uk/rendering_intents.shtml */
export enum ColorTransformationIntent {
    RelativeColorimetricBpc = "RelativeColorimetricBpc",
    AbsoluteColorimetric = "AbsoluteColorimetric",
    Perceptual = "Perceptual",
    RelativeColorimetric = "RelativeColorimetric",
    Saturation = "Saturation",
}

/** Specifies image resize parameters. */
export class ResizeAction implements IResizeAction {
    /** Target width for the output. */
    width!: number;
    /** Target height for the output. */
    height!: number;
    /** Specifies additional resize behaviour. */
    resizeMode!: ResizeMode;

    constructor(data?: IResizeAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.resizeMode = _data["resizeMode"];
        }
    }

    static fromJS(data: any): ResizeAction {
        data = typeof data === 'object' ? data : {};
        let result = new ResizeAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["resizeMode"] = this.resizeMode;
        return data;
    }
}

/** Specifies image resize parameters. */
export interface IResizeAction {
    /** Target width for the output. */
    width: number;
    /** Target height for the output. */
    height: number;
    /** Specifies additional resize behaviour. */
    resizeMode: ResizeMode;
}

/** Specifies how the dimensions of a ResizeAction are applied to the content */
export enum ResizeMode {
    Fit = "Fit",
    Shrink = "Shrink",
    Resize = "Resize",
}

export abstract class ImageActionBase implements IImageActionBase {

    protected _discriminator: string;

    constructor(data?: IImageActionBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ImageActionBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ImageActionBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AlphaHandlingAction") {
            let result = new AlphaHandlingAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropActionGeneric") {
            let result = new CropActionGeneric();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropActionAbsoluteSizeBase") {
            throw new Error("The abstract class 'CropActionAbsoluteSizeBase' cannot be instantiated.");
        }
        if (data["kind"] === "CropAction") {
            let result = new CropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GravityBasedCropAction") {
            let result = new GravityBasedCropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelativeCropAction") {
            let result = new RelativeCropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "UnsharpenMaskAction") {
            let result = new UnsharpenMaskAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "WatermarkAction") {
            let result = new WatermarkAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RotateAction") {
            let result = new RotateAction();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ImageActionBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface IImageActionBase {
}

/** An ImageAction that allows different forms of modifying alpha information in an image. */
export class AlphaHandlingAction extends ImageActionBase implements IAlphaHandlingAction {
    /** Specifies the kind of alpha handling to be applied. */
    alphaHandling?: AlphaHandling;
    /** Specifies potentially needed color information for alpha handling. Must be given in RGB hex format (8 bit per channel). */
    replacementRgbColorHexCode?: string | undefined;

    constructor(data?: IAlphaHandlingAction) {
        super(data);
        this._discriminator = "AlphaHandlingAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.alphaHandling = _data["alphaHandling"];
            this.replacementRgbColorHexCode = _data["replacementRgbColorHexCode"];
        }
    }

    static override fromJS(data: any): AlphaHandlingAction {
        data = typeof data === 'object' ? data : {};
        let result = new AlphaHandlingAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alphaHandling"] = this.alphaHandling;
        data["replacementRgbColorHexCode"] = this.replacementRgbColorHexCode;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows different forms of modifying alpha information in an image. */
export interface IAlphaHandlingAction extends IImageActionBase {
    /** Specifies the kind of alpha handling to be applied. */
    alphaHandling?: AlphaHandling;
    /** Specifies potentially needed color information for alpha handling. Must be given in RGB hex format (8 bit per channel). */
    replacementRgbColorHexCode?: string | undefined;
}

/** Specifies the kind of AlphaHandling to be applied to an image */
export enum AlphaHandling {
    DiscardAlpha = "DiscardAlpha",
    ReplaceAlpha = "ReplaceAlpha",
    ReplaceInvertedAlpha = "ReplaceInvertedAlpha",
}

/** Parameters for cropping actions. */
export class CropActionGeneric extends ImageActionBase implements ICropActionGeneric {
    /** Defines position of cropping rectangle. */
    position?: CropPositionBase | undefined;
    /** Defines size of cropping rectangle. */
    size?: CropSizeBase | undefined;

    constructor(data?: ICropActionGeneric) {
        super(data);
        this._discriminator = "CropActionGeneric";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.position = _data["position"] ? CropPositionBase.fromJS(_data["position"]) : <any>undefined;
            this.size = _data["size"] ? CropSizeBase.fromJS(_data["size"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CropActionGeneric {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CropActionAbsoluteSizeBase") {
            throw new Error("The abstract class 'CropActionAbsoluteSizeBase' cannot be instantiated.");
        }
        if (data["kind"] === "CropAction") {
            let result = new CropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GravityBasedCropAction") {
            let result = new GravityBasedCropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelativeCropAction") {
            let result = new RelativeCropAction();
            result.init(data);
            return result;
        }
        let result = new CropActionGeneric();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["size"] = this.size ? this.size.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Parameters for cropping actions. */
export interface ICropActionGeneric extends IImageActionBase {
    /** Defines position of cropping rectangle. */
    position?: CropPositionBase | undefined;
    /** Defines size of cropping rectangle. */
    size?: CropSizeBase | undefined;
}

/** Defines position of cropping rectangle. */
export abstract class CropPositionBase implements ICropPositionBase {

    protected _discriminator: string;

    constructor(data?: ICropPositionBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CropPositionBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CropPositionBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CropOriginAbsolute") {
            let result = new CropOriginAbsolute();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropCenterRelative") {
            let result = new CropCenterRelative();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropPositionGravity") {
            let result = new CropPositionGravity();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'CropPositionBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** Defines position of cropping rectangle. */
export interface ICropPositionBase {
}

export class CropOriginAbsolute extends CropPositionBase implements ICropOriginAbsolute {
    /** X-Coordinate of top left point of the cropping rectangle. */
    x?: number;
    /** Y-Coordinate of top left point of the cropping rectangle. */
    y?: number;

    constructor(data?: ICropOriginAbsolute) {
        super(data);
        this._discriminator = "CropOriginAbsolute";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static override fromJS(data: any): CropOriginAbsolute {
        data = typeof data === 'object' ? data : {};
        let result = new CropOriginAbsolute();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        super.toJSON(data);
        return data;
    }
}

export interface ICropOriginAbsolute extends ICropPositionBase {
    /** X-Coordinate of top left point of the cropping rectangle. */
    x?: number;
    /** Y-Coordinate of top left point of the cropping rectangle. */
    y?: number;
}

export class CropCenterRelative extends CropPositionBase implements ICropCenterRelative {
    /** Relative horizontal position of center for crop. 0.5 designates the center of the image. */
    x?: number;
    /** Relative vertical position of center for crop. 0.5 designates the center of the image. */
    y?: number;

    constructor(data?: ICropCenterRelative) {
        super(data);
        this._discriminator = "CropCenterRelative";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static override fromJS(data: any): CropCenterRelative {
        data = typeof data === 'object' ? data : {};
        let result = new CropCenterRelative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        super.toJSON(data);
        return data;
    }
}

export interface ICropCenterRelative extends ICropPositionBase {
    /** Relative horizontal position of center for crop. 0.5 designates the center of the image. */
    x?: number;
    /** Relative vertical position of center for crop. 0.5 designates the center of the image. */
    y?: number;
}

export class CropPositionGravity extends CropPositionBase implements ICropPositionGravity {
    /** Gravity of the cropping rectangle. */
    gravity?: CropGravity;

    constructor(data?: ICropPositionGravity) {
        super(data);
        this._discriminator = "CropPositionGravity";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gravity = _data["gravity"];
        }
    }

    static override fromJS(data: any): CropPositionGravity {
        data = typeof data === 'object' ? data : {};
        let result = new CropPositionGravity();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gravity"] = this.gravity;
        super.toJSON(data);
        return data;
    }
}

export interface ICropPositionGravity extends ICropPositionBase {
    /** Gravity of the cropping rectangle. */
    gravity?: CropGravity;
}

export enum CropGravity {
    NorthWest = "NorthWest",
    North = "North",
    NorthEast = "NorthEast",
    East = "East",
    SouthEast = "SouthEast",
    South = "South",
    SouthWest = "SouthWest",
    West = "West",
    Center = "Center",
}

/** Defines size of cropping rectangle. */
export abstract class CropSizeBase implements ICropSizeBase {

    protected _discriminator: string;

    constructor(data?: ICropSizeBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CropSizeBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CropSizeBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CropSizeAbsolute") {
            let result = new CropSizeAbsolute();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CropSizeRelative") {
            let result = new CropSizeRelative();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'CropSizeBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** Defines size of cropping rectangle. */
export interface ICropSizeBase {
}

export class CropSizeAbsolute extends CropSizeBase implements ICropSizeAbsolute {
    /** Width of the cropping rectangle. */
    width?: number;
    /** Height of the cropping rectangle. */
    height?: number;

    constructor(data?: ICropSizeAbsolute) {
        super(data);
        this._discriminator = "CropSizeAbsolute";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static override fromJS(data: any): CropSizeAbsolute {
        data = typeof data === 'object' ? data : {};
        let result = new CropSizeAbsolute();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data;
    }
}

export interface ICropSizeAbsolute extends ICropSizeBase {
    /** Width of the cropping rectangle. */
    width?: number;
    /** Height of the cropping rectangle. */
    height?: number;
}

export class CropSizeRelative extends CropSizeBase implements ICropSizeRelative {
    /** Width of the cropping rectangle in range [0, 1]. */
    width?: number;
    /** Height of the cropping rectangle in range [0, 1]. */
    height?: number;

    constructor(data?: ICropSizeRelative) {
        super(data);
        this._discriminator = "CropSizeRelative";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static override fromJS(data: any): CropSizeRelative {
        data = typeof data === 'object' ? data : {};
        let result = new CropSizeRelative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        super.toJSON(data);
        return data;
    }
}

export interface ICropSizeRelative extends ICropSizeBase {
    /** Width of the cropping rectangle in range [0, 1]. */
    width?: number;
    /** Height of the cropping rectangle in range [0, 1]. */
    height?: number;
}

export abstract class CropActionAbsoluteSizeBase extends CropActionGeneric implements ICropActionAbsoluteSizeBase {
    height?: number;
    width?: number;

    constructor(data?: ICropActionAbsoluteSizeBase) {
        super(data);
        this._discriminator = "CropActionAbsoluteSizeBase";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.height = _data["height"];
            this.width = _data["width"];
        }
    }

    static override fromJS(data: any): CropActionAbsoluteSizeBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CropAction") {
            let result = new CropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "GravityBasedCropAction") {
            let result = new GravityBasedCropAction();
            result.init(data);
            return result;
        }
        if (data["kind"] === "RelativeCropAction") {
            let result = new RelativeCropAction();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'CropActionAbsoluteSizeBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["height"] = this.height;
        data["width"] = this.width;
        super.toJSON(data);
        return data;
    }
}

export interface ICropActionAbsoluteSizeBase extends ICropActionGeneric {
    height?: number;
    width?: number;
}

/** An ImageAction that allows cropping an image. */
export class CropAction extends CropActionAbsoluteSizeBase implements ICropAction {
    x?: number;
    y?: number;

    constructor(data?: ICropAction) {
        super(data);
        this._discriminator = "CropAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static override fromJS(data: any): CropAction {
        data = typeof data === 'object' ? data : {};
        let result = new CropAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows cropping an image. */
export interface ICropAction extends ICropActionAbsoluteSizeBase {
    x?: number;
    y?: number;
}

/** An ImageAction that allows cropping an image, weighing the cropping rectangle on a gravity. */
export class GravityBasedCropAction extends CropActionAbsoluteSizeBase implements IGravityBasedCropAction {
    gravity?: CropGravity;

    constructor(data?: IGravityBasedCropAction) {
        super(data);
        this._discriminator = "GravityBasedCropAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gravity = _data["gravity"];
        }
    }

    static override fromJS(data: any): GravityBasedCropAction {
        data = typeof data === 'object' ? data : {};
        let result = new GravityBasedCropAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gravity"] = this.gravity;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows cropping an image, weighing the cropping rectangle on a gravity. */
export interface IGravityBasedCropAction extends ICropActionAbsoluteSizeBase {
    gravity?: CropGravity;
}

/** An ImageAction that allows cropping an image, positioning the cropping rectangle relative to the width/height of the image. */
export class RelativeCropAction extends CropActionAbsoluteSizeBase implements IRelativeCropAction {
    x?: number;
    y?: number;

    constructor(data?: IRelativeCropAction) {
        super(data);
        this._discriminator = "RelativeCropAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static override fromJS(data: any): RelativeCropAction {
        data = typeof data === 'object' ? data : {};
        let result = new RelativeCropAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows cropping an image, positioning the cropping rectangle relative to the width/height of the image. */
export interface IRelativeCropAction extends ICropActionAbsoluteSizeBase {
    x?: number;
    y?: number;
}

/** Increases sharpness of an image by using the unsharp mask technique. */
export class UnsharpenMaskAction extends ImageActionBase implements IUnsharpenMaskAction {
    /** Unsharp mask amount (the difference between blurred and original image). */
    amount?: number;
    /** Blur radius used to produce unfocused version of the image. */
    radius?: number;
    /** The threshold value for the unsharp mask in range [0, 1] */
    threshold?: number;

    constructor(data?: IUnsharpenMaskAction) {
        super(data);
        this._discriminator = "UnsharpenMaskAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.radius = _data["radius"];
            this.threshold = _data["threshold"];
        }
    }

    static override fromJS(data: any): UnsharpenMaskAction {
        data = typeof data === 'object' ? data : {};
        let result = new UnsharpenMaskAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["radius"] = this.radius;
        data["threshold"] = this.threshold;
        super.toJSON(data);
        return data;
    }
}

/** Increases sharpness of an image by using the unsharp mask technique. */
export interface IUnsharpenMaskAction extends IImageActionBase {
    /** Unsharp mask amount (the difference between blurred and original image). */
    amount?: number;
    /** Blur radius used to produce unfocused version of the image. */
    radius?: number;
    /** The threshold value for the unsharp mask in range [0, 1] */
    threshold?: number;
}

/** An ImageAction that allows rendering a watermark to an image */
export class WatermarkAction extends ImageActionBase implements IWatermarkAction {
    /** Identifies the image to be used as watermark */
    watermarkFilePath?: string | undefined;
    /** Margin to the left border of the image, in pixels */
    marginLeft?: number | undefined;
    /** Margin to the top of the image, in pixels */
    marginTop?: number | undefined;
    /** Margin to the right border of the image, in pixels */
    marginRight?: number | undefined;
    /** Margin to the bottom of the image, in pixels */
    marginBottom?: number | undefined;
    /** Scales the opacity of the watermark */
    opacity?: number;
    /** Scales the watermark width according to the size of the final image. */
    widthRatio?: number;
    /** Scales the watermark height according to the size of the final image. */
    heightRatio?: number;

    constructor(data?: IWatermarkAction) {
        super(data);
        this._discriminator = "WatermarkAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.watermarkFilePath = _data["watermarkFilePath"];
            this.marginLeft = _data["marginLeft"];
            this.marginTop = _data["marginTop"];
            this.marginRight = _data["marginRight"];
            this.marginBottom = _data["marginBottom"];
            this.opacity = _data["opacity"];
            this.widthRatio = _data["widthRatio"];
            this.heightRatio = _data["heightRatio"];
        }
    }

    static override fromJS(data: any): WatermarkAction {
        data = typeof data === 'object' ? data : {};
        let result = new WatermarkAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watermarkFilePath"] = this.watermarkFilePath;
        data["marginLeft"] = this.marginLeft;
        data["marginTop"] = this.marginTop;
        data["marginRight"] = this.marginRight;
        data["marginBottom"] = this.marginBottom;
        data["opacity"] = this.opacity;
        data["widthRatio"] = this.widthRatio;
        data["heightRatio"] = this.heightRatio;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows rendering a watermark to an image */
export interface IWatermarkAction extends IImageActionBase {
    /** Identifies the image to be used as watermark */
    watermarkFilePath?: string | undefined;
    /** Margin to the left border of the image, in pixels */
    marginLeft?: number | undefined;
    /** Margin to the top of the image, in pixels */
    marginTop?: number | undefined;
    /** Margin to the right border of the image, in pixels */
    marginRight?: number | undefined;
    /** Margin to the bottom of the image, in pixels */
    marginBottom?: number | undefined;
    /** Scales the opacity of the watermark */
    opacity?: number;
    /** Scales the watermark width according to the size of the final image. */
    widthRatio?: number;
    /** Scales the watermark height according to the size of the final image. */
    heightRatio?: number;
}

/** An ImageAction that allows rotating an image. */
export class RotateAction extends ImageActionBase implements IRotateAction {
    /** Degrees to rotate the image in. */
    degrees?: number;
    /** Direction the rotation should be applied in. */
    direction?: RotateDirection;

    constructor(data?: IRotateAction) {
        super(data);
        this._discriminator = "RotateAction";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.degrees = _data["degrees"];
            this.direction = _data["direction"];
        }
    }

    static override fromJS(data: any): RotateAction {
        data = typeof data === 'object' ? data : {};
        let result = new RotateAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["degrees"] = this.degrees;
        data["direction"] = this.direction;
        super.toJSON(data);
        return data;
    }
}

/** An ImageAction that allows rotating an image. */
export interface IRotateAction extends IImageActionBase {
    /** Degrees to rotate the image in. */
    degrees?: number;
    /** Direction the rotation should be applied in. */
    direction?: RotateDirection;
}

export enum RotateDirection {
    Clockwise = "Clockwise",
    CounterClockwise = "CounterClockwise",
}

/** Renders a JPEG image. */
export class JpegFormat extends ImageFormatBase implements IJpegFormat {
    /** Compression quality. Must be in range [0,100] and defaults to 80. */
    quality?: number;
    /** Whether to use chroma subsampling or not. */
    chromaSubsamplingEnabled?: boolean;

    constructor(data?: IJpegFormat) {
        super(data);
        this._discriminator = "JpegFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quality = _data["quality"];
            this.chromaSubsamplingEnabled = _data["chromaSubsamplingEnabled"];
        }
    }

    static override fromJS(data: any): JpegFormat {
        data = typeof data === 'object' ? data : {};
        let result = new JpegFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quality"] = this.quality;
        data["chromaSubsamplingEnabled"] = this.chromaSubsamplingEnabled;
        super.toJSON(data);
        return data;
    }
}

/** Renders a JPEG image. */
export interface IJpegFormat extends IImageFormatBase {
    /** Compression quality. Must be in range [0,100] and defaults to 80. */
    quality?: number;
    /** Whether to use chroma subsampling or not. */
    chromaSubsamplingEnabled?: boolean;
}

/** Renders a PNG image. */
export class PngFormat extends ImageFormatBase implements IPngFormat {

    constructor(data?: IPngFormat) {
        super(data);
        this._discriminator = "PngFormat";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): PngFormat {
        data = typeof data === 'object' ? data : {};
        let result = new PngFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Renders a PNG image. */
export interface IPngFormat extends IImageFormatBase {
}

/** Renders a TIFF image */
export class TiffFormat extends ImageFormatBase implements ITiffFormat {
    /** Specifies whether color channels should be premultiplied with alpha (associated alpha) or not (unassociated alpha). */
    alphaPremultiplied?: boolean;
    /** Specifies the compression type to use. */
    compressionType?: CompressionType;
    /** Preserve (including size affecting changes) unspecified extraChannels. */
    includeUnspecifiedTiffExtraChannels?: boolean;

    constructor(data?: ITiffFormat) {
        super(data);
        this._discriminator = "TiffFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.alphaPremultiplied = _data["alphaPremultiplied"];
            this.compressionType = _data["compressionType"];
            this.includeUnspecifiedTiffExtraChannels = _data["includeUnspecifiedTiffExtraChannels"];
        }
    }

    static override fromJS(data: any): TiffFormat {
        data = typeof data === 'object' ? data : {};
        let result = new TiffFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alphaPremultiplied"] = this.alphaPremultiplied;
        data["compressionType"] = this.compressionType;
        data["includeUnspecifiedTiffExtraChannels"] = this.includeUnspecifiedTiffExtraChannels;
        super.toJSON(data);
        return data;
    }
}

/** Renders a TIFF image */
export interface ITiffFormat extends IImageFormatBase {
    /** Specifies whether color channels should be premultiplied with alpha (associated alpha) or not (unassociated alpha). */
    alphaPremultiplied?: boolean;
    /** Specifies the compression type to use. */
    compressionType?: CompressionType;
    /** Preserve (including size affecting changes) unspecified extraChannels. */
    includeUnspecifiedTiffExtraChannels?: boolean;
}

/** Available compression types. */
export enum CompressionType {
    None = "None",
    Lzw = "Lzw",
    Rle = "Rle",
    Zip = "Zip",
}

/** Renders a WebP image. */
export class WebPFormat extends ImageFormatBase implements IWebPFormat {
    /** Compression quality. Must be in range [0,100] and defaults to 90. */
    quality?: number;

    constructor(data?: IWebPFormat) {
        super(data);
        this._discriminator = "WebPFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quality = _data["quality"];
        }
    }

    static override fromJS(data: any): WebPFormat {
        data = typeof data === 'object' ? data : {};
        let result = new WebPFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quality"] = this.quality;
        super.toJSON(data);
        return data;
    }
}

/** Renders a WebP image. */
export interface IWebPFormat extends IImageFormatBase {
    /** Compression quality. Must be in range [0,100] and defaults to 90. */
    quality?: number;
}

/** Renders an AVIF image. */
export class AvifFormat extends ImageFormatBase implements IAvifFormat {
    /** Compression quality. Must be in range [0,100] and defaults to 90. */
    quality?: number;

    constructor(data?: IAvifFormat) {
        super(data);
        this._discriminator = "AvifFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.quality = _data["quality"];
        }
    }

    static override fromJS(data: any): AvifFormat {
        data = typeof data === 'object' ? data : {};
        let result = new AvifFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quality"] = this.quality;
        super.toJSON(data);
        return data;
    }
}

/** Renders an AVIF image. */
export interface IAvifFormat extends IImageFormatBase {
    /** Compression quality. Must be in range [0,100] and defaults to 90. */
    quality?: number;
}

/** Base class for rendering video. */
export abstract class VideoFormatBase extends FormatWithFixedExtensionBase implements IVideoFormatBase {

    constructor(data?: IVideoFormatBase) {
        super(data);
        this._discriminator = "VideoFormatBase";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): VideoFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "Mp4VideoFormat") {
            let result = new Mp4VideoFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoSpriteFormat") {
            let result = new VideoSpriteFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VideoStillFormat") {
            let result = new VideoStillFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'VideoFormatBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Base class for rendering video. */
export interface IVideoFormatBase extends IFormatWithFixedExtensionBase {
}

/** Renders H.264 in mp4 container. */
export class Mp4VideoFormat extends VideoFormatBase implements IMp4VideoFormat {
    /** Allows resizing of the video. */
    resizeAction?: ResizeAction | undefined;
    /** Gets or sets the encoding audio codec. */
    audioCodec?: AudioFormatBase | undefined;
    /** Gets or sets the encoding codec preset. */
    preset?: Preset;

    constructor(data?: IMp4VideoFormat) {
        super(data);
        if (data) {
            this.resizeAction = data.resizeAction && !(<any>data.resizeAction).toJSON ? new ResizeAction(data.resizeAction) : <ResizeAction>this.resizeAction;
        }
        this._discriminator = "Mp4VideoFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resizeAction = _data["resizeAction"] ? ResizeAction.fromJS(_data["resizeAction"]) : <any>undefined;
            this.audioCodec = _data["audioCodec"] ? AudioFormatBase.fromJS(_data["audioCodec"]) : <any>undefined;
            this.preset = _data["preset"];
        }
    }

    static override fromJS(data: any): Mp4VideoFormat {
        data = typeof data === 'object' ? data : {};
        let result = new Mp4VideoFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resizeAction"] = this.resizeAction ? this.resizeAction.toJSON() : <any>undefined;
        data["audioCodec"] = this.audioCodec ? this.audioCodec.toJSON() : <any>undefined;
        data["preset"] = this.preset;
        super.toJSON(data);
        return data;
    }
}

/** Renders H.264 in mp4 container. */
export interface IMp4VideoFormat extends IVideoFormatBase {
    /** Allows resizing of the video. */
    resizeAction?: IResizeAction | undefined;
    /** Gets or sets the encoding audio codec. */
    audioCodec?: AudioFormatBase | undefined;
    /** Gets or sets the encoding codec preset. */
    preset?: Preset;
}

/** Base class for rendering audio. */
export abstract class AudioFormatBase extends FormatWithFixedExtensionBase implements IAudioFormatBase {

    constructor(data?: IAudioFormatBase) {
        super(data);
        this._discriminator = "AudioFormatBase";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AudioFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "AacAudioFormat") {
            let result = new AacAudioFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "AudioStillFormat") {
            let result = new AudioStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "Mp3AudioFormat") {
            let result = new Mp3AudioFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AudioFormatBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Base class for rendering audio. */
export interface IAudioFormatBase extends IFormatWithFixedExtensionBase {
}

/** Video rendering preset, see http://dev.beandog.org/x264_preset_reference.html for more information. */
export enum Preset {
    Ultrafast = "ultrafast",
    Superfast = "superfast",
    Veryfast = "veryfast",
    Faster = "faster",
    Fast = "fast",
    Medium = "medium",
    Slow = "slow",
    Slower = "slower",
}

/** Generates a sprite image of the input video. */
export class VideoSpriteFormat extends VideoFormatBase implements IVideoSpriteFormat {
    /** Specifies the dimensions of a single frame in the sprite. */
    spriteResizeAction?: ResizeAction | undefined;
    /** Limit for the number of frames to generate. */
    maxNumberOfSprites?: number;
    /** JPEG-quality to use for the sprite. */
    quality?: number;

    constructor(data?: IVideoSpriteFormat) {
        super(data);
        if (data) {
            this.spriteResizeAction = data.spriteResizeAction && !(<any>data.spriteResizeAction).toJSON ? new ResizeAction(data.spriteResizeAction) : <ResizeAction>this.spriteResizeAction;
        }
        this._discriminator = "VideoSpriteFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.spriteResizeAction = _data["spriteResizeAction"] ? ResizeAction.fromJS(_data["spriteResizeAction"]) : <any>undefined;
            this.maxNumberOfSprites = _data["maxNumberOfSprites"];
            this.quality = _data["quality"];
        }
    }

    static override fromJS(data: any): VideoSpriteFormat {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSpriteFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["spriteResizeAction"] = this.spriteResizeAction ? this.spriteResizeAction.toJSON() : <any>undefined;
        data["maxNumberOfSprites"] = this.maxNumberOfSprites;
        data["quality"] = this.quality;
        super.toJSON(data);
        return data;
    }
}

/** Generates a sprite image of the input video. */
export interface IVideoSpriteFormat extends IVideoFormatBase {
    /** Specifies the dimensions of a single frame in the sprite. */
    spriteResizeAction?: IResizeAction | undefined;
    /** Limit for the number of frames to generate. */
    maxNumberOfSprites?: number;
    /** JPEG-quality to use for the sprite. */
    quality?: number;
}

export class VideoStillFormat extends VideoFormatBase implements IVideoStillFormat {
    /** Specifies the position from which to produce the image. */
    positionInSeconds?: number;

    constructor(data?: IVideoStillFormat) {
        super(data);
        this._discriminator = "VideoStillFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.positionInSeconds = _data["positionInSeconds"];
        }
    }

    static override fromJS(data: any): VideoStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStillFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["positionInSeconds"] = this.positionInSeconds;
        super.toJSON(data);
        return data;
    }
}

export interface IVideoStillFormat extends IVideoFormatBase {
    /** Specifies the position from which to produce the image. */
    positionInSeconds?: number;
}

/** Specifies Aac encoding for the output and additional settings for the encoder. */
export class AacAudioFormat extends AudioFormatBase implements IAacAudioFormat {
    /** Gets or sets the encoding profile. */
    profile?: Profile;
    /** Gets or sets the encoding coder. */
    coder?: Coder;
    /** Gets or sets the bitrate of the encoding in kbps. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding variable bit rate (VBR) - 1 is lowest quality and 5 is highest quality. */
    variableBitRate?: number | undefined;

    constructor(data?: IAacAudioFormat) {
        super(data);
        this._discriminator = "AacAudioFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.profile = _data["profile"];
            this.coder = _data["coder"];
            this.bitrate = _data["bitrate"];
            this.variableBitRate = _data["variableBitRate"];
        }
    }

    static override fromJS(data: any): AacAudioFormat {
        data = typeof data === 'object' ? data : {};
        let result = new AacAudioFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profile"] = this.profile;
        data["coder"] = this.coder;
        data["bitrate"] = this.bitrate;
        data["variableBitRate"] = this.variableBitRate;
        super.toJSON(data);
        return data;
    }
}

/** Specifies Aac encoding for the output and additional settings for the encoder. */
export interface IAacAudioFormat extends IAudioFormatBase {
    /** Gets or sets the encoding profile. */
    profile?: Profile;
    /** Gets or sets the encoding coder. */
    coder?: Coder;
    /** Gets or sets the bitrate of the encoding in kbps. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding variable bit rate (VBR) - 1 is lowest quality and 5 is highest quality. */
    variableBitRate?: number | undefined;
}

export enum Profile {
    Aac_low = "aac_low",
    Mpeg2_aac_low = "mpeg2_aac_low",
    Aac_ltp = "aac_ltp",
    Aac_main = "aac_main",
}

/** Audio coders */
export enum Coder {
    Twoloop = "twoloop",
    Anmr = "anmr",
    Fast = "fast",
}

/** Generates a waveform image from an Audio source. */
export class AudioStillFormat extends AudioFormatBase implements IAudioStillFormat {

    constructor(data?: IAudioStillFormat) {
        super(data);
        this._discriminator = "AudioStillFormat";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AudioStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new AudioStillFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Generates a waveform image from an Audio source. */
export interface IAudioStillFormat extends IAudioFormatBase {
}

/** Renders an MP3 audio file. */
export class Mp3AudioFormat extends AudioFormatBase implements IMp3AudioFormat {
    /** Gets or sets the encoding bitrate. This setting and Quality are mutually exclusive. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding quality. This setting and Bitrate are mutually exclusive.
Values can be set it range of 0 to 9, where a lower value is a higher quality. */
    quality?: number | undefined;

    constructor(data?: IMp3AudioFormat) {
        super(data);
        this._discriminator = "Mp3AudioFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.bitrate = _data["bitrate"];
            this.quality = _data["quality"];
        }
    }

    static override fromJS(data: any): Mp3AudioFormat {
        data = typeof data === 'object' ? data : {};
        let result = new Mp3AudioFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitrate"] = this.bitrate;
        data["quality"] = this.quality;
        super.toJSON(data);
        return data;
    }
}

/** Renders an MP3 audio file. */
export interface IMp3AudioFormat extends IAudioFormatBase {
    /** Gets or sets the encoding bitrate. This setting and Quality are mutually exclusive. */
    bitrate?: number | undefined;
    /** Gets or sets the encoding quality. This setting and Bitrate are mutually exclusive.
Values can be set it range of 0 to 9, where a lower value is a higher quality. */
    quality?: number | undefined;
}

/** Base class for rendering documents. */
export abstract class DocumentFormatBase extends FormatWithFixedExtensionBase implements IDocumentFormatBase {

    constructor(data?: IDocumentFormatBase) {
        super(data);
        this._discriminator = "DocumentFormatBase";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DocumentFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DocumentStillFormat") {
            let result = new DocumentStillFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PdfFormat") {
            let result = new PdfFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DocumentFormatBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Base class for rendering documents. */
export interface IDocumentFormatBase extends IFormatWithFixedExtensionBase {
}

/** Render a document to a raster image */
export class DocumentStillFormat extends DocumentFormatBase implements IDocumentStillFormat {
    /** Allows resizing of the image. */
    resizeAction?: ResizeAction | undefined;

    constructor(data?: IDocumentStillFormat) {
        super(data);
        if (data) {
            this.resizeAction = data.resizeAction && !(<any>data.resizeAction).toJSON ? new ResizeAction(data.resizeAction) : <ResizeAction>this.resizeAction;
        }
        this._discriminator = "DocumentStillFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resizeAction = _data["resizeAction"] ? ResizeAction.fromJS(_data["resizeAction"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DocumentStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentStillFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resizeAction"] = this.resizeAction ? this.resizeAction.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Render a document to a raster image */
export interface IDocumentStillFormat extends IDocumentFormatBase {
    /** Allows resizing of the image. */
    resizeAction?: IResizeAction | undefined;
}

export class PdfFormat extends DocumentFormatBase implements IPdfFormat {
    /** Specifies compression quality used for ReduceFileSize. */
    jpegQuality?: number;
    /** Whether to linearize the output for fast web viewing. */
    fastWebView?: boolean;
    /** Whether to apply measures to decrease output size or not. */
    reduceFileSize?: boolean;
    /** Whether to extract document full text from this output. */
    extractFullText?: boolean;

    constructor(data?: IPdfFormat) {
        super(data);
        this._discriminator = "PdfFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jpegQuality = _data["jpegQuality"];
            this.fastWebView = _data["fastWebView"];
            this.reduceFileSize = _data["reduceFileSize"];
            this.extractFullText = _data["extractFullText"];
        }
    }

    static override fromJS(data: any): PdfFormat {
        data = typeof data === 'object' ? data : {};
        let result = new PdfFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jpegQuality"] = this.jpegQuality;
        data["fastWebView"] = this.fastWebView;
        data["reduceFileSize"] = this.reduceFileSize;
        data["extractFullText"] = this.extractFullText;
        super.toJSON(data);
        return data;
    }
}

export interface IPdfFormat extends IDocumentFormatBase {
    /** Specifies compression quality used for ReduceFileSize. */
    jpegQuality?: number;
    /** Whether to linearize the output for fast web viewing. */
    fastWebView?: boolean;
    /** Whether to apply measures to decrease output size or not. */
    reduceFileSize?: boolean;
    /** Whether to extract document full text from this output. */
    extractFullText?: boolean;
}

/** Base class for rendering vector graphics. */
export abstract class VectorFormatBase extends FormatWithFixedExtensionBase implements IVectorFormatBase {

    constructor(data?: IVectorFormatBase) {
        super(data);
        this._discriminator = "VectorFormatBase";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): VectorFormatBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "SvgFormat") {
            let result = new SvgFormat();
            result.init(data);
            return result;
        }
        if (data["kind"] === "VectorStillFormat") {
            let result = new VectorStillFormat();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'VectorFormatBase' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Base class for rendering vector graphics. */
export interface IVectorFormatBase extends IFormatWithFixedExtensionBase {
}

/** Render a PDF to SVG */
export class SvgFormat extends VectorFormatBase implements ISvgFormat {

    constructor(data?: ISvgFormat) {
        super(data);
        this._discriminator = "SvgFormat";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SvgFormat {
        data = typeof data === 'object' ? data : {};
        let result = new SvgFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Render a PDF to SVG */
export interface ISvgFormat extends IVectorFormatBase {
}

/** Render a vector graphic to a raster image */
export class VectorStillFormat extends VectorFormatBase implements IVectorStillFormat {
    /** Specifies output dimensions for raster operation */
    resizeAction?: ResizeAction | undefined;

    constructor(data?: IVectorStillFormat) {
        super(data);
        if (data) {
            this.resizeAction = data.resizeAction && !(<any>data.resizeAction).toJSON ? new ResizeAction(data.resizeAction) : <ResizeAction>this.resizeAction;
        }
        this._discriminator = "VectorStillFormat";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resizeAction = _data["resizeAction"] ? ResizeAction.fromJS(_data["resizeAction"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): VectorStillFormat {
        data = typeof data === 'object' ? data : {};
        let result = new VectorStillFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resizeAction"] = this.resizeAction ? this.resizeAction.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Render a vector graphic to a raster image */
export interface IVectorStillFormat extends IVectorFormatBase {
    /** Specifies output dimensions for raster operation */
    resizeAction?: IResizeAction | undefined;
}

/** Represents the editable part of the output format. */
export class OutputFormatEditable extends OutputFormatRenderingSpecification implements IOutputFormatEditable {
    /** Language specific names. */
    names!: TranslatedStringDictionary;
    /** How long should the dynamic outputs created from this format be kept. */
    retentionTime?: string;
    /** Optional patterns (liquid syntax) that produce the filename for item of this output format.
If set, the customer's default language is required. */
    downloadFileNamePatterns?: TranslatedStringDictionary | undefined;
    /** Indicates if outputs of this format should be accessible for users not having AccessOriginal permission on the content. */
    viewForAll?: boolean;
    /** Indicates if metadata should be written into XMP header of outputs where applicable and configured. */
    enableXmpWriteback?: boolean;
    /** Defines additional settings for XmpWriteback */
    xmpWritebackOptions?: XmpWritebackOptions | undefined;
    /** Defines how the OutputFormat should behave for certain features (Download, Sharing, Media editing). */
    behaviors?: OutputFormatBehaviors | undefined;

    constructor(data?: IOutputFormatEditable) {
        super(data);
        if (data) {
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.downloadFileNamePatterns = data.downloadFileNamePatterns && !(<any>data.downloadFileNamePatterns).toJSON ? new TranslatedStringDictionary(data.downloadFileNamePatterns) : <TranslatedStringDictionary>this.downloadFileNamePatterns;
            this.xmpWritebackOptions = data.xmpWritebackOptions && !(<any>data.xmpWritebackOptions).toJSON ? new XmpWritebackOptions(data.xmpWritebackOptions) : <XmpWritebackOptions>this.xmpWritebackOptions;
            this.behaviors = data.behaviors && !(<any>data.behaviors).toJSON ? new OutputFormatBehaviors(data.behaviors) : <OutputFormatBehaviors>this.behaviors;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            this.retentionTime = _data["retentionTime"];
            this.downloadFileNamePatterns = _data["downloadFileNamePatterns"] ? TranslatedStringDictionary.fromJS(_data["downloadFileNamePatterns"]) : <any>undefined;
            this.viewForAll = _data["viewForAll"];
            this.enableXmpWriteback = _data["enableXmpWriteback"];
            this.xmpWritebackOptions = _data["xmpWritebackOptions"] ? XmpWritebackOptions.fromJS(_data["xmpWritebackOptions"]) : <any>undefined;
            this.behaviors = _data["behaviors"] ? OutputFormatBehaviors.fromJS(_data["behaviors"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): OutputFormatEditable {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatEditable();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["retentionTime"] = this.retentionTime;
        data["downloadFileNamePatterns"] = this.downloadFileNamePatterns ? this.downloadFileNamePatterns.toJSON() : <any>undefined;
        data["viewForAll"] = this.viewForAll;
        data["enableXmpWriteback"] = this.enableXmpWriteback;
        data["xmpWritebackOptions"] = this.xmpWritebackOptions ? this.xmpWritebackOptions.toJSON() : <any>undefined;
        data["behaviors"] = this.behaviors ? this.behaviors.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents the editable part of the output format. */
export interface IOutputFormatEditable extends IOutputFormatRenderingSpecification {
    /** Language specific names. */
    names: ITranslatedStringDictionary;
    /** How long should the dynamic outputs created from this format be kept. */
    retentionTime?: string;
    /** Optional patterns (liquid syntax) that produce the filename for item of this output format.
If set, the customer's default language is required. */
    downloadFileNamePatterns?: ITranslatedStringDictionary | undefined;
    /** Indicates if outputs of this format should be accessible for users not having AccessOriginal permission on the content. */
    viewForAll?: boolean;
    /** Indicates if metadata should be written into XMP header of outputs where applicable and configured. */
    enableXmpWriteback?: boolean;
    /** Defines additional settings for XmpWriteback */
    xmpWritebackOptions?: IXmpWritebackOptions | undefined;
    /** Defines how the OutputFormat should behave for certain features (Download, Sharing, Media editing). */
    behaviors?: IOutputFormatBehaviors | undefined;
}

/** Represents an output format. */
export class OutputFormat extends OutputFormatEditable implements IOutputFormat {
    /** Output format ID. */
    id?: string | undefined;
    /** Marks if this is a system output format. */
    system?: boolean;
    /** A dynamic output format is not rendered automatically, but only on demand. */
    dynamic?: boolean;
    /** Specifies if output format should be taken into account during data extraction. */
    dataExtraction?: boolean;
    /** Temporary outputs will not be backed up. */
    temporary?: boolean;

    constructor(data?: IOutputFormat) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.system = _data["system"];
            this.dynamic = _data["dynamic"];
            this.dataExtraction = _data["dataExtraction"];
            this.temporary = _data["temporary"];
        }
    }

    static override fromJS(data: any): OutputFormat {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormat();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["system"] = this.system;
        data["dynamic"] = this.dynamic;
        data["dataExtraction"] = this.dataExtraction;
        data["temporary"] = this.temporary;
        super.toJSON(data);
        return data;
    }
}

/** Represents an output format. */
export interface IOutputFormat extends IOutputFormatEditable {
    /** Output format ID. */
    id?: string | undefined;
    /** Marks if this is a system output format. */
    system?: boolean;
    /** A dynamic output format is not rendered automatically, but only on demand. */
    dynamic?: boolean;
    /** Specifies if output format should be taken into account during data extraction. */
    dataExtraction?: boolean;
    /** Temporary outputs will not be backed up. */
    temporary?: boolean;
}

/** Represents an output format. */
export class OutputFormatDetail extends OutputFormat implements IOutputFormatDetail {
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IOutputFormatDetail) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): OutputFormatDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents an output format. */
export interface IOutputFormatDetail extends IOutputFormat {
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

/** Used to create multiple new output formats at once. */
export class OutputFormatCreateManyRequest implements IOutputFormatCreateManyRequest {
    /** Output format items to be created. */
    items?: OutputFormat[] | undefined;

    constructor(data?: IOutputFormatCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutputFormat.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputFormatCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to create multiple new output formats at once. */
export interface IOutputFormatCreateManyRequest {
    /** Output format items to be created. */
    items?: OutputFormat[] | undefined;
}

/** Used to modify multiple output formats at once. */
export class OutputFormatUpdateManyRequest implements IOutputFormatUpdateManyRequest {
    /** Output format items to be modified. */
    items?: OutputFormatUpdateManyRequestItem[] | undefined;

    constructor(data?: IOutputFormatUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutputFormatUpdateManyRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutputFormatUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Used to modify multiple output formats at once. */
export interface IOutputFormatUpdateManyRequest {
    /** Output format items to be modified. */
    items?: OutputFormatUpdateManyRequestItem[] | undefined;
}

/** Represents one item to be modified in a bulk update operation on output formats. */
export class OutputFormatUpdateManyRequestItem extends OutputFormatEditable implements IOutputFormatUpdateManyRequestItem {
    /** ID of the output format to modify. */
    id?: string | undefined;

    constructor(data?: IOutputFormatUpdateManyRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): OutputFormatUpdateManyRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatUpdateManyRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Represents one item to be modified in a bulk update operation on output formats. */
export interface IOutputFormatUpdateManyRequestItem extends IOutputFormatEditable {
    /** ID of the output format to modify. */
    id?: string | undefined;
}

/** Used to remove multiple output formats at once. */
export class OutputFormatDeleteManyRequest implements IOutputFormatDeleteManyRequest {
    /** List of IDs of output formats to remove. */
    ids?: string[] | undefined;

    constructor(data?: IOutputFormatDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): OutputFormatDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputFormatDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

/** Used to remove multiple output formats at once. */
export interface IOutputFormatDeleteManyRequest {
    /** List of IDs of output formats to remove. */
    ids?: string[] | undefined;
}

/** Base class for search results */
export class BaseResultOfOutput implements IBaseResultOfOutput {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Output[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Output.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfOutput {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Output[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class OutputSearchResult extends BaseResultOfOutput implements IOutputSearchResult {

    constructor(data?: IOutputSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): OutputSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOutputSearchResult extends IBaseResultOfOutput {
}

export class OutputSearchRequest implements IOutputSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[] | undefined;
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[] | undefined;
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[] | undefined;
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[] | undefined;

    constructor(data?: IOutputSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            if (Array.isArray(_data["renderingStates"])) {
                this.renderingStates = [] as any;
                for (let item of _data["renderingStates"])
                    this.renderingStates!.push(item);
            }
            if (Array.isArray(_data["fileExtensions"])) {
                this.fileExtensions = [] as any;
                for (let item of _data["fileExtensions"])
                    this.fileExtensions!.push(item);
            }
            if (Array.isArray(_data["outputFormatIds"])) {
                this.outputFormatIds = [] as any;
                for (let item of _data["outputFormatIds"])
                    this.outputFormatIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OutputSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        if (Array.isArray(this.renderingStates)) {
            data["renderingStates"] = [];
            for (let item of this.renderingStates)
                data["renderingStates"].push(item);
        }
        if (Array.isArray(this.fileExtensions)) {
            data["fileExtensions"] = [];
            for (let item of this.fileExtensions)
                data["fileExtensions"].push(item);
        }
        if (Array.isArray(this.outputFormatIds)) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data;
    }
}

export interface IOutputSearchRequest {
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** List of Content ids you want to use to fetch the outputs. */
    contentIds?: string[] | undefined;
    /** The allowed rendering states of the outputs you want to fetch. */
    renderingStates?: OutputRenderingState[] | undefined;
    /** The file extension of the outputs you want to fetch. */
    fileExtensions?: string[] | undefined;
    /** The output format id of the outputs you want to fetch. */
    outputFormatIds?: string[] | undefined;
}

export class OutputResetRetryAttemptsRequest implements IOutputResetRetryAttemptsRequest {
    /** List of output IDs you want to filter on. If this field is not empty, the other will be ignored. */
    outputIds?: string[] | undefined;
    /** List of Content IDs you want to filter on. */
    contentIds?: string[] | undefined;
    /** The file extension of the outputs you want to filter on. */
    fileExtensions?: string[] | undefined;
    /** The IDs of the output formats you want to filter on. */
    outputFormatIds?: string[] | undefined;
    /** Should the successful filter results also be reset (and subsequently re-rendered)? */
    includeCompleted!: boolean;

    constructor(data?: IOutputResetRetryAttemptsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["outputIds"])) {
                this.outputIds = [] as any;
                for (let item of _data["outputIds"])
                    this.outputIds!.push(item);
            }
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            if (Array.isArray(_data["fileExtensions"])) {
                this.fileExtensions = [] as any;
                for (let item of _data["fileExtensions"])
                    this.fileExtensions!.push(item);
            }
            if (Array.isArray(_data["outputFormatIds"])) {
                this.outputFormatIds = [] as any;
                for (let item of _data["outputFormatIds"])
                    this.outputFormatIds!.push(item);
            }
            this.includeCompleted = _data["includeCompleted"];
        }
    }

    static fromJS(data: any): OutputResetRetryAttemptsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OutputResetRetryAttemptsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.outputIds)) {
            data["outputIds"] = [];
            for (let item of this.outputIds)
                data["outputIds"].push(item);
        }
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        if (Array.isArray(this.fileExtensions)) {
            data["fileExtensions"] = [];
            for (let item of this.fileExtensions)
                data["fileExtensions"].push(item);
        }
        if (Array.isArray(this.outputFormatIds)) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        data["includeCompleted"] = this.includeCompleted;
        return data;
    }
}

export interface IOutputResetRetryAttemptsRequest {
    /** List of output IDs you want to filter on. If this field is not empty, the other will be ignored. */
    outputIds?: string[] | undefined;
    /** List of Content IDs you want to filter on. */
    contentIds?: string[] | undefined;
    /** The file extension of the outputs you want to filter on. */
    fileExtensions?: string[] | undefined;
    /** The IDs of the output formats you want to filter on. */
    outputFormatIds?: string[] | undefined;
    /** Should the successful filter results also be reset (and subsequently re-rendered)? */
    includeCompleted: boolean;
}

/** User profile. */
export class UserProfile implements IUserProfile {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;
    /** Authorization state. */
    authorizationState!: AuthorizationState;
    /** Indicates if the user is locked. */
    isLocked!: boolean;
    /** A list of user rights assigned to the user. */
    userRights?: UserRight[] | undefined;
    /** A list of user role IDs assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Indicates if the user has not accepted the latest terms of consent. */
    termsConsentExpired!: boolean;
    /** A list of system user roles assigned to the user. */
    systemUserRoles?: SystemUserRole[] | undefined;
    /** Indicates if the user has the developer flag set. */
    isDeveloper!: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated!: boolean;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.languageCode = _data["languageCode"];
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
            this.authorizationState = _data["authorizationState"];
            this.isLocked = _data["isLocked"];
            if (Array.isArray(_data["userRights"])) {
                this.userRights = [] as any;
                for (let item of _data["userRights"])
                    this.userRights!.push(item);
            }
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
            this.termsConsentExpired = _data["termsConsentExpired"];
            if (Array.isArray(_data["systemUserRoles"])) {
                this.systemUserRoles = [] as any;
                for (let item of _data["systemUserRoles"])
                    this.systemUserRoles!.push(item);
            }
            this.isDeveloper = _data["isDeveloper"];
            this.isFederated = _data["isFederated"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["authorizationState"] = this.authorizationState;
        data["isLocked"] = this.isLocked;
        if (Array.isArray(this.userRights)) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["termsConsentExpired"] = this.termsConsentExpired;
        if (Array.isArray(this.systemUserRoles)) {
            data["systemUserRoles"] = [];
            for (let item of this.systemUserRoles)
                data["systemUserRoles"].push(item);
        }
        data["isDeveloper"] = this.isDeveloper;
        data["isFederated"] = this.isFederated;
        return data;
    }
}

/** User profile. */
export interface IUserProfile {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: IUserAddress | undefined;
    /** Authorization state. */
    authorizationState: AuthorizationState;
    /** Indicates if the user is locked. */
    isLocked: boolean;
    /** A list of user rights assigned to the user. */
    userRights?: UserRight[] | undefined;
    /** A list of user role IDs assigned to the user. */
    userRoleIds?: string[] | undefined;
    /** Indicates if the user has not accepted the latest terms of consent. */
    termsConsentExpired: boolean;
    /** A list of system user roles assigned to the user. */
    systemUserRoles?: SystemUserRole[] | undefined;
    /** Indicates if the user has the developer flag set. */
    isDeveloper: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated: boolean;
}

/** User's address */
export class UserAddress implements IUserAddress {
    /** Company address line */
    company?: string | undefined;
    /** Company department. */
    department?: string | undefined;
    /** Street and house number. */
    address?: string | undefined;
    /** Additional address line. */
    alternativeAddress?: string | undefined;
    /** ZIP code. */
    zip?: string | undefined;
    /** City or town. */
    city?: string | undefined;
    /** Phone number. */
    phone?: string | undefined;
    /** Country code. */
    countryCode?: string | undefined;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.company = _data["company"];
            this.department = _data["department"];
            this.address = _data["address"];
            this.alternativeAddress = _data["alternativeAddress"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.phone = _data["phone"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["department"] = this.department;
        data["address"] = this.address;
        data["alternativeAddress"] = this.alternativeAddress;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

/** User's address */
export interface IUserAddress {
    /** Company address line */
    company?: string | undefined;
    /** Company department. */
    department?: string | undefined;
    /** Street and house number. */
    address?: string | undefined;
    /** Additional address line. */
    alternativeAddress?: string | undefined;
    /** ZIP code. */
    zip?: string | undefined;
    /** City or town. */
    city?: string | undefined;
    /** Phone number. */
    phone?: string | undefined;
    /** Country code. */
    countryCode?: string | undefined;
}

/** System user roles. */
export enum SystemUserRole {
    Administrator = "Administrator",
}

/** Request to update a user profile. */
export class UserProfileUpdateRequest implements IUserProfileUpdateRequest {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: UserAddress | undefined;

    constructor(data?: IUserProfileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.languageCode = _data["languageCode"];
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserProfileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to update a user profile. */
export interface IUserProfileUpdateRequest {
    /** ID of the user. */
    id?: string | undefined;
    /** Email address. */
    emailAddress?: string | undefined;
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Language code. */
    languageCode?: string | undefined;
    /** Address. */
    address?: IUserAddress | undefined;
}

/** Base class for detail of permission sets */
export abstract class PermissionSetDetailOfMetadataRight implements IPermissionSetDetailOfMetadataRight {
    /** The permission set ID. */
    id!: string;
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: PermissionUserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: PermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on the Content Item or List Item. */
    exclusive!: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId!: string;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IPermissionSetDetailOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfMetadataRight(item) : <PermissionUserRoleRightsOfMetadataRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new PermissionUserRoleRightsOfPermissionSetRight(item) : <PermissionUserRoleRightsOfPermissionSetRight>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(PermissionUserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(PermissionUserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = _data["exclusive"];
            this.ownerTokenId = _data["ownerTokenId"];
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionSetDetailOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetDetailOfMetadataRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["ownerTokenId"] = this.ownerTokenId;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        return data;
    }
}

/** Base class for detail of permission sets */
export interface IPermissionSetDetailOfMetadataRight {
    /** The permission set ID. */
    id: string;
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IPermissionUserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IPermissionUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on the Content Item or List Item. */
    exclusive: boolean;
    /** The owner token ID. Defines the permission set owner. */
    ownerTokenId: string;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

/** Detail of a schema permission set */
export class SchemaPermissionSetDetail extends PermissionSetDetailOfMetadataRight implements ISchemaPermissionSetDetail {

    constructor(data?: ISchemaPermissionSetDetail) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaPermissionSetDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Detail of a schema permission set */
export interface ISchemaPermissionSetDetail extends IPermissionSetDetailOfMetadataRight {
}

/** Rights assigned to a user role. */
export class PermissionUserRoleRightsOfMetadataRight implements IPermissionUserRoleRightsOfMetadataRight {
    /** The user role ID. */
    userRoleId!: string;
    /** Language specific user role names. */
    names?: TranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: MetadataRight[] | undefined;

    constructor(data?: IPermissionUserRoleRightsOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionUserRoleRightsOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

/** Rights assigned to a user role. */
export interface IPermissionUserRoleRightsOfMetadataRight {
    /** The user role ID. */
    userRoleId: string;
    /** Language specific user role names. */
    names?: ITranslatedStringDictionary | undefined;
    /** List of rights: they can be content, metadata or permission set rights, depending on the type defined on the class
(ContentRight, MetadataRight, PermissionSetRight). */
    rights?: MetadataRight[] | undefined;
}

export abstract class PermissionSetCreateRequestOfMetadataRight implements IPermissionSetCreateRequestOfMetadataRight {
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on Content Items or List Items. */
    exclusive!: boolean;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IPermissionSetCreateRequestOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfMetadataRight(item) : <UserRoleRightsOfMetadataRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfPermissionSetRight(item) : <UserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(UserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(UserRoleRightsOfPermissionSetRight.fromJS(item));
            }
            this.exclusive = _data["exclusive"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): PermissionSetCreateRequestOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetCreateRequestOfMetadataRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        data["exclusive"] = this.exclusive;
        data["requestId"] = this.requestId;
        return data;
    }
}

export interface IPermissionSetCreateRequestOfMetadataRight {
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IUserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
    /** When true this permission set will derogate all other configured permission sets on Content Items or List Items. */
    exclusive: boolean;
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to create a schema permission set */
export class SchemaPermissionSetCreateRequest extends PermissionSetCreateRequestOfMetadataRight implements ISchemaPermissionSetCreateRequest {

    constructor(data?: ISchemaPermissionSetCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaPermissionSetCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to create a schema permission set */
export interface ISchemaPermissionSetCreateRequest extends IPermissionSetCreateRequestOfMetadataRight {
}

export class UserRoleRightsOfMetadataRight implements IUserRoleRightsOfMetadataRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: MetadataRight[] | undefined;

    constructor(data?: IUserRoleRightsOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleId = _data["userRoleId"];
            if (Array.isArray(_data["rights"])) {
                this.rights = [] as any;
                for (let item of _data["rights"])
                    this.rights!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleRightsOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleRightsOfMetadataRight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleId"] = this.userRoleId;
        if (Array.isArray(this.rights)) {
            data["rights"] = [];
            for (let item of this.rights)
                data["rights"].push(item);
        }
        return data;
    }
}

export interface IUserRoleRightsOfMetadataRight {
    /** The user role id. */
    userRoleId?: string | undefined;
    /** A permission container which can hold content, metadata or permission set rights. */
    rights?: MetadataRight[] | undefined;
}

/** Base class for permission set update requests */
export abstract class PermissionSetUpdateRequestOfMetadataRight implements IPermissionSetUpdateRequestOfMetadataRight {
    /** Language specific permission set names. */
    names!: TranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: UserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: UserRoleRightsOfPermissionSetRight[] | undefined;

    constructor(data?: IPermissionSetUpdateRequestOfMetadataRight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.userRolesRights) {
                this.userRolesRights = [];
                for (let i = 0; i < data.userRolesRights.length; i++) {
                    let item = data.userRolesRights[i];
                    this.userRolesRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfMetadataRight(item) : <UserRoleRightsOfMetadataRight>item;
                }
            }
            if (data.userRolesPermissionSetRights) {
                this.userRolesPermissionSetRights = [];
                for (let i = 0; i < data.userRolesPermissionSetRights.length; i++) {
                    let item = data.userRolesPermissionSetRights[i];
                    this.userRolesPermissionSetRights[i] = item && !(<any>item).toJSON ? new UserRoleRightsOfPermissionSetRight(item) : <UserRoleRightsOfPermissionSetRight>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRolesRights"])) {
                this.userRolesRights = [] as any;
                for (let item of _data["userRolesRights"])
                    this.userRolesRights!.push(UserRoleRightsOfMetadataRight.fromJS(item));
            }
            if (Array.isArray(_data["userRolesPermissionSetRights"])) {
                this.userRolesPermissionSetRights = [] as any;
                for (let item of _data["userRolesPermissionSetRights"])
                    this.userRolesPermissionSetRights!.push(UserRoleRightsOfPermissionSetRight.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionSetUpdateRequestOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestOfMetadataRight' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRolesRights)) {
            data["userRolesRights"] = [];
            for (let item of this.userRolesRights)
                data["userRolesRights"].push(item.toJSON());
        }
        if (Array.isArray(this.userRolesPermissionSetRights)) {
            data["userRolesPermissionSetRights"] = [];
            for (let item of this.userRolesPermissionSetRights)
                data["userRolesPermissionSetRights"].push(item.toJSON());
        }
        return data;
    }
}

/** Base class for permission set update requests */
export interface IPermissionSetUpdateRequestOfMetadataRight {
    /** Language specific permission set names. */
    names: ITranslatedStringDictionary;
    /** A list of content or metadata rights authorizing operations on Content Items or List Items. */
    userRolesRights?: IUserRoleRightsOfMetadataRight[] | undefined;
    /** A list of permission set rights authorizing operations on this permission set. */
    userRolesPermissionSetRights?: IUserRoleRightsOfPermissionSetRight[] | undefined;
}

/** Request to update a schema permission set */
export class SchemaPermissionSetUpdateRequest extends PermissionSetUpdateRequestOfMetadataRight implements ISchemaPermissionSetUpdateRequest {

    constructor(data?: ISchemaPermissionSetUpdateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaPermissionSetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to update a schema permission set */
export interface ISchemaPermissionSetUpdateRequest extends IPermissionSetUpdateRequestOfMetadataRight {
}

/** Request to update multiple schema permission sets */
export class SchemaPermissionSetCreateManyRequest implements ISchemaPermissionSetCreateManyRequest {
    /** Schema permission sets create requests. */
    items?: SchemaPermissionSetCreateRequest[] | undefined;

    constructor(data?: ISchemaPermissionSetCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SchemaPermissionSetCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaPermissionSetCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple schema permission sets */
export interface ISchemaPermissionSetCreateManyRequest {
    /** Schema permission sets create requests. */
    items?: SchemaPermissionSetCreateRequest[] | undefined;
}

/** Request to update multiple schema permissions sets */
export class SchemaPermissionSetUpdateManyRequest implements ISchemaPermissionSetUpdateManyRequest {
    /** Schema permission sets update requests. */
    items?: SchemaPermissionSetUpdateRequestItem[] | undefined;

    constructor(data?: ISchemaPermissionSetUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SchemaPermissionSetUpdateRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaPermissionSetUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple schema permissions sets */
export interface ISchemaPermissionSetUpdateManyRequest {
    /** Schema permission sets update requests. */
    items?: SchemaPermissionSetUpdateRequestItem[] | undefined;
}

/** Base class for permission set update requests */
export abstract class PermissionSetUpdateRequestItemOfMetadataRight extends PermissionSetUpdateRequestOfMetadataRight implements IPermissionSetUpdateRequestItemOfMetadataRight {
    /** The permission set ID. */
    id!: string;

    constructor(data?: IPermissionSetUpdateRequestItemOfMetadataRight) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): PermissionSetUpdateRequestItemOfMetadataRight {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PermissionSetUpdateRequestItemOfMetadataRight' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Base class for permission set update requests */
export interface IPermissionSetUpdateRequestItemOfMetadataRight extends IPermissionSetUpdateRequestOfMetadataRight {
    /** The permission set ID. */
    id: string;
}

/** Request to update a schema permission set */
export class SchemaPermissionSetUpdateRequestItem extends PermissionSetUpdateRequestItemOfMetadataRight implements ISchemaPermissionSetUpdateRequestItem {

    constructor(data?: ISchemaPermissionSetUpdateRequestItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaPermissionSetUpdateRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaPermissionSetUpdateRequestItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request to update a schema permission set */
export interface ISchemaPermissionSetUpdateRequestItem extends IPermissionSetUpdateRequestItemOfMetadataRight {
}

/** The details of a schema */
export class SchemaDetail implements ISchemaDetail {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id!: string;
    /** System generated schema namespace. It contains the full schema hierarchy up to the root schema (i.e. [RootSchemaId].[ParentSchemaId].[SchemaId]). */
    schemaNamespace!: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types!: SchemaType[];
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns!: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system!: boolean;
    /** The owner token ID. Defines the schema owner. */
    ownerTokenId!: string;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** The complete list of all descendant schema IDs. */
    descendantSchemaIds?: string[] | undefined;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** The number of fields generated by the schema in the search index for filtering, searching and sorting. */
    searchFieldCount?: SearchFieldCount | undefined;
    /** Metadata protection options. */
    metadataProtection?: MetadataProtection | undefined;

    constructor(data?: ISchemaDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
            this.searchFieldCount = data.searchFieldCount && !(<any>data.searchFieldCount).toJSON ? new SearchFieldCount(data.searchFieldCount) : <SearchFieldCount>this.searchFieldCount;
            this.metadataProtection = data.metadataProtection && !(<any>data.metadataProtection).toJSON ? new MetadataProtection(data.metadataProtection) : <MetadataProtection>this.metadataProtection;
        }
        if (!data) {
            this.types = [];
            this.displayPatterns = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schemaNamespace = _data["schemaNamespace"];
            this.parentSchemaId = _data["parentSchemaId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["displayPatterns"])) {
                this.displayPatterns = [] as any;
                for (let item of _data["displayPatterns"])
                    this.displayPatterns!.push(DisplayPattern.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldBase.fromJS(item));
            }
            if (Array.isArray(_data["fieldsOverwrite"])) {
                this.fieldsOverwrite = [] as any;
                for (let item of _data["fieldsOverwrite"])
                    this.fieldsOverwrite!.push(FieldOverwriteBase.fromJS(item));
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            this.system = _data["system"];
            this.ownerTokenId = _data["ownerTokenId"];
            this.viewForAll = _data["viewForAll"];
            if (Array.isArray(_data["schemaPermissionSetIds"])) {
                this.schemaPermissionSetIds = [] as any;
                for (let item of _data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds!.push(item);
            }
            if (Array.isArray(_data["referencedInContentSchemaIds"])) {
                this.referencedInContentSchemaIds = [] as any;
                for (let item of _data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds!.push(item);
            }
            if (Array.isArray(_data["descendantSchemaIds"])) {
                this.descendantSchemaIds = [] as any;
                for (let item of _data["descendantSchemaIds"])
                    this.descendantSchemaIds!.push(item);
            }
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
            this.searchFieldCount = _data["searchFieldCount"] ? SearchFieldCount.fromJS(_data["searchFieldCount"]) : <any>undefined;
            this.metadataProtection = _data["metadataProtection"] ? MetadataProtection.fromJS(_data["metadataProtection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schemaNamespace"] = this.schemaNamespace;
        data["parentSchemaId"] = this.parentSchemaId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (Array.isArray(this.displayPatterns)) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.fieldsOverwrite)) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        data["system"] = this.system;
        data["ownerTokenId"] = this.ownerTokenId;
        data["viewForAll"] = this.viewForAll;
        if (Array.isArray(this.schemaPermissionSetIds)) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (Array.isArray(this.referencedInContentSchemaIds)) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        if (Array.isArray(this.descendantSchemaIds)) {
            data["descendantSchemaIds"] = [];
            for (let item of this.descendantSchemaIds)
                data["descendantSchemaIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["searchFieldCount"] = this.searchFieldCount ? this.searchFieldCount.toJSON() : <any>undefined;
        data["metadataProtection"] = this.metadataProtection ? this.metadataProtection.toJSON() : <any>undefined;
        return data;
    }
}

/** The details of a schema */
export interface ISchemaDetail {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id: string;
    /** System generated schema namespace. It contains the full schema hierarchy up to the root schema (i.e. [RootSchemaId].[ParentSchemaId].[SchemaId]). */
    schemaNamespace: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types: SchemaType[];
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
    /** The owner token ID. Defines the schema owner. */
    ownerTokenId: string;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** The complete list of all descendant schema IDs. */
    descendantSchemaIds?: string[] | undefined;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
    /** The number of fields generated by the schema in the search index for filtering, searching and sorting. */
    searchFieldCount?: ISearchFieldCount | undefined;
    /** Metadata protection options. */
    metadataProtection?: IMetadataProtection | undefined;
}

/** Represent the template whose value will be resolved based on the actual content. */
export class DisplayPattern implements IDisplayPattern {
    /** The template engine used for parsing the display patterns. */
    templateEngine!: TemplateEngine;
    /** The display pattern type. */
    displayPatternType!: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: TranslatedStringDictionary | undefined;

    constructor(data?: IDisplayPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.templates = data.templates && !(<any>data.templates).toJSON ? new TranslatedStringDictionary(data.templates) : <TranslatedStringDictionary>this.templates;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateEngine = _data["templateEngine"];
            this.displayPatternType = _data["displayPatternType"];
            this.templates = _data["templates"] ? TranslatedStringDictionary.fromJS(_data["templates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DisplayPattern {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateEngine"] = this.templateEngine;
        data["displayPatternType"] = this.displayPatternType;
        data["templates"] = this.templates ? this.templates.toJSON() : <any>undefined;
        return data;
    }
}

/** Represent the template whose value will be resolved based on the actual content. */
export interface IDisplayPattern {
    /** The template engine used for parsing the display patterns. */
    templateEngine: TemplateEngine;
    /** The display pattern type. */
    displayPatternType: DisplayPatternType;
    /** Language specific pattern templates. */
    templates?: ITranslatedStringDictionary | undefined;
}

/** The template engine used for parsing the display patterns */
export enum TemplateEngine {
    DotLiquid = "DotLiquid",
}

/** The field base class */
export abstract class FieldBase implements IFieldBase {
    /** The field ID. It can be a slug; it must be unique within the schema hierarchy (ancestors / descendants); it must be begin with lower case. */
    id!: string;
    /** The index ID is auto generated by the system. */
    indexId?: string | undefined;
    /** The field namespace is auto generated by the system: it carries the hierarchy information. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required!: boolean;
    /** Field is stored for filtering. */
    index!: boolean;
    /** Field is stored for simple search. */
    simpleSearch!: boolean;
    /** Field is stored for sorting. */
    sortable!: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
        }
        this._discriminator = "FieldBase";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.indexId = _data["indexId"];
            this.fieldNamespace = _data["fieldNamespace"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            this.required = _data["required"];
            this.index = _data["index"];
            this.simpleSearch = _data["simpleSearch"];
            this.sortable = _data["sortable"];
        }
    }

    static fromJS(data: any): FieldBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldBoolean") {
            let result = new FieldBoolean();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDate") {
            let result = new FieldDate();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTime") {
            let result = new FieldDateTime();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDecimal") {
            let result = new FieldDecimal();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionary") {
            let result = new FieldDictionary();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldGeoPoint") {
            let result = new FieldGeoPoint();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTrigger") {
            let result = new FieldTrigger();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLong") {
            let result = new FieldLong();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleFieldset") {
            let result = new FieldSingleFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiFieldset") {
            let result = new FieldMultiFieldset();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleTagbox") {
            let result = new FieldSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiTagbox") {
            let result = new FieldMultiTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldString") {
            let result = new FieldString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldTranslatedString") {
            let result = new FieldTranslatedString();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldSingleRelation") {
            let result = new FieldSingleRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldMultiRelation") {
            let result = new FieldMultiRelation();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldDynamicView") {
            let result = new FieldDynamicView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        data["indexId"] = this.indexId;
        data["fieldNamespace"] = this.fieldNamespace;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["required"] = this.required;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["sortable"] = this.sortable;
        return data;
    }
}

/** The field base class */
export interface IFieldBase {
    /** The field ID. It can be a slug; it must be unique within the schema hierarchy (ancestors / descendants); it must be begin with lower case. */
    id: string;
    /** The index ID is auto generated by the system. */
    indexId?: string | undefined;
    /** The field namespace is auto generated by the system: it carries the hierarchy information. */
    fieldNamespace?: string | undefined;
    /** Language specific field names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific field descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Defines if a field value is mandatory or not. */
    required: boolean;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Field is stored for sorting. */
    sortable: boolean;
}

/** The field used to store a boolean */
export class FieldBoolean extends FieldBase implements IFieldBoolean {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldBoolean) {
        super(data);
        this._discriminator = "FieldBoolean";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldBoolean();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a boolean */
export interface IFieldBoolean extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a date */
export class FieldDate extends FieldBase implements IFieldDate {
    /** The date format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldDate) {
        super(data);
        this._discriminator = "FieldDate";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.format = _data["format"];
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldDate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a date */
export interface IFieldDate extends IFieldBase {
    /** The date format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a date time */
export class FieldDateTime extends FieldBase implements IFieldDateTime {
    /** The date time format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** If set to true, the date time value is automatically set when a content or list item is created. */
    initializeOnItemCreation?: boolean;

    constructor(data?: IFieldDateTime) {
        super(data);
        this._discriminator = "FieldDateTime";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.format = _data["format"];
            this.boost = _data["boost"];
            this.initializeOnItemCreation = _data["initializeOnItemCreation"];
        }
    }

    static override fromJS(data: any): FieldDateTime {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDateTimeArray") {
            let result = new FieldDateTimeArray();
            result.init(data);
            return result;
        }
        let result = new FieldDateTime();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["boost"] = this.boost;
        data["initializeOnItemCreation"] = this.initializeOnItemCreation;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a date time */
export interface IFieldDateTime extends IFieldBase {
    /** The date time format structure. */
    format?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** If set to true, the date time value is automatically set when a content or list item is created. */
    initializeOnItemCreation?: boolean;
}

/** The field used to store multiple date time values */
export class FieldDateTimeArray extends FieldDateTime implements IFieldDateTimeArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldDateTimeArray) {
        super(data);
        this._discriminator = "FieldDateTimeArray";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
        }
    }

    static override fromJS(data: any): FieldDateTimeArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDateTimeArray();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple date time values */
export interface IFieldDateTimeArray extends IFieldDateTime {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a decimal value */
export class FieldDecimal extends FieldBase implements IFieldDecimal {
    /** The decimal pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldDecimal) {
        super(data);
        this._discriminator = "FieldDecimal";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pattern = _data["pattern"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDecimal();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a decimal value */
export interface IFieldDecimal extends IFieldBase {
    /** The decimal pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a dictionary of values */
export class FieldDictionary extends FieldBase implements IFieldDictionary {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldDictionary) {
        super(data);
        this._discriminator = "FieldDictionary";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldDictionary {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldDictionaryArray") {
            let result = new FieldDictionaryArray();
            result.init(data);
            return result;
        }
        let result = new FieldDictionary();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a dictionary of values */
export interface IFieldDictionary extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store multiple dictionaries' values */
export class FieldDictionaryArray extends FieldDictionary implements IFieldDictionaryArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldDictionaryArray) {
        super(data);
        this._discriminator = "FieldDictionaryArray";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
        }
    }

    static override fromJS(data: any): FieldDictionaryArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDictionaryArray();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple dictionaries' values */
export interface IFieldDictionaryArray extends IFieldDictionary {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a geo point */
export class FieldGeoPoint extends FieldBase implements IFieldGeoPoint {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldGeoPoint) {
        super(data);
        this._discriminator = "FieldGeoPoint";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldGeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new FieldGeoPoint();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a geo point */
export interface IFieldGeoPoint extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** A field that can be triggered, and store in such occasion the id of the user and the time that triggered it. The last user who triggered it and the last time in which it was triggered can be used for filtering or for simple search (if enabled on the field). Such information are stored in two inner fields: "triggeredBy" and "triggeredOn". In order to be triggered in a Content or ListItem metadata dictionary, the special '"_trigger": true' should be sent in the data of the field itself. */
export class FieldTrigger extends FieldBase implements IFieldTrigger {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldTrigger) {
        super(data);
        this._discriminator = "FieldTrigger";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldTrigger {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTrigger();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** A field that can be triggered, and store in such occasion the id of the user and the time that triggered it. The last user who triggered it and the last time in which it was triggered can be used for filtering or for simple search (if enabled on the field). Such information are stored in two inner fields: "triggeredBy" and "triggeredOn". In order to be triggered in a Content or ListItem metadata dictionary, the special '"_trigger": true' should be sent in the data of the field itself. */
export interface IFieldTrigger extends IFieldBase {
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store a long value */
export class FieldLong extends FieldBase implements IFieldLong {
    /** The long pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;

    constructor(data?: IFieldLong) {
        super(data);
        this._discriminator = "FieldLong";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pattern = _data["pattern"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.boost = _data["boost"];
        }
    }

    static override fromJS(data: any): FieldLong {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldLongArray") {
            let result = new FieldLongArray();
            result.init(data);
            return result;
        }
        let result = new FieldLong();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["boost"] = this.boost;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a long value */
export interface IFieldLong extends IFieldBase {
    /** The long pattern structure. */
    pattern?: string | undefined;
    /** The minimum possible value. */
    minimum?: number | undefined;
    /** The maximum possible value. */
    maximum?: number | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
}

/** The field used to store multiple long values */
export class FieldLongArray extends FieldLong implements IFieldLongArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldLongArray) {
        super(data);
        this._discriminator = "FieldLongArray";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
        }
    }

    static override fromJS(data: any): FieldLongArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLongArray();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple long values */
export interface IFieldLongArray extends IFieldLong {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single fieldset */
export class FieldSingleFieldset extends FieldBase implements IFieldSingleFieldset {
    /** The ID of the schema to be used as fieldset (it must be of type Struct). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldSingleFieldset) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
        }
        this._discriminator = "FieldSingleFieldset";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FieldSingleFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleFieldset();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a single fieldset */
export interface IFieldSingleFieldset extends IFieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
}

/** Indexing information for a schema */
export class SchemaIndexingInfo implements ISchemaIndexingInfo {
    /** A collection of indexing information for the fields of a schema */
    fields?: FieldIndexingInfo[] | undefined;
    /** Schema's display value Name is stored for filtering. Only available for tagbox fields. */
    includeNameDisplayValueInFilters!: boolean;

    constructor(data?: ISchemaIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.fields) {
                this.fields = [];
                for (let i = 0; i < data.fields.length; i++) {
                    let item = data.fields[i];
                    this.fields[i] = item && !(<any>item).toJSON ? new FieldIndexingInfo(item) : <FieldIndexingInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldIndexingInfo.fromJS(item));
            }
            this.includeNameDisplayValueInFilters = _data["includeNameDisplayValueInFilters"];
        }
    }

    static fromJS(data: any): SchemaIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["includeNameDisplayValueInFilters"] = this.includeNameDisplayValueInFilters;
        return data;
    }
}

/** Indexing information for a schema */
export interface ISchemaIndexingInfo {
    /** A collection of indexing information for the fields of a schema */
    fields?: IFieldIndexingInfo[] | undefined;
    /** Schema's display value Name is stored for filtering. Only available for tagbox fields. */
    includeNameDisplayValueInFilters: boolean;
}

/** Indexing information for a field of a schema */
export class FieldIndexingInfo implements IFieldIndexingInfo {
    /** The field ID. */
    id!: string;
    /** Field is stored for filtering. */
    index!: boolean;
    /** Field is stored for simple search. */
    simpleSearch!: boolean;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost!: number;
    /** Indexing information of schema's fields related to this field (if existing). */
    relatedSchemaIndexing?: SchemaIndexingInfo | undefined;

    constructor(data?: IFieldIndexingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.relatedSchemaIndexing = data.relatedSchemaIndexing && !(<any>data.relatedSchemaIndexing).toJSON ? new SchemaIndexingInfo(data.relatedSchemaIndexing) : <SchemaIndexingInfo>this.relatedSchemaIndexing;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.simpleSearch = _data["simpleSearch"];
            this.boost = _data["boost"];
            this.relatedSchemaIndexing = _data["relatedSchemaIndexing"] ? SchemaIndexingInfo.fromJS(_data["relatedSchemaIndexing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldIndexingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldIndexingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["simpleSearch"] = this.simpleSearch;
        data["boost"] = this.boost;
        data["relatedSchemaIndexing"] = this.relatedSchemaIndexing ? this.relatedSchemaIndexing.toJSON() : <any>undefined;
        return data;
    }
}

/** Indexing information for a field of a schema */
export interface IFieldIndexingInfo {
    /** The field ID. */
    id: string;
    /** Field is stored for filtering. */
    index: boolean;
    /** Field is stored for simple search. */
    simpleSearch: boolean;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost: number;
    /** Indexing information of schema's fields related to this field (if existing). */
    relatedSchemaIndexing?: ISchemaIndexingInfo | undefined;
}

/** The field used to store multiple fieldsets */
export class FieldMultiFieldset extends FieldBase implements IFieldMultiFieldset {
    /** The ID of the schema to be used as fieldset (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldMultiFieldset) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
        }
        this._discriminator = "FieldMultiFieldset";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
        }
    }

    static override fromJS(data: any): FieldMultiFieldset {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiFieldset();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple fieldsets */
export interface IFieldMultiFieldset extends IFieldBase {
    /** The ID of the schema to be used as fieldset (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a single tagbox */
export class FieldSingleTagbox extends FieldBase implements IFieldSingleTagbox {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;

    constructor(data?: IFieldSingleTagbox) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
        }
        this._discriminator = "FieldSingleTagbox";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = _data["listItemCreateTemplate"];
            this.viewModeDisplayPatternType = _data["viewModeDisplayPatternType"];
        }
    }

    static override fromJS(data: any): FieldSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleTagbox();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["viewModeDisplayPatternType"] = this.viewModeDisplayPatternType;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a single tagbox */
export interface IFieldSingleTagbox extends IFieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** An optional filter to limit the list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;
}

/** The field used to store multiple tagboxes */
export class FieldMultiTagbox extends FieldBase implements IFieldMultiTagbox {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** An optional filter to limit the returned list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;

    constructor(data?: IFieldMultiTagbox) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
        }
        this._discriminator = "FieldMultiTagbox";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.listItemCreateTemplate = _data["listItemCreateTemplate"];
            this.viewModeDisplayPatternType = _data["viewModeDisplayPatternType"];
        }
    }

    static override fromJS(data: any): FieldMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiTagbox();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["viewModeDisplayPatternType"] = this.viewModeDisplayPatternType;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple tagboxes */
export interface IFieldMultiTagbox extends IFieldBase {
    /** The ID of the schema to be used as tagbox (it must be of type List). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** An optional filter to limit the returned list items. */
    filter?: FilterBase | undefined;
    /** Json serialized template used for creating new list item (no logic is implemented in backend). */
    listItemCreateTemplate?: string | undefined;
    /** Defines the display pattern type to be used (Name or List only) when showing a tagbox item in view mode. Defaults to "Name".
The information is only consumed by the client application. No actual logic is implemented in the backend. */
    viewModeDisplayPatternType?: DisplayPatternType;
}

/** The field used to store a string value */
export class FieldString extends FieldBase implements IFieldString {
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template. */
    template?: string | undefined;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's length. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** If values are stored in this list, field values are limited to these ones. */
    grantedValues?: string[] | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** Stores information on how values of this field should be rendered */
    renderingType?: StringRenderingType;

    constructor(data?: IFieldString) {
        super(data);
        this._discriminator = "FieldString";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.template = _data["template"];
            this.pattern = _data["pattern"];
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            if (Array.isArray(_data["indexAnalyzers"])) {
                this.indexAnalyzers = [] as any;
                for (let item of _data["indexAnalyzers"])
                    this.indexAnalyzers!.push(AnalyzerBase.fromJS(item));
            }
            if (Array.isArray(_data["simpleSearchAnalyzers"])) {
                this.simpleSearchAnalyzers = [] as any;
                for (let item of _data["simpleSearchAnalyzers"])
                    this.simpleSearchAnalyzers!.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = _data["multiLine"];
            if (Array.isArray(_data["grantedValues"])) {
                this.grantedValues = [] as any;
                for (let item of _data["grantedValues"])
                    this.grantedValues!.push(item);
            }
            this.boost = _data["boost"];
            this.renderingType = _data["renderingType"];
        }
    }

    static override fromJS(data: any): FieldString {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldStringArray") {
            let result = new FieldStringArray();
            result.init(data);
            return result;
        }
        let result = new FieldString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (Array.isArray(this.indexAnalyzers)) {
            data["indexAnalyzers"] = [];
            for (let item of this.indexAnalyzers)
                data["indexAnalyzers"].push(item.toJSON());
        }
        if (Array.isArray(this.simpleSearchAnalyzers)) {
            data["simpleSearchAnalyzers"] = [];
            for (let item of this.simpleSearchAnalyzers)
                data["simpleSearchAnalyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (Array.isArray(this.grantedValues)) {
            data["grantedValues"] = [];
            for (let item of this.grantedValues)
                data["grantedValues"].push(item);
        }
        data["boost"] = this.boost;
        data["renderingType"] = this.renderingType;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a string value */
export interface IFieldString extends IFieldBase {
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template. */
    template?: string | undefined;
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's length. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** If values are stored in this list, field values are limited to these ones. */
    grantedValues?: string[] | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** Stores information on how values of this field should be rendered */
    renderingType?: StringRenderingType;
}

/** The analyzer base class */
export abstract class AnalyzerBase implements IAnalyzerBase {

    protected _discriminator: string;

    constructor(data?: IAnalyzerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AnalyzerBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): AnalyzerBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "EdgeNGramAnalyzer") {
            let result = new EdgeNGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "LanguageAnalyzer") {
            let result = new LanguageAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NGramAnalyzer") {
            let result = new NGramAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "PathHierarchyAnalyzer") {
            let result = new PathHierarchyAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SimpleAnalyzer") {
            let result = new SimpleAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NoDiacriticsAnalyzer") {
            let result = new NoDiacriticsAnalyzer();
            result.init(data);
            return result;
        }
        if (data["kind"] === "KeywordLowercaseAnalyzer") {
            let result = new KeywordLowercaseAnalyzer();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AnalyzerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** The analyzer base class */
export interface IAnalyzerBase {
}

/** An analyzer using the ElasticSearch's EdgeNGram tokenizer */
export class EdgeNGramAnalyzer extends AnalyzerBase implements IEdgeNGramAnalyzer {
    /** The analyzer type: EdgeNGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: edgengram. */
    fieldSuffix?: string | undefined;

    constructor(data?: IEdgeNGramAnalyzer) {
        super(data);
        this._discriminator = "EdgeNGramAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): EdgeNGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new EdgeNGramAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer using the ElasticSearch's EdgeNGram tokenizer */
export interface IEdgeNGramAnalyzer extends IAnalyzerBase {
    /** The analyzer type: EdgeNGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: edgengram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using an ElasticSearch's language tokenizer */
export class LanguageAnalyzer extends AnalyzerBase implements ILanguageAnalyzer {
    /** The analyzer type: Language */
    type?: Analyzer;
    /** The suffix for the analyzed field: language. */
    fieldSuffix?: string | undefined;

    constructor(data?: ILanguageAnalyzer) {
        super(data);
        this._discriminator = "LanguageAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): LanguageAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer using an ElasticSearch's language tokenizer */
export interface ILanguageAnalyzer extends IAnalyzerBase {
    /** The analyzer type: Language */
    type?: Analyzer;
    /** The suffix for the analyzed field: language. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's NGram tokenizer */
export class NGramAnalyzer extends AnalyzerBase implements INGramAnalyzer {
    /** The analyzer type: NGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: ngram. */
    fieldSuffix?: string | undefined;

    constructor(data?: INGramAnalyzer) {
        super(data);
        this._discriminator = "NGramAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): NGramAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new NGramAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer using the ElasticSearch's NGram tokenizer */
export interface INGramAnalyzer extends IAnalyzerBase {
    /** The analyzer type: NGram */
    type?: Analyzer;
    /** The suffix for the analyzed field: ngram. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using the ElasticSearch's path hierarchy tokenizer */
export class PathHierarchyAnalyzer extends AnalyzerBase implements IPathHierarchyAnalyzer {
    /** The analyzer type: PathHierarchy */
    type?: Analyzer;
    /** The suffix for the analyzed field: pathhierarchy. */
    fieldSuffix?: string | undefined;

    constructor(data?: IPathHierarchyAnalyzer) {
        super(data);
        this._discriminator = "PathHierarchyAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): PathHierarchyAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new PathHierarchyAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer using the ElasticSearch's path hierarchy tokenizer */
export interface IPathHierarchyAnalyzer extends IAnalyzerBase {
    /** The analyzer type: PathHierarchy */
    type?: Analyzer;
    /** The suffix for the analyzed field: pathhierarchy. */
    fieldSuffix?: string | undefined;
}

/** An analyzer using a custom pattern tokenizer */
export class SimpleAnalyzer extends AnalyzerBase implements ISimpleAnalyzer {
    /** The analyzer type: Simple */
    type?: Analyzer;
    /** The suffix for the analyzed field: simple. */
    fieldSuffix?: string | undefined;

    constructor(data?: ISimpleAnalyzer) {
        super(data);
        this._discriminator = "SimpleAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): SimpleAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer using a custom pattern tokenizer */
export interface ISimpleAnalyzer extends IAnalyzerBase {
    /** The analyzer type: Simple */
    type?: Analyzer;
    /** The suffix for the analyzed field: simple. */
    fieldSuffix?: string | undefined;
}

/** An analyzer that removes diacritics from words and uses a custom pattern tokenizer */
export class NoDiacriticsAnalyzer extends AnalyzerBase implements INoDiacriticsAnalyzer {
    /** The analyzer type: NoDiacritics */
    type?: Analyzer;
    /** The suffix for the analyzed field: nodiacritics. */
    fieldSuffix?: string | undefined;

    constructor(data?: INoDiacriticsAnalyzer) {
        super(data);
        this._discriminator = "NoDiacriticsAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): NoDiacriticsAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new NoDiacriticsAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer that removes diacritics from words and uses a custom pattern tokenizer */
export interface INoDiacriticsAnalyzer extends IAnalyzerBase {
    /** The analyzer type: NoDiacritics */
    type?: Analyzer;
    /** The suffix for the analyzed field: nodiacritics. */
    fieldSuffix?: string | undefined;
}

/** An analyzer that represents a lowercase normalizer on a keyword field */
export class KeywordLowercaseAnalyzer extends AnalyzerBase implements IKeywordLowercaseAnalyzer {
    /** The analyzer type: KeywordLowercase */
    type?: Analyzer;
    /** The suffix for the analyzed field: keywordlowercase. */
    fieldSuffix?: string | undefined;

    constructor(data?: IKeywordLowercaseAnalyzer) {
        super(data);
        this._discriminator = "KeywordLowercaseAnalyzer";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.fieldSuffix = _data["fieldSuffix"];
        }
    }

    static override fromJS(data: any): KeywordLowercaseAnalyzer {
        data = typeof data === 'object' ? data : {};
        let result = new KeywordLowercaseAnalyzer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["fieldSuffix"] = this.fieldSuffix;
        super.toJSON(data);
        return data;
    }
}

/** An analyzer that represents a lowercase normalizer on a keyword field */
export interface IKeywordLowercaseAnalyzer extends IAnalyzerBase {
    /** The analyzer type: KeywordLowercase */
    type?: Analyzer;
    /** The suffix for the analyzed field: keywordlowercase. */
    fieldSuffix?: string | undefined;
}

/** Describes how a string value should be rendered */
export enum StringRenderingType {
    Default = "Default",
    Markdown = "Markdown",
}

/** The field used to store multiple string values */
export class FieldStringArray extends FieldString implements IFieldStringArray {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;

    constructor(data?: IFieldStringArray) {
        super(data);
        this._discriminator = "FieldStringArray";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
        }
    }

    static override fromJS(data: any): FieldStringArray {
        data = typeof data === 'object' ? data : {};
        let result = new FieldStringArray();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple string values */
export interface IFieldStringArray extends IFieldString {
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
}

/** The field used to store a translated string values */
export class FieldTranslatedString extends FieldBase implements IFieldTranslatedString {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's length. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory. */
    requiredMetadataLanguages?: string[] | undefined;
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template.
             */
    template?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** Stores information on how values of this field should be rendered */
    renderingType?: StringRenderingType;

    constructor(data?: IFieldTranslatedString) {
        super(data);
        this._discriminator = "FieldTranslatedString";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pattern = _data["pattern"];
            this.minimumLength = _data["minimumLength"];
            this.maximumLength = _data["maximumLength"];
            if (Array.isArray(_data["indexAnalyzers"])) {
                this.indexAnalyzers = [] as any;
                for (let item of _data["indexAnalyzers"])
                    this.indexAnalyzers!.push(AnalyzerBase.fromJS(item));
            }
            if (Array.isArray(_data["simpleSearchAnalyzers"])) {
                this.simpleSearchAnalyzers = [] as any;
                for (let item of _data["simpleSearchAnalyzers"])
                    this.simpleSearchAnalyzers!.push(AnalyzerBase.fromJS(item));
            }
            this.multiLine = _data["multiLine"];
            if (Array.isArray(_data["requiredMetadataLanguages"])) {
                this.requiredMetadataLanguages = [] as any;
                for (let item of _data["requiredMetadataLanguages"])
                    this.requiredMetadataLanguages!.push(item);
            }
            this.template = _data["template"];
            this.boost = _data["boost"];
            this.renderingType = _data["renderingType"];
        }
    }

    static override fromJS(data: any): FieldTranslatedString {
        data = typeof data === 'object' ? data : {};
        let result = new FieldTranslatedString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pattern"] = this.pattern;
        data["minimumLength"] = this.minimumLength;
        data["maximumLength"] = this.maximumLength;
        if (Array.isArray(this.indexAnalyzers)) {
            data["indexAnalyzers"] = [];
            for (let item of this.indexAnalyzers)
                data["indexAnalyzers"].push(item.toJSON());
        }
        if (Array.isArray(this.simpleSearchAnalyzers)) {
            data["simpleSearchAnalyzers"] = [];
            for (let item of this.simpleSearchAnalyzers)
                data["simpleSearchAnalyzers"].push(item.toJSON());
        }
        data["multiLine"] = this.multiLine;
        if (Array.isArray(this.requiredMetadataLanguages)) {
            data["requiredMetadataLanguages"] = [];
            for (let item of this.requiredMetadataLanguages)
                data["requiredMetadataLanguages"].push(item);
        }
        data["template"] = this.template;
        data["boost"] = this.boost;
        data["renderingType"] = this.renderingType;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a translated string values */
export interface IFieldTranslatedString extends IFieldBase {
    /** Contains a regex validation pattern. */
    pattern?: string | undefined;
    /** The minimum string's length. */
    minimumLength?: number | undefined;
    /** The maximum string's length. */
    maximumLength?: number | undefined;
    /** Defines how the value must be analyzed for filtering by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the Index property is set to true. */
    indexAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines how the value must be analyzed for searches by ElasticSearch. A string field can have multiple analyzers, but only one per analyzer type.
The analyzers are applied only if the SimpleSearch property is set to true. */
    simpleSearchAnalyzers?: AnalyzerBase[] | undefined;
    /** Defines that the field value must be displayed in a multiline component. */
    multiLine?: boolean;
    /** Sets the required metadata languages for the translation field. The langauge configuration limits the available metadata languages.
If Required is true, the field and all its metadata languages are required.
If Required is false, the field can be left empty, but as soon as a value is entered all required metadata languages are mandatory. */
    requiredMetadataLanguages?: string[] | undefined;
    /** A DotLiquid template. If set, it transforms the field in a calculated field, so that its value is calculated based on this template.
             */
    template?: string | undefined;
    /** Value to prioritize search results. Set to 1 by default. Ignored if SimpleSearch not set to true. */
    boost?: number;
    /** Stores information on how values of this field should be rendered */
    renderingType?: StringRenderingType;
}

/** The field used to store a single relation */
export class FieldSingleRelation extends FieldBase implements IFieldSingleRelation {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** Defines the allowed elation types. */
    relationTypes!: RelationType[];
    /** Settings for displaying purposes in the UI */
    uiSettings?: RelationUiSettings | undefined;

    constructor(data?: IFieldSingleRelation) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
            if (data.relationTypes) {
                this.relationTypes = [];
                for (let i = 0; i < data.relationTypes.length; i++) {
                    let item = data.relationTypes[i];
                    this.relationTypes[i] = item && !(<any>item).toJSON ? new RelationType(item) : <RelationType>item;
                }
            }
            this.uiSettings = data.uiSettings && !(<any>data.uiSettings).toJSON ? new RelationUiSettings(data.uiSettings) : <RelationUiSettings>this.uiSettings;
        }
        if (!data) {
            this.relationTypes = [];
        }
        this._discriminator = "FieldSingleRelation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
            if (Array.isArray(_data["relationTypes"])) {
                this.relationTypes = [] as any;
                for (let item of _data["relationTypes"])
                    this.relationTypes!.push(RelationType.fromJS(item));
            }
            this.uiSettings = _data["uiSettings"] ? RelationUiSettings.fromJS(_data["uiSettings"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FieldSingleRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldSingleRelation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.relationTypes)) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["uiSettings"] = this.uiSettings ? this.uiSettings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store a single relation */
export interface IFieldSingleRelation extends IFieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** Defines the allowed elation types. */
    relationTypes: IRelationType[];
    /** Settings for displaying purposes in the UI */
    uiSettings?: IRelationUiSettings | undefined;
}

/** Defines a relation */
export class RelationType implements IRelationType {
    /** The ID of the relation type. */
    id!: string;
    /** Language specific relation names. */
    names?: TranslatedStringDictionary | undefined;
    /** Defines the type of the document target of the relation. Currently supported: Content, ListItem. */
    targetDocType!: string;
    /** An optional filter to limit the documents of type TargetDocType. */
    filter?: FilterBase | undefined;

    constructor(data?: IRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.targetDocType = _data["targetDocType"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RelationType {
        data = typeof data === 'object' ? data : {};
        let result = new RelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["targetDocType"] = this.targetDocType;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data;
    }
}

/** Defines a relation */
export interface IRelationType {
    /** The ID of the relation type. */
    id: string;
    /** Language specific relation names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Defines the type of the document target of the relation. Currently supported: Content, ListItem. */
    targetDocType: string;
    /** An optional filter to limit the documents of type TargetDocType. */
    filter?: FilterBase | undefined;
}

export abstract class ItemFieldUiSettingsViewItemBase implements IItemFieldUiSettingsViewItemBase {
    /** Maximum number of rows to be displayed in the List view. */
    maxListRows?: number | undefined;
    /** Maximum number of rows to be displayed in the Thumbnail views. */
    maxThumbRows?: number | undefined;
    /** The view to be used when rendering the field. */
    view!: ItemFieldViewMode;
    /** Whether related content should be shown in UI download dialog */
    showRelatedContentOnDownload?: boolean | undefined;

    constructor(data?: IItemFieldUiSettingsViewItemBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxListRows = _data["maxListRows"];
            this.maxThumbRows = _data["maxThumbRows"];
            this.view = _data["view"];
            this.showRelatedContentOnDownload = _data["showRelatedContentOnDownload"];
        }
    }

    static fromJS(data: any): ItemFieldUiSettingsViewItemBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ItemFieldUiSettingsViewItemBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxListRows"] = this.maxListRows;
        data["maxThumbRows"] = this.maxThumbRows;
        data["view"] = this.view;
        data["showRelatedContentOnDownload"] = this.showRelatedContentOnDownload;
        return data;
    }
}

export interface IItemFieldUiSettingsViewItemBase {
    /** Maximum number of rows to be displayed in the List view. */
    maxListRows?: number | undefined;
    /** Maximum number of rows to be displayed in the Thumbnail views. */
    maxThumbRows?: number | undefined;
    /** The view to be used when rendering the field. */
    view: ItemFieldViewMode;
    /** Whether related content should be shown in UI download dialog */
    showRelatedContentOnDownload?: boolean | undefined;
}

/** Ui settings for the single and multi relationship fields */
export class RelationUiSettings extends ItemFieldUiSettingsViewItemBase implements IRelationUiSettings {

    constructor(data?: IRelationUiSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RelationUiSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RelationUiSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Ui settings for the single and multi relationship fields */
export interface IRelationUiSettings extends IItemFieldUiSettingsViewItemBase {
}

/** The view mode for related items */
export enum ItemFieldViewMode {
    List = "List",
    ThumbSmall = "ThumbSmall",
    ThumbMedium = "ThumbMedium",
    ThumbLarge = "ThumbLarge",
}

/** Ui settings for FieldDynamicView */
export class DynamicViewFieldUiSettings extends ItemFieldUiSettingsViewItemBase implements IDynamicViewFieldUiSettings {

    constructor(data?: IDynamicViewFieldUiSettings) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): DynamicViewFieldUiSettings {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicViewFieldUiSettings();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Ui settings for FieldDynamicView */
export interface IDynamicViewFieldUiSettings extends IItemFieldUiSettingsViewItemBase {
}

/** The field used to store multiple relations */
export class FieldMultiRelation extends FieldBase implements IFieldMultiRelation {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId!: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: SchemaIndexingInfo | undefined;
    /** The relation types supported by the field. */
    relationTypes!: RelationType[];
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** Settings for displaying purposes in the UI */
    uiSettings?: RelationUiSettings | undefined;

    constructor(data?: IFieldMultiRelation) {
        super(data);
        if (data) {
            this.schemaIndexingInfo = data.schemaIndexingInfo && !(<any>data.schemaIndexingInfo).toJSON ? new SchemaIndexingInfo(data.schemaIndexingInfo) : <SchemaIndexingInfo>this.schemaIndexingInfo;
            if (data.relationTypes) {
                this.relationTypes = [];
                for (let i = 0; i < data.relationTypes.length; i++) {
                    let item = data.relationTypes[i];
                    this.relationTypes[i] = item && !(<any>item).toJSON ? new RelationType(item) : <RelationType>item;
                }
            }
            this.uiSettings = data.uiSettings && !(<any>data.uiSettings).toJSON ? new RelationUiSettings(data.uiSettings) : <RelationUiSettings>this.uiSettings;
        }
        if (!data) {
            this.relationTypes = [];
        }
        this._discriminator = "FieldMultiRelation";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.schemaId = _data["schemaId"];
            this.schemaIndexingInfo = _data["schemaIndexingInfo"] ? SchemaIndexingInfo.fromJS(_data["schemaIndexingInfo"]) : <any>undefined;
            if (Array.isArray(_data["relationTypes"])) {
                this.relationTypes = [] as any;
                for (let item of _data["relationTypes"])
                    this.relationTypes!.push(RelationType.fromJS(item));
            }
            this.maximumItems = _data["maximumItems"];
            this.minimumItems = _data["minimumItems"];
            this.uiSettings = _data["uiSettings"] ? RelationUiSettings.fromJS(_data["uiSettings"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FieldMultiRelation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMultiRelation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        data["schemaIndexingInfo"] = this.schemaIndexingInfo ? this.schemaIndexingInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.relationTypes)) {
            data["relationTypes"] = [];
            for (let item of this.relationTypes)
                data["relationTypes"].push(item.toJSON());
        }
        data["maximumItems"] = this.maximumItems;
        data["minimumItems"] = this.minimumItems;
        data["uiSettings"] = this.uiSettings ? this.uiSettings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** The field used to store multiple relations */
export interface IFieldMultiRelation extends IFieldBase {
    /** The ID of the schema used for relation metadata (it must be of type Struct, and it cannot be a system schema). */
    schemaId: string;
    /** Indexing information of fields of the related schema identified by the SchemaId property. */
    schemaIndexingInfo?: ISchemaIndexingInfo | undefined;
    /** The relation types supported by the field. */
    relationTypes: IRelationType[];
    /** The maximum number of items that can be stored. */
    maximumItems?: number | undefined;
    /** The minimum number of items that must be stored. */
    minimumItems?: number | undefined;
    /** Settings for displaying purposes in the UI */
    uiSettings?: IRelationUiSettings | undefined;
}

/** Stores a filter template which can be used to query for related items */
export class FieldDynamicView extends FieldBase implements IFieldDynamicView {
    /** Type of item this field points to. Restricted to Content at this time. */
    targetDocType!: string;
    /** Settings for displaying purposes in the UI */
    viewUiSettings!: DynamicViewFieldUiSettings;
    /** Template to generate filter based on current item. */
    filterTemplate!: FilterBase;
    /** Specifies sorting to be used in search with FilterBase> from FilterTemplate */
    sort!: SortInfo[];

    constructor(data?: IFieldDynamicView) {
        super(data);
        if (data) {
            this.viewUiSettings = data.viewUiSettings && !(<any>data.viewUiSettings).toJSON ? new DynamicViewFieldUiSettings(data.viewUiSettings) : <DynamicViewFieldUiSettings>this.viewUiSettings;
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.viewUiSettings = new DynamicViewFieldUiSettings();
            this.filterTemplate = new FilterBase();
            this.sort = [];
        }
        this._discriminator = "FieldDynamicView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.targetDocType = _data["targetDocType"];
            this.viewUiSettings = _data["viewUiSettings"] ? DynamicViewFieldUiSettings.fromJS(_data["viewUiSettings"]) : new DynamicViewFieldUiSettings();
            this.filterTemplate = _data["filterTemplate"] ? FilterBase.fromJS(_data["filterTemplate"]) : new FilterBase();
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): FieldDynamicView {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDynamicView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetDocType"] = this.targetDocType;
        data["viewUiSettings"] = this.viewUiSettings ? this.viewUiSettings.toJSON() : <any>undefined;
        data["filterTemplate"] = this.filterTemplate ? this.filterTemplate.toJSON() : <any>undefined;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Stores a filter template which can be used to query for related items */
export interface IFieldDynamicView extends IFieldBase {
    /** Type of item this field points to. Restricted to Content at this time. */
    targetDocType: string;
    /** Settings for displaying purposes in the UI */
    viewUiSettings: IDynamicViewFieldUiSettings;
    /** Template to generate filter based on current item. */
    filterTemplate: FilterBase;
    /** Specifies sorting to be used in search with FilterBase> from FilterTemplate */
    sort: ISortInfo[];
}

/** Base class to overwrite field's information */
export abstract class FieldOverwriteBase implements IFieldOverwriteBase {
    /** The field's ID whose information need to be overwritten. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not: this value will overwrite the existing Required value specified in the parent schema  if
OverwriteRequired is set to true. */
    required!: boolean;
    /** Enable the overwriting of the Required property of the field specified by the Id property. */
    overwriteRequired!: boolean;

    protected _discriminator: string;

    constructor(data?: IFieldOverwriteBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldOverwriteBase";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.required = _data["required"];
            this.overwriteRequired = _data["overwriteRequired"];
        }
    }

    static fromJS(data: any): FieldOverwriteBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "FieldOverwriteSingleTagbox") {
            let result = new FieldOverwriteSingleTagbox();
            result.init(data);
            return result;
        }
        if (data["kind"] === "FieldOverwriteMultiTagbox") {
            let result = new FieldOverwriteMultiTagbox();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'FieldOverwriteBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        data["required"] = this.required;
        data["overwriteRequired"] = this.overwriteRequired;
        return data;
    }
}

/** Base class to overwrite field's information */
export interface IFieldOverwriteBase {
    /** The field's ID whose information need to be overwritten. */
    id?: string | undefined;
    /** Defines if a field value is mandatory or not: this value will overwrite the existing Required value specified in the parent schema  if
OverwriteRequired is set to true. */
    required: boolean;
    /** Enable the overwriting of the Required property of the field specified by the Id property. */
    overwriteRequired: boolean;
}

/** Overwritten information for FieldSingleTagbox */
export class FieldOverwriteSingleTagbox extends FieldOverwriteBase implements IFieldOverwriteSingleTagbox {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema  if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema  if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;

    constructor(data?: IFieldOverwriteSingleTagbox) {
        super(data);
        this._discriminator = "FieldOverwriteSingleTagbox";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.overwriteFilter = _data["overwriteFilter"];
            this.listItemCreateTemplate = _data["listItemCreateTemplate"];
            this.overwriteListItemCreateTemplate = _data["overwriteListItemCreateTemplate"];
        }
    }

    static override fromJS(data: any): FieldOverwriteSingleTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteSingleTagbox();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["overwriteFilter"] = this.overwriteFilter;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["overwriteListItemCreateTemplate"] = this.overwriteListItemCreateTemplate;
        super.toJSON(data);
        return data;
    }
}

/** Overwritten information for FieldSingleTagbox */
export interface IFieldOverwriteSingleTagbox extends IFieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema  if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema  if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;
}

/** Overwritten information for FieldMultiTagbox */
export class FieldOverwriteMultiTagbox extends FieldOverwriteBase implements IFieldOverwriteMultiTagbox {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;
    /** The maximum number of items that can be stored: this value will overwrite the existing MaximumItems value specified in the parent schema if
OverwriteMaximumItems is set to true. */
    maximumItems?: number | undefined;
    /** Enable the overwriting of the MaximumItems property of the field specified by the Id property. */
    overwriteMaximumItems?: boolean;
    /** The minimum number of items that must be stored: this value will overwrite the existing MinimumItems value specified in the parent schema if
OverwriteMinimumItems is set to true. */
    minimumItems?: number | undefined;
    /** Enable the overwriting of the MinimumItems property of the field specified by the Id property. */
    overwriteMinimumItems?: boolean;

    constructor(data?: IFieldOverwriteMultiTagbox) {
        super(data);
        this._discriminator = "FieldOverwriteMultiTagbox";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.overwriteFilter = _data["overwriteFilter"];
            this.listItemCreateTemplate = _data["listItemCreateTemplate"];
            this.overwriteListItemCreateTemplate = _data["overwriteListItemCreateTemplate"];
            this.maximumItems = _data["maximumItems"];
            this.overwriteMaximumItems = _data["overwriteMaximumItems"];
            this.minimumItems = _data["minimumItems"];
            this.overwriteMinimumItems = _data["overwriteMinimumItems"];
        }
    }

    static override fromJS(data: any): FieldOverwriteMultiTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOverwriteMultiTagbox();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["overwriteFilter"] = this.overwriteFilter;
        data["listItemCreateTemplate"] = this.listItemCreateTemplate;
        data["overwriteListItemCreateTemplate"] = this.overwriteListItemCreateTemplate;
        data["maximumItems"] = this.maximumItems;
        data["overwriteMaximumItems"] = this.overwriteMaximumItems;
        data["minimumItems"] = this.minimumItems;
        data["overwriteMinimumItems"] = this.overwriteMinimumItems;
        super.toJSON(data);
        return data;
    }
}

/** Overwritten information for FieldMultiTagbox */
export interface IFieldOverwriteMultiTagbox extends IFieldOverwriteBase {
    /** An optional filter to limit the list items: this value will overwrite the existing Filter value specified in the parent schema if
OverwriteFilter is set to true. */
    filter?: FilterBase | undefined;
    /** Enable the overwriting of the Filter property of the field specified by the Id property. */
    overwriteFilter?: boolean;
    /** Json serialized template used for creating new list item: this value will overwrite the existing ListItemCreateTemplate value specified in the parent schema if
OverwriteListItemCreateTemplate is set to true. */
    listItemCreateTemplate?: string | undefined;
    /** Enable the overwriting of the ListItemCreateTemplate property of the field specified by the Id property. */
    overwriteListItemCreateTemplate?: boolean;
    /** The maximum number of items that can be stored: this value will overwrite the existing MaximumItems value specified in the parent schema if
OverwriteMaximumItems is set to true. */
    maximumItems?: number | undefined;
    /** Enable the overwriting of the MaximumItems property of the field specified by the Id property. */
    overwriteMaximumItems?: boolean;
    /** The minimum number of items that must be stored: this value will overwrite the existing MinimumItems value specified in the parent schema if
OverwriteMinimumItems is set to true. */
    minimumItems?: number | undefined;
    /** Enable the overwriting of the MinimumItems property of the field specified by the Id property. */
    overwriteMinimumItems?: boolean;
}

/** Count information of fields in the search index for filtering, searching and sorting */
export class SearchFieldCount implements ISearchFieldCount {
    /** The number of fields created in the search index to store filter information for a schema. */
    indexedField!: number;
    /** The number of fields created in the search index to store search information for a schema. */
    simpleSearchField!: number;
    /** The number of fields created in the search index to store sorting information for a schema. */
    sortableField!: number;

    constructor(data?: ISearchFieldCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.indexedField = _data["indexedField"];
            this.simpleSearchField = _data["simpleSearchField"];
            this.sortableField = _data["sortableField"];
        }
    }

    static fromJS(data: any): SearchFieldCount {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFieldCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexedField"] = this.indexedField;
        data["simpleSearchField"] = this.simpleSearchField;
        data["sortableField"] = this.sortableField;
        return data;
    }
}

/** Count information of fields in the search index for filtering, searching and sorting */
export interface ISearchFieldCount {
    /** The number of fields created in the search index to store filter information for a schema. */
    indexedField: number;
    /** The number of fields created in the search index to store search information for a schema. */
    simpleSearchField: number;
    /** The number of fields created in the search index to store sorting information for a schema. */
    sortableField: number;
}

/** Metadata protection options */
export class MetadataProtection implements IMetadataProtection {
    /** Prevent creation of items in ContentSchemas/Lists or assignments of Layers. */
    preventCreate!: boolean;
    /** Prevent updating metadata associated with schema. */
    preventUpdate!: boolean;
    /** Prevent deletion of items in ContentSchemas/Lists or unassignments of Layers. */
    preventDelete!: boolean;

    constructor(data?: IMetadataProtection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preventCreate = _data["preventCreate"];
            this.preventUpdate = _data["preventUpdate"];
            this.preventDelete = _data["preventDelete"];
        }
    }

    static fromJS(data: any): MetadataProtection {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataProtection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preventCreate"] = this.preventCreate;
        data["preventUpdate"] = this.preventUpdate;
        data["preventDelete"] = this.preventDelete;
        return data;
    }
}

/** Metadata protection options */
export interface IMetadataProtection {
    /** Prevent creation of items in ContentSchemas/Lists or assignments of Layers. */
    preventCreate: boolean;
    /** Prevent updating metadata associated with schema. */
    preventUpdate: boolean;
    /** Prevent deletion of items in ContentSchemas/Lists or unassignments of Layers. */
    preventDelete: boolean;
}

/** Exists response */
export class SchemaExistsResponse implements ISchemaExistsResponse {
    /** It indicates if it exists. */
    exists!: boolean;

    constructor(data?: ISchemaExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exists = _data["exists"];
        }
    }

    static fromJS(data: any): SchemaExistsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        return data;
    }
}

/** Exists response */
export interface ISchemaExistsResponse {
    /** It indicates if it exists. */
    exists: boolean;
}

/** Response for a query if a field exists */
export class FieldExistsResponse implements IFieldExistsResponse {
    /** Indicates if a field with the specified ID currently exists. */
    exists!: boolean;
    /** Indicates if a field with the specified ID was previously used.
A field ID that was previously in use cannot be used again. */
    previouslyUsed!: boolean;
    /** If the field does already exist or has already existed, this will contain the ID
of the schema containing it. It case of parent-child schemas, a field ID
has to be unique across the schema hierarchy. */
    schemaId?: string | undefined;

    constructor(data?: IFieldExistsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exists = _data["exists"];
            this.previouslyUsed = _data["previouslyUsed"];
            this.schemaId = _data["schemaId"];
        }
    }

    static fromJS(data: any): FieldExistsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FieldExistsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        data["previouslyUsed"] = this.previouslyUsed;
        data["schemaId"] = this.schemaId;
        return data;
    }
}

/** Response for a query if a field exists */
export interface IFieldExistsResponse {
    /** Indicates if a field with the specified ID currently exists. */
    exists: boolean;
    /** Indicates if a field with the specified ID was previously used.
A field ID that was previously in use cannot be used again. */
    previouslyUsed: boolean;
    /** If the field does already exist or has already existed, this will contain the ID
of the schema containing it. It case of parent-child schemas, a field ID
has to be unique across the schema hierarchy. */
    schemaId?: string | undefined;
}

/** Result of a schema update operation */
export class SchemaUpdateResult implements ISchemaUpdateResult {
    /** The details of the updated schema. */
    schema?: SchemaDetail | undefined;

    constructor(data?: ISchemaUpdateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.schema = data.schema && !(<any>data.schema).toJSON ? new SchemaDetail(data.schema) : <SchemaDetail>this.schema;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schema = _data["schema"] ? SchemaDetail.fromJS(_data["schema"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaUpdateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data;
    }
}

/** Result of a schema update operation */
export interface ISchemaUpdateResult {
    /** The details of the updated schema. */
    schema?: ISchemaDetail | undefined;
}

/** Request to update an existing schema */
export class SchemaUpdateRequest implements ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: DisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Metadata protection options. */
    metadataProtection?: MetadataProtection | undefined;

    constructor(data?: ISchemaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.metadataProtection = data.metadataProtection && !(<any>data.metadataProtection).toJSON ? new MetadataProtection(data.metadataProtection) : <MetadataProtection>this.metadataProtection;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            if (Array.isArray(_data["displayPatterns"])) {
                this.displayPatterns = [] as any;
                for (let item of _data["displayPatterns"])
                    this.displayPatterns!.push(DisplayPattern.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldBase.fromJS(item));
            }
            if (Array.isArray(_data["fieldsOverwrite"])) {
                this.fieldsOverwrite = [] as any;
                for (let item of _data["fieldsOverwrite"])
                    this.fieldsOverwrite!.push(FieldOverwriteBase.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.viewForAll = _data["viewForAll"];
            if (Array.isArray(_data["schemaPermissionSetIds"])) {
                this.schemaPermissionSetIds = [] as any;
                for (let item of _data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds!.push(item);
            }
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["referencedInContentSchemaIds"])) {
                this.referencedInContentSchemaIds = [] as any;
                for (let item of _data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds!.push(item);
            }
            this.metadataProtection = _data["metadataProtection"] ? MetadataProtection.fromJS(_data["metadataProtection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (Array.isArray(this.displayPatterns)) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.fieldsOverwrite)) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["viewForAll"] = this.viewForAll;
        if (Array.isArray(this.schemaPermissionSetIds)) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (Array.isArray(this.referencedInContentSchemaIds)) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        data["metadataProtection"] = this.metadataProtection ? this.metadataProtection.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to update an existing schema */
export interface ISchemaUpdateRequest {
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns?: IDisplayPattern[] | undefined;
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Metadata protection options. */
    metadataProtection?: IMetadataProtection | undefined;
}

/** Result of a schema delete operation */
export class SchemaDeleteResult implements ISchemaDeleteResult {

    constructor(data?: ISchemaDeleteResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): SchemaDeleteResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaDeleteResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Result of a schema delete operation */
export interface ISchemaDeleteResult {
}

export class SchemaOwnershipTransferRequest implements ISchemaOwnershipTransferRequest {
    /** The id of the user to whom the schema has to be transferred to. */
    transferUserId?: string | undefined;

    constructor(data?: ISchemaOwnershipTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferUserId = _data["transferUserId"];
        }
    }

    static fromJS(data: any): SchemaOwnershipTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaOwnershipTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferUserId"] = this.transferUserId;
        return data;
    }
}

export interface ISchemaOwnershipTransferRequest {
    /** The id of the user to whom the schema has to be transferred to. */
    transferUserId?: string | undefined;
}

/** Result of a schema create operation */
export class SchemaCreateResult implements ISchemaCreateResult {
    /** The details of the created schema. */
    schema?: SchemaDetail | undefined;

    constructor(data?: ISchemaCreateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.schema = data.schema && !(<any>data.schema).toJSON ? new SchemaDetail(data.schema) : <SchemaDetail>this.schema;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schema = _data["schema"] ? SchemaDetail.fromJS(_data["schema"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaCreateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data;
    }
}

/** Result of a schema create operation */
export interface ISchemaCreateResult {
    /** The details of the created schema. */
    schema?: ISchemaDetail | undefined;
}

/** Request to create a schema */
export class SchemaCreateRequest implements ISchemaCreateRequest {
    /** The schema ID. It can be a slug, but must be unique throughout the whole customer setup. */
    id!: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns!: DisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: SortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll!: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Metadata protection options. */
    metadataProtection?: MetadataProtection | undefined;

    constructor(data?: ISchemaCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
            if (data.displayPatterns) {
                this.displayPatterns = [];
                for (let i = 0; i < data.displayPatterns.length; i++) {
                    let item = data.displayPatterns[i];
                    this.displayPatterns[i] = item && !(<any>item).toJSON ? new DisplayPattern(item) : <DisplayPattern>item;
                }
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
            this.metadataProtection = data.metadataProtection && !(<any>data.metadataProtection).toJSON ? new MetadataProtection(data.metadataProtection) : <MetadataProtection>this.metadataProtection;
        }
        if (!data) {
            this.displayPatterns = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentSchemaId = _data["parentSchemaId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            if (Array.isArray(_data["displayPatterns"])) {
                this.displayPatterns = [] as any;
                for (let item of _data["displayPatterns"])
                    this.displayPatterns!.push(DisplayPattern.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldBase.fromJS(item));
            }
            if (Array.isArray(_data["fieldsOverwrite"])) {
                this.fieldsOverwrite = [] as any;
                for (let item of _data["fieldsOverwrite"])
                    this.fieldsOverwrite!.push(FieldOverwriteBase.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.viewForAll = _data["viewForAll"];
            if (Array.isArray(_data["schemaPermissionSetIds"])) {
                this.schemaPermissionSetIds = [] as any;
                for (let item of _data["schemaPermissionSetIds"])
                    this.schemaPermissionSetIds!.push(item);
            }
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (Array.isArray(_data["referencedInContentSchemaIds"])) {
                this.referencedInContentSchemaIds = [] as any;
                for (let item of _data["referencedInContentSchemaIds"])
                    this.referencedInContentSchemaIds!.push(item);
            }
            this.metadataProtection = _data["metadataProtection"] ? MetadataProtection.fromJS(_data["metadataProtection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchemaCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (Array.isArray(this.displayPatterns)) {
            data["displayPatterns"] = [];
            for (let item of this.displayPatterns)
                data["displayPatterns"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.fieldsOverwrite)) {
            data["fieldsOverwrite"] = [];
            for (let item of this.fieldsOverwrite)
                data["fieldsOverwrite"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["viewForAll"] = this.viewForAll;
        if (Array.isArray(this.schemaPermissionSetIds)) {
            data["schemaPermissionSetIds"] = [];
            for (let item of this.schemaPermissionSetIds)
                data["schemaPermissionSetIds"].push(item);
        }
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (Array.isArray(this.referencedInContentSchemaIds)) {
            data["referencedInContentSchemaIds"] = [];
            for (let item of this.referencedInContentSchemaIds)
                data["referencedInContentSchemaIds"].push(item);
        }
        data["metadataProtection"] = this.metadataProtection ? this.metadataProtection.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to create a schema */
export interface ISchemaCreateRequest {
    /** The schema ID. It can be a slug, but must be unique throughout the whole customer setup. */
    id: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** Language specific DotLiquid templates. These templates will be resolved into display values in content documents and/or list items. */
    displayPatterns: IDisplayPattern[];
    /** The schema fields. */
    fields?: FieldBase[] | undefined;
    /** A list of schema fields overwrite information. It is used to overwrite the field configuration coming from the parent schema.
Only a subset of properties of a FieldSingleTagbox and FieldMultiTagbox can be be overwritten. All other properties and fields cannot. */
    fieldsOverwrite?: FieldOverwriteBase[] | undefined;
    /** An optional list of aggregations to show grouped list item documents. When aggregations are defined for a List,
the UI uses such information to show the available filters and grouped results. */
    aggregations?: AggregatorBase[] | undefined;
    /** Sorts content documents and/or list items. In order for the sorting to work properly, the Sortable property of the related field
must be set to true. Multiple sorting is supported: they are applied in the specified order. */
    sort?: ISortInfo[] | undefined;
    /** Defines a schema as viewable by everyone. Everyone with ManageSchema user permission is able to see the schema. */
    viewForAll: boolean;
    /** An optional list of schema permission set IDs which control schema permissions. */
    schemaPermissionSetIds?: string[] | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** If the schema if of type Layer, the list contains the schemas with type Content
that reference the layer. */
    referencedInContentSchemaIds?: string[] | undefined;
    /** Metadata protection options. */
    metadataProtection?: IMetadataProtection | undefined;
}

/** Request to create multiple schemas */
export class SchemaCreateManyRequest implements ISchemaCreateManyRequest {
    /** The schemas to create. Cyclic dependencies between schemas are supported, if they
are all in the same request. */
    schemas!: SchemaCreateRequest[];

    constructor(data?: ISchemaCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.schemas) {
                this.schemas = [];
                for (let i = 0; i < data.schemas.length; i++) {
                    let item = data.schemas[i];
                    this.schemas[i] = item && !(<any>item).toJSON ? new SchemaCreateRequest(item) : <SchemaCreateRequest>item;
                }
            }
        }
        if (!data) {
            this.schemas = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schemas"])) {
                this.schemas = [] as any;
                for (let item of _data["schemas"])
                    this.schemas!.push(SchemaCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemas)) {
            data["schemas"] = [];
            for (let item of this.schemas)
                data["schemas"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to create multiple schemas */
export interface ISchemaCreateManyRequest {
    /** The schemas to create. Cyclic dependencies between schemas are supported, if they
are all in the same request. */
    schemas: ISchemaCreateRequest[];
}

/** Request to update multiple schemas */
export class SchemaUpdateManyRequest implements ISchemaUpdateManyRequest {
    /** The schemas to update. */
    schemas!: SchemaUpdateItem[];

    constructor(data?: ISchemaUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schemas = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schemas"])) {
                this.schemas = [] as any;
                for (let item of _data["schemas"])
                    this.schemas!.push(SchemaUpdateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemas)) {
            data["schemas"] = [];
            for (let item of this.schemas)
                data["schemas"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update multiple schemas */
export interface ISchemaUpdateManyRequest {
    /** The schemas to update. */
    schemas: SchemaUpdateItem[];
}

/** Item to update a schema */
export class SchemaUpdateItem extends SchemaUpdateRequest implements ISchemaUpdateItem {
    /** Id of the schema to update */
    id!: string;

    constructor(data?: ISchemaUpdateItem) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): SchemaUpdateItem {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaUpdateItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Item to update a schema */
export interface ISchemaUpdateItem extends ISchemaUpdateRequest {
    /** Id of the schema to update */
    id: string;
}

export class SchemaOwnershipTransferManyRequest implements ISchemaOwnershipTransferManyRequest {
    /** The schema ids. */
    schemaIds?: string[] | undefined;
    /** The id of user to whom the schemas have to be transferred to. */
    transferUserId?: string | undefined;

    constructor(data?: ISchemaOwnershipTransferManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["schemaIds"])) {
                this.schemaIds = [] as any;
                for (let item of _data["schemaIds"])
                    this.schemaIds!.push(item);
            }
            this.transferUserId = _data["transferUserId"];
        }
    }

    static fromJS(data: any): SchemaOwnershipTransferManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaOwnershipTransferManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.schemaIds)) {
            data["schemaIds"] = [];
            for (let item of this.schemaIds)
                data["schemaIds"].push(item);
        }
        data["transferUserId"] = this.transferUserId;
        return data;
    }
}

export interface ISchemaOwnershipTransferManyRequest {
    /** The schema ids. */
    schemaIds?: string[] | undefined;
    /** The id of user to whom the schemas have to be transferred to. */
    transferUserId?: string | undefined;
}

/** Base class for search results */
export class BaseResultOfSchema implements IBaseResultOfSchema {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Schema[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfSchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Schema(item) : <Schema>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Schema.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfSchema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfSchema {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ISchema[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfSchema extends BaseResultOfSchema implements ISearchBehaviorBaseResultOfSchema {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfSchema) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfSchema();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfSchema extends IBaseResultOfSchema {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfSchema extends SearchBehaviorBaseResultOfSchema implements ISearchBehaviorWithAggregationBaseResultOfSchema {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfSchema) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfSchema {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfSchema();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfSchema extends ISearchBehaviorBaseResultOfSchema {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Result for schema search operation */
export class SchemaSearchResult extends SearchBehaviorWithAggregationBaseResultOfSchema implements ISchemaSearchResult {

    constructor(data?: ISchemaSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SchemaSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result for schema search operation */
export interface ISchemaSearchResult extends ISearchBehaviorWithAggregationBaseResultOfSchema {
}

/** A schema */
export class Schema implements ISchema {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id!: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: TranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: TranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount!: number;
    /** The count of all schema descendants with an immediate inheritance. */
    childCount!: number;
    /** The descendant depth of the schema. */
    level!: number;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system!: boolean;

    constructor(data?: ISchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentSchemaId = _data["parentSchemaId"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.fieldCount = _data["fieldCount"];
            this.childCount = _data["childCount"];
            this.level = _data["level"];
            this.system = _data["system"];
        }
    }

    static fromJS(data: any): Schema {
        data = typeof data === 'object' ? data : {};
        let result = new Schema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentSchemaId"] = this.parentSchemaId;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["fieldCount"] = this.fieldCount;
        data["childCount"] = this.childCount;
        data["level"] = this.level;
        data["system"] = this.system;
        return data;
    }
}

/** A schema */
export interface ISchema {
    /** The schema ID. It is unique throughout the whole customer setup. */
    id: string;
    /** The parent schema ID. */
    parentSchemaId?: string | undefined;
    /** List of schema types. Currently only one schema type can be assigned to this list, and it cannot be modified once the schema is created. */
    types?: SchemaType[] | undefined;
    /** Language specific schema names. */
    names?: ITranslatedStringDictionary | undefined;
    /** Language specific schema descriptions. */
    descriptions?: ITranslatedStringDictionary | undefined;
    /** An optional list of schemas' IDs with type layer. For a Content schema it stores the layers that can be assigned to a content. */
    layerSchemaIds?: string[] | undefined;
    /** The count of all fields. */
    fieldCount: number;
    /** The count of all schema descendants with an immediate inheritance. */
    childCount: number;
    /** The descendant depth of the schema. */
    level: number;
    /** Identifies a system provided schema. A system schema cannot be created, updated or deleted. */
    system: boolean;
}

/** Request to search schemas */
export class SchemaSearchRequest implements ISchemaSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Currently only sorting on the Names property is allowed. */
    sort?: SortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the schemas. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the SchemaSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the schemas to the ones the user has the specified MetadataRights. */
    rightsFilter?: MetadataRight[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;

    constructor(data?: ISchemaSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            if (Array.isArray(_data["rightsFilter"])) {
                this.rightsFilter = [] as any;
                for (let item of _data["rightsFilter"])
                    this.rightsFilter!.push(item);
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchemaSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        if (Array.isArray(this.rightsFilter)) {
            data["rightsFilter"] = [];
            for (let item of this.rightsFilter)
                data["rightsFilter"].push(item);
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to search schemas */
export interface ISchemaSearchRequest {
    /** The string used to query the data. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied in the specified order. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Sorts the search results. Currently only sorting on the Names property is allowed. */
    sort?: ISortInfo[] | undefined;
    /** Limits the number of the returned schemas. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional filter to limit the schemas. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the SchemaSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
    /** When searching in multi language fields, limit the searchable fields to the ones corresponding to the specified languages.
If not specified, all metadata languages in the system are used. */
    searchLanguages?: string[] | undefined;
    /** Limits the schemas to the ones the user has the specified MetadataRights. */
    rightsFilter?: MetadataRight[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
}

/** Represents a transfer. */
export class Transfer implements ITransfer {
    /** ID of transfer. */
    id!: string;
    /** Name of transfer. */
    name!: string;
    /** State of transfer. */
    state!: TransferState;
    /** Type of transfer. */
    transferType!: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string | undefined;
    /** Number of files in transfer. */
    fileTransferCount!: number;
    /** ID of collection created from transfer. */
    collectionId?: string | undefined;

    constructor(data?: ITransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.transferType = _data["transferType"];
            this.businessProcessId = _data["businessProcessId"];
            this.fileTransferCount = _data["fileTransferCount"];
            this.collectionId = _data["collectionId"];
        }
    }

    static fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["transferType"] = this.transferType;
        data["businessProcessId"] = this.businessProcessId;
        data["fileTransferCount"] = this.fileTransferCount;
        data["collectionId"] = this.collectionId;
        return data;
    }
}

/** Represents a transfer. */
export interface ITransfer {
    /** ID of transfer. */
    id: string;
    /** Name of transfer. */
    name: string;
    /** State of transfer. */
    state: TransferState;
    /** Type of transfer. */
    transferType: TransferType;
    /** Associated business process ID. */
    businessProcessId?: string | undefined;
    /** Number of files in transfer. */
    fileTransferCount: number;
    /** ID of collection created from transfer. */
    collectionId?: string | undefined;
}

/** Transfer states */
export enum TransferState {
    Draft = "Draft",
    UploadInProgress = "UploadInProgress",
    UploadCompleted = "UploadCompleted",
    ImportInProgress = "ImportInProgress",
    ImportCompleted = "ImportCompleted",
    UploadCancelled = "UploadCancelled",
    ImportCancelled = "ImportCancelled",
    ImportFailed = "ImportFailed",
    Created = "Created",
    Deleted = "Deleted",
    TransferReady = "TransferReady",
    FileDeleteInProgress = "FileDeleteInProgress",
    TransferCleanup = "TransferCleanup",
    ImportCompletedWithErrors = "ImportCompletedWithErrors",
    UploadCompletedWithErrors = "UploadCompletedWithErrors",
    UploadCancellationInProgress = "UploadCancellationInProgress",
    ImportDone = "ImportDone",
}

/** Request to import schemas and list items */
export class SchemaImportRequest implements ISchemaImportRequest {
    /** ID of the file transfer identifying the file previously uploaded. */
    fileTransferId!: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies!: boolean;
    /** Import the list items belonging to the schema. */
    importListItems!: boolean;

    constructor(data?: ISchemaImportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileTransferId = _data["fileTransferId"];
            this.allowMissingDependencies = _data["allowMissingDependencies"];
            this.importListItems = _data["importListItems"];
        }
    }

    static fromJS(data: any): SchemaImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SchemaImportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileTransferId"] = this.fileTransferId;
        data["allowMissingDependencies"] = this.allowMissingDependencies;
        data["importListItems"] = this.importListItems;
        return data;
    }
}

/** Request to import schemas and list items */
export interface ISchemaImportRequest {
    /** ID of the file transfer identifying the file previously uploaded. */
    fileTransferId: string;
    /** Allow creating list items that refer to list items or contents that don't exist in the system. */
    allowMissingDependencies: boolean;
    /** Import the list items belonging to the schema. */
    importListItems: boolean;
}

/** Share detail */
export class ShareDetail implements IShareDetail {
    /** Share ID. */
    id!: string;
    /** Name of share. */
    name!: string;
    /** Description of share entered by user. */
    description?: string | undefined;
    /** Creator of share. */
    creator!: ShareUser;
    /** Audit information. */
    audit!: UserAudit;
    /** Detailed information about contents in the share. */
    contentSelections!: ShareContentDetail[];
    /** List of all contents in share including outputs. */
    contents!: ShareContentBase[];
    /** List of shared layers. */
    layerSchemaIds?: string[] | undefined;
    /** Detail of share. */
    data?: ShareDataBase | undefined;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Info if share is already expired. */
    expired!: boolean;
    /** Defined access for contents in share. */
    outputAccess!: OutputAccess;
    /** Type of share. */
    shareType!: ShareType;
    /** Schema detail of the content and the layers. */
    schemas?: SchemaDetail[] | undefined;
    /** Page token to retrieve next page of content selections. */
    pageToken?: string | undefined;
    /** Number of contents in share. */
    contentCount!: number;

    constructor(data?: IShareDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.creator = data.creator && !(<any>data.creator).toJSON ? new ShareUser(data.creator) : <ShareUser>this.creator;
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
            if (data.contentSelections) {
                this.contentSelections = [];
                for (let i = 0; i < data.contentSelections.length; i++) {
                    let item = data.contentSelections[i];
                    this.contentSelections[i] = item && !(<any>item).toJSON ? new ShareContentDetail(item) : <ShareContentDetail>item;
                }
            }
            if (data.schemas) {
                this.schemas = [];
                for (let i = 0; i < data.schemas.length; i++) {
                    let item = data.schemas[i];
                    this.schemas[i] = item && !(<any>item).toJSON ? new SchemaDetail(item) : <SchemaDetail>item;
                }
            }
        }
        if (!data) {
            this.creator = new ShareUser();
            this.audit = new UserAudit();
            this.contentSelections = [];
            this.contents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.creator = _data["creator"] ? ShareUser.fromJS(_data["creator"]) : new ShareUser();
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : new UserAudit();
            if (Array.isArray(_data["contentSelections"])) {
                this.contentSelections = [] as any;
                for (let item of _data["contentSelections"])
                    this.contentSelections!.push(ShareContentDetail.fromJS(item));
            }
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ShareContentBase.fromJS(item));
            }
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.data = _data["data"] ? ShareDataBase.fromJS(_data["data"]) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.expired = _data["expired"];
            this.outputAccess = _data["outputAccess"];
            this.shareType = _data["shareType"];
            if (Array.isArray(_data["schemas"])) {
                this.schemas = [] as any;
                for (let item of _data["schemas"])
                    this.schemas!.push(SchemaDetail.fromJS(item));
            }
            this.pageToken = _data["pageToken"];
            this.contentCount = _data["contentCount"];
        }
    }

    static fromJS(data: any): ShareDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        if (Array.isArray(this.contentSelections)) {
            data["contentSelections"] = [];
            for (let item of this.contentSelections)
                data["contentSelections"].push(item.toJSON());
        }
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["expired"] = this.expired;
        data["outputAccess"] = this.outputAccess;
        data["shareType"] = this.shareType;
        if (Array.isArray(this.schemas)) {
            data["schemas"] = [];
            for (let item of this.schemas)
                data["schemas"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["contentCount"] = this.contentCount;
        return data;
    }
}

/** Share detail */
export interface IShareDetail {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name: string;
    /** Description of share entered by user. */
    description?: string | undefined;
    /** Creator of share. */
    creator: IShareUser;
    /** Audit information. */
    audit: IUserAudit;
    /** Detailed information about contents in the share. */
    contentSelections: IShareContentDetail[];
    /** List of all contents in share including outputs. */
    contents: ShareContentBase[];
    /** List of shared layers. */
    layerSchemaIds?: string[] | undefined;
    /** Detail of share. */
    data?: ShareDataBase | undefined;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Info if share is already expired. */
    expired: boolean;
    /** Defined access for contents in share. */
    outputAccess: OutputAccess;
    /** Type of share. */
    shareType: ShareType;
    /** Schema detail of the content and the layers. */
    schemas?: ISchemaDetail[] | undefined;
    /** Page token to retrieve next page of content selections. */
    pageToken?: string | undefined;
    /** Number of contents in share. */
    contentCount: number;
}

/** Reduced set of user information used for shares */
export class ShareUser implements IShareUser {
    /** Name of user */
    displayName!: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash!: string;

    constructor(data?: IShareUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.emailHash = _data["emailHash"];
        }
    }

    static fromJS(data: any): ShareUser {
        data = typeof data === 'object' ? data : {};
        let result = new ShareUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["emailHash"] = this.emailHash;
        return data;
    }
}

/** Reduced set of user information used for shares */
export interface IShareUser {
    /** Name of user */
    displayName: string;
    /** MD5 hash of email address. Can be used to display gravatar image */
    emailHash: string;
}

/** Detail of shared content */
export class ShareContentDetail implements IShareContentDetail {
    /** The ID of the schema with schema type content. */
    contentSchemaId!: string;
    /** An optional ID list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content!: any;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** Content ID. */
    id!: string;
    /** List of shared outputs for this content. */
    outputs!: ShareOutputBase[];
    /** The type of content */
    contentType!: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues!: DisplayValueDictionary;
    /** Contains an URL that can be used to retrieve the icon corresponding to the file type. */
    iconUrl?: string | undefined;
    /** The id of related DisplayContent */
    displayContentId?: string | undefined;

    isVirtual() {
    return !NON_VIRTUAL_CONTENT_SCHEMAS_IDS.includes(this.contentSchemaId);
  }

    constructor(data?: IShareContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.displayValues = data.displayValues && !(<any>data.displayValues).toJSON ? new DisplayValueDictionary(data.displayValues) : <DisplayValueDictionary>this.displayValues;
        }
        if (!data) {
            this.outputs = [];
            this.displayValues = new DisplayValueDictionary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentSchemaId = _data["contentSchemaId"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.content = _data["content"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.id = _data["id"];
            if (Array.isArray(_data["outputs"])) {
                this.outputs = [] as any;
                for (let item of _data["outputs"])
                    this.outputs!.push(ShareOutputBase.fromJS(item));
            }
            this.contentType = _data["contentType"];
            this.displayValues = _data["displayValues"] ? DisplayValueDictionary.fromJS(_data["displayValues"]) : new DisplayValueDictionary();
            this.iconUrl = _data["iconUrl"];
            this.displayContentId = _data["displayContentId"];
        }
    }

    static fromJS(data: any): ShareContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentSchemaId"] = this.contentSchemaId;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["content"] = this.content;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["id"] = this.id;
        if (Array.isArray(this.outputs)) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        data["contentType"] = this.contentType;
        data["displayValues"] = this.displayValues ? this.displayValues.toJSON() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["displayContentId"] = this.displayContentId;
        return data;
    }
}

/** Detail of shared content */
export interface IShareContentDetail {
    /** The ID of the schema with schema type content. */
    contentSchemaId: string;
    /** An optional ID list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The content data. It's an object of dynamic metadata whose structure is defined in the Content schema specified
by the ContentSchemaId property. */
    content: any;
    /** The metadata belonging to the layers of the content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** Content ID. */
    id: string;
    /** List of shared outputs for this content. */
    outputs: ShareOutputBase[];
    /** The type of content */
    contentType: ContentType;
    /** Contains language specific display values, rendered according to the content schema's display pattern configuration. */
    displayValues: IDisplayValueDictionary;
    /** Contains an URL that can be used to retrieve the icon corresponding to the file type. */
    iconUrl?: string | undefined;
    /** The id of related DisplayContent */
    displayContentId?: string | undefined;
}

/** Base of shared output */
export abstract class ShareOutputBase implements IShareOutputBase {
    /** Content ID. */
    contentId!: string;
    /** Output format ID. */
    outputFormatId!: string;
    /** Url to directly view output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    viewUrl?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    downloadUrl?: string | undefined;
    /** Output details. */
    detail?: OutputDataBase | undefined;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering!: boolean;
    /** The rendering state of the output file. */
    renderingState!: OutputRenderingState;

    protected _discriminator: string;

    constructor(data?: IShareOutputBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareOutputBase";
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
            this.viewUrl = _data["viewUrl"];
            this.downloadUrl = _data["downloadUrl"];
            this.detail = _data["detail"] ? OutputDataBase.fromJS(_data["detail"]) : <any>undefined;
            this.dynamicRendering = _data["dynamicRendering"];
            this.renderingState = _data["renderingState"];
        }
    }

    static fromJS(data: any): ShareOutputBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareOutputBasic") {
            let result = new ShareOutputBasic();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputEmbed") {
            let result = new ShareOutputEmbed();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareOutputDisplayContent") {
            let result = new ShareOutputDisplayContent();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareOutputBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["viewUrl"] = this.viewUrl;
        data["downloadUrl"] = this.downloadUrl;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        data["dynamicRendering"] = this.dynamicRendering;
        data["renderingState"] = this.renderingState;
        return data;
    }
}

/** Base of shared output */
export interface IShareOutputBase {
    /** Content ID. */
    contentId: string;
    /** Output format ID. */
    outputFormatId: string;
    /** Url to directly view output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    viewUrl?: string | undefined;
    /** Url to directly download output. In case of BasicShare if not fetched using a token, a placeholder {token} is included which needs to be replaced with the recipient's token */
    downloadUrl?: string | undefined;
    /** Output details. */
    detail?: OutputDataBase | undefined;
    /** Whether this Output belongs to a dynamic OutputFormat */
    dynamicRendering: boolean;
    /** The rendering state of the output file. */
    renderingState: OutputRenderingState;
}

/** Shared output for basic share */
export class ShareOutputBasic extends ShareOutputBase implements IShareOutputBasic {

    constructor(data?: IShareOutputBasic) {
        super(data);
        this._discriminator = "ShareOutputBasic";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareOutputBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputBasic();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Shared output for basic share */
export interface IShareOutputBasic extends IShareOutputBase {
}

/** Shared output for embed share */
export class ShareOutputEmbed extends ShareOutputBase implements IShareOutputEmbed {
    /** Share token for the shared output. */
    token?: string | undefined;

    constructor(data?: IShareOutputEmbed) {
        super(data);
        this._discriminator = "ShareOutputEmbed";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): ShareOutputEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputEmbed();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

/** Shared output for embed share */
export interface IShareOutputEmbed extends IShareOutputBase {
    /** Share token for the shared output. */
    token?: string | undefined;
}

/** Shared output for a display content */
export class ShareOutputDisplayContent extends ShareOutputBase implements IShareOutputDisplayContent {

    constructor(data?: IShareOutputDisplayContent) {
        super(data);
        this._discriminator = "ShareOutputDisplayContent";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareOutputDisplayContent {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputDisplayContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Shared output for a display content */
export interface IShareOutputDisplayContent extends IShareOutputBase {
}

export abstract class ShareContentBase implements IShareContentBase {
    /** Content ID to share. */
    contentId!: string;
    /** List of output formats for this content to share. If not specified outer OutputAccess is used. */
    outputFormatIds?: string[] | undefined;

    protected _discriminator: string;

    constructor(data?: IShareContentBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareContentBase";
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            if (Array.isArray(_data["outputFormatIds"])) {
                this.outputFormatIds = [] as any;
                for (let item of _data["outputFormatIds"])
                    this.outputFormatIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ShareContentBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareContent") {
            let result = new ShareContent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "EmbedContent") {
            let result = new EmbedContent();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareContentBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["contentId"] = this.contentId;
        if (Array.isArray(this.outputFormatIds)) {
            data["outputFormatIds"] = [];
            for (let item of this.outputFormatIds)
                data["outputFormatIds"].push(item);
        }
        return data;
    }
}

export interface IShareContentBase {
    /** Content ID to share. */
    contentId: string;
    /** List of output formats for this content to share. If not specified outer OutputAccess is used. */
    outputFormatIds?: string[] | undefined;
}

/** Shared content */
export class ShareContent extends ShareContentBase implements IShareContent {

    constructor(data?: IShareContent) {
        super(data);
        this._discriminator = "ShareContent";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareContent {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Shared content */
export interface IShareContent extends IShareContentBase {
}

/** Embedded content */
export class EmbedContent extends ShareContentBase implements IEmbedContent {
    /** Conversion presets: Each output format of the shared content can be optionally converted/edited
when delivering. */
    conversionPresets?: ConversionPreset[] | undefined;

    constructor(data?: IEmbedContent) {
        super(data);
        if (data) {
            if (data.conversionPresets) {
                this.conversionPresets = [];
                for (let i = 0; i < data.conversionPresets.length; i++) {
                    let item = data.conversionPresets[i];
                    this.conversionPresets[i] = item && !(<any>item).toJSON ? new ConversionPreset(item) : <ConversionPreset>item;
                }
            }
        }
        this._discriminator = "EmbedContent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["conversionPresets"])) {
                this.conversionPresets = [] as any;
                for (let item of _data["conversionPresets"])
                    this.conversionPresets!.push(ConversionPreset.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): EmbedContent {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conversionPresets)) {
            data["conversionPresets"] = [];
            for (let item of this.conversionPresets)
                data["conversionPresets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Embedded content */
export interface IEmbedContent extends IShareContentBase {
    /** Conversion presets: Each output format of the shared content can be optionally converted/edited
when delivering. */
    conversionPresets?: IConversionPreset[] | undefined;
}

/** Preset for converting an output. */
export class ConversionPreset implements IConversionPreset {
    /** OutputFormatId of output to be converted. */
    outputFormatId!: string;
    /** Conversion to apply to the output. */
    conversion?: string | undefined;
    /** Indicates if the conversion is locked and therefore cannot be changed by the caller of the embed URI. */
    locked!: boolean;

    constructor(data?: IConversionPreset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outputFormatId = _data["outputFormatId"];
            this.conversion = _data["conversion"];
            this.locked = _data["locked"];
        }
    }

    static fromJS(data: any): ConversionPreset {
        data = typeof data === 'object' ? data : {};
        let result = new ConversionPreset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputFormatId"] = this.outputFormatId;
        data["conversion"] = this.conversion;
        data["locked"] = this.locked;
        return data;
    }
}

/** Preset for converting an output. */
export interface IConversionPreset {
    /** OutputFormatId of output to be converted. */
    outputFormatId: string;
    /** Conversion to apply to the output. */
    conversion?: string | undefined;
    /** Indicates if the conversion is locked and therefore cannot be changed by the caller of the embed URI. */
    locked: boolean;
}

/** Base of share data */
export abstract class ShareDataBase implements IShareDataBase {
    /** The URL to access the share. */
    url!: string;

    protected _discriminator: string;

    constructor(data?: IShareDataBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ShareDataBase";
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ShareDataBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareDataEmbed") {
            let result = new ShareDataEmbed();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareDataBasic") {
            let result = new ShareDataBasic();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareDataBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["url"] = this.url;
        return data;
    }
}

/** Base of share data */
export interface IShareDataBase {
    /** The URL to access the share. */
    url: string;
}

/** Embed share data */
export class ShareDataEmbed extends ShareDataBase implements IShareDataEmbed {
    /** Token for the embed share. */
    token!: string;

    constructor(data?: IShareDataEmbed) {
        super(data);
        this._discriminator = "ShareDataEmbed";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }

    static override fromJS(data: any): ShareDataEmbed {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataEmbed();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

/** Embed share data */
export interface IShareDataEmbed extends IShareDataBase {
    /** Token for the embed share. */
    token: string;
}

/** Basic share data */
export class ShareDataBasic extends ShareDataBase implements IShareDataBasic {
    /** List of recipients added using email address */
    mailRecipients!: MailRecipient[];
    /** List of recipients that exist in Picturepark. */
    internalRecipients!: InternalRecipient[];
    /** Language of share. */
    languageCode?: string | undefined;

    constructor(data?: IShareDataBasic) {
        super(data);
        if (data) {
            if (data.mailRecipients) {
                this.mailRecipients = [];
                for (let i = 0; i < data.mailRecipients.length; i++) {
                    let item = data.mailRecipients[i];
                    this.mailRecipients[i] = item && !(<any>item).toJSON ? new MailRecipient(item) : <MailRecipient>item;
                }
            }
            if (data.internalRecipients) {
                this.internalRecipients = [];
                for (let i = 0; i < data.internalRecipients.length; i++) {
                    let item = data.internalRecipients[i];
                    this.internalRecipients[i] = item && !(<any>item).toJSON ? new InternalRecipient(item) : <InternalRecipient>item;
                }
            }
        }
        if (!data) {
            this.mailRecipients = [];
            this.internalRecipients = [];
        }
        this._discriminator = "ShareDataBasic";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["mailRecipients"])) {
                this.mailRecipients = [] as any;
                for (let item of _data["mailRecipients"])
                    this.mailRecipients!.push(MailRecipient.fromJS(item));
            }
            if (Array.isArray(_data["internalRecipients"])) {
                this.internalRecipients = [] as any;
                for (let item of _data["internalRecipients"])
                    this.internalRecipients!.push(InternalRecipient.fromJS(item));
            }
            this.languageCode = _data["languageCode"];
        }
    }

    static override fromJS(data: any): ShareDataBasic {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDataBasic();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mailRecipients)) {
            data["mailRecipients"] = [];
            for (let item of this.mailRecipients)
                data["mailRecipients"].push(item.toJSON());
        }
        if (Array.isArray(this.internalRecipients)) {
            data["internalRecipients"] = [];
            for (let item of this.internalRecipients)
                data["internalRecipients"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        super.toJSON(data);
        return data;
    }
}

/** Basic share data */
export interface IShareDataBasic extends IShareDataBase {
    /** List of recipients added using email address */
    mailRecipients: IMailRecipient[];
    /** List of recipients that exist in Picturepark. */
    internalRecipients: IInternalRecipient[];
    /** Language of share. */
    languageCode?: string | undefined;
}

/** Share mail recipient */
export class MailRecipient implements IMailRecipient {
    /** User information including email. */
    userEmail!: UserEmail;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;

    constructor(data?: IMailRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userEmail = data.userEmail && !(<any>data.userEmail).toJSON ? new UserEmail(data.userEmail) : <UserEmail>this.userEmail;
        }
        if (!data) {
            this.userEmail = new UserEmail();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userEmail = _data["userEmail"] ? UserEmail.fromJS(_data["userEmail"]) : new UserEmail();
            this.token = _data["token"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): MailRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new MailRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userEmail"] = this.userEmail ? this.userEmail.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data;
    }
}

/** Share mail recipient */
export interface IMailRecipient {
    /** User information including email. */
    userEmail: IUserEmail;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export class UserEmail implements IUserEmail {
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Email address */
    emailAddress!: string;

    constructor(data?: IUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface IUserEmail {
    /** First name. */
    firstName?: string | undefined;
    /** Last name. */
    lastName?: string | undefined;
    /** Email address */
    emailAddress: string;
}

/** Internal share recipient */
export class InternalRecipient implements IInternalRecipient {
    /** User information of recipient. */
    recipient!: User;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;

    constructor(data?: IInternalRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.recipient = data.recipient && !(<any>data.recipient).toJSON ? new User(data.recipient) : <User>this.recipient;
        }
        if (!data) {
            this.recipient = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipient = _data["recipient"] ? User.fromJS(_data["recipient"]) : new User();
            this.token = _data["token"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): InternalRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new InternalRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["token"] = this.token;
        data["url"] = this.url;
        return data;
    }
}

/** Internal share recipient */
export interface IInternalRecipient {
    /** User information of recipient. */
    recipient: IUser;
    /** Recipient specific token. */
    token?: string | undefined;
    /** URL to access the share for this recipient. */
    url?: string | undefined;
}

export enum OutputAccess {
    Full = "Full",
    Preview = "Preview",
    None = "None",
}

export enum ShareResolveBehavior {
    Schemas = "Schemas",
}

/** Base class for search results */
export class BaseResultOfShareContentDetail implements IBaseResultOfShareContentDetail {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: ShareContentDetail[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfShareContentDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ShareContentDetail(item) : <ShareContentDetail>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShareContentDetail.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfShareContentDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfShareContentDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfShareContentDetail {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IShareContentDetail[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

export class ShareContentDetailResult extends BaseResultOfShareContentDetail implements IShareContentDetailResult {

    constructor(data?: IShareContentDetailResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareContentDetailResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContentDetailResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IShareContentDetailResult extends IBaseResultOfShareContentDetail {
}

export class ShareOutputsResult implements IShareOutputsResult {
    outputs?: OutputResolveResult[] | undefined;
    contentInfos?: ShareContentInfo[] | undefined;

    constructor(data?: IShareOutputsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.outputs) {
                this.outputs = [];
                for (let i = 0; i < data.outputs.length; i++) {
                    let item = data.outputs[i];
                    this.outputs[i] = item && !(<any>item).toJSON ? new OutputResolveResult(item) : <OutputResolveResult>item;
                }
            }
            if (data.contentInfos) {
                this.contentInfos = [];
                for (let i = 0; i < data.contentInfos.length; i++) {
                    let item = data.contentInfos[i];
                    this.contentInfos[i] = item && !(<any>item).toJSON ? new ShareContentInfo(item) : <ShareContentInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["outputs"])) {
                this.outputs = [] as any;
                for (let item of _data["outputs"])
                    this.outputs!.push(OutputResolveResult.fromJS(item));
            }
            if (Array.isArray(_data["contentInfos"])) {
                this.contentInfos = [] as any;
                for (let item of _data["contentInfos"])
                    this.contentInfos!.push(ShareContentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShareOutputsResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShareOutputsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.outputs)) {
            data["outputs"] = [];
            for (let item of this.outputs)
                data["outputs"].push(item.toJSON());
        }
        if (Array.isArray(this.contentInfos)) {
            data["contentInfos"] = [];
            for (let item of this.contentInfos)
                data["contentInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShareOutputsResult {
    outputs?: IOutputResolveResult[] | undefined;
    contentInfos?: IShareContentInfo[] | undefined;
}

export class ShareContentInfo implements IShareContentInfo {
    /** Content ID. */
    id?: string | undefined;
    /** The type of content */
    contentType!: ContentType;
    /** The ID of the schema with schema type content. */
    contentSchemaId?: string | undefined;

    constructor(data?: IShareContentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contentType = _data["contentType"];
            this.contentSchemaId = _data["contentSchemaId"];
        }
    }

    static fromJS(data: any): ShareContentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ShareContentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentType"] = this.contentType;
        data["contentSchemaId"] = this.contentSchemaId;
        return data;
    }
}

export interface IShareContentInfo {
    /** Content ID. */
    id?: string | undefined;
    /** The type of content */
    contentType: ContentType;
    /** The ID of the schema with schema type content. */
    contentSchemaId?: string | undefined;
}

/** Request specifying which part of a share should be downloaded */
export class ShareDownloadRequest implements IShareDownloadRequest {
    /** Specifies which content / output format combinations should be downloaded. */
    items!: ContentDownloadRequestItem[];

    constructor(data?: IShareDownloadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new ContentDownloadRequestItem(item) : <ContentDownloadRequestItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContentDownloadRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShareDownloadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDownloadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request specifying which part of a share should be downloaded */
export interface IShareDownloadRequest {
    /** Specifies which content / output format combinations should be downloaded. */
    items: IContentDownloadRequestItem[];
}

/** Base of update request for share */
export abstract class ShareBaseUpdateRequest implements IShareBaseUpdateRequest {
    /** Name of share. */
    name!: string;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Optional description of share. */
    description?: string | undefined;
    /** List of contents including outputs. Existing items needs to be sent again, otherwise they will be removed. */
    contents!: ShareContentBase[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess!: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contents = [];
        }
        this._discriminator = "ShareBaseUpdateRequest";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ShareContentBase.fromJS(item));
            }
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.outputAccess = _data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseUpdateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicUpdateRequest") {
            let result = new ShareBasicUpdateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedUpdateRequest") {
            let result = new ShareEmbedUpdateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseUpdateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["outputAccess"] = this.outputAccess;
        return data;
    }
}

/** Base of update request for share */
export interface IShareBaseUpdateRequest {
    /** Name of share. */
    name: string;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Optional description of share. */
    description?: string | undefined;
    /** List of contents including outputs. Existing items needs to be sent again, otherwise they will be removed. */
    contents: ShareContentBase[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

/** Update request for basic share */
export class ShareBasicUpdateRequest extends ShareBaseUpdateRequest implements IShareBasicUpdateRequest {

    constructor(data?: IShareBasicUpdateRequest) {
        super(data);
        this._discriminator = "ShareBasicUpdateRequest";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareBasicUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Update request for basic share */
export interface IShareBasicUpdateRequest extends IShareBaseUpdateRequest {
}

/** Update request for embed share */
export class ShareEmbedUpdateRequest extends ShareBaseUpdateRequest implements IShareEmbedUpdateRequest {

    constructor(data?: IShareEmbedUpdateRequest) {
        super(data);
        this._discriminator = "ShareEmbedUpdateRequest";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareEmbedUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Update request for embed share */
export interface IShareEmbedUpdateRequest extends IShareBaseUpdateRequest {
}

/** Base create request for share */
export abstract class ShareBaseCreateRequest implements IShareBaseCreateRequest {
    /** Name of share. */
    name!: string;
    /** Optional description of share. */
    description?: string | undefined;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** List of contents including outputs to share. */
    contents!: ShareContentBase[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess!: OutputAccess;

    protected _discriminator: string;

    constructor(data?: IShareBaseCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contents = [];
        }
        this._discriminator = "ShareBaseCreateRequest";
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(ShareContentBase.fromJS(item));
            }
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            this.outputAccess = _data["outputAccess"];
        }
    }

    static fromJS(data: any): ShareBaseCreateRequest {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "ShareBasicCreateRequest") {
            let result = new ShareBasicCreateRequest();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ShareEmbedCreateRequest") {
            let result = new ShareEmbedCreateRequest();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ShareBaseCreateRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["name"] = this.name;
        data["description"] = this.description;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        data["outputAccess"] = this.outputAccess;
        return data;
    }
}

/** Base create request for share */
export interface IShareBaseCreateRequest {
    /** Name of share. */
    name: string;
    /** Optional description of share. */
    description?: string | undefined;
    /** Optional date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** List of contents including outputs to share. */
    contents: ShareContentBase[];
    /** List of content layers to share. */
    layerSchemaIds?: string[] | undefined;
    /** Access for content outputs in share. */
    outputAccess: OutputAccess;
}

export class ShareBasicCreateRequest extends ShareBaseCreateRequest implements IShareBasicCreateRequest {
    /** List of external mail recipients which are no Picturepark users. */
    recipientEmails?: UserEmail[] | undefined;
    /** System language used for share (mail and detail page). en or de. */
    languageCode!: string;
    /** Set to true to disable the creation of notifications and emails to recipients. */
    suppressNotifications?: boolean;

    constructor(data?: IShareBasicCreateRequest) {
        super(data);
        if (data) {
            if (data.recipientEmails) {
                this.recipientEmails = [];
                for (let i = 0; i < data.recipientEmails.length; i++) {
                    let item = data.recipientEmails[i];
                    this.recipientEmails[i] = item && !(<any>item).toJSON ? new UserEmail(item) : <UserEmail>item;
                }
            }
        }
        this._discriminator = "ShareBasicCreateRequest";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["recipientEmails"])) {
                this.recipientEmails = [] as any;
                for (let item of _data["recipientEmails"])
                    this.recipientEmails!.push(UserEmail.fromJS(item));
            }
            this.languageCode = _data["languageCode"];
            this.suppressNotifications = _data["suppressNotifications"];
        }
    }

    static override fromJS(data: any): ShareBasicCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBasicCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recipientEmails)) {
            data["recipientEmails"] = [];
            for (let item of this.recipientEmails)
                data["recipientEmails"].push(item.toJSON());
        }
        data["languageCode"] = this.languageCode;
        data["suppressNotifications"] = this.suppressNotifications;
        super.toJSON(data);
        return data;
    }
}

export interface IShareBasicCreateRequest extends IShareBaseCreateRequest {
    /** List of external mail recipients which are no Picturepark users. */
    recipientEmails?: IUserEmail[] | undefined;
    /** System language used for share (mail and detail page). en or de. */
    languageCode: string;
    /** Set to true to disable the creation of notifications and emails to recipients. */
    suppressNotifications?: boolean;
}

/** Create request for embed share */
export class ShareEmbedCreateRequest extends ShareBaseCreateRequest implements IShareEmbedCreateRequest {

    constructor(data?: IShareEmbedCreateRequest) {
        super(data);
        this._discriminator = "ShareEmbedCreateRequest";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareEmbedCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareEmbedCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Create request for embed share */
export interface IShareEmbedCreateRequest extends IShareBaseCreateRequest {
}

export class ShareDeleteManyRequest implements IShareDeleteManyRequest {
    /** IDs of shares to delete. */
    ids!: string[];

    constructor(data?: IShareDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): ShareDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IShareDeleteManyRequest {
    /** IDs of shares to delete. */
    ids: string[];
}

export class ShareRevokeManyRequest implements IShareRevokeManyRequest {
    ids?: string[] | undefined;

    constructor(data?: IShareRevokeManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): ShareRevokeManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareRevokeManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IShareRevokeManyRequest {
    ids?: string[] | undefined;
}

/** Request to aggregate shares based on the specified aggregators */
export abstract class ShareSearchAndAggregationBaseRequest implements IShareSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;

    constructor(data?: IShareSearchAndAggregationBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShareSearchAndAggregationBaseRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ShareSearchAndAggregationBaseRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to aggregate shares based on the specified aggregators */
export interface IShareSearchAndAggregationBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
}

/** Request to aggregate shares based on the specified aggregators */
export class ShareAggregationRequest extends ShareSearchAndAggregationBaseRequest implements IShareAggregationRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: IShareAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ShareAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareAggregationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to aggregate shares based on the specified aggregators */
export interface IShareAggregationRequest extends IShareSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Base class for search results */
export class BaseResultOfShare implements IBaseResultOfShare {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Share[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Share(item) : <Share>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Share.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfShare();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfShare {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IShare[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfShare extends BaseResultOfShare implements ISearchBehaviorBaseResultOfShare {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfShare) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfShare();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfShare extends IBaseResultOfShare {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfShare extends SearchBehaviorBaseResultOfShare implements ISearchBehaviorWithAggregationBaseResultOfShare {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfShare) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfShare {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfShare();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfShare extends ISearchBehaviorBaseResultOfShare {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Result for share search operation */
export class ShareSearchResult extends SearchBehaviorWithAggregationBaseResultOfShare implements IShareSearchResult {

    constructor(data?: IShareSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ShareSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result for share search operation */
export interface IShareSearchResult extends ISearchBehaviorWithAggregationBaseResultOfShare {
}

/** Share */
export class Share implements IShare {
    /** Share ID. */
    id!: string;
    /** Name of share. */
    name?: string | undefined;
    /** List of shared content IDs. */
    contentIds!: string[];
    /** Audit information. */
    audit!: UserAudit;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Type of share. */
    shareType!: ShareType;
    /** Share is readonly if the current user is not the creator but only the recipient. */
    isReadOnly!: boolean;

    constructor(data?: IShare) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
        if (!data) {
            this.contentIds = [];
            this.audit = new UserAudit();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : new UserAudit();
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.shareType = _data["shareType"];
            this.isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): Share {
        data = typeof data === 'object' ? data : {};
        let result = new Share();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["shareType"] = this.shareType;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }
}

/** Share */
export interface IShare {
    /** Share ID. */
    id: string;
    /** Name of share. */
    name?: string | undefined;
    /** List of shared content IDs. */
    contentIds: string[];
    /** Audit information. */
    audit: IUserAudit;
    /** Date when share expires and cannot be accessed anymore. */
    expirationDate?: Date | undefined;
    /** Type of share. */
    shareType: ShareType;
    /** Share is readonly if the current user is not the creator but only the recipient. */
    isReadOnly: boolean;
}

/** Request to search shares */
export class ShareSearchRequest extends ShareSearchAndAggregationBaseRequest implements IShareSearchRequest {
    /** Limits the document count of the result set. */
    limit?: number;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: IShareSearchRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.limit = _data["limit"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.pageToken = _data["pageToken"];
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ShareSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShareSearchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["pageToken"] = this.pageToken;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Request to search shares */
export interface IShareSearchRequest extends IShareSearchAndAggregationBaseRequest {
    /** Limits the document count of the result set. */
    limit?: number;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

export class ContentStatisticsAggregated implements IContentStatisticsAggregated {
    /** Contains aggregated data for the complete lifetime of the Content */
    overall!: ContentStatisticsData;
    /** Contains aggregated data according to requested time frames */
    timeFrames!: ContentStatisticsAggregatedTimeFrameBucket[];

    constructor(data?: IContentStatisticsAggregated) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.overall = data.overall && !(<any>data.overall).toJSON ? new ContentStatisticsData(data.overall) : <ContentStatisticsData>this.overall;
            if (data.timeFrames) {
                this.timeFrames = [];
                for (let i = 0; i < data.timeFrames.length; i++) {
                    let item = data.timeFrames[i];
                    this.timeFrames[i] = item && !(<any>item).toJSON ? new ContentStatisticsAggregatedTimeFrameBucket(item) : <ContentStatisticsAggregatedTimeFrameBucket>item;
                }
            }
        }
        if (!data) {
            this.overall = new ContentStatisticsData();
            this.timeFrames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.overall = _data["overall"] ? ContentStatisticsData.fromJS(_data["overall"]) : new ContentStatisticsData();
            if (Array.isArray(_data["timeFrames"])) {
                this.timeFrames = [] as any;
                for (let item of _data["timeFrames"])
                    this.timeFrames!.push(ContentStatisticsAggregatedTimeFrameBucket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContentStatisticsAggregated {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatisticsAggregated();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overall"] = this.overall ? this.overall.toJSON() : <any>undefined;
        if (Array.isArray(this.timeFrames)) {
            data["timeFrames"] = [];
            for (let item of this.timeFrames)
                data["timeFrames"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContentStatisticsAggregated {
    /** Contains aggregated data for the complete lifetime of the Content */
    overall: IContentStatisticsData;
    /** Contains aggregated data according to requested time frames */
    timeFrames: IContentStatisticsAggregatedTimeFrameBucket[];
}

export class ContentStatisticsData implements IContentStatisticsData {
    /** Statistical data for downloads of a Content */
    downloads?: ContentDownloads | undefined;
    /** Statistical data of share-related activities for a Content */
    sharings!: ContentSharings;

    constructor(data?: IContentStatisticsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.downloads = data.downloads && !(<any>data.downloads).toJSON ? new ContentDownloads(data.downloads) : <ContentDownloads>this.downloads;
            this.sharings = data.sharings && !(<any>data.sharings).toJSON ? new ContentSharings(data.sharings) : <ContentSharings>this.sharings;
        }
        if (!data) {
            this.sharings = new ContentSharings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloads = _data["downloads"] ? ContentDownloads.fromJS(_data["downloads"]) : <any>undefined;
            this.sharings = _data["sharings"] ? ContentSharings.fromJS(_data["sharings"]) : new ContentSharings();
        }
    }

    static fromJS(data: any): ContentStatisticsData {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatisticsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloads"] = this.downloads ? this.downloads.toJSON() : <any>undefined;
        data["sharings"] = this.sharings ? this.sharings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContentStatisticsData {
    /** Statistical data for downloads of a Content */
    downloads?: IContentDownloads | undefined;
    /** Statistical data of share-related activities for a Content */
    sharings: IContentSharings;
}

export class ContentDownloads implements IContentDownloads {
    /** Total downloads of content (regardless of formats, single download of multiple formats is counted once) */
    total!: number;
    /** Downloads of content through basic Share */
    share!: number;
    /** Downloads of content through embed */
    embed!: number;

    constructor(data?: IContentDownloads) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.share = _data["share"];
            this.embed = _data["embed"];
        }
    }

    static fromJS(data: any): ContentDownloads {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloads();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["share"] = this.share;
        data["embed"] = this.embed;
        return data;
    }
}

export interface IContentDownloads {
    /** Total downloads of content (regardless of formats, single download of multiple formats is counted once) */
    total: number;
    /** Downloads of content through basic Share */
    share: number;
    /** Downloads of content through embed */
    embed: number;
}

export class ContentSharings implements IContentSharings {
    /** Times this Content was added to a Share (does not decrease when removed from Share) */
    shareAdd!: number;
    /** Times this Content was added to an Embed (does not decrease when removed from Embed) */
    embedAdd!: number;

    constructor(data?: IContentSharings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shareAdd = _data["shareAdd"];
            this.embedAdd = _data["embedAdd"];
        }
    }

    static fromJS(data: any): ContentSharings {
        data = typeof data === 'object' ? data : {};
        let result = new ContentSharings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareAdd"] = this.shareAdd;
        data["embedAdd"] = this.embedAdd;
        return data;
    }
}

export interface IContentSharings {
    /** Times this Content was added to a Share (does not decrease when removed from Share) */
    shareAdd: number;
    /** Times this Content was added to an Embed (does not decrease when removed from Embed) */
    embedAdd: number;
}

export class ContentStatisticsAggregatedTimeFrameBucket implements IContentStatisticsAggregatedTimeFrameBucket {
    /** The timeframe for which statistical data in this bucket was aggregated */
    timeFrame!: string;
    /** Aggregated data for timeframe */
    data!: ContentStatisticsData;

    constructor(data?: IContentStatisticsAggregatedTimeFrameBucket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new ContentStatisticsData(data.data) : <ContentStatisticsData>this.data;
        }
        if (!data) {
            this.data = new ContentStatisticsData();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeFrame = _data["timeFrame"];
            this.data = _data["data"] ? ContentStatisticsData.fromJS(_data["data"]) : new ContentStatisticsData();
        }
    }

    static fromJS(data: any): ContentStatisticsAggregatedTimeFrameBucket {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatisticsAggregatedTimeFrameBucket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeFrame"] = this.timeFrame;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContentStatisticsAggregatedTimeFrameBucket {
    /** The timeframe for which statistical data in this bucket was aggregated */
    timeFrame: string;
    /** Aggregated data for timeframe */
    data: IContentStatisticsData;
}

export class ExportContentStatisticsRequest implements IExportContentStatisticsRequest {
    /** Allows filtering of retrieved statistical data */
    filter?: ContentFilterRequest | undefined;
    /** Optional begin of time range for which statistical data should be exported */
    after?: Date | undefined;
    /** Optional end of time range for which statistical data should be exported */
    before?: Date | undefined;
    /** Whether exported information should be separated by api client */
    aggregateApiClients!: boolean;
    /** Enrich export with Name display value of Content */
    includeContentNames!: boolean;
    /** Desired temporal resolution of exported data. Must not be lower than 1 hour */
    interval?: string | undefined;
    /** Whether notifications should be published for progress and completion */
    notifyProgress!: boolean;

    constructor(data?: IExportContentStatisticsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.filter = data.filter && !(<any>data.filter).toJSON ? new ContentFilterRequest(data.filter) : <ContentFilterRequest>this.filter;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"] ? ContentFilterRequest.fromJS(_data["filter"]) : <any>undefined;
            this.after = _data["after"] ? new Date(_data["after"].toString()) : <any>undefined;
            this.before = _data["before"] ? new Date(_data["before"].toString()) : <any>undefined;
            this.aggregateApiClients = _data["aggregateApiClients"];
            this.includeContentNames = _data["includeContentNames"];
            this.interval = _data["interval"];
            this.notifyProgress = _data["notifyProgress"];
        }
    }

    static fromJS(data: any): ExportContentStatisticsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportContentStatisticsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["after"] = this.after ? this.after.toISOString() : <any>undefined;
        data["before"] = this.before ? this.before.toISOString() : <any>undefined;
        data["aggregateApiClients"] = this.aggregateApiClients;
        data["includeContentNames"] = this.includeContentNames;
        data["interval"] = this.interval;
        data["notifyProgress"] = this.notifyProgress;
        return data;
    }
}

export interface IExportContentStatisticsRequest {
    /** Allows filtering of retrieved statistical data */
    filter?: IContentFilterRequest | undefined;
    /** Optional begin of time range for which statistical data should be exported */
    after?: Date | undefined;
    /** Optional end of time range for which statistical data should be exported */
    before?: Date | undefined;
    /** Whether exported information should be separated by api client */
    aggregateApiClients: boolean;
    /** Enrich export with Name display value of Content */
    includeContentNames: boolean;
    /** Desired temporal resolution of exported data. Must not be lower than 1 hour */
    interval?: string | undefined;
    /** Whether notifications should be published for progress and completion */
    notifyProgress: boolean;
}

export class AddContentEventsRequest implements IAddContentEventsRequest {
    /** Data to be added to statistics */
    events!: AddContentEventsRequestItem[];

    constructor(data?: IAddContentEventsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.events) {
                this.events = [];
                for (let i = 0; i < data.events.length; i++) {
                    let item = data.events[i];
                    this.events[i] = item && !(<any>item).toJSON ? new AddContentEventsRequestItem(item) : <AddContentEventsRequestItem>item;
                }
            }
        }
        if (!data) {
            this.events = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(AddContentEventsRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddContentEventsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddContentEventsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddContentEventsRequest {
    /** Data to be added to statistics */
    events: IAddContentEventsRequestItem[];
}

export class AddContentEventsRequestItem implements IAddContentEventsRequestItem {
    /** Specifies at which time the events happened. The information will be automatically aggregated according to internal temporal resolution of statistics. */
    timestamp!: Date;
    /** Specifies content for which the events happened */
    contentId!: string;
    /** Optionally specify the used ApiClient. Defaults to the API Client sending this request. */
    apiClientId?: string | undefined;
    /** Data to be added to statistics */
    statistics!: ContentStatisticsDataEditable;
    /** Optionally specify an additional id under which the supplied data should be tracked. This
Id is only used internally and cannot be retrieved through API or export. */
    externalEventTraceId?: string | undefined;

    constructor(data?: IAddContentEventsRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.statistics = data.statistics && !(<any>data.statistics).toJSON ? new ContentStatisticsDataEditable(data.statistics) : <ContentStatisticsDataEditable>this.statistics;
        }
        if (!data) {
            this.statistics = new ContentStatisticsDataEditable();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.contentId = _data["contentId"];
            this.apiClientId = _data["apiClientId"];
            this.statistics = _data["statistics"] ? ContentStatisticsDataEditable.fromJS(_data["statistics"]) : new ContentStatisticsDataEditable();
            this.externalEventTraceId = _data["externalEventTraceId"];
        }
    }

    static fromJS(data: any): AddContentEventsRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new AddContentEventsRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["contentId"] = this.contentId;
        data["apiClientId"] = this.apiClientId;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>undefined;
        data["externalEventTraceId"] = this.externalEventTraceId;
        return data;
    }
}

export interface IAddContentEventsRequestItem {
    /** Specifies at which time the events happened. The information will be automatically aggregated according to internal temporal resolution of statistics. */
    timestamp: Date;
    /** Specifies content for which the events happened */
    contentId: string;
    /** Optionally specify the used ApiClient. Defaults to the API Client sending this request. */
    apiClientId?: string | undefined;
    /** Data to be added to statistics */
    statistics: IContentStatisticsDataEditable;
    /** Optionally specify an additional id under which the supplied data should be tracked. This
Id is only used internally and cannot be retrieved through API or export. */
    externalEventTraceId?: string | undefined;
}

export class ContentStatisticsDataEditable implements IContentStatisticsDataEditable {
    /** Statistical data for downloads of a Content */
    downloads?: ContentDownloadsEditable | undefined;

    constructor(data?: IContentStatisticsDataEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.downloads = data.downloads && !(<any>data.downloads).toJSON ? new ContentDownloadsEditable(data.downloads) : <ContentDownloadsEditable>this.downloads;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloads = _data["downloads"] ? ContentDownloadsEditable.fromJS(_data["downloads"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentStatisticsDataEditable {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatisticsDataEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloads"] = this.downloads ? this.downloads.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContentStatisticsDataEditable {
    /** Statistical data for downloads of a Content */
    downloads?: IContentDownloadsEditable | undefined;
}

export class ContentDownloadsEditable implements IContentDownloadsEditable {
    /** Total downloads of content (regardless of formats, single download of multiple formats is counted once) */
    total!: number;
    /** Downloads of content through basic Share */
    share!: number;
    /** Downloads of content through embed */
    embed!: number;

    constructor(data?: IContentDownloadsEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.share = _data["share"];
            this.embed = _data["embed"];
        }
    }

    static fromJS(data: any): ContentDownloadsEditable {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadsEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["share"] = this.share;
        data["embed"] = this.embed;
        return data;
    }
}

export interface IContentDownloadsEditable {
    /** Total downloads of content (regardless of formats, single download of multiple formats is counted once) */
    total: number;
    /** Downloads of content through basic Share */
    share: number;
    /** Downloads of content through embed */
    embed: number;
}

/** Request to update a template */
export class TemplateUpdateRequest implements ITemplateUpdateRequest {
    /** Language specific names. */
    names!: TranslatedStringDictionary;
    /** Values per media type for the template. */
    values!: TemplateValue[];

    constructor(data?: ITemplateUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            if (data.values) {
                this.values = [];
                for (let i = 0; i < data.values.length; i++) {
                    let item = data.values[i];
                    this.values[i] = item && !(<any>item).toJSON ? new TemplateValue(item) : <TemplateValue>item;
                }
            }
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(TemplateValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update a template */
export interface ITemplateUpdateRequest {
    /** Language specific names. */
    names: ITranslatedStringDictionary;
    /** Values per media type for the template. */
    values: ITemplateValue[];
}

/** Request to create a new template */
export class TemplateCreateRequest extends TemplateUpdateRequest implements ITemplateCreateRequest {
    /** Name of the template. */
    name!: string;
    /** Language code of the template. */
    languageCode!: string;
    /** Type of the template. */
    templateType!: TemplateType;

    constructor(data?: ITemplateCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.languageCode = _data["languageCode"];
            this.templateType = _data["templateType"];
        }
    }

    static override fromJS(data: any): TemplateCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["languageCode"] = this.languageCode;
        data["templateType"] = this.templateType;
        super.toJSON(data);
        return data;
    }
}

/** Request to create a new template */
export interface ITemplateCreateRequest extends ITemplateUpdateRequest {
    /** Name of the template. */
    name: string;
    /** Language code of the template. */
    languageCode: string;
    /** Type of the template. */
    templateType: TemplateType;
}

/** Template */
export class Template extends TemplateCreateRequest implements ITemplate {
    /** ID of template. */
    id!: string;
    /** Indicates if this is a read-only system template. */
    system?: boolean;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: ITemplate) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.system = _data["system"];
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Template {
        data = typeof data === 'object' ? data : {};
        let result = new Template();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["system"] = this.system;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Template */
export interface ITemplate extends ITemplateCreateRequest {
    /** ID of template. */
    id: string;
    /** Indicates if this is a read-only system template. */
    system?: boolean;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

export enum TemplateType {
    ShareMail = "ShareMail",
    SharePage = "SharePage",
    NewUserRegisteredMail = "NewUserRegisteredMail",
    UserLockedMail = "UserLockedMail",
    UserUnlockedMail = "UserUnlockedMail",
    UserReviewedMail = "UserReviewedMail",
    UserInvitationMail = "UserInvitationMail",
    ShareNotFoundPage = "ShareNotFoundPage",
    UserTriggeredDeactivationRequestMail = "UserTriggeredDeactivationRequestMail",
    UserEmailConflictSolvedMail = "UserEmailConflictSolvedMail",
    NotificationMail = "NotificationMail",
    NotificationMailItem = "NotificationMailItem",
    DashboardPage = "DashboardPage",
    CommentNotificationMailItem = "CommentNotificationMailItem",
}

/** Media type specific value for a template */
export class TemplateValue implements ITemplateValue {
    /** Media type. */
    mediaType!: string;
    /** Text. */
    text!: string;

    constructor(data?: ITemplateValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediaType = _data["mediaType"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): TemplateValue {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediaType"] = this.mediaType;
        data["text"] = this.text;
        return data;
    }
}

/** Media type specific value for a template */
export interface ITemplateValue {
    /** Media type. */
    mediaType: string;
    /** Text. */
    text: string;
}

/** Result for template search operation */
export class TemplateSearchResult implements ITemplateSearchResult {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Template[];

    constructor(data?: ITemplateSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Template.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** Result for template search operation */
export interface ITemplateSearchResult {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: Template[];
}

/** Request to search for templates */
export class TemplateSearchRequest implements ITemplateSearchRequest {
    /** Language code of the template. */
    languageCode?: string | undefined;
    /** Type of the template. */
    templateType?: TemplateType | undefined;

    constructor(data?: ITemplateSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.templateType = _data["templateType"];
        }
    }

    static fromJS(data: any): TemplateSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["templateType"] = this.templateType;
        return data;
    }
}

/** Request to search for templates */
export interface ITemplateSearchRequest {
    /** Language code of the template. */
    languageCode?: string | undefined;
    /** Type of the template. */
    templateType?: TemplateType | undefined;
}

/** Creates a transfer. */
export class CreateTransferRequest implements ICreateTransferRequest {
    /** Name of transfer. */
    name!: string;
    /** Type of transfer. */
    transferType!: TransferType;
    /** Files uploaded in transfer.
The client is responsible for uploading files to backend.
Required when TransferType is FileUpload or FileUploadAutoImport. */
    files?: TransferUploadFile[] | undefined;
    /** Weblinks downloaded in transfer.
The backend will download files using HTTP, therefore public access to files is needed.
Required when TransferType is WebDownload. */
    webLinks?: TransferWebLink[] | undefined;
    /** Name of collection created after transfer. */
    collectionName?: string | undefined;
    /** A value indicating whether to create a collection after importing the transfer. */
    createCollection!: boolean;

    constructor(data?: ICreateTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.transferType = _data["transferType"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(TransferUploadFile.fromJS(item));
            }
            if (Array.isArray(_data["webLinks"])) {
                this.webLinks = [] as any;
                for (let item of _data["webLinks"])
                    this.webLinks!.push(TransferWebLink.fromJS(item));
            }
            this.collectionName = _data["collectionName"];
            this.createCollection = _data["createCollection"];
        }
    }

    static fromJS(data: any): CreateTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["transferType"] = this.transferType;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (Array.isArray(this.webLinks)) {
            data["webLinks"] = [];
            for (let item of this.webLinks)
                data["webLinks"].push(item.toJSON());
        }
        data["collectionName"] = this.collectionName;
        data["createCollection"] = this.createCollection;
        return data;
    }
}

/** Creates a transfer. */
export interface ICreateTransferRequest {
    /** Name of transfer. */
    name: string;
    /** Type of transfer. */
    transferType: TransferType;
    /** Files uploaded in transfer.
The client is responsible for uploading files to backend.
Required when TransferType is FileUpload or FileUploadAutoImport. */
    files?: TransferUploadFile[] | undefined;
    /** Weblinks downloaded in transfer.
The backend will download files using HTTP, therefore public access to files is needed.
Required when TransferType is WebDownload. */
    webLinks?: TransferWebLink[] | undefined;
    /** Name of collection created after transfer. */
    collectionName?: string | undefined;
    /** A value indicating whether to create a collection after importing the transfer. */
    createCollection: boolean;
}

/** Represents the base class for transfer items. */
export abstract class TransferFile implements ITransferFile {
    /** Replaced in favor of RequestId. Client generated identifier of the item. */
    identifier?: string | undefined;
    /** Client generated identifier of the item. */
    requestId?: string | undefined;

    constructor(data?: ITransferFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): TransferFile {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'TransferFile' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identifier"] = this.identifier;
        data["requestId"] = this.requestId;
        return data;
    }
}

/** Represents the base class for transfer items. */
export interface ITransferFile {
    /** Replaced in favor of RequestId. Client generated identifier of the item. */
    identifier?: string | undefined;
    /** Client generated identifier of the item. */
    requestId?: string | undefined;
}

/** Represents a file being uploaded in a transfer. */
export class TransferUploadFile extends TransferFile implements ITransferUploadFile {
    /** Target filename of file. */
    fileName!: string;

    constructor(data?: ITransferUploadFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"];
        }
    }

    static override fromJS(data: any): TransferUploadFile {
        data = typeof data === 'object' ? data : {};
        let result = new TransferUploadFile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        super.toJSON(data);
        return data;
    }
}

/** Represents a file being uploaded in a transfer. */
export interface ITransferUploadFile extends ITransferFile {
    /** Target filename of file. */
    fileName: string;
}

/** Represents an item being downloaded by URL in a transfer. */
export class TransferWebLink extends TransferFile implements ITransferWebLink {
    /** URL of the item. */
    url!: string;
    /** Optional target filename of the file. */
    fileName?: string | undefined;

    constructor(data?: ITransferWebLink) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.url = _data["url"];
            this.fileName = _data["fileName"];
        }
    }

    static override fromJS(data: any): TransferWebLink {
        data = typeof data === 'object' ? data : {};
        let result = new TransferWebLink();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        super.toJSON(data);
        return data;
    }
}

/** Represents an item being downloaded by URL in a transfer. */
export interface ITransferWebLink extends ITransferFile {
    /** URL of the item. */
    url: string;
    /** Optional target filename of the file. */
    fileName?: string | undefined;
}

/** Represents a transfer and includes detailed information. */
export class TransferDetail extends Transfer implements ITransferDetail {
    /** Audit information. */
    audit!: UserAudit;
    /** Number of items processed. */
    itemProgress?: number;
    /** Total number of items. */
    itemCount?: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount?: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount?: number;
    /** Number of items failed. */
    itemsFailed?: number;
    /** Number of items cancelled. */
    itemsCancelled?: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressTimeStamp?: Date | undefined;
    /** Time stamp of last progress update from upload. */
    lastFileUploadProgressTimeStamp?: Date | undefined;

    constructor(data?: ITransferDetail) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
        }
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : new UserAudit();
            this.itemProgress = _data["itemProgress"];
            this.itemCount = _data["itemCount"];
            this.fileUploadInProgressCount = _data["fileUploadInProgressCount"];
            this.dataExtractionInProgressCount = _data["dataExtractionInProgressCount"];
            this.itemsFailed = _data["itemsFailed"];
            this.itemsCancelled = _data["itemsCancelled"];
            this.lastDataExtractionProgressTimeStamp = _data["lastDataExtractionProgressTimeStamp"] ? new Date(_data["lastDataExtractionProgressTimeStamp"].toString()) : <any>undefined;
            this.lastFileUploadProgressTimeStamp = _data["lastFileUploadProgressTimeStamp"] ? new Date(_data["lastFileUploadProgressTimeStamp"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): TransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["itemProgress"] = this.itemProgress;
        data["itemCount"] = this.itemCount;
        data["fileUploadInProgressCount"] = this.fileUploadInProgressCount;
        data["dataExtractionInProgressCount"] = this.dataExtractionInProgressCount;
        data["itemsFailed"] = this.itemsFailed;
        data["itemsCancelled"] = this.itemsCancelled;
        data["lastDataExtractionProgressTimeStamp"] = this.lastDataExtractionProgressTimeStamp ? this.lastDataExtractionProgressTimeStamp.toISOString() : <any>undefined;
        data["lastFileUploadProgressTimeStamp"] = this.lastFileUploadProgressTimeStamp ? this.lastFileUploadProgressTimeStamp.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents a transfer and includes detailed information. */
export interface ITransferDetail extends ITransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Number of items processed. */
    itemProgress?: number;
    /** Total number of items. */
    itemCount?: number;
    /** Number of items currently being uploaded. */
    fileUploadInProgressCount?: number;
    /** Number of items currently being processed in data extraction. */
    dataExtractionInProgressCount?: number;
    /** Number of items failed. */
    itemsFailed?: number;
    /** Number of items cancelled. */
    itemsCancelled?: number;
    /** Time stamp of last progress update from data extraction. */
    lastDataExtractionProgressTimeStamp?: Date | undefined;
    /** Time stamp of last progress update from upload. */
    lastFileUploadProgressTimeStamp?: Date | undefined;
}

export class ImportTransferRequest implements IImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IImportTransferRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["contentPermissionSetIds"])) {
                this.contentPermissionSetIds = [] as any;
                for (let item of _data["contentPermissionSetIds"])
                    this.contentPermissionSetIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ImportTransferRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.contentPermissionSetIds)) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data;
    }
}

export interface IImportTransferRequest {
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

export class ImportTransferPartialRequest implements IImportTransferPartialRequest {
    items?: FileTransferCreateItem[] | undefined;

    constructor(data?: IImportTransferPartialRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new FileTransferCreateItem(item) : <FileTransferCreateItem>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileTransferCreateItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportTransferPartialRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTransferPartialRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportTransferPartialRequest {
    items?: IFileTransferCreateItem[] | undefined;
}

export class FileTransferCreateItem implements IFileTransferCreateItem {
    fileId!: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;

    constructor(data?: IFileTransferCreateItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileId = _data["fileId"];
            if (Array.isArray(_data["layerSchemaIds"])) {
                this.layerSchemaIds = [] as any;
                for (let item of _data["layerSchemaIds"])
                    this.layerSchemaIds!.push(item);
            }
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["contentPermissionSetIds"])) {
                this.contentPermissionSetIds = [] as any;
                for (let item of _data["contentPermissionSetIds"])
                    this.contentPermissionSetIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferCreateItem {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferCreateItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        if (Array.isArray(this.layerSchemaIds)) {
            data["layerSchemaIds"] = [];
            for (let item of this.layerSchemaIds)
                data["layerSchemaIds"].push(item);
        }
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.contentPermissionSetIds)) {
            data["contentPermissionSetIds"] = [];
            for (let item of this.contentPermissionSetIds)
                data["contentPermissionSetIds"].push(item);
        }
        return data;
    }
}

export interface IFileTransferCreateItem {
    fileId: string;
    /** An optional id list of schemas with type layer. */
    layerSchemaIds?: string[] | undefined;
    /** The metadata to be assigned to the imported content. It's a dictionary of dynamic metadata whose structure is defined in the Layer schemas identified
by the LayerSchemaIds property. */
    metadata?: { [key: string]: any; } | undefined;
    /** An optional id list of content permission sets. Controls content accessibility outside of content ownership. */
    contentPermissionSetIds?: string[] | undefined;
}

/** Base class for search results */
export class BaseResultOfTransfer implements IBaseResultOfTransfer {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: Transfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Transfer(item) : <Transfer>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Transfer.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfTransfer {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: ITransfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfTransfer extends BaseResultOfTransfer implements ISearchBehaviorBaseResultOfTransfer {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfTransfer) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfTransfer extends IBaseResultOfTransfer {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Result from a search for transfers. */
export class TransferSearchResult extends SearchBehaviorBaseResultOfTransfer implements ITransferSearchResult {

    constructor(data?: ITransferSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): TransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result from a search for transfers. */
export interface ITransferSearchResult extends ISearchBehaviorBaseResultOfTransfer {
}

/** Request to search for transfers. */
export class TransferSearchRequest implements ITransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the TransferSearchResult.
Warning! It severely affects performance. */
    debugMode!: boolean;

    constructor(data?: ITransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.debugMode = _data["debugMode"];
        }
    }

    static fromJS(data: any): TransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        return data;
    }
}

/** Request to search for transfers. */
export interface ITransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Enable debug mode: additional debug information regarding the query execution and reason of the matched documents are returned in the TransferSearchResult.
Warning! It severely affects performance. */
    debugMode: boolean;
}

/** Representation of a file transfer. */
export class FileTransfer implements IFileTransfer {
    /** ID of file transfer. */
    id!: string;
    /** Name of file transfer. */
    name!: string;
    /** Replaced in favor of RequestId. Client provided identifier. */
    identifier?: string | undefined;
    /** Client provided identifier. */
    requestId!: string;
    /** ID of transfer. */
    transferId!: string;
    /** State of file transfer. */
    state!: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string | undefined;

    constructor(data?: IFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.requestId = _data["requestId"];
            this.transferId = _data["transferId"];
            this.state = _data["state"];
            this.contentId = _data["contentId"];
        }
    }

    static fromJS(data: any): FileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["requestId"] = this.requestId;
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        data["contentId"] = this.contentId;
        return data;
    }
}

/** Representation of a file transfer. */
export interface IFileTransfer {
    /** ID of file transfer. */
    id: string;
    /** Name of file transfer. */
    name: string;
    /** Replaced in favor of RequestId. Client provided identifier. */
    identifier?: string | undefined;
    /** Client provided identifier. */
    requestId: string;
    /** ID of transfer. */
    transferId: string;
    /** State of file transfer. */
    state: FileTransferState;
    /** ID of Content created for file. */
    contentId?: string | undefined;
}

/** Detailed representation of file transfer. */
export class FileTransferDetail extends FileTransfer implements IFileTransferDetail {
    /** Audit information. */
    audit!: UserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: FileMetadata | undefined;
    /** Outputs rendered during data extraction phase. */
    outputItems?: FileTransferOutput[] | undefined;

    constructor(data?: IFileTransferDetail) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAudit(data.audit) : <UserAudit>this.audit;
            this.fileMetadata = data.fileMetadata && !(<any>data.fileMetadata).toJSON ? new FileMetadata(data.fileMetadata) : <FileMetadata>this.fileMetadata;
            if (data.outputItems) {
                this.outputItems = [];
                for (let i = 0; i < data.outputItems.length; i++) {
                    let item = data.outputItems[i];
                    this.outputItems[i] = item && !(<any>item).toJSON ? new FileTransferOutput(item) : <FileTransferOutput>item;
                }
            }
        }
        if (!data) {
            this.audit = new UserAudit();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.audit = _data["audit"] ? UserAudit.fromJS(_data["audit"]) : new UserAudit();
            this.fileMetadata = _data["fileMetadata"] ? FileMetadata.fromJS(_data["fileMetadata"]) : <any>undefined;
            if (Array.isArray(_data["outputItems"])) {
                this.outputItems = [] as any;
                for (let item of _data["outputItems"])
                    this.outputItems!.push(FileTransferOutput.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): FileTransferDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["fileMetadata"] = this.fileMetadata ? this.fileMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.outputItems)) {
            data["outputItems"] = [];
            for (let item of this.outputItems)
                data["outputItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Detailed representation of file transfer. */
export interface IFileTransferDetail extends IFileTransfer {
    /** Audit information. */
    audit: IUserAudit;
    /** Metadata extracted for file. */
    fileMetadata?: IFileMetadata | undefined;
    /** Outputs rendered during data extraction phase. */
    outputItems?: IFileTransferOutput[] | undefined;
}

export class FileMetadata implements IFileMetadata {
    names?: TranslatedStringDictionary | undefined;
    descriptions?: TranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: any | undefined;
    exifMetadata?: any | undefined;
    language?: string | undefined;

    constructor(data?: IFileMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
            this.descriptions = data.descriptions && !(<any>data.descriptions).toJSON ? new TranslatedStringDictionary(data.descriptions) : <TranslatedStringDictionary>this.descriptions;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : <any>undefined;
            this.descriptions = _data["descriptions"] ? TranslatedStringDictionary.fromJS(_data["descriptions"]) : <any>undefined;
            this.fileExtension = _data["fileExtension"];
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.fileSizeInBytes = _data["fileSizeInBytes"];
            this.sha1Hash = _data["sha1Hash"];
            this.xmpMetadata = _data["xmpMetadata"];
            this.exifMetadata = _data["exifMetadata"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): FileMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        data["descriptions"] = this.descriptions ? this.descriptions.toJSON() : <any>undefined;
        data["fileExtension"] = this.fileExtension;
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["sha1Hash"] = this.sha1Hash;
        data["xmpMetadata"] = this.xmpMetadata;
        data["exifMetadata"] = this.exifMetadata;
        data["language"] = this.language;
        return data;
    }
}

export interface IFileMetadata {
    names?: ITranslatedStringDictionary | undefined;
    descriptions?: ITranslatedStringDictionary | undefined;
    fileExtension?: string | undefined;
    fileName?: string | undefined;
    filePath?: string | undefined;
    fileSizeInBytes?: number | undefined;
    sha1Hash?: string | undefined;
    xmpMetadata?: any | undefined;
    exifMetadata?: any | undefined;
    language?: string | undefined;
}

export class FileTransferOutput implements IFileTransferOutput {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource!: OutputSource;

    constructor(data?: IFileTransferOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.filePath = _data["filePath"];
            this.outputSource = _data["outputSource"];
        }
    }

    static fromJS(data: any): FileTransferOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["outputSource"] = this.outputSource;
        return data;
    }
}

export interface IFileTransferOutput {
    id?: string | undefined;
    filePath?: string | undefined;
    outputSource: OutputSource;
}

export enum OutputSource {
    Rendered = "Rendered",
    Embedded = "Embedded",
}

export enum FileTransferState {
    Draft = "Draft",
    UploadInProgress = "UploadInProgress",
    UploadCompleted = "UploadCompleted",
    DataExtractionInProgress = "DataExtractionInProgress",
    DataExtractionDone = "DataExtractionDone",
    ImportInProgress = "ImportInProgress",
    ImportCompleted = "ImportCompleted",
    UploadCancelled = "UploadCancelled",
    ImportCancelled = "ImportCancelled",
    UploadFailed = "UploadFailed",
    ImportFailed = "ImportFailed",
    DeleteInProgress = "DeleteInProgress",
    Deleted = "Deleted",
    CleanupInProgress = "CleanupInProgress",
    CleanupCompleted = "CleanupCompleted",
}

/** Base class for search results */
export class BaseResultOfFileTransfer implements IBaseResultOfFileTransfer {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: FileTransfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfFileTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new FileTransfer(item) : <FileTransfer>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(FileTransfer.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfFileTransfer {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IFileTransfer[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfFileTransfer extends BaseResultOfFileTransfer implements ISearchBehaviorBaseResultOfFileTransfer {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfFileTransfer) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfFileTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfFileTransfer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfFileTransfer extends IBaseResultOfFileTransfer {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Result from a search for file transfers. */
export class FileTransferSearchResult extends SearchBehaviorBaseResultOfFileTransfer implements IFileTransferSearchResult {

    constructor(data?: IFileTransferSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FileTransferSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Result from a search for file transfers. */
export interface IFileTransferSearchResult extends ISearchBehaviorBaseResultOfFileTransfer {
}

/** Request to search for file transfers. */
export class FileTransferSearchRequest implements IFileTransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;

    constructor(data?: IFileTransferSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileTransferSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to search for file transfers. */
export interface IFileTransferSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
}

/** Deletes files from transfer. */
export class FileTransferDeleteRequest implements IFileTransferDeleteRequest {
    /** ID of transfer. */
    transferId!: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds!: string[];

    constructor(data?: IFileTransferDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fileTransferIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferId = _data["transferId"];
            if (Array.isArray(_data["fileTransferIds"])) {
                this.fileTransferIds = [] as any;
                for (let item of _data["fileTransferIds"])
                    this.fileTransferIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FileTransferDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileTransferDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        if (Array.isArray(this.fileTransferIds)) {
            data["fileTransferIds"] = [];
            for (let item of this.fileTransferIds)
                data["fileTransferIds"].push(item);
        }
        return data;
    }
}

/** Deletes files from transfer. */
export interface IFileTransferDeleteRequest {
    /** ID of transfer. */
    transferId: string;
    /** List of IDs of file transfers to delete. */
    fileTransferIds: string[];
}

/** Blacklist containing file name patterns skipped when uploading. */
export class Blacklist implements IBlacklist {
    /** Blacklist entries. */
    items!: BlacklistItem[];

    constructor(data?: IBlacklist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.items) {
                this.items = [];
                for (let i = 0; i < data.items.length; i++) {
                    let item = data.items[i];
                    this.items[i] = item && !(<any>item).toJSON ? new BlacklistItem(item) : <BlacklistItem>item;
                }
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlacklistItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Blacklist {
        data = typeof data === 'object' ? data : {};
        let result = new Blacklist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Blacklist containing file name patterns skipped when uploading. */
export interface IBlacklist {
    /** Blacklist entries. */
    items: IBlacklistItem[];
}

/** Entry in the Blacklist. */
export class BlacklistItem implements IBlacklistItem {
    /** Friendly name of item. */
    name!: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match!: string;

    constructor(data?: IBlacklistItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.match = _data["match"];
        }
    }

    static fromJS(data: any): BlacklistItem {
        data = typeof data === 'object' ? data : {};
        let result = new BlacklistItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["match"] = this.match;
        return data;
    }
}

/** Entry in the Blacklist. */
export interface IBlacklistItem {
    /** Friendly name of item. */
    name: string;
    /** Pattern a file name must match to be excluded from the transfer. */
    match: string;
}

/** Base class for search results */
export class BaseResultOfUserRole implements IBaseResultOfUserRole {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: UserRole[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UserRole.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfUserRole {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: UserRole[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfUserRole extends BaseResultOfUserRole implements ISearchBehaviorBaseResultOfUserRole {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfUserRole) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfUserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfUserRole extends IBaseResultOfUserRole {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Holds results of the user role search. */
export class UserRoleSearchResult extends SearchBehaviorBaseResultOfUserRole implements IUserRoleSearchResult {

    constructor(data?: IUserRoleSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserRoleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of the user role search. */
export interface IUserRoleSearchResult extends ISearchBehaviorBaseResultOfUserRole {
}

/** Represents a user role, which associates users with user rights. */
export class UserRoleEditable implements IUserRoleEditable {
    /** Language specific user role names. */
    names!: TranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights!: UserRight[];

    constructor(data?: IUserRoleEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.names = data.names && !(<any>data.names).toJSON ? new TranslatedStringDictionary(data.names) : <TranslatedStringDictionary>this.names;
        }
        if (!data) {
            this.names = new TranslatedStringDictionary();
            this.userRights = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.names = _data["names"] ? TranslatedStringDictionary.fromJS(_data["names"]) : new TranslatedStringDictionary();
            if (Array.isArray(_data["userRights"])) {
                this.userRights = [] as any;
                for (let item of _data["userRights"])
                    this.userRights!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleEditable {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["names"] = this.names ? this.names.toJSON() : <any>undefined;
        if (Array.isArray(this.userRights)) {
            data["userRights"] = [];
            for (let item of this.userRights)
                data["userRights"].push(item);
        }
        return data;
    }
}

/** Represents a user role, which associates users with user rights. */
export interface IUserRoleEditable {
    /** Language specific user role names. */
    names: ITranslatedStringDictionary;
    /** All user rights for this user role. */
    userRights: UserRight[];
}

/** Represents a user role, which associates users with user rights. */
export class UserRole extends UserRoleEditable implements IUserRole {
    /** User role ID. */
    id!: string;

    constructor(data?: IUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** Represents a user role, which associates users with user rights. */
export interface IUserRole extends IUserRoleEditable {
    /** User role ID. */
    id: string;
}

export class UserRoleSearchRequest implements IUserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to user roles. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode!: boolean;
    /** Which languages to search against when using the search string. */
    searchLanguages?: string[] | undefined;
    /** Defines if the user roles with system user role Administrator is returned. */
    includeAdministratorSystemUserRole!: boolean;

    constructor(data?: IUserRoleSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["searchLanguages"])) {
                this.searchLanguages = [] as any;
                for (let item of _data["searchLanguages"])
                    this.searchLanguages!.push(item);
            }
            this.includeAdministratorSystemUserRole = _data["includeAdministratorSystemUserRole"];
        }
    }

    static fromJS(data: any): UserRoleSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.searchLanguages)) {
            data["searchLanguages"] = [];
            for (let item of this.searchLanguages)
                data["searchLanguages"].push(item);
        }
        data["includeAdministratorSystemUserRole"] = this.includeAdministratorSystemUserRole;
        return data;
    }
}

export interface IUserRoleSearchRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. Defaults to 30. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Filter applied to user roles. */
    filter?: FilterBase | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! It severely affects performance. */
    debugMode: boolean;
    /** Which languages to search against when using the search string. */
    searchLanguages?: string[] | undefined;
    /** Defines if the user roles with system user role Administrator is returned. */
    includeAdministratorSystemUserRole: boolean;
}

/** Represents a user role, which associates users with user rights. */
export class UserRoleDetail extends UserRole implements IUserRoleDetail {
    /** Audit information. */
    audit?: UserAuditDetail | undefined;

    constructor(data?: IUserRoleDetail) {
        super(data);
        if (data) {
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): UserRoleDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents a user role, which associates users with user rights. */
export interface IUserRoleDetail extends IUserRole {
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
}

/** Holds information needed to create multiple user roles. */
export class UserRoleCreateManyRequest implements IUserRoleCreateManyRequest {
    /** Multiple user creation requests. */
    items!: UserRoleCreateRequest[];

    constructor(data?: IUserRoleCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRoleCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Holds information needed to create multiple user roles. */
export interface IUserRoleCreateManyRequest {
    /** Multiple user creation requests. */
    items: UserRoleCreateRequest[];
}

/** Holds information needed for user role creation. */
export class UserRoleCreateRequest extends UserRoleEditable implements IUserRoleCreateRequest {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IUserRoleCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestId = _data["requestId"];
        }
    }

    static override fromJS(data: any): UserRoleCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data;
    }
}

/** Holds information needed for user role creation. */
export interface IUserRoleCreateRequest extends IUserRoleEditable {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Holds information about which user roles and how are requested to be updated. */
export class UserRoleUpdateManyRequest implements IUserRoleUpdateManyRequest {
    /** New value for user roles with specified IDs. */
    items!: UserRole[];

    constructor(data?: IUserRoleUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Holds information about which user roles and how are requested to be updated. */
export interface IUserRoleUpdateManyRequest {
    /** New value for user roles with specified IDs. */
    items: UserRole[];
}

/** Holds information about which user roles are requested to be deleted. */
export class UserRoleDeleteManyRequest implements IUserRoleDeleteManyRequest {
    /** IDs of the user roles to delete. */
    ids!: string[];

    constructor(data?: IUserRoleDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRoleDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

/** Holds information about which user roles are requested to be deleted. */
export interface IUserRoleDeleteManyRequest {
    /** IDs of the user roles to delete. */
    ids: string[];
}

/** Detail information about a user. */
export class UserDetail extends User implements IUserDetail {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRoleAssignment[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** User's address. */
    address?: UserAddress | undefined;
    /** Identity provider that governs this user or null for Picturepark's own IdentityServer. */
    identityProviderId?: string | undefined;
    /** Owner tokens referencing the user. */
    ownerTokens?: OwnerToken[] | undefined;
    /** Authorization state the user is currently in. */
    authorizationState?: AuthorizationState;
    /** Locked users are unable to log in and use the system. */
    isLocked?: boolean;
    /** Life cycle state the user is currently in. */
    lifeCycle?: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser?: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly?: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated?: boolean;
    /** Audit information. */
    audit?: UserAuditDetail | undefined;
    /** Last activity of user. */
    lastActivity?: Date | undefined;

    constructor(data?: IUserDetail) {
        super(data);
        if (data) {
            if (data.userRoles) {
                this.userRoles = [];
                for (let i = 0; i < data.userRoles.length; i++) {
                    let item = data.userRoles[i];
                    this.userRoles[i] = item && !(<any>item).toJSON ? new UserRoleAssignment(item) : <UserRoleAssignment>item;
                }
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address;
            if (data.ownerTokens) {
                this.ownerTokens = [];
                for (let i = 0; i < data.ownerTokens.length; i++) {
                    let item = data.ownerTokens[i];
                    this.ownerTokens[i] = item && !(<any>item).toJSON ? new OwnerToken(item) : <OwnerToken>item;
                }
            }
            this.audit = data.audit && !(<any>data.audit).toJSON ? new UserAuditDetail(data.audit) : <UserAuditDetail>this.audit;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleAssignment.fromJS(item));
            }
            this.comment = _data["comment"];
            this.languageCode = _data["languageCode"];
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
            this.identityProviderId = _data["identityProviderId"];
            if (Array.isArray(_data["ownerTokens"])) {
                this.ownerTokens = [] as any;
                for (let item of _data["ownerTokens"])
                    this.ownerTokens!.push(OwnerToken.fromJS(item));
            }
            this.authorizationState = _data["authorizationState"];
            this.isLocked = _data["isLocked"];
            this.lifeCycle = _data["lifeCycle"];
            this.isSupportUser = _data["isSupportUser"];
            this.isReadOnly = _data["isReadOnly"];
            this.isFederated = _data["isFederated"];
            this.audit = _data["audit"] ? UserAuditDetail.fromJS(_data["audit"]) : <any>undefined;
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["identityProviderId"] = this.identityProviderId;
        if (Array.isArray(this.ownerTokens)) {
            data["ownerTokens"] = [];
            for (let item of this.ownerTokens)
                data["ownerTokens"].push(item.toJSON());
        }
        data["authorizationState"] = this.authorizationState;
        data["isLocked"] = this.isLocked;
        data["lifeCycle"] = this.lifeCycle;
        data["isSupportUser"] = this.isSupportUser;
        data["isReadOnly"] = this.isReadOnly;
        data["isFederated"] = this.isFederated;
        data["audit"] = this.audit ? this.audit.toJSON() : <any>undefined;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Detail information about a user. */
export interface IUserDetail extends IUser {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: IUserRoleAssignment[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode?: string | undefined;
    /** User's address. */
    address?: IUserAddress | undefined;
    /** Identity provider that governs this user or null for Picturepark's own IdentityServer. */
    identityProviderId?: string | undefined;
    /** Owner tokens referencing the user. */
    ownerTokens?: IOwnerToken[] | undefined;
    /** Authorization state the user is currently in. */
    authorizationState?: AuthorizationState;
    /** Locked users are unable to log in and use the system. */
    isLocked?: boolean;
    /** Life cycle state the user is currently in. */
    lifeCycle?: LifeCycle;
    /** The support user is a user created for Picturepark support personnel. */
    isSupportUser?: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly?: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated?: boolean;
    /** Audit information. */
    audit?: IUserAuditDetail | undefined;
    /** Last activity of user. */
    lastActivity?: Date | undefined;
}

export class UserRoleAssignment implements IUserRoleAssignment {
    /** User role assigned. */
    userRole?: UserRole | undefined;
    /** Marks user roles that were assigned automatically to a federated user based on group mapping of a federated identity provider. */
    isFederated!: boolean;

    constructor(data?: IUserRoleAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.userRole = data.userRole && !(<any>data.userRole).toJSON ? new UserRole(data.userRole) : <UserRole>this.userRole;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRole = _data["userRole"] ? UserRole.fromJS(_data["userRole"]) : <any>undefined;
            this.isFederated = _data["isFederated"];
        }
    }

    static fromJS(data: any): UserRoleAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRole"] = this.userRole ? this.userRole.toJSON() : <any>undefined;
        data["isFederated"] = this.isFederated;
        return data;
    }
}

export interface IUserRoleAssignment {
    /** User role assigned. */
    userRole?: IUserRole | undefined;
    /** Marks user roles that were assigned automatically to a federated user based on group mapping of a federated identity provider. */
    isFederated: boolean;
}

export class OwnerToken implements IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;

    constructor(data?: IOwnerToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): OwnerToken {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IOwnerToken {
    /** The ownertoken id. */
    id?: string | undefined;
    /** The id of the user to whom this ownertoken currently belongs to. */
    userId?: string | undefined;
}

/** Represents the updateable fields of the user. */
export class UserUpdateRequest extends User implements IUserUpdateRequest {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRole[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode!: string;
    /** User's address. */
    address?: UserAddress | undefined;
    /** Identity provider that governs this user or null for Picturepark's own IdentityServer. */
    identityProviderId?: string | undefined;

    constructor(data?: IUserUpdateRequest) {
        super(data);
        if (data) {
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
            this.comment = _data["comment"];
            this.languageCode = _data["languageCode"];
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
            this.identityProviderId = _data["identityProviderId"];
        }
    }

    static override fromJS(data: any): UserUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["languageCode"] = this.languageCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["identityProviderId"] = this.identityProviderId;
        super.toJSON(data);
        return data;
    }
}

/** Represents the updateable fields of the user. */
export interface IUserUpdateRequest extends IUser {
    /** User roles the user should be assigned to. Overwrites the original user roles. */
    userRoles?: UserRole[] | undefined;
    /** Comment saved for the user. */
    comment?: string | undefined;
    /** Preferred language, e.g. for correspondence. */
    languageCode: string;
    /** User's address. */
    address?: IUserAddress | undefined;
    /** Identity provider that governs this user or null for Picturepark's own IdentityServer. */
    identityProviderId?: string | undefined;
}

export class UserLockRequest implements IUserLockRequest {
    /** Indicates the requested lock state of the user.
If _true_ was specified, the user will be _locked_. _False_ will unlock the previously _locked_ user.
If User is already in desired state, this will be returned as error. */
    lock!: boolean;

    constructor(data?: IUserLockRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lock = _data["lock"];
        }
    }

    static fromJS(data: any): UserLockRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lock"] = this.lock;
        return data;
    }
}

export interface IUserLockRequest {
    /** Indicates the requested lock state of the user.
If _true_ was specified, the user will be _locked_. _False_ will unlock the previously _locked_ user.
If User is already in desired state, this will be returned as error. */
    lock: boolean;
}

/** Base class for requests affecting multiple users */
export abstract class UserManyRequestBase implements IUserManyRequestBase {
    /** User IDs. */
    userIds!: string[];

    constructor(data?: IUserManyRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UserManyRequestBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserManyRequestBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

/** Base class for requests affecting multiple users */
export interface IUserManyRequestBase {
    /** User IDs. */
    userIds: string[];
}

/** Request update of lock state of multiple users */
export class UserLockManyRequest extends UserManyRequestBase implements IUserLockManyRequest {
    /** Indicates the requested lock state of the users.
If _true_ was specified, the users will be _locked_. _False_ will unlock the previously _locked_ users.
Users which are already in desired state will be returned as errors. */
    lock!: boolean;

    constructor(data?: IUserLockManyRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lock = _data["lock"];
        }
    }

    static override fromJS(data: any): UserLockManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lock"] = this.lock;
        super.toJSON(data);
        return data;
    }
}

/** Request update of lock state of multiple users */
export interface IUserLockManyRequest extends IUserManyRequestBase {
    /** Indicates the requested lock state of the users.
If _true_ was specified, the users will be _locked_. _False_ will unlock the previously _locked_ users.
Users which are already in desired state will be returned as errors. */
    lock: boolean;
}

/** Holds additional information for user review. */
export class UserReviewRequest implements IUserReviewRequest {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed!: boolean;
    /** If true, no email will be sent to inform the user that they were reviewed. */
    suppressEmail!: boolean;

    constructor(data?: IUserReviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewed = _data["reviewed"];
            this.suppressEmail = _data["suppressEmail"];
        }
    }

    static fromJS(data: any): UserReviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserReviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewed"] = this.reviewed;
        data["suppressEmail"] = this.suppressEmail;
        return data;
    }
}

/** Holds additional information for user review. */
export interface IUserReviewRequest {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed: boolean;
    /** If true, no email will be sent to inform the user that they were reviewed. */
    suppressEmail: boolean;
}

/** Review many request */
export class UserReviewManyRequest extends UserManyRequestBase implements IUserReviewManyRequest {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed!: boolean;
    /** If true, no email will be sent to inform the users that they were reviewed. */
    suppressEmail?: boolean;

    constructor(data?: IUserReviewManyRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reviewed = _data["reviewed"];
            this.suppressEmail = _data["suppressEmail"];
        }
    }

    static override fromJS(data: any): UserReviewManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserReviewManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewed"] = this.reviewed;
        data["suppressEmail"] = this.suppressEmail;
        super.toJSON(data);
        return data;
    }
}

/** Review many request */
export interface IUserReviewManyRequest extends IUserManyRequestBase {
    /** Indicates the requested review state of the user.
If _true_ is specified, user will be transitioned into _reviewed_ state. _False_ will put the user back into _to be reviewed_ state. */
    reviewed: boolean;
    /** If true, no email will be sent to inform the users that they were reviewed. */
    suppressEmail?: boolean;
}

/** Request for inviting users (applies to users in states ToBeReviewed + Reviewed) */
export class UserInviteManyRequest extends UserManyRequestBase implements IUserInviteManyRequest {

    constructor(data?: IUserInviteManyRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserInviteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserInviteManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request for inviting users (applies to users in states ToBeReviewed + Reviewed) */
export interface IUserInviteManyRequest extends IUserManyRequestBase {
}

/** Request for re-inviting users (applies to users in states Invited) */
export class UserReinviteManyRequest extends UserManyRequestBase implements IUserReinviteManyRequest {

    constructor(data?: IUserReinviteManyRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserReinviteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserReinviteManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Request for re-inviting users (applies to users in states Invited) */
export interface IUserReinviteManyRequest extends IUserManyRequestBase {
}

/** Request to update role assignment of users. */
export class UserRoleAssignManyRequest extends UserManyRequestBase implements IUserRoleAssignManyRequest {
    /** Users roles to modify. */
    userRoleIds!: string[];
    /** Defines how to apply specified UserRoleIds to UserIds
If an operation results in no change for a user, that user will be returned as succeeded. */
    operation!: UserRoleAssignmentOperationType;

    constructor(data?: IUserRoleAssignManyRequest) {
        super(data);
        if (!data) {
            this.userRoleIds = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
            this.operation = _data["operation"];
        }
    }

    static override fromJS(data: any): UserRoleAssignManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["operation"] = this.operation;
        super.toJSON(data);
        return data;
    }
}

/** Request to update role assignment of users. */
export interface IUserRoleAssignManyRequest extends IUserManyRequestBase {
    /** Users roles to modify. */
    userRoleIds: string[];
    /** Defines how to apply specified UserRoleIds to UserIds
If an operation results in no change for a user, that user will be returned as succeeded. */
    operation: UserRoleAssignmentOperationType;
}

/** User role assignment operation type */
export enum UserRoleAssignmentOperationType {
    Add = "Add",
    Remove = "Remove",
    Update = "Update",
}

/** Details of the user deletion. */
export class UserDeleteRequest implements IUserDeleteRequest {
    /** User ID of user who will take over the ownership of the content currently owned by the deleted user. */
    ownerTokenTransferUserId?: string | undefined;

    constructor(data?: IUserDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownerTokenTransferUserId = _data["ownerTokenTransferUserId"];
        }
    }

    static fromJS(data: any): UserDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerTokenTransferUserId"] = this.ownerTokenTransferUserId;
        return data;
    }
}

/** Details of the user deletion. */
export interface IUserDeleteRequest {
    /** User ID of user who will take over the ownership of the content currently owned by the deleted user. */
    ownerTokenTransferUserId?: string | undefined;
}

/** Holds information needed for user creation. */
export class UserCreateRequest implements IUserCreateRequest {
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;
    /** Preferred language, e.g. for correspondence. */
    languageCode!: string;
    /** IDs of user roles the user is assigned to. */
    userRoleIds?: string[] | undefined;
    /** User address. */
    address?: UserAddress | undefined;

    constructor(data?: IUserCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.address = data.address && !(<any>data.address).toJSON ? new UserAddress(data.address) : <UserAddress>this.address;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.languageCode = _data["languageCode"];
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["languageCode"] = this.languageCode;
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

/** Holds information needed for user creation. */
export interface IUserCreateRequest {
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Preferred language, e.g. for correspondence. */
    languageCode: string;
    /** IDs of user roles the user is assigned to. */
    userRoleIds?: string[] | undefined;
    /** User address. */
    address?: IUserAddress | undefined;
}

/** Base class for search results */
export class BaseResultOfUserWithRoles implements IBaseResultOfUserWithRoles {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: UserWithRoles[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUserWithRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new UserWithRoles(item) : <UserWithRoles>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UserWithRoles.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfUserWithRoles {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IUserWithRoles[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfUserWithRoles extends BaseResultOfUserWithRoles implements ISearchBehaviorBaseResultOfUserWithRoles {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfUserWithRoles) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfUserWithRoles extends IBaseResultOfUserWithRoles {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfUserWithRoles extends SearchBehaviorBaseResultOfUserWithRoles implements ISearchBehaviorWithAggregationBaseResultOfUserWithRoles {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfUserWithRoles) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfUserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfUserWithRoles();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfUserWithRoles extends ISearchBehaviorBaseResultOfUserWithRoles {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Holds results of the user search. */
export class UserSearchResult extends SearchBehaviorWithAggregationBaseResultOfUserWithRoles implements IUserSearchResult {

    constructor(data?: IUserSearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of the user search. */
export interface IUserSearchResult extends ISearchBehaviorWithAggregationBaseResultOfUserWithRoles {
}

/** User information retrieved via search */
export class UserWithRoles implements IUserWithRoles {
    /** IDs of user roles user is assigned to */
    userRoleIds?: string[] | undefined;
    /** User's Picturepark ID. */
    id!: string;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress!: string;
    /** Authorization state the user is currently in. */
    authorizationState!: AuthorizationState;
    /** Life cycle state the user is currently in. */
    lifeCycle!: LifeCycle;
    /** A locked user is not allowed to log in. */
    isLocked!: boolean;
    /** A support user is a user created for Picturepark support personnel. */
    isSupportUser!: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly!: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated!: boolean;
    /** Last activity of user. */
    lastActivity?: Date | undefined;

    constructor(data?: IUserWithRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userRoleIds"])) {
                this.userRoleIds = [] as any;
                for (let item of _data["userRoleIds"])
                    this.userRoleIds!.push(item);
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.authorizationState = _data["authorizationState"];
            this.lifeCycle = _data["lifeCycle"];
            this.isLocked = _data["isLocked"];
            this.isSupportUser = _data["isSupportUser"];
            this.isReadOnly = _data["isReadOnly"];
            this.isFederated = _data["isFederated"];
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserWithRoles {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userRoleIds)) {
            data["userRoleIds"] = [];
            for (let item of this.userRoleIds)
                data["userRoleIds"].push(item);
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["authorizationState"] = this.authorizationState;
        data["lifeCycle"] = this.lifeCycle;
        data["isLocked"] = this.isLocked;
        data["isSupportUser"] = this.isSupportUser;
        data["isReadOnly"] = this.isReadOnly;
        data["isFederated"] = this.isFederated;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : <any>undefined;
        return data;
    }
}

/** User information retrieved via search */
export interface IUserWithRoles {
    /** IDs of user roles user is assigned to */
    userRoleIds?: string[] | undefined;
    /** User's Picturepark ID. */
    id: string;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** Email address of the user (doubles as username). */
    emailAddress: string;
    /** Authorization state the user is currently in. */
    authorizationState: AuthorizationState;
    /** Life cycle state the user is currently in. */
    lifeCycle: LifeCycle;
    /** A locked user is not allowed to log in. */
    isLocked: boolean;
    /** A support user is a user created for Picturepark support personnel. */
    isSupportUser: boolean;
    /** Read-only users can't be removed from the system, e.g. service user. */
    isReadOnly: boolean;
    /** Federated user is a user who is (currently) governed by an external identity provider. */
    isFederated: boolean;
    /** Last activity of user. */
    lastActivity?: Date | undefined;
}

/** Represents a search request over users. */
export abstract class UsersSearchBaseRequest implements IUsersSearchBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Return only users in certain life cycle state(s). */
    lifeCycleFilter!: LifeCycleFilter;
    /** Return only users with certain user rights. */
    userRightsFilter?: UserRight[] | undefined;
    /** Includes the service user in result. */
    includeServiceUser!: boolean;
    /** Restricts the results to users that are editable for calling user.
If set to true, IncludeServiceUser is ignored. */
    editableOnly!: boolean;

    constructor(data?: IUsersSearchBaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.lifeCycleFilter = _data["lifeCycleFilter"];
            if (Array.isArray(_data["userRightsFilter"])) {
                this.userRightsFilter = [] as any;
                for (let item of _data["userRightsFilter"])
                    this.userRightsFilter!.push(item);
            }
            this.includeServiceUser = _data["includeServiceUser"];
            this.editableOnly = _data["editableOnly"];
        }
    }

    static fromJS(data: any): UsersSearchBaseRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UsersSearchBaseRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["lifeCycleFilter"] = this.lifeCycleFilter;
        if (Array.isArray(this.userRightsFilter)) {
            data["userRightsFilter"] = [];
            for (let item of this.userRightsFilter)
                data["userRightsFilter"].push(item);
        }
        data["includeServiceUser"] = this.includeServiceUser;
        data["editableOnly"] = this.editableOnly;
        return data;
    }
}

/** Represents a search request over users. */
export interface IUsersSearchBaseRequest {
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Return only users in certain life cycle state(s). */
    lifeCycleFilter: LifeCycleFilter;
    /** Return only users with certain user rights. */
    userRightsFilter?: UserRight[] | undefined;
    /** Includes the service user in result. */
    includeServiceUser: boolean;
    /** Restricts the results to users that are editable for calling user.
If set to true, IncludeServiceUser is ignored. */
    editableOnly: boolean;
}

/** Represents an aggregation request over users. */
export abstract class UserSearchAndAggregationBaseRequest extends UsersSearchBaseRequest implements IUserSearchAndAggregationBaseRequest {
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;

    constructor(data?: IUserSearchAndAggregationBaseRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserSearchAndAggregationBaseRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserSearchAndAggregationBaseRequest' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents an aggregation request over users. */
export interface IUserSearchAndAggregationBaseRequest extends IUsersSearchBaseRequest {
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
}

/** Represents user search request. */
export class UserSearchRequest extends UserSearchAndAggregationBaseRequest implements IUserSearchRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;

    constructor(data?: IUserSearchRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents user search request. */
export interface IUserSearchRequest extends IUserSearchAndAggregationBaseRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode?: boolean;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
}

/** Represents an aggregation request over users. */
export class UserAggregationRequest extends UserSearchAndAggregationBaseRequest implements IUserAggregationRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators!: AggregatorBase[];

    constructor(data?: IUserAggregationRequest) {
        super(data);
        if (!data) {
            this.aggregators = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserAggregationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserAggregationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents an aggregation request over users. */
export interface IUserAggregationRequest extends IUserSearchAndAggregationBaseRequest {
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators: AggregatorBase[];
}

/** Request to update identity provider assignment of users. */
export class UserUpdateIdentityProviderManyRequest extends UserManyRequestBase implements IUserUpdateIdentityProviderManyRequest {
    /** Identity provider to assign to users. */
    identityProviderId?: string | undefined;

    constructor(data?: IUserUpdateIdentityProviderManyRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.identityProviderId = _data["identityProviderId"];
        }
    }

    static override fromJS(data: any): UserUpdateIdentityProviderManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateIdentityProviderManyRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityProviderId"] = this.identityProviderId;
        super.toJSON(data);
        return data;
    }
}

/** Request to update identity provider assignment of users. */
export interface IUserUpdateIdentityProviderManyRequest extends IUserManyRequestBase {
    /** Identity provider to assign to users. */
    identityProviderId?: string | undefined;
}

/** Base class for search results */
export class BaseResultOfUser implements IBaseResultOfUser {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: User[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new User(item) : <User>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(User.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfUser {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: IUser[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfUser extends BaseResultOfUser implements ISearchBehaviorBaseResultOfUser {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfUser) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfUser extends IBaseResultOfUser {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Holds results of the list user search. */
export class UserListResult extends SearchBehaviorBaseResultOfUser implements IUserListResult {

    constructor(data?: IUserListResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UserListResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserListResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of the list user search. */
export interface IUserListResult extends ISearchBehaviorBaseResultOfUser {
}

/** Represents user list request. */
export class UserListRequest extends UsersSearchBaseRequest implements IUserListRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;

    constructor(data?: IUserListRequest) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
        }
    }

    static override fromJS(data: any): UserListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        super.toJSON(data);
        return data;
    }
}

/** Represents user list request. */
export interface IUserListRequest extends IUsersSearchBaseRequest {
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
    /** Limits the document count of the result set. */
    limit?: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
}

/** Represents a list of source/target fields for XMP mappings */
export class XmpMappingTargets implements IXmpMappingTargets {
    /** Fields in XMP/Exif. */
    xmpFields!: XmpField[];
    /** Fields in metadata. */
    metadataFields!: MetadataField[];

    constructor(data?: IXmpMappingTargets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.xmpFields) {
                this.xmpFields = [];
                for (let i = 0; i < data.xmpFields.length; i++) {
                    let item = data.xmpFields[i];
                    this.xmpFields[i] = item && !(<any>item).toJSON ? new XmpField(item) : <XmpField>item;
                }
            }
            if (data.metadataFields) {
                this.metadataFields = [];
                for (let i = 0; i < data.metadataFields.length; i++) {
                    let item = data.metadataFields[i];
                    this.metadataFields[i] = item && !(<any>item).toJSON ? new MetadataField(item) : <MetadataField>item;
                }
            }
        }
        if (!data) {
            this.xmpFields = [];
            this.metadataFields = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["xmpFields"])) {
                this.xmpFields = [] as any;
                for (let item of _data["xmpFields"])
                    this.xmpFields!.push(XmpField.fromJS(item));
            }
            if (Array.isArray(_data["metadataFields"])) {
                this.metadataFields = [] as any;
                for (let item of _data["metadataFields"])
                    this.metadataFields!.push(MetadataField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMappingTargets {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingTargets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.xmpFields)) {
            data["xmpFields"] = [];
            for (let item of this.xmpFields)
                data["xmpFields"].push(item.toJSON());
        }
        if (Array.isArray(this.metadataFields)) {
            data["metadataFields"] = [];
            for (let item of this.metadataFields)
                data["metadataFields"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a list of source/target fields for XMP mappings */
export interface IXmpMappingTargets {
    /** Fields in XMP/Exif. */
    xmpFields: IXmpField[];
    /** Fields in metadata. */
    metadataFields: IMetadataField[];
}

/** Represents a field in XMP that can be mapped from or to */
export class XmpField implements IXmpField {
    /** Path of the field in XMP. */
    path?: string | undefined;
    /** Indicates if the field can be written to. */
    isWritable!: boolean;
    /** Data type of the field. */
    dataType!: XmpFieldDataType;

    constructor(data?: IXmpField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.isWritable = _data["isWritable"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): XmpField {
        data = typeof data === 'object' ? data : {};
        let result = new XmpField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["isWritable"] = this.isWritable;
        data["dataType"] = this.dataType;
        return data;
    }
}

/** Represents a field in XMP that can be mapped from or to */
export interface IXmpField {
    /** Path of the field in XMP. */
    path?: string | undefined;
    /** Indicates if the field can be written to. */
    isWritable: boolean;
    /** Data type of the field. */
    dataType: XmpFieldDataType;
}

/** Data types of XMP fields */
export enum XmpFieldDataType {
    Simple = "Simple",
    LangAlt = "LangAlt",
    List = "List",
}

/** Represents a field in metadata that XMP can be mapped to or from */
export class MetadataField implements IMetadataField {
    /** Path to the field in metadata. */
    path!: string;
    /** Indicates if the field can act as target for a mapping.
If field is read-only, it can only act as source of a mapping. */
    isWritable!: boolean;
    /** Data type of the field. */
    dataType!: MetadataFieldDataType;
    /** A list of field IDs that can be used as a key field when a tagbox is mapped. */
    availableKeyFields?: string[] | undefined;

    constructor(data?: IMetadataField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.isWritable = _data["isWritable"];
            this.dataType = _data["dataType"];
            if (Array.isArray(_data["availableKeyFields"])) {
                this.availableKeyFields = [] as any;
                for (let item of _data["availableKeyFields"])
                    this.availableKeyFields!.push(item);
            }
        }
    }

    static fromJS(data: any): MetadataField {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["isWritable"] = this.isWritable;
        data["dataType"] = this.dataType;
        if (Array.isArray(this.availableKeyFields)) {
            data["availableKeyFields"] = [];
            for (let item of this.availableKeyFields)
                data["availableKeyFields"].push(item);
        }
        return data;
    }
}

/** Represents a field in metadata that XMP can be mapped to or from */
export interface IMetadataField {
    /** Path to the field in metadata. */
    path: string;
    /** Indicates if the field can act as target for a mapping.
If field is read-only, it can only act as source of a mapping. */
    isWritable: boolean;
    /** Data type of the field. */
    dataType: MetadataFieldDataType;
    /** A list of field IDs that can be used as a key field when a tagbox is mapped. */
    availableKeyFields?: string[] | undefined;
}

/** Data types of metadata fields */
export enum MetadataFieldDataType {
    Simple = "Simple",
    TranslatedString = "TranslatedString",
    Tagbox = "Tagbox",
}

/** Base class for search results */
export class BaseResultOfXmpMappingEntry implements IBaseResultOfXmpMappingEntry {
    /** The total number of matching documents. */
    totalResults!: number;
    /** The matched documents. */
    results!: XmpMappingEntry[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds!: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;

    constructor(data?: IBaseResultOfXmpMappingEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalResults = _data["totalResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(XmpMappingEntry.fromJS(item));
            }
            this.elapsedMilliseconds = _data["elapsedMilliseconds"];
            this.pageToken = _data["pageToken"];
        }
    }

    static fromJS(data: any): BaseResultOfXmpMappingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResultOfXmpMappingEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalResults"] = this.totalResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["elapsedMilliseconds"] = this.elapsedMilliseconds;
        data["pageToken"] = this.pageToken;
        return data;
    }
}

/** Base class for search results */
export interface IBaseResultOfXmpMappingEntry {
    /** The total number of matching documents. */
    totalResults: number;
    /** The matched documents. */
    results: XmpMappingEntry[];
    /** The search execution time in milliseconds. */
    elapsedMilliseconds: number;
    /** An optional token to access the next page of results for those endpoints that support backend scrolling logic. */
    pageToken?: string | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorBaseResultOfXmpMappingEntry extends BaseResultOfXmpMappingEntry implements ISearchBehaviorBaseResultOfXmpMappingEntry {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: QueryDebugInformation[] | undefined;

    constructor(data?: ISearchBehaviorBaseResultOfXmpMappingEntry) {
        super(data);
        if (data) {
            if (data.queryDebugInformation) {
                this.queryDebugInformation = [];
                for (let i = 0; i < data.queryDebugInformation.length; i++) {
                    let item = data.queryDebugInformation[i];
                    this.queryDebugInformation[i] = item && !(<any>item).toJSON ? new QueryDebugInformation(item) : <QueryDebugInformation>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchString = _data["searchString"];
            this.isSearchStringRewritten = _data["isSearchStringRewritten"];
            if (Array.isArray(_data["queryDebugInformation"])) {
                this.queryDebugInformation = [] as any;
                for (let item of _data["queryDebugInformation"])
                    this.queryDebugInformation!.push(QueryDebugInformation.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorBaseResultOfXmpMappingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorBaseResultOfXmpMappingEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchString"] = this.searchString;
        data["isSearchStringRewritten"] = this.isSearchStringRewritten;
        if (Array.isArray(this.queryDebugInformation)) {
            data["queryDebugInformation"] = [];
            for (let item of this.queryDebugInformation)
                data["queryDebugInformation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorBaseResultOfXmpMappingEntry extends IBaseResultOfXmpMappingEntry {
    /** The search string used to query the data. */
    searchString?: string | undefined;
    /** Flag to notify if the SearchString was modified compared to the original requested one. */
    isSearchStringRewritten?: boolean;
    /** Additional information regarding the query execution and reason of the matched documents. Multiple items are returned if multiple queries were performed. */
    queryDebugInformation?: IQueryDebugInformation[] | undefined;
}

/** Base class for search result queries that support SearchBehaviors */
export class SearchBehaviorWithAggregationBaseResultOfXmpMappingEntry extends SearchBehaviorBaseResultOfXmpMappingEntry implements ISearchBehaviorWithAggregationBaseResultOfXmpMappingEntry {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: AggregationResult[] | undefined;

    constructor(data?: ISearchBehaviorWithAggregationBaseResultOfXmpMappingEntry) {
        super(data);
        if (data) {
            if (data.aggregationResults) {
                this.aggregationResults = [];
                for (let i = 0; i < data.aggregationResults.length; i++) {
                    let item = data.aggregationResults[i];
                    this.aggregationResults[i] = item && !(<any>item).toJSON ? new AggregationResult(item) : <AggregationResult>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aggregationResults"])) {
                this.aggregationResults = [] as any;
                for (let item of _data["aggregationResults"])
                    this.aggregationResults!.push(AggregationResult.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SearchBehaviorWithAggregationBaseResultOfXmpMappingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SearchBehaviorWithAggregationBaseResultOfXmpMappingEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregationResults)) {
            data["aggregationResults"] = [];
            for (let item of this.aggregationResults)
                data["aggregationResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Base class for search result queries that support SearchBehaviors */
export interface ISearchBehaviorWithAggregationBaseResultOfXmpMappingEntry extends ISearchBehaviorBaseResultOfXmpMappingEntry {
    /** Results of the aggregation, if any aggregators was passed in the request. */
    aggregationResults?: IAggregationResult[] | undefined;
}

/** Holds results of search for XMP mappings */
export class XmpMappingEntrySearchResult extends SearchBehaviorWithAggregationBaseResultOfXmpMappingEntry implements IXmpMappingEntrySearchResult {

    constructor(data?: IXmpMappingEntrySearchResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): XmpMappingEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntrySearchResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Holds results of search for XMP mappings */
export interface IXmpMappingEntrySearchResult extends ISearchBehaviorWithAggregationBaseResultOfXmpMappingEntry {
}

/** Editable properties of a XMP mapping entry */
export class XmpMappingEntryEditable implements IXmpMappingEntryEditable {
    /** Direction of the mapping. */
    direction!: MappingDirection;
    /** Priority of the mapping. */
    priority!: number;
    /** Stop processing further mappings for the same field if a value was found. */
    stopProcessing!: boolean;
    /** Path to source property in XMP. */
    xmpPath!: string;
    /** Path to target property in metadata. */
    metadataPath!: string;
    /** Optional additional configuration for the mapping. */
    configuration?: XmpMappingEntryConfigurationBase | undefined;

    constructor(data?: IXmpMappingEntryEditable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.direction = _data["direction"];
            this.priority = _data["priority"];
            this.stopProcessing = _data["stopProcessing"];
            this.xmpPath = _data["xmpPath"];
            this.metadataPath = _data["metadataPath"];
            this.configuration = _data["configuration"] ? XmpMappingEntryConfigurationBase.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XmpMappingEntryEditable {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryEditable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["direction"] = this.direction;
        data["priority"] = this.priority;
        data["stopProcessing"] = this.stopProcessing;
        data["xmpPath"] = this.xmpPath;
        data["metadataPath"] = this.metadataPath;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data;
    }
}

/** Editable properties of a XMP mapping entry */
export interface IXmpMappingEntryEditable {
    /** Direction of the mapping. */
    direction: MappingDirection;
    /** Priority of the mapping. */
    priority: number;
    /** Stop processing further mappings for the same field if a value was found. */
    stopProcessing: boolean;
    /** Path to source property in XMP. */
    xmpPath: string;
    /** Path to target property in metadata. */
    metadataPath: string;
    /** Optional additional configuration for the mapping. */
    configuration?: XmpMappingEntryConfigurationBase | undefined;
}

/** XMP mapping entry */
export class XmpMappingEntry extends XmpMappingEntryEditable implements IXmpMappingEntry {
    id!: string;

    constructor(data?: IXmpMappingEntry) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): XmpMappingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntry();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

/** XMP mapping entry */
export interface IXmpMappingEntry extends IXmpMappingEntryEditable {
    id: string;
}

/** Direction of mapping of XMP data */
export enum MappingDirection {
    XmpToMetadata = "XmpToMetadata",
    MetadataToXmp = "MetadataToXmp",
    Both = "Both",
}

export abstract class XmpMappingEntryConfigurationBase implements IXmpMappingEntryConfigurationBase {

    protected _discriminator: string;

    constructor(data?: IXmpMappingEntryConfigurationBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "XmpMappingEntryConfigurationBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): XmpMappingEntryConfigurationBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "XmpMappingEntryConfigurationTagbox") {
            let result = new XmpMappingEntryConfigurationTagbox();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'XmpMappingEntryConfigurationBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

export interface IXmpMappingEntryConfigurationBase {
}

/** Additional configuration for a mapping tagbox fields */
export class XmpMappingEntryConfigurationTagbox extends XmpMappingEntryConfigurationBase implements IXmpMappingEntryConfigurationTagbox {
    /** IDs of key fields. */
    keyFieldIds!: string[];
    /** Indicates if lookup shall be performed case sensitive. */
    caseSensitive!: boolean;
    /** Indicates if child schemas should also be included. */
    includeAllSchemaChildren!: boolean;

    constructor(data?: IXmpMappingEntryConfigurationTagbox) {
        super(data);
        if (!data) {
            this.keyFieldIds = [];
        }
        this._discriminator = "XmpMappingEntryConfigurationTagbox";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["keyFieldIds"])) {
                this.keyFieldIds = [] as any;
                for (let item of _data["keyFieldIds"])
                    this.keyFieldIds!.push(item);
            }
            this.caseSensitive = _data["caseSensitive"];
            this.includeAllSchemaChildren = _data["includeAllSchemaChildren"];
        }
    }

    static override fromJS(data: any): XmpMappingEntryConfigurationTagbox {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryConfigurationTagbox();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.keyFieldIds)) {
            data["keyFieldIds"] = [];
            for (let item of this.keyFieldIds)
                data["keyFieldIds"].push(item);
        }
        data["caseSensitive"] = this.caseSensitive;
        data["includeAllSchemaChildren"] = this.includeAllSchemaChildren;
        super.toJSON(data);
        return data;
    }
}

/** Additional configuration for a mapping tagbox fields */
export interface IXmpMappingEntryConfigurationTagbox extends IXmpMappingEntryConfigurationBase {
    /** IDs of key fields. */
    keyFieldIds: string[];
    /** Indicates if lookup shall be performed case sensitive. */
    caseSensitive: boolean;
    /** Indicates if child schemas should also be included. */
    includeAllSchemaChildren: boolean;
}

/** Search request for getting configured XMP mappings */
export class XmpMappingEntrySearchRequest implements IXmpMappingEntrySearchRequest {
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode!: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. */
    limit!: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: SortInfo[] | undefined;

    constructor(data?: IXmpMappingEntrySearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debugMode = _data["debugMode"];
            if (Array.isArray(_data["aggregationFilters"])) {
                this.aggregationFilters = [] as any;
                for (let item of _data["aggregationFilters"])
                    this.aggregationFilters!.push(AggregationFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregators"])) {
                this.aggregators = [] as any;
                for (let item of _data["aggregators"])
                    this.aggregators!.push(AggregatorBase.fromJS(item));
            }
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : <any>undefined;
            this.limit = _data["limit"];
            this.pageToken = _data["pageToken"];
            this.searchString = _data["searchString"];
            if (Array.isArray(_data["searchBehaviors"])) {
                this.searchBehaviors = [] as any;
                for (let item of _data["searchBehaviors"])
                    this.searchBehaviors!.push(item);
            }
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMappingEntrySearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntrySearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debugMode"] = this.debugMode;
        if (Array.isArray(this.aggregationFilters)) {
            data["aggregationFilters"] = [];
            for (let item of this.aggregationFilters)
                data["aggregationFilters"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregators)) {
            data["aggregators"] = [];
            for (let item of this.aggregators)
                data["aggregators"].push(item.toJSON());
        }
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["limit"] = this.limit;
        data["pageToken"] = this.pageToken;
        data["searchString"] = this.searchString;
        if (Array.isArray(this.searchBehaviors)) {
            data["searchBehaviors"] = [];
            for (let item of this.searchBehaviors)
                data["searchBehaviors"].push(item);
        }
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        return data;
    }
}

/** Search request for getting configured XMP mappings */
export interface IXmpMappingEntrySearchRequest {
    /** Enable debug mode to get as result of the Searched additional debug information. Warning! Severely affects performance. */
    debugMode: boolean;
    /** Special filters used to filter down independently the aggregations' values and the search results on specific conditions.
For the search results, the aggregation filters are used to create a Filter that is put in AND with the eventual existing Filter of the search request to nail down the search results. The filters generated
by the aggregation filters are put in OR each other if they have the same AggregationName, and then such groups are put in AND.
For the aggregation values, only the original Filter of the search request is used to nail down the data to be considered for the aggregations. Then, on top of that, for each aggregator in the search request, a Filter is created to filter down the
aggregation results of that aggregation: depending if the AggregationName of the AggregationFilter matches the AggregationName of the Aggregator, the filter is put in OR (if it matches) or in AND (if it does not match it).
Moreover, an AggregationFilter ensures that the related value is returned in the AggregationResults also if the top aggregation values returned by default do not contain it. */
    aggregationFilters?: AggregationFilter[] | undefined;
    /** List of aggregators that defines how the items should be aggregated. */
    aggregators?: AggregatorBase[] | undefined;
    /** An optional search filter. Limits the document result set. */
    filter?: FilterBase | undefined;
    /** Limits the document count of the result set. */
    limit: number;
    /** The token used to retrieve the next page of results. It must be null on first request and only filled with the returned pageToken to request next page of results. */
    pageToken?: string | undefined;
    /** Limits the search by using a query string filter. The Lucene query string syntax is supported. */
    searchString?: string | undefined;
    /** An optional list of search behaviors. All the passed behaviors will be applied. */
    searchBehaviors?: SearchBehavior[] | undefined;
    /** Fields and respective directions requested to sort the search results. Sorting on a not indexed field will throw an exception. */
    sort?: ISortInfo[] | undefined;
}

/** Request to create XMP mapping */
export class XmpMappingEntryCreateRequest extends XmpMappingEntryEditable implements IXmpMappingEntryCreateRequest {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;

    constructor(data?: IXmpMappingEntryCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestId = _data["requestId"];
        }
    }

    static override fromJS(data: any): XmpMappingEntryCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data;
    }
}

/** Request to create XMP mapping */
export interface IXmpMappingEntryCreateRequest extends IXmpMappingEntryEditable {
    /** Optional client reference for this request.
Will be returned back in response to make easier for clients to match request items with the respective results.
It is not persisted anywhere and it is ignored in single operations. */
    requestId?: string | undefined;
}

/** Request to create many XMP mappings */
export class XmpMappingEntryCreateManyRequest implements IXmpMappingEntryCreateManyRequest {
    /** Mappings to create. */
    items?: XmpMappingEntryCreateRequest[] | undefined;

    constructor(data?: IXmpMappingEntryCreateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(XmpMappingEntryCreateRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMappingEntryCreateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryCreateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to create many XMP mappings */
export interface IXmpMappingEntryCreateManyRequest {
    /** Mappings to create. */
    items?: XmpMappingEntryCreateRequest[] | undefined;
}

/** Request to update many XMP mappings */
export class XmpMappingEntryUpdateManyRequest implements IXmpMappingEntryUpdateManyRequest {
    /** Items to update. */
    items?: XmpMappingEntry[] | undefined;

    constructor(data?: IXmpMappingEntryUpdateManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(XmpMappingEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XmpMappingEntryUpdateManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryUpdateManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to update many XMP mappings */
export interface IXmpMappingEntryUpdateManyRequest {
    /** Items to update. */
    items?: XmpMappingEntry[] | undefined;
}

/** Request to delete many XMP mappings */
export class XmpMappingEntryDeleteManyRequest implements IXmpMappingEntryDeleteManyRequest {
    /** IDs to delete. */
    ids?: string[] | undefined;

    constructor(data?: IXmpMappingEntryDeleteManyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): XmpMappingEntryDeleteManyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XmpMappingEntryDeleteManyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

/** Request to delete many XMP mappings */
export interface IXmpMappingEntryDeleteManyRequest {
    /** IDs to delete. */
    ids?: string[] | undefined;
}

export class DataDictionary implements IDataDictionary {

    [key: string]: any;

    constructor(data?: IDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): DataDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IDataDictionary {

    [key: string]: any;
}

export abstract class Message implements IMessage {
    id?: string | undefined;
    retries!: number;
    retriesPerformed!: number;
    priority!: number;
    deduplicate!: boolean;

    protected _discriminator: string;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Message";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.retries = _data["retries"];
            this.retriesPerformed = _data["retriesPerformed"];
            this.priority = _data["priority"];
            this.deduplicate = _data["deduplicate"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "LiveStreamMessage") {
            let result = new LiveStreamMessage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConsoleMessage") {
            let result = new ConsoleMessage();
            result.init(data);
            return result;
        }
        if (data["kind"] === "NodeInfoMessage") {
            let result = new NodeInfoMessage();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Message' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["id"] = this.id;
        data["retries"] = this.retries;
        data["retriesPerformed"] = this.retriesPerformed;
        data["priority"] = this.priority;
        data["deduplicate"] = this.deduplicate;
        return data;
    }
}

export interface IMessage {
    id?: string | undefined;
    retries: number;
    retriesPerformed: number;
    priority: number;
    deduplicate: boolean;
}

export class LiveStreamMessage extends Message implements ILiveStreamMessage {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    timestamp?: Date;
    scope?: string | undefined;
    documentChange?: DocumentChange | undefined;
    applicationEvent?: ApplicationEvent | undefined;

    constructor(data?: ILiveStreamMessage) {
        super(data);
        if (data) {
            this.documentChange = data.documentChange && !(<any>data.documentChange).toJSON ? new DocumentChange(data.documentChange) : <DocumentChange>this.documentChange;
        }
        this._discriminator = "LiveStreamMessage";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerAlias = _data["customerAlias"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.scope = _data["scope"];
            this.documentChange = _data["documentChange"] ? DocumentChange.fromJS(_data["documentChange"]) : <any>undefined;
            this.applicationEvent = _data["applicationEvent"] ? ApplicationEvent.fromJS(_data["applicationEvent"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): LiveStreamMessage {
        data = typeof data === 'object' ? data : {};
        let result = new LiveStreamMessage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerAlias"] = this.customerAlias;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["scope"] = this.scope;
        data["documentChange"] = this.documentChange ? this.documentChange.toJSON() : <any>undefined;
        data["applicationEvent"] = this.applicationEvent ? this.applicationEvent.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ILiveStreamMessage extends IMessage {
    customerId?: string | undefined;
    customerAlias?: string | undefined;
    timestamp?: Date;
    scope?: string | undefined;
    documentChange?: IDocumentChange | undefined;
    applicationEvent?: ApplicationEvent | undefined;
}

export class DocumentChange implements IDocumentChange {
    documentName?: string | undefined;
    documentId?: string | undefined;
    version!: number;
    action?: string | undefined;
    timeStamp!: Date;

    constructor(data?: IDocumentChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentName = _data["documentName"];
            this.documentId = _data["documentId"];
            this.version = _data["version"];
            this.action = _data["action"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentChange {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentName"] = this.documentName;
        data["documentId"] = this.documentId;
        data["version"] = this.version;
        data["action"] = this.action;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocumentChange {
    documentName?: string | undefined;
    documentId?: string | undefined;
    version: number;
    action?: string | undefined;
    timeStamp: Date;
}

export class ApplicationEvent implements IApplicationEvent {
    timestamp!: Date;

    protected _discriminator: string;

    constructor(data?: IApplicationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ApplicationEvent";
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationEvent {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "TransferEvent") {
            let result = new TransferEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ReindexEvent") {
            let result = new ReindexEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentDetailViewEvent") {
            let result = new ContentDetailViewEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentDownloadEvent") {
            let result = new ContentDownloadEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ContentShareEvent") {
            let result = new ContentShareEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SessionRenewalEvent") {
            let result = new SessionRenewalEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SharePageViewEvent") {
            let result = new SharePageViewEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ApiStatisticsEvent") {
            let result = new ApiStatisticsEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TrafficStatisticsEvent") {
            let result = new TrafficStatisticsEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "OutputRenderedEvent") {
            let result = new OutputRenderedEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "ConfigurationChangeEvent") {
            let result = new ConfigurationChangeEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "CustomerChangeEvent") {
            let result = new CustomerChangeEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "SearchReindexCompletedEvent") {
            let result = new SearchReindexCompletedEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessRuleFiredEvent") {
            let result = new BusinessRuleFiredEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "BusinessProcessCancellationRequestedEvent") {
            let result = new BusinessProcessCancellationRequestedEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DataExtractionRepairEvent") {
            let result = new DataExtractionRepairEvent();
            result.init(data);
            return result;
        }
        if (data["kind"] === "TaggerStatisticsEvent") {
            let result = new TaggerStatisticsEvent();
            result.init(data);
            return result;
        }
        let result = new ApplicationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApplicationEvent {
    timestamp: Date;
}

export class TransferEvent extends ApplicationEvent implements ITransferEvent {
    transferId?: string | undefined;
    state?: TransferState;

    constructor(data?: ITransferEvent) {
        super(data);
        this._discriminator = "TransferEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.transferId = _data["transferId"];
            this.state = _data["state"];
        }
    }

    static override fromJS(data: any): TransferEvent {
        data = typeof data === 'object' ? data : {};
        let result = new TransferEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferId"] = this.transferId;
        data["state"] = this.state;
        super.toJSON(data);
        return data;
    }
}

export interface ITransferEvent extends IApplicationEvent {
    transferId?: string | undefined;
    state?: TransferState;
}

export class ReindexEvent extends ApplicationEvent implements IReindexEvent {
    indexId?: string | undefined;
    state?: IndexState;

    constructor(data?: IReindexEvent) {
        super(data);
        this._discriminator = "ReindexEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.indexId = _data["indexId"];
            this.state = _data["state"];
        }
    }

    static override fromJS(data: any): ReindexEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ReindexEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["indexId"] = this.indexId;
        data["state"] = this.state;
        super.toJSON(data);
        return data;
    }
}

export interface IReindexEvent extends IApplicationEvent {
    indexId?: string | undefined;
    state?: IndexState;
}

export enum IndexState {
    Draft = "Draft",
    Create = "Create",
    Inactive = "Inactive",
    Active = "Active",
    Closed = "Closed",
    ReindexInProgress = "ReindexInProgress",
    Cancelled = "Cancelled",
}

export class ContentDetailViewEvent extends ApplicationEvent implements IContentDetailViewEvent {
    contentIds?: string[] | undefined;

    constructor(data?: IContentDetailViewEvent) {
        super(data);
        this._discriminator = "ContentDetailViewEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["contentIds"])) {
                this.contentIds = [] as any;
                for (let item of _data["contentIds"])
                    this.contentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentDetailViewEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDetailViewEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contentIds)) {
            data["contentIds"] = [];
            for (let item of this.contentIds)
                data["contentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentDetailViewEvent extends IApplicationEvent {
    contentIds?: string[] | undefined;
}

export class ContentDownloadEvent extends ApplicationEvent implements IContentDownloadEvent {
    downloadInfos?: DownloadTrackingInfo[] | undefined;
    fileSize?: number;
    shareToken?: string | undefined;
    range?: string | undefined;

    constructor(data?: IContentDownloadEvent) {
        super(data);
        if (data) {
            if (data.downloadInfos) {
                this.downloadInfos = [];
                for (let i = 0; i < data.downloadInfos.length; i++) {
                    let item = data.downloadInfos[i];
                    this.downloadInfos[i] = item && !(<any>item).toJSON ? new DownloadTrackingInfo(item) : <DownloadTrackingInfo>item;
                }
            }
        }
        this._discriminator = "ContentDownloadEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["downloadInfos"])) {
                this.downloadInfos = [] as any;
                for (let item of _data["downloadInfos"])
                    this.downloadInfos!.push(DownloadTrackingInfo.fromJS(item));
            }
            this.fileSize = _data["fileSize"];
            this.shareToken = _data["shareToken"];
            this.range = _data["range"];
        }
    }

    static override fromJS(data: any): ContentDownloadEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDownloadEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.downloadInfos)) {
            data["downloadInfos"] = [];
            for (let item of this.downloadInfos)
                data["downloadInfos"].push(item.toJSON());
        }
        data["fileSize"] = this.fileSize;
        data["shareToken"] = this.shareToken;
        data["range"] = this.range;
        super.toJSON(data);
        return data;
    }
}

export interface IContentDownloadEvent extends IApplicationEvent {
    downloadInfos?: IDownloadTrackingInfo[] | undefined;
    fileSize?: number;
    shareToken?: string | undefined;
    range?: string | undefined;
}

export class DownloadTrackingInfo implements IDownloadTrackingInfo {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    contentDisposition!: ContentDisposition;

    constructor(data?: IDownloadTrackingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.contentDisposition = _data["contentDisposition"];
        }
    }

    static fromJS(data: any): DownloadTrackingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadTrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["width"] = this.width;
        data["height"] = this.height;
        data["contentDisposition"] = this.contentDisposition;
        return data;
    }
}

export interface IDownloadTrackingInfo {
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    width?: number | undefined;
    height?: number | undefined;
    contentDisposition: ContentDisposition;
}

export enum ContentDisposition {
    Attachment = "Attachment",
    Inline = "Inline",
}

export class ContentShareEvent extends ApplicationEvent implements IContentShareEvent {
    shareId?: string | undefined;
    shareType?: ShareType;
    addedContentIds?: string[] | undefined;

    constructor(data?: IContentShareEvent) {
        super(data);
        this._discriminator = "ContentShareEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shareId = _data["shareId"];
            this.shareType = _data["shareType"];
            if (Array.isArray(_data["addedContentIds"])) {
                this.addedContentIds = [] as any;
                for (let item of _data["addedContentIds"])
                    this.addedContentIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): ContentShareEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ContentShareEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareId"] = this.shareId;
        data["shareType"] = this.shareType;
        if (Array.isArray(this.addedContentIds)) {
            data["addedContentIds"] = [];
            for (let item of this.addedContentIds)
                data["addedContentIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IContentShareEvent extends IApplicationEvent {
    shareId?: string | undefined;
    shareType?: ShareType;
    addedContentIds?: string[] | undefined;
}

export class SessionRenewalEvent extends ApplicationEvent implements ISessionRenewalEvent {
    authorizationState?: AuthorizationState;

    constructor(data?: ISessionRenewalEvent) {
        super(data);
        this._discriminator = "SessionRenewalEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.authorizationState = _data["authorizationState"];
        }
    }

    static override fromJS(data: any): SessionRenewalEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SessionRenewalEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authorizationState"] = this.authorizationState;
        super.toJSON(data);
        return data;
    }
}

export interface ISessionRenewalEvent extends IApplicationEvent {
    authorizationState?: AuthorizationState;
}

export class SharePageViewEvent extends ApplicationEvent implements ISharePageViewEvent {
    shareToken?: string | undefined;

    constructor(data?: ISharePageViewEvent) {
        super(data);
        this._discriminator = "SharePageViewEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shareToken = _data["shareToken"];
        }
    }

    static override fromJS(data: any): SharePageViewEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SharePageViewEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareToken"] = this.shareToken;
        super.toJSON(data);
        return data;
    }
}

export interface ISharePageViewEvent extends IApplicationEvent {
    shareToken?: string | undefined;
}

export class ApiStatisticsEvent extends ApplicationEvent implements IApiStatisticsEvent {
    requestsPerClient?: { [key: string]: number; } | undefined;

    constructor(data?: IApiStatisticsEvent) {
        super(data);
        this._discriminator = "ApiStatisticsEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["requestsPerClient"]) {
                this.requestsPerClient = {} as any;
                for (let key in _data["requestsPerClient"]) {
                    if (_data["requestsPerClient"].hasOwnProperty(key))
                        (<any>this.requestsPerClient)![key] = _data["requestsPerClient"][key];
                }
            }
        }
    }

    static override fromJS(data: any): ApiStatisticsEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ApiStatisticsEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.requestsPerClient) {
            data["requestsPerClient"] = {};
            for (let key in this.requestsPerClient) {
                if (this.requestsPerClient.hasOwnProperty(key))
                    (<any>data["requestsPerClient"])[key] = (<any>this.requestsPerClient)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApiStatisticsEvent extends IApplicationEvent {
    requestsPerClient?: { [key: string]: number; } | undefined;
}

export class TrafficStatisticsEvent extends ApplicationEvent implements ITrafficStatisticsEvent {
    service?: string | undefined;
    requestSize?: number;
    responseSize?: number;

    constructor(data?: ITrafficStatisticsEvent) {
        super(data);
        this._discriminator = "TrafficStatisticsEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.service = _data["service"];
            this.requestSize = _data["requestSize"];
            this.responseSize = _data["responseSize"];
        }
    }

    static override fromJS(data: any): TrafficStatisticsEvent {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficStatisticsEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service"] = this.service;
        data["requestSize"] = this.requestSize;
        data["responseSize"] = this.responseSize;
        super.toJSON(data);
        return data;
    }
}

export interface ITrafficStatisticsEvent extends IApplicationEvent {
    service?: string | undefined;
    requestSize?: number;
    responseSize?: number;
}

export class OutputRenderedEvent extends ApplicationEvent implements IOutputRenderedEvent {
    outputId?: string | undefined;
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    renderingState?: OutputRenderingState;

    constructor(data?: IOutputRenderedEvent) {
        super(data);
        this._discriminator = "OutputRenderedEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.outputId = _data["outputId"];
            this.contentId = _data["contentId"];
            this.outputFormatId = _data["outputFormatId"];
            this.renderingState = _data["renderingState"];
        }
    }

    static override fromJS(data: any): OutputRenderedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new OutputRenderedEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outputId"] = this.outputId;
        data["contentId"] = this.contentId;
        data["outputFormatId"] = this.outputFormatId;
        data["renderingState"] = this.renderingState;
        super.toJSON(data);
        return data;
    }
}

export interface IOutputRenderedEvent extends IApplicationEvent {
    outputId?: string | undefined;
    contentId?: string | undefined;
    outputFormatId?: string | undefined;
    renderingState?: OutputRenderingState;
}

export class ConfigurationChangeEvent extends ApplicationEvent implements IConfigurationChangeEvent {
    documentType?: string | undefined;

    constructor(data?: IConfigurationChangeEvent) {
        super(data);
        this._discriminator = "ConfigurationChangeEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.documentType = _data["documentType"];
        }
    }

    static override fromJS(data: any): ConfigurationChangeEvent {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "CustomerChangeEvent") {
            let result = new CustomerChangeEvent();
            result.init(data);
            return result;
        }
        let result = new ConfigurationChangeEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        super.toJSON(data);
        return data;
    }
}

export interface IConfigurationChangeEvent extends IApplicationEvent {
    documentType?: string | undefined;
}

export class CustomerChangeEvent extends ConfigurationChangeEvent implements ICustomerChangeEvent {
    lifeCycle?: LifeCycle;

    constructor(data?: ICustomerChangeEvent) {
        super(data);
        this._discriminator = "CustomerChangeEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lifeCycle = _data["lifeCycle"];
        }
    }

    static override fromJS(data: any): CustomerChangeEvent {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerChangeEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lifeCycle"] = this.lifeCycle;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerChangeEvent extends IConfigurationChangeEvent {
    lifeCycle?: LifeCycle;
}

export class SearchReindexCompletedEvent extends ApplicationEvent implements ISearchReindexCompletedEvent {
    searchIndex?: SearchIndexType;
    items?: number;
    duration?: string;

    constructor(data?: ISearchReindexCompletedEvent) {
        super(data);
        this._discriminator = "SearchReindexCompletedEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.searchIndex = _data["searchIndex"];
            this.items = _data["items"];
            this.duration = _data["duration"];
        }
    }

    static override fromJS(data: any): SearchReindexCompletedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SearchReindexCompletedEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchIndex"] = this.searchIndex;
        data["items"] = this.items;
        data["duration"] = this.duration;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchReindexCompletedEvent extends IApplicationEvent {
    searchIndex?: SearchIndexType;
    items?: number;
    duration?: string;
}

export enum SearchIndexType {
    Content = "Content",
    ListItem = "ListItem",
}

export class BusinessRuleFiredEvent extends ApplicationEvent implements IBusinessRuleFiredEvent {
    details?: BusinessRuleFiredEventDetail[] | undefined;

    constructor(data?: IBusinessRuleFiredEvent) {
        super(data);
        if (data) {
            if (data.details) {
                this.details = [];
                for (let i = 0; i < data.details.length; i++) {
                    let item = data.details[i];
                    this.details[i] = item && !(<any>item).toJSON ? new BusinessRuleFiredEventDetail(item) : <BusinessRuleFiredEventDetail>item;
                }
            }
        }
        this._discriminator = "BusinessRuleFiredEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(BusinessRuleFiredEventDetail.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): BusinessRuleFiredEvent {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleFiredEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessRuleFiredEvent extends IApplicationEvent {
    details?: IBusinessRuleFiredEventDetail[] | undefined;
}

export class BusinessRuleFiredEventDetail implements IBusinessRuleFiredEventDetail {
    documentId?: string | undefined;
    documentType?: string | undefined;
    ruleIds?: string[] | undefined;

    constructor(data?: IBusinessRuleFiredEventDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["ruleIds"])) {
                this.ruleIds = [] as any;
                for (let item of _data["ruleIds"])
                    this.ruleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BusinessRuleFiredEventDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRuleFiredEventDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        if (Array.isArray(this.ruleIds)) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        return data;
    }
}

export interface IBusinessRuleFiredEventDetail {
    documentId?: string | undefined;
    documentType?: string | undefined;
    ruleIds?: string[] | undefined;
}

export class BusinessProcessCancellationRequestedEvent extends ApplicationEvent implements IBusinessProcessCancellationRequestedEvent {
    businessProcessId?: string | undefined;

    constructor(data?: IBusinessProcessCancellationRequestedEvent) {
        super(data);
        this._discriminator = "BusinessProcessCancellationRequestedEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.businessProcessId = _data["businessProcessId"];
        }
    }

    static override fromJS(data: any): BusinessProcessCancellationRequestedEvent {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProcessCancellationRequestedEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProcessId"] = this.businessProcessId;
        super.toJSON(data);
        return data;
    }
}

export interface IBusinessProcessCancellationRequestedEvent extends IApplicationEvent {
    businessProcessId?: string | undefined;
}

export class DataExtractionRepairEvent extends ApplicationEvent implements IDataExtractionRepairEvent {
    contentRepairRequestId?: string | undefined;
    contentId?: string | undefined;
    error?: ErrorResponse | undefined;
    hadChanges?: boolean;

    constructor(data?: IDataExtractionRepairEvent) {
        super(data);
        if (data) {
            this.error = data.error && !(<any>data.error).toJSON ? new ErrorResponse(data.error) : <ErrorResponse>this.error;
        }
        this._discriminator = "DataExtractionRepairEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.contentRepairRequestId = _data["contentRepairRequestId"];
            this.contentId = _data["contentId"];
            this.error = _data["error"] ? ErrorResponse.fromJS(_data["error"]) : <any>undefined;
            this.hadChanges = _data["hadChanges"];
        }
    }

    static override fromJS(data: any): DataExtractionRepairEvent {
        data = typeof data === 'object' ? data : {};
        let result = new DataExtractionRepairEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentRepairRequestId"] = this.contentRepairRequestId;
        data["contentId"] = this.contentId;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["hadChanges"] = this.hadChanges;
        super.toJSON(data);
        return data;
    }
}

export interface IDataExtractionRepairEvent extends IApplicationEvent {
    contentRepairRequestId?: string | undefined;
    contentId?: string | undefined;
    error?: IErrorResponse | undefined;
    hadChanges?: boolean;
}

export class TaggerStatisticsEvent extends ApplicationEvent implements ITaggerStatisticsEvent {
    requestsCounter?: number;
    taggerCounter?: number;
    ocrCounter?: number;
    taggerName?: string | undefined;

    constructor(data?: ITaggerStatisticsEvent) {
        super(data);
        this._discriminator = "TaggerStatisticsEvent";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestsCounter = _data["requestsCounter"];
            this.taggerCounter = _data["taggerCounter"];
            this.ocrCounter = _data["ocrCounter"];
            this.taggerName = _data["taggerName"];
        }
    }

    static override fromJS(data: any): TaggerStatisticsEvent {
        data = typeof data === 'object' ? data : {};
        let result = new TaggerStatisticsEvent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestsCounter"] = this.requestsCounter;
        data["taggerCounter"] = this.taggerCounter;
        data["ocrCounter"] = this.ocrCounter;
        data["taggerName"] = this.taggerName;
        super.toJSON(data);
        return data;
    }
}

export interface ITaggerStatisticsEvent extends IApplicationEvent {
    requestsCounter?: number;
    taggerCounter?: number;
    ocrCounter?: number;
    taggerName?: string | undefined;
}

export class ConsoleMessage extends Message implements IConsoleMessage {
    command?: string | undefined;
    arguments?: TupleOfStringAndString[] | undefined;
    targetQueue?: string | undefined;

    constructor(data?: IConsoleMessage) {
        super(data);
        if (data) {
            if (data.arguments) {
                this.arguments = [];
                for (let i = 0; i < data.arguments.length; i++) {
                    let item = data.arguments[i];
                    this.arguments[i] = item && !(<any>item).toJSON ? new TupleOfStringAndString(item) : <TupleOfStringAndString>item;
                }
            }
        }
        this._discriminator = "ConsoleMessage";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.command = _data["command"];
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(TupleOfStringAndString.fromJS(item));
            }
            this.targetQueue = _data["targetQueue"];
        }
    }

    static override fromJS(data: any): ConsoleMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ConsoleMessage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["command"] = this.command;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item.toJSON());
        }
        data["targetQueue"] = this.targetQueue;
        super.toJSON(data);
        return data;
    }
}

export interface IConsoleMessage extends IMessage {
    command?: string | undefined;
    arguments?: ITupleOfStringAndString[] | undefined;
    targetQueue?: string | undefined;
}

export class TupleOfStringAndString implements ITupleOfStringAndString {
    item1!: string;
    item2!: string;

    constructor(data?: ITupleOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): TupleOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface ITupleOfStringAndString {
    item1: string;
    item2: string;
}

export class NodeInfoMessage extends Message implements INodeInfoMessage {
    nodeId?: string | undefined;
    hostName?: string | undefined;
    lastResponseTime?: Date;
    serviceName?: string | undefined;
    fileVersion?: string | undefined;
    productVersion?: string | undefined;
    release?: string | undefined;
    logLevel?: string | undefined;

    constructor(data?: INodeInfoMessage) {
        super(data);
        this._discriminator = "NodeInfoMessage";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nodeId = _data["nodeId"];
            this.hostName = _data["hostName"];
            this.lastResponseTime = _data["lastResponseTime"] ? new Date(_data["lastResponseTime"].toString()) : <any>undefined;
            this.serviceName = _data["serviceName"];
            this.fileVersion = _data["fileVersion"];
            this.productVersion = _data["productVersion"];
            this.release = _data["release"];
            this.logLevel = _data["logLevel"];
        }
    }

    static override fromJS(data: any): NodeInfoMessage {
        data = typeof data === 'object' ? data : {};
        let result = new NodeInfoMessage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodeId"] = this.nodeId;
        data["hostName"] = this.hostName;
        data["lastResponseTime"] = this.lastResponseTime ? this.lastResponseTime.toISOString() : <any>undefined;
        data["serviceName"] = this.serviceName;
        data["fileVersion"] = this.fileVersion;
        data["productVersion"] = this.productVersion;
        data["release"] = this.release;
        data["logLevel"] = this.logLevel;
        super.toJSON(data);
        return data;
    }
}

export interface INodeInfoMessage extends IMessage {
    nodeId?: string | undefined;
    hostName?: string | undefined;
    lastResponseTime?: Date;
    serviceName?: string | undefined;
    fileVersion?: string | undefined;
    productVersion?: string | undefined;
    release?: string | undefined;
    logLevel?: string | undefined;
}

export class AudioMetadata extends FileMetadata implements IAudioMetadata {
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IAudioMetadata) {
        super(data);
        if (data) {
            if (data.audioStreams) {
                this.audioStreams = [];
                for (let i = 0; i < data.audioStreams.length; i++) {
                    let item = data.audioStreams[i];
                    this.audioStreams[i] = item && !(<any>item).toJSON ? new AudioStream(item) : <AudioStream>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["audioStreams"])) {
                this.audioStreams = [] as any;
                for (let item of _data["audioStreams"])
                    this.audioStreams!.push(AudioStream.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AudioMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new AudioMetadata();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.audioStreams)) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAudioMetadata extends IFileMetadata {
    audioStreams?: IAudioStream[] | undefined;
}

export class AudioStream implements IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;

    constructor(data?: IAudioStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bitRate = _data["bitRate"];
            this.bitRateMode = _data["bitRateMode"];
            this.channels = _data["channels"];
            this.channelPositions = _data["channelPositions"];
            this.codec = _data["codec"];
            this.durationInSeconds = _data["durationInSeconds"];
            this.format = _data["format"];
            this.language = _data["language"];
            this.resolution = _data["resolution"];
            this.samplingRate = _data["samplingRate"];
            this.streamSize = _data["streamSize"];
        }
    }

    static fromJS(data: any): AudioStream {
        data = typeof data === 'object' ? data : {};
        let result = new AudioStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["bitRateMode"] = this.bitRateMode;
        data["channels"] = this.channels;
        data["channelPositions"] = this.channelPositions;
        data["codec"] = this.codec;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["language"] = this.language;
        data["resolution"] = this.resolution;
        data["samplingRate"] = this.samplingRate;
        data["streamSize"] = this.streamSize;
        return data;
    }
}

export interface IAudioStream {
    bitRate?: string | undefined;
    bitRateMode?: string | undefined;
    channels?: string | undefined;
    channelPositions?: string | undefined;
    codec?: string | undefined;
    durationInSeconds?: number | undefined;
    format?: string | undefined;
    language?: string | undefined;
    resolution?: number | undefined;
    samplingRate?: number | undefined;
    streamSize?: number | undefined;
}

export class DocumentMetadata extends FileMetadata implements IDocumentMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount?: number;
    characterCountWithSpaces?: number;
    lineCount?: number;
    pageCount?: number;
    slideCount?: number;
    paragraphCount?: number;
    revisionNumber?: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: EpsMetadata | undefined;

    constructor(data?: IDocumentMetadata) {
        super(data);
        if (data) {
            this.epsInfo = data.epsInfo && !(<any>data.epsInfo).toJSON ? new EpsMetadata(data.epsInfo) : <EpsMetadata>this.epsInfo;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.applicationVersion = _data["applicationVersion"];
            this.author = _data["author"];
            this.creator = _data["creator"];
            this.publisher = _data["publisher"];
            this.company = _data["company"];
            this.documentTitle = _data["documentTitle"];
            this.characterCount = _data["characterCount"];
            this.characterCountWithSpaces = _data["characterCountWithSpaces"];
            this.lineCount = _data["lineCount"];
            this.pageCount = _data["pageCount"];
            this.slideCount = _data["slideCount"];
            this.paragraphCount = _data["paragraphCount"];
            this.revisionNumber = _data["revisionNumber"];
            if (Array.isArray(_data["titles"])) {
                this.titles = [] as any;
                for (let item of _data["titles"])
                    this.titles!.push(item);
            }
            if (Array.isArray(_data["imageTitles"])) {
                this.imageTitles = [] as any;
                for (let item of _data["imageTitles"])
                    this.imageTitles!.push(item);
            }
            this.epsInfo = _data["epsInfo"] ? EpsMetadata.fromJS(_data["epsInfo"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): DocumentMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentMetadata();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["applicationVersion"] = this.applicationVersion;
        data["author"] = this.author;
        data["creator"] = this.creator;
        data["publisher"] = this.publisher;
        data["company"] = this.company;
        data["documentTitle"] = this.documentTitle;
        data["characterCount"] = this.characterCount;
        data["characterCountWithSpaces"] = this.characterCountWithSpaces;
        data["lineCount"] = this.lineCount;
        data["pageCount"] = this.pageCount;
        data["slideCount"] = this.slideCount;
        data["paragraphCount"] = this.paragraphCount;
        data["revisionNumber"] = this.revisionNumber;
        if (Array.isArray(this.titles)) {
            data["titles"] = [];
            for (let item of this.titles)
                data["titles"].push(item);
        }
        if (Array.isArray(this.imageTitles)) {
            data["imageTitles"] = [];
            for (let item of this.imageTitles)
                data["imageTitles"].push(item);
        }
        data["epsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentMetadata extends IFileMetadata {
    applicationName?: string | undefined;
    applicationVersion?: string | undefined;
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    documentTitle?: string | undefined;
    characterCount?: number;
    characterCountWithSpaces?: number;
    lineCount?: number;
    pageCount?: number;
    slideCount?: number;
    paragraphCount?: number;
    revisionNumber?: number;
    titles?: string[] | undefined;
    imageTitles?: string[] | undefined;
    epsInfo?: IEpsMetadata | undefined;
}

export class EpsMetadata implements IEpsMetadata {
    isRasterized!: boolean;
    widthInPoints!: number;
    heightInPoints!: number;

    constructor(data?: IEpsMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isRasterized = _data["isRasterized"];
            this.widthInPoints = _data["widthInPoints"];
            this.heightInPoints = _data["heightInPoints"];
        }
    }

    static fromJS(data: any): EpsMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new EpsMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRasterized"] = this.isRasterized;
        data["widthInPoints"] = this.widthInPoints;
        data["heightInPoints"] = this.heightInPoints;
        return data;
    }
}

export interface IEpsMetadata {
    isRasterized: boolean;
    widthInPoints: number;
    heightInPoints: number;
}

export class ImageMetadata extends FileMetadata implements IImageMetadata {
    width?: number;
    height?: number;
    widthInInch?: number;
    heightInInch?: number;
    widthInCm?: number;
    heightInCm?: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel?: number;
    bitsPerChannel?: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha?: boolean;
    isIndexed?: boolean;
    isExtended?: boolean;
    horizontalResolution?: number;
    verticalResolution?: number;
    totalFrames?: number;
    totalUnspecifiedTiffExtraChannels?: number;
    hasExifData?: boolean;
    hasIptcData?: boolean;
    hasAdobeResourceData?: boolean;
    hasXmpData?: boolean;
    uncompressedSizeInBytes?: number;

    constructor(data?: IImageMetadata) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.widthInInch = _data["widthInInch"];
            this.heightInInch = _data["heightInInch"];
            this.widthInCm = _data["widthInCm"];
            this.heightInCm = _data["heightInCm"];
            this.colorSpace = _data["colorSpace"];
            this.colorProfile = _data["colorProfile"];
            this.bitsPerPixel = _data["bitsPerPixel"];
            this.bitsPerChannel = _data["bitsPerChannel"];
            this.channels = _data["channels"];
            this.pixelFormat = _data["pixelFormat"];
            this.hasAlpha = _data["hasAlpha"];
            this.isIndexed = _data["isIndexed"];
            this.isExtended = _data["isExtended"];
            this.horizontalResolution = _data["horizontalResolution"];
            this.verticalResolution = _data["verticalResolution"];
            this.totalFrames = _data["totalFrames"];
            this.totalUnspecifiedTiffExtraChannels = _data["totalUnspecifiedTiffExtraChannels"];
            this.hasExifData = _data["hasExifData"];
            this.hasIptcData = _data["hasIptcData"];
            this.hasAdobeResourceData = _data["hasAdobeResourceData"];
            this.hasXmpData = _data["hasXmpData"];
            this.uncompressedSizeInBytes = _data["uncompressedSizeInBytes"];
        }
    }

    static override fromJS(data: any): ImageMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ImageMetadata();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["widthInInch"] = this.widthInInch;
        data["heightInInch"] = this.heightInInch;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["colorSpace"] = this.colorSpace;
        data["colorProfile"] = this.colorProfile;
        data["bitsPerPixel"] = this.bitsPerPixel;
        data["bitsPerChannel"] = this.bitsPerChannel;
        data["channels"] = this.channels;
        data["pixelFormat"] = this.pixelFormat;
        data["hasAlpha"] = this.hasAlpha;
        data["isIndexed"] = this.isIndexed;
        data["isExtended"] = this.isExtended;
        data["horizontalResolution"] = this.horizontalResolution;
        data["verticalResolution"] = this.verticalResolution;
        data["totalFrames"] = this.totalFrames;
        data["totalUnspecifiedTiffExtraChannels"] = this.totalUnspecifiedTiffExtraChannels;
        data["hasExifData"] = this.hasExifData;
        data["hasIptcData"] = this.hasIptcData;
        data["hasAdobeResourceData"] = this.hasAdobeResourceData;
        data["hasXmpData"] = this.hasXmpData;
        data["uncompressedSizeInBytes"] = this.uncompressedSizeInBytes;
        super.toJSON(data);
        return data;
    }
}

export interface IImageMetadata extends IFileMetadata {
    width?: number;
    height?: number;
    widthInInch?: number;
    heightInInch?: number;
    widthInCm?: number;
    heightInCm?: number;
    colorSpace?: string | undefined;
    colorProfile?: string | undefined;
    bitsPerPixel?: number;
    bitsPerChannel?: number;
    channels?: string | undefined;
    pixelFormat?: string | undefined;
    hasAlpha?: boolean;
    isIndexed?: boolean;
    isExtended?: boolean;
    horizontalResolution?: number;
    verticalResolution?: number;
    totalFrames?: number;
    totalUnspecifiedTiffExtraChannels?: number;
    hasExifData?: boolean;
    hasIptcData?: boolean;
    hasAdobeResourceData?: boolean;
    hasXmpData?: boolean;
    uncompressedSizeInBytes?: number;
}

export class VideoMetadata extends FileMetadata implements IVideoMetadata {
    width?: number;
    height?: number;
    durationInSeconds?: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: VideoStream[] | undefined;
    audioStreams?: AudioStream[] | undefined;

    constructor(data?: IVideoMetadata) {
        super(data);
        if (data) {
            if (data.videoStreams) {
                this.videoStreams = [];
                for (let i = 0; i < data.videoStreams.length; i++) {
                    let item = data.videoStreams[i];
                    this.videoStreams[i] = item && !(<any>item).toJSON ? new VideoStream(item) : <VideoStream>item;
                }
            }
            if (data.audioStreams) {
                this.audioStreams = [];
                for (let i = 0; i < data.audioStreams.length; i++) {
                    let item = data.audioStreams[i];
                    this.audioStreams[i] = item && !(<any>item).toJSON ? new AudioStream(item) : <AudioStream>item;
                }
            }
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.width = _data["width"];
            this.height = _data["height"];
            this.durationInSeconds = _data["durationInSeconds"];
            this.format = _data["format"];
            this.codec = _data["codec"];
            this.overallBitrate = _data["overallBitrate"];
            if (Array.isArray(_data["videoStreams"])) {
                this.videoStreams = [] as any;
                for (let item of _data["videoStreams"])
                    this.videoStreams!.push(VideoStream.fromJS(item));
            }
            if (Array.isArray(_data["audioStreams"])) {
                this.audioStreams = [] as any;
                for (let item of _data["audioStreams"])
                    this.audioStreams!.push(AudioStream.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): VideoMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new VideoMetadata();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["width"] = this.width;
        data["height"] = this.height;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["codec"] = this.codec;
        data["overallBitrate"] = this.overallBitrate;
        if (Array.isArray(this.videoStreams)) {
            data["videoStreams"] = [];
            for (let item of this.videoStreams)
                data["videoStreams"].push(item.toJSON());
        }
        if (Array.isArray(this.audioStreams)) {
            data["audioStreams"] = [];
            for (let item of this.audioStreams)
                data["audioStreams"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVideoMetadata extends IFileMetadata {
    width?: number;
    height?: number;
    durationInSeconds?: number;
    format?: string | undefined;
    codec?: string | undefined;
    overallBitrate?: number | undefined;
    videoStreams?: IVideoStream[] | undefined;
    audioStreams?: IAudioStream[] | undefined;
}

export class VideoStream implements IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds!: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;

    constructor(data?: IVideoStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bitRate = _data["bitRate"];
            this.codec = _data["codec"];
            this.displayAspectRatio = _data["displayAspectRatio"];
            this.durationInSeconds = _data["durationInSeconds"];
            this.format = _data["format"];
            this.frameCount = _data["frameCount"];
            this.frameRate = _data["frameRate"];
            this.height = _data["height"];
            this.language = _data["language"];
            this.pixelAspectRatio = _data["pixelAspectRatio"];
            this.resolution = _data["resolution"];
            this.streamSize = _data["streamSize"];
            this.width = _data["width"];
            this.rotation = _data["rotation"];
        }
    }

    static fromJS(data: any): VideoStream {
        data = typeof data === 'object' ? data : {};
        let result = new VideoStream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bitRate"] = this.bitRate;
        data["codec"] = this.codec;
        data["displayAspectRatio"] = this.displayAspectRatio;
        data["durationInSeconds"] = this.durationInSeconds;
        data["format"] = this.format;
        data["frameCount"] = this.frameCount;
        data["frameRate"] = this.frameRate;
        data["height"] = this.height;
        data["language"] = this.language;
        data["pixelAspectRatio"] = this.pixelAspectRatio;
        data["resolution"] = this.resolution;
        data["streamSize"] = this.streamSize;
        data["width"] = this.width;
        data["rotation"] = this.rotation;
        return data;
    }
}

export interface IVideoStream {
    bitRate?: string | undefined;
    codec?: string | undefined;
    displayAspectRatio?: string | undefined;
    durationInSeconds: number;
    format?: string | undefined;
    frameCount?: number | undefined;
    frameRate?: number | undefined;
    height?: number | undefined;
    language?: string | undefined;
    pixelAspectRatio?: number | undefined;
    resolution?: number | undefined;
    streamSize?: number | undefined;
    width?: number | undefined;
    rotation?: number | undefined;
}

export class VectorMetadata extends FileMetadata implements IVectorMetadata {
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    title?: string | undefined;
    pageCount?: number;
    epsInfo?: EpsMetadata | undefined;

    constructor(data?: IVectorMetadata) {
        super(data);
        if (data) {
            this.epsInfo = data.epsInfo && !(<any>data.epsInfo).toJSON ? new EpsMetadata(data.epsInfo) : <EpsMetadata>this.epsInfo;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.author = _data["author"];
            this.creator = _data["creator"];
            this.publisher = _data["publisher"];
            this.company = _data["company"];
            this.title = _data["title"];
            this.pageCount = _data["pageCount"];
            this.epsInfo = _data["epsInfo"] ? EpsMetadata.fromJS(_data["epsInfo"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): VectorMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new VectorMetadata();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author;
        data["creator"] = this.creator;
        data["publisher"] = this.publisher;
        data["company"] = this.company;
        data["title"] = this.title;
        data["pageCount"] = this.pageCount;
        data["epsInfo"] = this.epsInfo ? this.epsInfo.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IVectorMetadata extends IFileMetadata {
    author?: string | undefined;
    creator?: string | undefined;
    publisher?: string | undefined;
    company?: string | undefined;
    title?: string | undefined;
    pageCount?: number;
    epsInfo?: IEpsMetadata | undefined;
}

/** Base class of meta information for a dynamic view field */
export abstract class DynamicViewFieldMetaBase implements IDynamicViewFieldMetaBase {

    protected _discriminator: string;

    constructor(data?: IDynamicViewFieldMetaBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "DynamicViewFieldMetaBase";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DynamicViewFieldMetaBase {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DynamicViewFieldMeta") {
            let result = new DynamicViewFieldMeta();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DynamicViewFieldMetaWithRenderingError") {
            let result = new DynamicViewFieldMetaWithRenderingError();
            result.init(data);
            return result;
        }
        if (data["kind"] === "DynamicViewFieldMetaWithHasItems") {
            let result = new DynamicViewFieldMetaWithHasItems();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DynamicViewFieldMetaBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this._discriminator;
        return data;
    }
}

/** Base class of meta information for a dynamic view field */
export interface IDynamicViewFieldMetaBase {
}

/** Meta information for a dynamic view field */
export class DynamicViewFieldMeta extends DynamicViewFieldMetaBase implements IDynamicViewFieldMeta {
    /** Filter for the dynamic view field. */
    filter!: FilterBase;
    /** Sorting information. */
    sort?: SortInfo[] | undefined;
    /** Target doc type. */
    targetDocType!: string;

    constructor(data?: IDynamicViewFieldMeta) {
        super(data);
        if (data) {
            if (data.sort) {
                this.sort = [];
                for (let i = 0; i < data.sort.length; i++) {
                    let item = data.sort[i];
                    this.sort[i] = item && !(<any>item).toJSON ? new SortInfo(item) : <SortInfo>item;
                }
            }
        }
        if (!data) {
            this.filter = new FilterBase();
        }
        this._discriminator = "DynamicViewFieldMeta";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filter = _data["filter"] ? FilterBase.fromJS(_data["filter"]) : new FilterBase();
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(SortInfo.fromJS(item));
            }
            this.targetDocType = _data["targetDocType"];
        }
    }

    static override fromJS(data: any): DynamicViewFieldMeta {
        data = typeof data === 'object' ? data : {};
        if (data["kind"] === "DynamicViewFieldMetaWithHasItems") {
            let result = new DynamicViewFieldMetaWithHasItems();
            result.init(data);
            return result;
        }
        let result = new DynamicViewFieldMeta();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["targetDocType"] = this.targetDocType;
        super.toJSON(data);
        return data;
    }
}

/** Meta information for a dynamic view field */
export interface IDynamicViewFieldMeta extends IDynamicViewFieldMetaBase {
    /** Filter for the dynamic view field. */
    filter: FilterBase;
    /** Sorting information. */
    sort?: ISortInfo[] | undefined;
    /** Target doc type. */
    targetDocType: string;
}

/** Meta information for a dynamic view field including a flag that indicates if the rendered filter does match some items. */
export class DynamicViewFieldMetaWithHasItems extends DynamicViewFieldMeta implements IDynamicViewFieldMetaWithHasItems {
    /** indicates if the rendered filter does match some items. */
    hasItems?: boolean;

    constructor(data?: IDynamicViewFieldMetaWithHasItems) {
        super(data);
        this._discriminator = "DynamicViewFieldMetaWithHasItems";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.hasItems = _data["hasItems"];
        }
    }

    static override fromJS(data: any): DynamicViewFieldMetaWithHasItems {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicViewFieldMetaWithHasItems();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasItems"] = this.hasItems;
        super.toJSON(data);
        return data;
    }
}

/** Meta information for a dynamic view field including a flag that indicates if the rendered filter does match some items. */
export interface IDynamicViewFieldMetaWithHasItems extends IDynamicViewFieldMeta {
    /** indicates if the rendered filter does match some items. */
    hasItems?: boolean;
}

/** Meta information for a dynamic view field where the filter could not be rendered successfully. */
export class DynamicViewFieldMetaWithRenderingError extends DynamicViewFieldMetaBase implements IDynamicViewFieldMetaWithRenderingError {
    /** Error. */
    error?: string | undefined;

    constructor(data?: IDynamicViewFieldMetaWithRenderingError) {
        super(data);
        this._discriminator = "DynamicViewFieldMetaWithRenderingError";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.error = _data["error"];
        }
    }

    static override fromJS(data: any): DynamicViewFieldMetaWithRenderingError {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicViewFieldMetaWithRenderingError();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        super.toJSON(data);
        return data;
    }
}

/** Meta information for a dynamic view field where the filter could not be rendered successfully. */
export interface IDynamicViewFieldMetaWithRenderingError extends IDynamicViewFieldMetaBase {
    /** Error. */
    error?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

/* eslint-disable @typescript-eslint/no-unused-vars */
// prettier-ignore

export const NON_VIRTUAL_CONTENT_SCHEMAS_IDS = [
  'AudioMetadata',
  'DocumentMetadata',
  'FileMetadata',
  'ImageMetadata',
  'VideoMetadata',
  'VectorMetadata',
];

export const SYSTEM_LAYER_SCHEMA_IDS = ['XmpMetadata', 'ExifMetadata'];